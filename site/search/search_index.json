{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Open source firmware for ESP8266 devices ~ Total local control with quick setup and updates. Control using MQTT, Web UI, HTTP or serial. Automate using timers, rules or scripts. Integration with home automation solutions. Incredibly expandable and flexible. Current release ~ Tasmota 8.2 Elliot BREAKING CHANGE Most of the sensor support is moved to tasmota-sensors.bin! If your sensor didn't come with the device, it is most likely not supported in the default tasmota.bin firmware build anymore. Consult Builds table for complete information. Enabling SetOption19 will no longer switch %prefix% and %topic% and will keep the default topic structure Zigbee command prefixes have changed from Zigbee* to Zb* Notable new features: Support for gzipped binaries Added group control of devices using UDP Added support for Mijia BLE sensors using HM10 or NRF24L01 peripherals Added native support for Martin Jerry type PWM dimmer switches Plenty of new switchmodes . See changelog for a complete list of new features, changes and fixes. Join our community ~ See Discord , Telegram or Community Forum for feedback, questions and troubleshooting.","title":"Home"},{"location":"#open-source-firmware-for-esp8266-devices","text":"Total local control with quick setup and updates. Control using MQTT, Web UI, HTTP or serial. Automate using timers, rules or scripts. Integration with home automation solutions. Incredibly expandable and flexible.","title":"Open source firmware for ESP8266 devices"},{"location":"#current-release","text":"Tasmota 8.2 Elliot BREAKING CHANGE","title":"Current release"},{"location":"#join-our-community","text":"See Discord , Telegram or Community Forum for feedback, questions and troubleshooting.","title":"Join our community"},{"location":"A4988-Stepper-Motor-Controller/","text":"!> This feature is not included in precompiled binaries. To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_A4988_STEPPER #define USE_A4988_STEPPER // A4988/DRV8825 stepper motor (+10k5 code) #endif This driver is used to control stepper-motors such as NEMA 17 . Configuration ~ Wiring ~ The driverboard has several connectors: powering the controller (3.3-5.0 V), input (+/-) & output (1a/1b/2a/2b), the motor (up to 35V/2A), and to control the circuit (in order at the control side of the board): Connector Description DIR Direction of rotation STEP Initiate stepping MS1 Microstep increment select MS2 Microstep increment select MS3 Microstep increment select EN Enable the power supply for the motor SLP Sleep (bridge to RST) RST Reset (bridge to SLP) Tasmota Settings ~ There are six GPIO components that should be configured to free GPIOs: A4988 DIR (170) A4988 STP (171) A4988 ENA (172) A4988 MS1 (173) A4988 MS2 (174) A4988 MS3 (175) The minimal configuration are the DIR and STEP signals. In such a configuration the motor will be permanently powered and microstepping will be set to 1/1 (full steps). A4988 Controller ~ Detailed information about the A4988 controller can be found in the datasheet . Microstepping Configuration DRV8825 Controller ~ The DRV8825 is directly pin compatible with the A4988. The microstepping increment settings are different. Also, there is one additional option on the DRV8825. Microstepping Configuration Operation ~ Refer to the Stepper Motor Commands MotorRPM is an imprecise setting due to the implementation method. Also, if the value is too high for the combination of chosen micro stepping increment ( MotorMIS ) and the number of steps the given motor needs for one revolution ( MotorSPR ), the motor will not turn but make a whining noise. You will have to experiment some to find the optimal combination for your use case. Example Project ~ The cheap auto-feeder for my cats broke. It was a fancy plastic-thingy with voice-recording-function & programmable to feed several times a day after playing back your voice (cats don't give a sh$7 about your voice - they come when they hear the food falling into the bowl). It was never precise - a concern for the amount of nutrition it gave the cats. And it was not reliable, as the torque of the internal moving mechanism was insufficient to spin the separator/proportioning wheel through the food reliably. In addition, the batteries were always drained in a day meaning very grumpy cats when we returned! Thus the wish to install a high-torque stepper-motor (with shifting gear) was born. I could power it with mains instead of relying on a battery, control it over WiFi from my home automation hub. Tasmota now offers a way to do this! The \"TasmotaSmartCatFeeder\" circuit consists of a WeMos D1 mini, a A4988 controller, and two power supplies (5V&12V). This all fits into the housing of the feeder and costs less than 50\u20ac! Virtually everything which has to be moved or rotated can be done now using these cheap components. It can be a window, door, shutter, cat or dog flap, a solar panel which follows the sun, a moving spotlight, PTZ-camera, or whatever. Wiring Diagrams ~ Convert 28BYJ-48 to bipolar so that it works with this driver Breakout Boards ~ Buy Links Banggood AliExpress #1 AliExpress #1","title":"A4988 stepper motor controller"},{"location":"A4988-Stepper-Motor-Controller/#configuration","text":"","title":"Configuration"},{"location":"A4988-Stepper-Motor-Controller/#wiring","text":"The driverboard has several connectors: powering the controller (3.3-5.0 V), input (+/-) & output (1a/1b/2a/2b), the motor (up to 35V/2A), and to control the circuit (in order at the control side of the board): Connector Description DIR Direction of rotation STEP Initiate stepping MS1 Microstep increment select MS2 Microstep increment select MS3 Microstep increment select EN Enable the power supply for the motor SLP Sleep (bridge to RST) RST Reset (bridge to SLP)","title":"Wiring"},{"location":"A4988-Stepper-Motor-Controller/#tasmota-settings","text":"There are six GPIO components that should be configured to free GPIOs: A4988 DIR (170) A4988 STP (171) A4988 ENA (172) A4988 MS1 (173) A4988 MS2 (174) A4988 MS3 (175) The minimal configuration are the DIR and STEP signals. In such a configuration the motor will be permanently powered and microstepping will be set to 1/1 (full steps).","title":"Tasmota Settings"},{"location":"A4988-Stepper-Motor-Controller/#a4988-controller","text":"Detailed information about the A4988 controller can be found in the datasheet .","title":"A4988 Controller"},{"location":"A4988-Stepper-Motor-Controller/#drv8825-controller","text":"The DRV8825 is directly pin compatible with the A4988. The microstepping increment settings are different. Also, there is one additional option on the DRV8825.","title":"DRV8825 Controller"},{"location":"A4988-Stepper-Motor-Controller/#operation","text":"Refer to the Stepper Motor Commands MotorRPM is an imprecise setting due to the implementation method. Also, if the value is too high for the combination of chosen micro stepping increment ( MotorMIS ) and the number of steps the given motor needs for one revolution ( MotorSPR ), the motor will not turn but make a whining noise. You will have to experiment some to find the optimal combination for your use case.","title":"Operation"},{"location":"A4988-Stepper-Motor-Controller/#example-project","text":"The cheap auto-feeder for my cats broke. It was a fancy plastic-thingy with voice-recording-function & programmable to feed several times a day after playing back your voice (cats don't give a sh$7 about your voice - they come when they hear the food falling into the bowl). It was never precise - a concern for the amount of nutrition it gave the cats. And it was not reliable, as the torque of the internal moving mechanism was insufficient to spin the separator/proportioning wheel through the food reliably. In addition, the batteries were always drained in a day meaning very grumpy cats when we returned! Thus the wish to install a high-torque stepper-motor (with shifting gear) was born. I could power it with mains instead of relying on a battery, control it over WiFi from my home automation hub. Tasmota now offers a way to do this! The \"TasmotaSmartCatFeeder\" circuit consists of a WeMos D1 mini, a A4988 controller, and two power supplies (5V&12V). This all fits into the housing of the feeder and costs less than 50\u20ac! Virtually everything which has to be moved or rotated can be done now using these cheap components. It can be a window, door, shutter, cat or dog flap, a solar panel which follows the sun, a moving spotlight, PTZ-camera, or whatever.","title":"Example Project"},{"location":"A4988-Stepper-Motor-Controller/#wiring-diagrams","text":"Convert 28BYJ-48 to bipolar so that it works with this driver","title":"Wiring Diagrams"},{"location":"A4988-Stepper-Motor-Controller/#breakout-boards","text":"","title":"Breakout Boards"},{"location":"ADC/","text":"ESP8266 has a single ADC pin available. It may be used to read voltage at ADC pin or to read module supply voltage (VCC). [!NOTE] When referring to the ADC pin these terms are used interchangeably: ADC (Analog-to-digital Converter), TOUT, Pin6, A0 or Analog0. Warning Check your Wi-Fi module. The ESP8266 A0 pin supports a maximum voltage of 1.0V. Many newer Wi-Fi modules have an on-board voltage divider to support a higher A0 input voltage range (typically in the range between 0 and 3.3 volts). You may need to use an external voltage divider to ensure your input voltage is in the right range. By default Tasmota uses the ADC pin to read voltage. The signal comes from an analog peripheral , or sometimes from the device itself (see Shelly 2.5 ). After wiring a peripheral to A0 pin you have to configure it in Configure Module : # Option WebUI display MQTT mesage 0 None none none 1 Analog Analog0 %value% {\"A0\":%value%} 2 Temperature Temperature %value% \u00b0C (\u00b0F) {\"Temperature\":%value%},\"TempUnit\":\"C\"} 3 Light Illuminance %value% lux {\"Illuminance\":%value%} 4 Button none none 5 Buttoni none none The reading will show in web UI's sensor section as \" %option% %value% \" depending on the selected option. Tasmota calculates the values for temperature and light, analog values can be 1 to 1024 . [!NOTE] When using Temperature (2) or light (3) a calibration could be needed. In case of shifted values AdcParam can be used to calibrate the output. Example: ADC as Analog (1) A message will be published in tele/%topic%/SENSOR JSON response as \"ANALOG\": depending on the selected option. Example: ADC as Light (3) 18 : 55 : 09 MQT: tele/tasmota/SENSOR = { \"Time\" : \"2019-10-31T18:55:09\" , \"ANALOG\" :{ \"Illuminance\" : 8 }} [!WARNING] Careful when setting ADC as Button, if there is constant voltage on the pin it might register as a long press and reset the device to firmware defaults Rule triggers ~ Use these triggers in rules: on ANALOG#A0div10 do ... - when the ADC input changes by more than 1% it provides a value between 0 and 100 on Tele-ANALOG#A0 do ... - triggers on tele messages with Analog object MQT: tele/tasmota/SENSOR = {\"Time\":\"2019-01-14T19:36:51\",\"ANALOG\":{\"A0\":1024}} Rule example: using a potentiometer on analog pin . ADC_VCC ~ Instead of an input, ADC pin can be used to measure supply voltage of the ESP module ( this reading in not 100% accurate ). To enable ADC_VCC feature you need to compile your own build : If you enable ADC_VCC you cannot use the pin as analog input anymore. user_config_override.h flag: // -- Internal Analog input ----------------------- #define USE_ADC_VCC // Display Vcc in Power status Supply voltage is published in tele/%topic%/STATE under \"Vcc\": in mV: 11 : 14 : 59 MQT : tele /tasmota/ STATE = { \"Time\" : \"2019-10-31T11:14:59\" , \"Uptime\" : \"0T18:36:12\" , \"UptimeSec\" : 66972 , \"Vcc\" : 3.423 , \"Heap\" : 28 , \"SleepMode\" : \"Dynamic\" , \"Sleep\" : 50 , \"LoadAvg\" : 19 , \"MqttCount\" : 6 , \"POWER\" : \"OFF\" , \"Wifi\" :{ \"AP\" : 1 , \"SSId\" : \"Tasmota\" , \"BSSId\" : \"00:00:00:00:00:00\" , \"Channel\" : 13 , \"RSSI\" : 100 , \"LinkCount\" : 1 , \"Downtime\" : \"0T00:00:06\" }}","title":"ADC"},{"location":"ADC/#rule-triggers","text":"Use these triggers in rules: on ANALOG#A0div10 do ... - when the ADC input changes by more than 1% it provides a value between 0 and 100 on Tele-ANALOG#A0 do ... - triggers on tele messages with Analog object MQT: tele/tasmota/SENSOR = {\"Time\":\"2019-01-14T19:36:51\",\"ANALOG\":{\"A0\":1024}} Rule example: using a potentiometer on analog pin .","title":"Rule triggers"},{"location":"ADC/#adc_vcc","text":"Instead of an input, ADC pin can be used to measure supply voltage of the ESP module ( this reading in not 100% accurate ). To enable ADC_VCC feature you need to compile your own build : If you enable ADC_VCC you cannot use the pin as analog input anymore. user_config_override.h flag: // -- Internal Analog input ----------------------- #define USE_ADC_VCC // Display Vcc in Power status Supply voltage is published in tele/%topic%/STATE under \"Vcc\": in mV: 11 : 14 : 59 MQT : tele /tasmota/ STATE = { \"Time\" : \"2019-10-31T11:14:59\" , \"Uptime\" : \"0T18:36:12\" , \"UptimeSec\" : 66972 , \"Vcc\" : 3.423 , \"Heap\" : 28 , \"SleepMode\" : \"Dynamic\" , \"Sleep\" : 50 , \"LoadAvg\" : 19 , \"MqttCount\" : 6 , \"POWER\" : \"OFF\" , \"Wifi\" :{ \"AP\" : 1 , \"SSId\" : \"Tasmota\" , \"BSSId\" : \"00:00:00:00:00:00\" , \"Channel\" : 13 , \"RSSI\" : 100 , \"LinkCount\" : 1 , \"Downtime\" : \"0T00:00:06\" }}","title":"ADC_VCC"},{"location":"AM2301/","text":"AM2301 driver supports AM2301 (DHT21) , AM2302 (DHT22) and AM2321 temperature and humidity sensors. Introduced in Tasmota through Sonoff AM2301 accessory for Sonoff TH . This driver is ONLY for single wire implementations of the sensor. Configuration ~ Wiring ~ AM2301 ESP266 - GND OUT GPIOx + 3.3V Tasmota Settings ~ In the Configuration -> Configure Module page assign: - GPIOx to AM2301 (2) After a reboot webUI will display temperature and humidity measured. Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2019-01-01T00:00:00\" , \"AM2301\" : { \"Temperature\" : 24.6 , \"Humidity\" : 58.2 }, \"TempUnit\" : \"C\" } Commands ~ TempOffset can be used for calibrating the measured temperature. This setting affects all temperature sensors on the device. Wemos DHT Shield ~ Like the Wemos DHT11 shield specs the DATA OUT pin of Wemos DHT22 is connected to D4 of the Wemos. Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIO2 to AM2301 (2) Sensors ~ Read more about differences between sensors .","title":"AM2301 temperature and humidity sensor"},{"location":"AM2301/#configuration","text":"","title":"Configuration"},{"location":"AM2301/#wiring","text":"AM2301 ESP266 - GND OUT GPIOx + 3.3V","title":"Wiring"},{"location":"AM2301/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: - GPIOx to AM2301 (2) After a reboot webUI will display temperature and humidity measured. Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2019-01-01T00:00:00\" , \"AM2301\" : { \"Temperature\" : 24.6 , \"Humidity\" : 58.2 }, \"TempUnit\" : \"C\" }","title":"Tasmota Settings"},{"location":"AM2301/#commands","text":"TempOffset can be used for calibrating the measured temperature. This setting affects all temperature sensors on the device.","title":"Commands"},{"location":"AM2301/#wemos-dht-shield","text":"Like the Wemos DHT11 shield specs the DATA OUT pin of Wemos DHT22 is connected to D4 of the Wemos.","title":"Wemos DHT Shield"},{"location":"AM2301/#tasmota-settings_1","text":"In the Configuration -> Configure Module page assign: GPIO2 to AM2301 (2)","title":"Tasmota Settings"},{"location":"AM2301/#sensors","text":"Read more about differences between sensors .","title":"Sensors"},{"location":"APDS-9960/","text":"!> This feature is not included in precompiled binaries. To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_APDS9960 #define USE_APDS9960 // Enable APDS9960 Proximity Sensor (+4k7 code) #endif Broadcom APDS-9960 is a digital RGB, ambient light, proximity and gesture sensor device in a single 8-pin package. The device has an I2C compatible interface providing red, green, blue, clear (RGBC), proximity and gesture sensing with IR LED. The RGB and ambient light sensing feature detects light intensity under various lighting conditions and through various attentuation materials including darkened glass. In addition, the integrated UV-IR blocking filter enables accurate ambient light and correlated color temperature sensing. Configuration ~ Wiring Breakout ESP8266 VCC/VIN +3.3VDC GND GND SCL GPIOy SDA GPIOx INT/IRQ not used Tasmota Settings In the Configuration -> Configure Module page assign: GPIOx to I2C SDA (6) GPIOy to I2C SCL (5) After configuring the GPIO's the driver will detect the APDS-9960 automatically. On first boot sensor will start in gesture mode. It will not appear in the webUI but it can be observed via MQTT messages in console: 21 : 34 : 21 MQT: tele/tasmota/RESULT = { \"Gesture\" : \"Off\" } 21 : 34 : 23 MQT: tele/tasmota/RESULT = { \"Gesture\" : \"On\" } 21 : 34 : 25 MQT: tele/tasmota/SENSOR = { \"Time\" : \"2019-10-31T21:34:25\" , \"APDS9960\" :{ \"None\" : 1 }} 21 : 34 : 26 MQT: tele/tasmota/SENSOR = { \"Time\" : \"2019-10-31T21:34:26\" , \"APDS9960\" :{ \"Right\" : 1 }} 21 : 34 : 29 MQT: tele/tasmota/SENSOR = { \"Time\" : \"2019-10-31T21:34:29\" , \"APDS9960\" :{ \"Down\" : 1 }} 21 : 34 : 29 MQT: tele/tasmota/SENSOR = { \"Time\" : \"2019-10-31T21:34:29\" , \"APDS9960\" :{ \"Right\" : 1 }} 21 : 34 : 31 MQT: tele/tasmota/SENSOR = { \"Time\" : \"2019-10-31T21:34:31\" , \"APDS9960\" :{ \"Left\" : 1 }} 21 : 34 : 33 MQT: tele/tasmota/SENSOR = { \"Time\" : \"2019-10-31T21:34:33\" , \"APDS9960\" :{ \"Up\" : 1 }} 21 : 34 : 35 MQT: tele/tasmota/SENSOR = { \"Time\" : \"2019-10-31T21:34:35\" , \"APDS9960\" :{ \"Down\" : 1 }} When you enable RGBC mode with Sensor27 0 sensor will show up in web UI: and in MQTT topic (according to TelePeriod): MQT: tele/tasmota/SENSOR = {\"Time\":\"2019-10-31T21:48:51\",\"APDS9960\":{\"Red\":282,\"Green\":252,\"Blue\":196,\"Ambient\":169,\"CCT\":4217,\"Proximity\":9}} Commands ~ Command Value Description Sensor27 Show APDS9960 gesture/RGBC mode Sensor27 0 / off Disable APDS9960 gesture mode/Enable RGBC mode Sensor27 1 / on Enable APDS9960 gesture mode/Disable RGBC mode Sensor27 2 / on Enable APDS9960 gesture mode/Disable RGBC mode with half gain Sensor27 3 ...255 Set ATIME register for different integration times Example Rules ~ In gesture sensing mode Tele-APDS9960 is the trigger (APDS9960 will not work) Device will be in RGBC mode until something is close to it, then it switches into gesture mode for 60 seconds. Rule on APDS9960#Proximity=250 do backlog Sensor27 1; RuleTimer1 60 endon on Rules#Timer=1 do Sensor27 0 endon Relay ON when ambient light is below 100 lux. Rule on APDS9960#Ambient<100 do POWER ON endon Control ON/OFF, brightness and color temperature with gestures Rule on Tele-APDS9960#Long do power toggle endon on Tele-APDS9960#Up do dimmer + endon on Tele-APDS9960#Down do dimmer - endon on Tele-APDS9960#Left do ct + endon on Tele-APDS9960#Right do ct - endon Known Issues ~ The different PCB\u2019s on the market seem to differ quite substantially regarding to their electrical characteristics. We have at least one case report, where this led to a malfunction on an ESP8266-board within Tasmota but in another library too. The exact technical reason can only be suspected, but it is probably related to electrical noise and/or power consumption. In the case from above the sensor measured an incorrect high proximity value, which resulted in repeated triggering of a \"LONG\" gesture. The solution was to decrease the gain factor for proximity and gesture. Therefore the argument 2 ( sensor27 2 ) was introduced to change this at runtime. If you experience gesture sensing problems you could try this out, but if you measure proximity values <25 with nothing in front of the sensor (e.g. web interface after sensor27 0 ), then there is very likely another problem. It can be assumed, that the gesture sensitivity will suffer with reduced gain, so first try option 1 (=default). Beside that better wiring and maybe an additional capacitor over VCC and GROUND might be helpful. The measurement of the light level is briefly described in the datasheet and the open-source-libraries use the ambient-light-value directly from the sensor or calculate a LUX-value from RGB. Both variants are usable and differentiate between low and strong light, but the absolute values are questionable and at the moment we have an uncalibrated sensor. All known solutions use a fixed integration time, which is more or less the same as a fixed exposure time in photography. In contrast the TSL2561-library uses various integration times and maybe this is possible on the APDS9960 too. To eventually achieve this in the future, the option to set this integration time at runtime was added. Every argument between 3 and 255 sets the ATIME-register. The formula is: integration time = (256-ATIME) 2,78 ms, so with the default value of 219 we get (256-219) 2,78 = 102,86 ms. That means a smaller ATIME makes the integration time longer and more photons are captured, which might be usable for (very) low light conditions, because otherwise the sensor will saturate too early. The opposite is valid for a bigger ATIME value. The change of this value only makes sense for: users who need to change the sensitivity, if the sensor resides behind dark glass or want to contribute to the development of a new LUX-calculation in the driver. If we get enough feedback, this could lead to an improvement on the software side. Feel free to open (or search for) an issue, if you have measured the APDS9960 against other devices with different ATIME-values at different light levels. This is not a trivial task though. Breakout Boards ~ Where to get ~ 2\u20ac at AliExpress ~ $8 at Adafruit APDS-9960 Datasheet","title":"APDS 9960"},{"location":"APDS-9960/#configuration","text":"","title":"Configuration"},{"location":"APDS-9960/#commands","text":"Command Value Description Sensor27 Show APDS9960 gesture/RGBC mode Sensor27 0 / off Disable APDS9960 gesture mode/Enable RGBC mode Sensor27 1 / on Enable APDS9960 gesture mode/Disable RGBC mode Sensor27 2 / on Enable APDS9960 gesture mode/Disable RGBC mode with half gain Sensor27 3 ...255 Set ATIME register for different integration times","title":"Commands"},{"location":"APDS-9960/#example-rules","text":"In gesture sensing mode Tele-APDS9960 is the trigger (APDS9960 will not work) Device will be in RGBC mode until something is close to it, then it switches into gesture mode for 60 seconds. Rule on APDS9960#Proximity=250 do backlog Sensor27 1; RuleTimer1 60 endon on Rules#Timer=1 do Sensor27 0 endon Relay ON when ambient light is below 100 lux. Rule on APDS9960#Ambient<100 do POWER ON endon Control ON/OFF, brightness and color temperature with gestures Rule on Tele-APDS9960#Long do power toggle endon on Tele-APDS9960#Up do dimmer + endon on Tele-APDS9960#Down do dimmer - endon on Tele-APDS9960#Left do ct + endon on Tele-APDS9960#Right do ct - endon","title":"Example Rules"},{"location":"APDS-9960/#known-issues","text":"The different PCB\u2019s on the market seem to differ quite substantially regarding to their electrical characteristics. We have at least one case report, where this led to a malfunction on an ESP8266-board within Tasmota but in another library too. The exact technical reason can only be suspected, but it is probably related to electrical noise and/or power consumption. In the case from above the sensor measured an incorrect high proximity value, which resulted in repeated triggering of a \"LONG\" gesture. The solution was to decrease the gain factor for proximity and gesture. Therefore the argument 2 ( sensor27 2 ) was introduced to change this at runtime. If you experience gesture sensing problems you could try this out, but if you measure proximity values <25 with nothing in front of the sensor (e.g. web interface after sensor27 0 ), then there is very likely another problem. It can be assumed, that the gesture sensitivity will suffer with reduced gain, so first try option 1 (=default). Beside that better wiring and maybe an additional capacitor over VCC and GROUND might be helpful. The measurement of the light level is briefly described in the datasheet and the open-source-libraries use the ambient-light-value directly from the sensor or calculate a LUX-value from RGB. Both variants are usable and differentiate between low and strong light, but the absolute values are questionable and at the moment we have an uncalibrated sensor. All known solutions use a fixed integration time, which is more or less the same as a fixed exposure time in photography. In contrast the TSL2561-library uses various integration times and maybe this is possible on the APDS9960 too. To eventually achieve this in the future, the option to set this integration time at runtime was added. Every argument between 3 and 255 sets the ATIME-register. The formula is: integration time = (256-ATIME) 2,78 ms, so with the default value of 219 we get (256-219) 2,78 = 102,86 ms. That means a smaller ATIME makes the integration time longer and more photons are captured, which might be usable for (very) low light conditions, because otherwise the sensor will saturate too early. The opposite is valid for a bigger ATIME value. The change of this value only makes sense for: users who need to change the sensitivity, if the sensor resides behind dark glass or want to contribute to the development of a new LUX-calculation in the driver. If we get enough feedback, this could lead to an improvement on the software side. Feel free to open (or search for) an issue, if you have measured the APDS9960 against other devices with different ATIME-values at different light levels. This is not a trivial task though.","title":"Known Issues"},{"location":"APDS-9960/#breakout-boards","text":"","title":"Breakout Boards"},{"location":"AWS-IoT/","text":"This feature is not included in precompiled binaries To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_MQTT_TLS #define USE_MQTT_TLS #define USE_MQTT_TLS_CA_CERT // Optional but highly recommended #endif #ifndef USE_MQTT_AWS_IOT #define USE_MQTT_AWS_IOT #endif #ifdef USE_DISCOVERY #undef USE_DISCOVERY #endif As of Tasmota version 6.6.0.3, the device-specific credentials are no longer restricted to being set at compile time only. You can now use the same firmware for all your devices. AWS IoT credentials can be set through the Console at runtime and are stored in flash memory. Credentials will survive firmware updates and OTA. Credentials will not survive a full Flash reset Reset 5 or Reset 6 nor will it survive a System Parameter Flash reset Reset 3 Benefits ~ AWS IoT provides secure, bi-directional communication between Internet-connected devices such as sensors, actuators, embedded micro-controllers. This basically allows to communicate in both direction from the cloud using MQTT over secure channels using TLS. 1. More Alexa controls It's actually easy to develop smarthome Alexa skills, so that you can control your whole house. Currently you can only use the local Philips Hue/Wemo emulation - limited to lights and switches. You can imagine for instance controlling your Sonoff RF Bridge and send IR codes to your TV. Alexa skills need to communicate back to your devices, which is easy using MQTT and AWS IoT 2. No need for a local gateway Of course you can do it with a local gateway like Raspberry PI using many of the open-source solutions (Domoticz...). You can also do it entirely from the cloud without the hassle of managing and updating a local gateway. On top of it, AWS IoT provides tools to collect and archive your data, automate (AWS IoT things). Maximum security Keep in mind that AWS IoT is based with 'security first' in mind. All the data in AWS IoT is your data and is not shared with anyone else. Communication is done over TLS 1.2 tunnels, using client certificates to authenticate each device. Up to now it was challenging to enable TLS on ESP8266 because of the high memory requirements of TLS. Thanks to the switch of Arduino to BearSSL and aggressive optimization, the amount of memory needed is as low as 6.0k during normal operation, and an additional 6.6k during connection (TLS handshake). This makes it totally doable with standard 'Tasmota' firmware with Web and Hue emulation activated. You should see more than 20k of memory still available. Caveats ~ AWS IoT requires each Tasmota device to have its own distinct Private Key and Certificate (~800 bytes). Although you could imagine to use the same Private Key in all your devices, this is considered as a very bad practice. You are warned! Currently the only way to onboard your private key is to custom compile your own firmware, each one with its own private key embedded in C code. We explore later ways to store the keys in EEPROM or somewhere that wouldn't need to burn it into the firmware and that would survive OTA update. During TLS handshake, a secondary stack of 5.3k is allocated on the heap to allow BearSSL to have enough stack room. Memory is freed at the end of the handshake. Allocating such big chunks of memory can cause issues when heap fragmentation gets too high. During the first testing campaign, I didn't see any crash due to lack of memory - but this is something we need to keep on monitoring. The alternative would be to allocate this memory once and for all, meaning less memory for Tasmota but no possible crash due to fragmentation. Cost AWS provides a Free Tier that allows you to use some services for free up to a specific level. For example, it allows you to have 50 devices connecting 24 hours a day exchanging 300 messages per day. For a typical house, there is a good chance the service costs you nothing (the first year). How to configure? ~ AWS IoT requires a distinct Private Key and Certificate per Tasmota device. Currently you need to custom compile your Tasmota firmware and burn the Key and Certificate in your firmware. We will later explore how to configure them separately. Here is a simple guide. 0. Open an AWS Account ~ If you don't have already one, just follow the guide: https://aws.amazon.com/premiumsupport/knowledge-center/create-and-activate-aws-account/ 1. Prerequisites ~ You will need to install/compile the following: Complete environment to compile Tasmota, ex: PlatformIO (PlatformIO) Recent version of openssl 1.5 Deploy required resources using AWS CloudFormation and skip to Step 6. ~ The following AWS CloudFormation template will create these resources: One IAM Role LambdaExecutionRole Will allow the Lambda function to write to CloudWatch for Logging. One AWS Lambda function to create a CSR and Private Key as described in Step 3. One Custom Resource to Invoke the Lambda function One IoT Certificate using the Generated CSR One IoT Thing One IoT Policy One IoT PolicyAssociation One IoT ThingAssociation Click on the link for the region you have chosen: Region Code Launch US East (N. Virginia) us-east-1 EU (Ireland) eu-west-1 AWS CloudFormation Launch Instructions (expand for details) 1. Click the **Launch Stack** link above for the region of your choice. 1. Click **Next** on the Select Template page. 1. On the Specify Details page, leave all the defaults and click **Next**. 1. On the Options page, leave all the defaults and click **Next**. 1. On the Review page, Click the checkboxes to give AWS CloudFormation permission to **\"create IAM resources\"** 1. Click **\"Create stack\"** 1. Wait for the `IotThingGenerator` stack to reach a status of `CREATE_COMPLETE`. 1. With the `IotThingGenerator` stack selected, click on the **Outputs** tab. You will find your CSR and Private Key which will be referenced in the later steps. You need to copy & paste the contents of the Outputs tab of the CloudFormation stack for the Key to a separate text editor and save the file as tasmota-01.key . To download the IoT certifcate (.cert) key. Navigate to Click on \" Services \" and select \" IoT Core \". On the left panel, click on \" Secure \" > \" Certificates \". Select the three dots on the right of certificate and click on Download . skip to Step 6. To get the IoT endpoint go to Step 4. 2. Configure AWS IoT (to be done once) ~ Open the AWS Console. Click on \" Services \" and select \" IoT Core \". Select the AWS Region where you want to locate your data, for ex: \" (EU) Frankfurt \". Now we need to create a security policy to allow your Tasmota devices to connect to AWS IoT, publish and subscribe to topics. On the left panel, click on \" Secure \" > \" Policies \". Click on the \" Create \" button in the upper right corner. Enter in the \" Name \" field, enter the name of your policy, for ex: \" TasmotaMqttPolicy \". Then click on \" Advanced mode \" Cut and paste the policy below. Click on \" Create \" in the lower right corner. { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Action\": [ \"iot:Connect\", \"iot:Publish\", \"iot:Subscribe\", \"iot:Receive\" ], \"Resource\": \"*\" } ] } 3. Create a Private Key and Certificate (once per Tasmota device) ~ Do not use the default AWS IoT feature to generate your private key online. It creates a 2048 bits RSA key. Instead we are using elliptic curves keys - they are much smaller in memory than RSA keys (this saves ~1k of memory) and the handshake is significantly faster. First create an ECC private key for your device (as described in this Blog ). Keep you private key in a safe place. $ openssl ecparam -name prime256v1 -genkey -out tasmota-01.key Next, using this private key, create a certificate signing request (CSR). When asked enter the certificate details. This is not really used later, you can just enter a 2 letters country code like \" EU \" and leave all other fields blank (type 8 times enter). $ openssl req -new -sha256 -key tasmota-01.key -nodes -out tasmota-01.csr You are about to be asked to enter information that will be incorporated into your certificate request. What you are about to enter is what is called a Distinguished Name or a DN. There are quite a few fields but you can leave some blank For some fields there will be a default value, If you enter '.' , the field will be left blank. ----- Country Name ( 2 letter code ) [] :EU <enter> State or Province Name ( full name ) [] : <enter> Locality Name ( eg, city ) [] : <enter> Organization Name ( eg, company ) [] : <enter> Organizational Unit Name ( eg, section ) [] : <enter> Common Name ( eg, fully qualified host name ) [] : <enter> Email Address [] : <enter> Please enter the following 'extra' attributes to be sent with your certificate request A challenge password [] : <enter> Next ask AWS IoT to sign your key with its certificate. On the left panel, click on \" Secure \" > \" Certificates \". Click on \" Create a certificate \". Then choose the \" Create with CSR \" button, locate your CSR file from above. Click on \" Upload file \". Download the certificate file, click on \" Download \", save the file as \" tasmota-01.cert.pem \". Important : don't forget to click on the \" Activate \" to activate the certificate. Your Private Key and Certificates are ready to use. Now we need to register the Tasmota Device. 4. Write down your AWS IoT endpoint (same for all devices) ~ Click on \" Settings \" in the left panel. You should see a field called \" Custom endpoint \". Write down the endpoint domain name. It should look like this (if you have chosen the Frankfurt region: <xxxxxxxxxxxxxx>-ats.iot.eu-central-1.amazonaws.com This is your MQTT endpoint, the port is 8883 - MQTT over TLS. 5. Register the device in AWS IoT (once per Tasmota device) ~ Now on the left pane, click on \" Manage \" > \" Things \". Click on \" Register a thing \", then \" Create a single thing \". Give your device a name like \" Tasmota-01 \". Scroll down and click \" Next \" at the botton right. Then click on \" Create thing without a certificate \". Now we need to associate the certificate created earlier to your device. In the left panel, click back on \" Secure \" > \" Certificates \". Select the certificate created earlier. In the next pane, click on \" Actions \" in the upper right part. First select \" Attach policy \", check \" TasmotaMqttPolicy \" and \" Attach \". Click again on \" Actions \" and select \" Attach thing \", check \" Tasmota-01 \" and \" Attach \". Your setup is done in AWS IoT. Let's proceed to the custom firmware. 6. Enable AWS IoT in Tasmota ~ Using your favorite IDE, create user_config_override.h and add the required compilation directives as documented at the top of this article. Note: TLS handshake takes ~1.2s on ESP8266 @80MHz. You may choose to switch to 160MHz if the power supply of your device supports it. If you do so, handshake time should be ~0.7s. Compile the firmware and ensure it completes successfully. This step is only to check compilation goes well. Your firmware is still not usable since it does not contain the Private Key + Certificate. 7. Flash your device ~ Flash your device the normal way; either through serial or OTA. If you use OTA, first flash a sonoff-minimal firmware, then your target firmware. 8. Prepare your AWS IoT credentials ~ You will now need to convert your AWS IoT credentials to Tasmota commands. Credentials are composed of two distinct parts, first a Private Key - this is the secret that will allow your device to prove it is who it pretends to be. Consider this as sensitive as a password. The Private Key is exactly 32 bytes (256 bits). The second part is the Certificate delivered by AWS IoT. Tasmota will also need it to authenticate to the AWS IoT endpoint. Both credentials must be stored in Tasmota Flash memory, in that order, using the new TLSKey command. a. First check that the key store is empty Type the following command: TLSKey hh : mm : ss CMD : TLSKey hh : mm : ss MQT : stat / tasmota / RESULT = { \"TLSKey1\" :- 1 , \"TLSKey2\" :- 1 } If both values are -1 , it means it does not contain any key. If you need to reset the key store, use the command TLSKey 0 . b. Convert the Private Key We will extract the 32 bytes Private key from tasmota-01.key generated above. 1-line method, use the following command: (fake key below) openssl ec -in tasmota-01.key -inform PEM -outform DER | openssl asn1parse -inform DER | head -3 | tail -1 | awk -F':' '{ print $4 }' | xxd -r -p | base64 | echo \"TLSKey1 $(</dev/stdin)\" Example: openssl ec -in tasmota-01.key -inform PEM -outform DER | openssl asn1parse -inform DER | head -3 | tail -1 | awk -F':' '{ print $4 }' | xxd -r -p | base64 | echo \"TLSKey1 $(</dev/stdin)\" read EC key writing EC key TLSKey1 UvBgyCuPr/lKSgwumf/8o/mIsKQPBHn3ZZAGZl4ui9E= Cut and paste the command starting with TLSKey1 ... into the Tasmota Web Console or through MQTT. hh : mm : ss CMD : TLSKey1 UvBgyCuPr / lKSgwumf / 8 o / mIsKQPBHn3ZZAGZl4ui9E = hh : mm : ss MQT : stat / tasmota / RESULT = { \"TLSKey1\" : 32 , \"TLSKey2\" :- 1 } Alternative method: Convert the Private Key file from PEM to DER (binary format): openssl ec -in tasmota-01.key -inform PEM -outform DER -out tasmota-01.key.der Dump the ASN.1 format from the DER file: openssl asn1parse - inform DER - in tasmota - 01. key . der 0 : d = 0 hl = 2 l = 119 cons : SEQUENCE 2 : d = 1 hl = 2 l = 1 prim : INTEGER : 01 5 : d = 1 hl = 2 l = 32 prim : OCTET STRING [ HEX DUMP ] : 52F 060 C82B8FAFF94A4A0C2E99FFFCA3F988B0A40F0479F7659006665E2E8BD1 39 : d = 1 hl = 2 l = 10 cons : cont [ 0 ] 41 : d = 2 hl = 2 l = 8 prim : OBJECT : prime256v1 51 : d = 1 hl = 2 l = 68 cons : cont [ 1 ] 53 : d = 2 hl = 2 l = 66 prim : BIT STRING Then convert the byte stream after [HEX DUMP] to base64 and use it with the TLSKey1 command. c. Convert the Certificate Similarly you will need to convert the file \" tasmota-01.cert.pem \" generated above to a Tasmota command. 1-line version, use the following command: openssl x509 -in tasmota-01.cert.pem -inform PEM -outform DER | base64 | echo \"TLSKey2 $(</dev/stdin)\" Example: (fake certificate) openssl x509 -in tasmota-01.cert.pem -inform PEM -outform DER | base64 | echo \"TLSKey2 $(</dev/stdin)\" TLSKey2 MIICfTCCAWWgAwIBAgIUMPd6KefJYqwIHxzgCk1kEXIjHhkwDQYJKoZIhvcNAQELBQAwTTFLMEkGA1UECwxCQW1hem9uIFdlYiBTZXJ2aWNlcyBPPUFtYXpvbi5jb20gSW5jLiBMPVNlYXR0bGUgU1Q9V2FzaGluZ3RvbiBDPVVTMB4XDTE5MDgwNDE5MjI1NVoXDTQ5MTIzMTIzNTk1OVowDTELMAkGA1UEBhMCRVUwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAASCzFZFhPXBbr6G6gbhT/rGXROhN5AHdwhxfpY55xi3c1W3TBuvUdZYdU2Urc9t4ces9Nz3UcF1xfMBvIpVqMVco2AwXjAfBgNVHSMEGDAWgBT3n7seZ1eHUIcZCcuwn0fkEad77TAdBgNVHQ4EFgQUUruspk3ohBJB8buA8qq9kQIZUs0wDAYDVR0TAQH/BAIwADAOBgNVHQ8BAf8EBAMCB4AwDQYJKoZIhvcNAQELBQADggEBAFPKpVjaowYY3taAcKsSxfwkwzglI2eUlnmSdnu6WZkNEdiYpx8QVYb+miJnIyTVaE3bzkTr4PvObwf4Vs92uMtIQ5BuU1lj8EdfsZAs6uA1rqfQIl0n7ty3bErtVb3d+uUBm4C1b9mtbQS45itfrTvzWEoLuWflUxAFqyYVmNPNHTfPFLjAP9dcpWk+388pRl3jkGo1qiFrEp+ucQMtkqwn3lfVXlRFuGY6GxKg2lBWvqW5CuHaBhFjeT63pqUmjj76VrBk/Vp9BMjIJ3a1omuW3ZUGCPdXUVqj4/m2pXoYIGW7l/fZpfV4piKOW1tcxeX/iBdgPUL1XUMbCtBybbc= Copy and paste the last line starting with TLSKey2 ... into the Web Tasmota Console or through MQTT. Note: you cannot use this command through Serial, it is bigger than the max serial buffer (520 bytes). hh : mm : ss CMD : TLSKey2 MIICfTCCAWWgAwIBAgIUMPd6KefJYqwIHxzgCk1kEXIjHhkwDQYJKoZIhvcNAQELBQAwTTFLMEkGA1UECwxCQW1hem9uIFdlYiBTZXJ2aWNlcyBPPUFtYXpvbi5jb20gSW5jLiBMPVNlYXR0bGUgU1Q9V2FzaGluZ3RvbiBDPVVTMB4XDTE5MDgwNDE5MjI1NVoXDTQ5MTIzMTIzNTk1OVowDTELMAkGA1UEBhMCRVUwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAASCzFZFhPXBbr6G6gbhT /rGXROhN5AHdwhxfpY55xi3c1W3TBuvUdZYdU2Urc9t4ces9Nz3UcF1xfMBvIpVqMVco2AwXjAfBgNVHSMEGDAWgBT3n7seZ1eHUIcZCcuwn0fkEad77TAdBgNVHQ4EFgQUUruspk3ohBJB8buA8qq9kQIZUs0wDAYDVR0TAQH/ BAIwADAOBgNVHQ8BAf8EBAMCB4AwDQYJKoZIhvcNAQELBQ hh : mm : ss MQT : stat /tasmota/IR2/ RESULT = { \"TLSKey1\" : 32 , \"TLSKey2\" : 641 } You need to check that both values are not \"-1\". The value for \"TLSKey1\" should always be 32. The value for \"TLSKey2\" varies depending on several parameters, and should be within the 640-700 bytes range. Alternative version: Convert your certificate from PEM to DER (binary) format: openssl x509 -in tasmota-01.cert.pem -inform PEM -outform DER -out tasmota-01.cert.der Then convert the Certificate to plain base64 in a single line (use -A flag): openssl base64 -e -in tasmota-01.cert.der -A -out tasmota-01.cert.b64 Then use the command TSLKey2 <base64> and replace <base64> with the content of tasmota-01.cert.b64 . 9. Configure Tasmota device ~ This is the last step, you need to configure the MQTT parameters. The easiest way is through the web console. Here is a command per command description. Most commands will trigger a device reboot. You can use backlog to launch all commands at once. Enter the AWS IoT endpoint. MqttHost <xxxxxxxxxxxxxx>-ats.iot.eu-central-1.amazonaws.com Set the MQTT port: MqttPort 8883 Note: the AWS IoT endpoints will not always fit into the 32 bytes MqttHost field. If the endpoints is bigger than 32 chars, it will be transparently split between MqttUser and MqttHost. MqttUser is not used anyways in AWS IoT. You may however notice it if you flash later with a non-AWS IoT Tasmota firmware. Optional, change the topic to distinguish the devices from each others: Topic sonoff/Tasmota-01 There are two ways to check the server certificate. This is controlled with the #define USE_MQTT_TLS_CA_CERT option in sonoff/my_user_config.h file. If activated, Tasmota will check the server certificate validity with the AmazonCA1 certificate embedded. This is the simplest option but it's a little slower. Alternatively you can use fingerprint validation instead - see appendix. Here is the wrap-up of commands: BackLog MqttHost <xxxxxxxxxxxxxx>-ats.iot.eu-central-1.amazonaws.com; MqttPort 8883; Topic sonoff/Tasmota-01; MqttFingerprint1 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 Keep in mind that AWS IoT does not support 'retained' messages. Whatever the 'retained' configuration in Tasmota, messages are always published as 'retained=false'. Here is an example of output you should see: 00 : 00 : 04 HTP : Web server active on sonoff - 4585 with IP address 192.168 . 1.59 00 : 00 : 04 UPP : Multicast ( re ) joined 21 : 28 : 25 MQT : Attempting connection ... 21 : 28 : 25 MQT : AWS IoT endpoint : xxxxxxxxxxxxx - ats . iot . eu - central - 1 . amazonaws . com 21 : 28 : 26 MQT : AWS IoT connected in 1279 ms 21 : 28 : 26 MQT : Connected 21 : 28 : 26 MQT : tele /tasmota/ LWT = Online 21 : 28 : 26 MQT : cmnd /tasmota/ POWER = 21 : 28 : 26 MQT : tele /tasmota/ INFO1 = { \"Module\" : \"Sonoff Basic\" , \"Version\" : \"6.5.0.14(sonoff)\" , \"FallbackTopic\" : \"cmnd/DVES_67B1E9_fb/\" , \"GroupTopic\" : \"sonoffs\" } 10. Check end-to-end communication ~ In the AWS IoT console, click on \" Test \" in the left panel. In the \" Subscription topic \" field, type +/sonoff/# then click on \" Subscribe to topic \". This will display all MQTT messages received. Type a command in the Web Tasmota console, you should see MQTT message flow. Enjoy! For implementation details, see here ~ Appendix: Fingerprint validation ~ If you don't use #define USE_MQTT_TLS_CA_CERT , Tasmota will check the fingerprint of the public key of the server. To ease configuration you are advised to activate the 'learn on first connect feature'. Tasmota will learn the fingerprint during the first connection. To do so use: MqttFingerprint1 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 Alternatively you can completely disable fingerprint validation and accept any server. Keep in mind that this allows Man-in-the-Middle interception of your data. To do so use: MqttFingerprint1 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF","title":"AWS IoT"},{"location":"AWS-IoT/#benefits","text":"AWS IoT provides secure, bi-directional communication between Internet-connected devices such as sensors, actuators, embedded micro-controllers. This basically allows to communicate in both direction from the cloud using MQTT over secure channels using TLS.","title":"Benefits"},{"location":"AWS-IoT/#caveats","text":"AWS IoT requires each Tasmota device to have its own distinct Private Key and Certificate (~800 bytes). Although you could imagine to use the same Private Key in all your devices, this is considered as a very bad practice. You are warned! Currently the only way to onboard your private key is to custom compile your own firmware, each one with its own private key embedded in C code. We explore later ways to store the keys in EEPROM or somewhere that wouldn't need to burn it into the firmware and that would survive OTA update. During TLS handshake, a secondary stack of 5.3k is allocated on the heap to allow BearSSL to have enough stack room. Memory is freed at the end of the handshake. Allocating such big chunks of memory can cause issues when heap fragmentation gets too high. During the first testing campaign, I didn't see any crash due to lack of memory - but this is something we need to keep on monitoring. The alternative would be to allocate this memory once and for all, meaning less memory for Tasmota but no possible crash due to fragmentation.","title":"Caveats"},{"location":"AWS-IoT/#how-to-configure","text":"AWS IoT requires a distinct Private Key and Certificate per Tasmota device. Currently you need to custom compile your Tasmota firmware and burn the Key and Certificate in your firmware. We will later explore how to configure them separately. Here is a simple guide.","title":"How to configure?"},{"location":"AWS-IoT/#0-open-an-aws-account","text":"If you don't have already one, just follow the guide: https://aws.amazon.com/premiumsupport/knowledge-center/create-and-activate-aws-account/","title":"0. Open an AWS Account"},{"location":"AWS-IoT/#1-prerequisites","text":"You will need to install/compile the following: Complete environment to compile Tasmota, ex: PlatformIO (PlatformIO) Recent version of openssl","title":"1. Prerequisites"},{"location":"AWS-IoT/#15-deploy-required-resources-using-aws-cloudformation-and-skip-to-step-6","text":"The following AWS CloudFormation template will create these resources: One IAM Role LambdaExecutionRole Will allow the Lambda function to write to CloudWatch for Logging. One AWS Lambda function to create a CSR and Private Key as described in Step 3. One Custom Resource to Invoke the Lambda function One IoT Certificate using the Generated CSR One IoT Thing One IoT Policy One IoT PolicyAssociation One IoT ThingAssociation Click on the link for the region you have chosen: Region Code Launch US East (N. Virginia) us-east-1 EU (Ireland) eu-west-1 AWS CloudFormation Launch Instructions (expand for details) 1. Click the **Launch Stack** link above for the region of your choice. 1. Click **Next** on the Select Template page. 1. On the Specify Details page, leave all the defaults and click **Next**. 1. On the Options page, leave all the defaults and click **Next**. 1. On the Review page, Click the checkboxes to give AWS CloudFormation permission to **\"create IAM resources\"** 1. Click **\"Create stack\"** 1. Wait for the `IotThingGenerator` stack to reach a status of `CREATE_COMPLETE`. 1. With the `IotThingGenerator` stack selected, click on the **Outputs** tab. You will find your CSR and Private Key which will be referenced in the later steps. You need to copy & paste the contents of the Outputs tab of the CloudFormation stack for the Key to a separate text editor and save the file as tasmota-01.key . To download the IoT certifcate (.cert) key. Navigate to Click on \" Services \" and select \" IoT Core \". On the left panel, click on \" Secure \" > \" Certificates \". Select the three dots on the right of certificate and click on Download . skip to Step 6. To get the IoT endpoint go to Step 4.","title":"1.5 Deploy required resources using AWS CloudFormation and skip to Step 6."},{"location":"AWS-IoT/#2-configure-aws-iot-to-be-done-once","text":"Open the AWS Console. Click on \" Services \" and select \" IoT Core \". Select the AWS Region where you want to locate your data, for ex: \" (EU) Frankfurt \". Now we need to create a security policy to allow your Tasmota devices to connect to AWS IoT, publish and subscribe to topics. On the left panel, click on \" Secure \" > \" Policies \". Click on the \" Create \" button in the upper right corner. Enter in the \" Name \" field, enter the name of your policy, for ex: \" TasmotaMqttPolicy \". Then click on \" Advanced mode \" Cut and paste the policy below. Click on \" Create \" in the lower right corner. { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Action\": [ \"iot:Connect\", \"iot:Publish\", \"iot:Subscribe\", \"iot:Receive\" ], \"Resource\": \"*\" } ] }","title":"2. Configure AWS IoT (to be done once)"},{"location":"AWS-IoT/#3-create-a-private-key-and-certificate-once-per-tasmota-device","text":"Do not use the default AWS IoT feature to generate your private key online. It creates a 2048 bits RSA key. Instead we are using elliptic curves keys - they are much smaller in memory than RSA keys (this saves ~1k of memory) and the handshake is significantly faster. First create an ECC private key for your device (as described in this Blog ). Keep you private key in a safe place. $ openssl ecparam -name prime256v1 -genkey -out tasmota-01.key Next, using this private key, create a certificate signing request (CSR). When asked enter the certificate details. This is not really used later, you can just enter a 2 letters country code like \" EU \" and leave all other fields blank (type 8 times enter). $ openssl req -new -sha256 -key tasmota-01.key -nodes -out tasmota-01.csr You are about to be asked to enter information that will be incorporated into your certificate request. What you are about to enter is what is called a Distinguished Name or a DN. There are quite a few fields but you can leave some blank For some fields there will be a default value, If you enter '.' , the field will be left blank. ----- Country Name ( 2 letter code ) [] :EU <enter> State or Province Name ( full name ) [] : <enter> Locality Name ( eg, city ) [] : <enter> Organization Name ( eg, company ) [] : <enter> Organizational Unit Name ( eg, section ) [] : <enter> Common Name ( eg, fully qualified host name ) [] : <enter> Email Address [] : <enter> Please enter the following 'extra' attributes to be sent with your certificate request A challenge password [] : <enter> Next ask AWS IoT to sign your key with its certificate. On the left panel, click on \" Secure \" > \" Certificates \". Click on \" Create a certificate \". Then choose the \" Create with CSR \" button, locate your CSR file from above. Click on \" Upload file \". Download the certificate file, click on \" Download \", save the file as \" tasmota-01.cert.pem \". Important : don't forget to click on the \" Activate \" to activate the certificate. Your Private Key and Certificates are ready to use. Now we need to register the Tasmota Device.","title":"3. Create a Private Key and Certificate (once per Tasmota device)"},{"location":"AWS-IoT/#4-write-down-your-aws-iot-endpoint-same-for-all-devices","text":"Click on \" Settings \" in the left panel. You should see a field called \" Custom endpoint \". Write down the endpoint domain name. It should look like this (if you have chosen the Frankfurt region: <xxxxxxxxxxxxxx>-ats.iot.eu-central-1.amazonaws.com This is your MQTT endpoint, the port is 8883 - MQTT over TLS.","title":"4. Write down your AWS IoT endpoint (same for all devices)"},{"location":"AWS-IoT/#5-register-the-device-in-aws-iot-once-per-tasmota-device","text":"Now on the left pane, click on \" Manage \" > \" Things \". Click on \" Register a thing \", then \" Create a single thing \". Give your device a name like \" Tasmota-01 \". Scroll down and click \" Next \" at the botton right. Then click on \" Create thing without a certificate \". Now we need to associate the certificate created earlier to your device. In the left panel, click back on \" Secure \" > \" Certificates \". Select the certificate created earlier. In the next pane, click on \" Actions \" in the upper right part. First select \" Attach policy \", check \" TasmotaMqttPolicy \" and \" Attach \". Click again on \" Actions \" and select \" Attach thing \", check \" Tasmota-01 \" and \" Attach \". Your setup is done in AWS IoT. Let's proceed to the custom firmware.","title":"5. Register the device in AWS IoT (once per Tasmota device)"},{"location":"AWS-IoT/#6-enable-aws-iot-in-tasmota","text":"Using your favorite IDE, create user_config_override.h and add the required compilation directives as documented at the top of this article. Note: TLS handshake takes ~1.2s on ESP8266 @80MHz. You may choose to switch to 160MHz if the power supply of your device supports it. If you do so, handshake time should be ~0.7s. Compile the firmware and ensure it completes successfully. This step is only to check compilation goes well. Your firmware is still not usable since it does not contain the Private Key + Certificate.","title":"6. Enable AWS IoT in Tasmota"},{"location":"AWS-IoT/#7-flash-your-device","text":"Flash your device the normal way; either through serial or OTA. If you use OTA, first flash a sonoff-minimal firmware, then your target firmware.","title":"7. Flash your device"},{"location":"AWS-IoT/#8-prepare-your-aws-iot-credentials","text":"You will now need to convert your AWS IoT credentials to Tasmota commands. Credentials are composed of two distinct parts, first a Private Key - this is the secret that will allow your device to prove it is who it pretends to be. Consider this as sensitive as a password. The Private Key is exactly 32 bytes (256 bits). The second part is the Certificate delivered by AWS IoT. Tasmota will also need it to authenticate to the AWS IoT endpoint. Both credentials must be stored in Tasmota Flash memory, in that order, using the new TLSKey command.","title":"8. Prepare your AWS IoT credentials"},{"location":"AWS-IoT/#9-configure-tasmota-device","text":"This is the last step, you need to configure the MQTT parameters. The easiest way is through the web console. Here is a command per command description. Most commands will trigger a device reboot. You can use backlog to launch all commands at once. Enter the AWS IoT endpoint. MqttHost <xxxxxxxxxxxxxx>-ats.iot.eu-central-1.amazonaws.com Set the MQTT port: MqttPort 8883 Note: the AWS IoT endpoints will not always fit into the 32 bytes MqttHost field. If the endpoints is bigger than 32 chars, it will be transparently split between MqttUser and MqttHost. MqttUser is not used anyways in AWS IoT. You may however notice it if you flash later with a non-AWS IoT Tasmota firmware. Optional, change the topic to distinguish the devices from each others: Topic sonoff/Tasmota-01 There are two ways to check the server certificate. This is controlled with the #define USE_MQTT_TLS_CA_CERT option in sonoff/my_user_config.h file. If activated, Tasmota will check the server certificate validity with the AmazonCA1 certificate embedded. This is the simplest option but it's a little slower. Alternatively you can use fingerprint validation instead - see appendix. Here is the wrap-up of commands: BackLog MqttHost <xxxxxxxxxxxxxx>-ats.iot.eu-central-1.amazonaws.com; MqttPort 8883; Topic sonoff/Tasmota-01; MqttFingerprint1 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 Keep in mind that AWS IoT does not support 'retained' messages. Whatever the 'retained' configuration in Tasmota, messages are always published as 'retained=false'. Here is an example of output you should see: 00 : 00 : 04 HTP : Web server active on sonoff - 4585 with IP address 192.168 . 1.59 00 : 00 : 04 UPP : Multicast ( re ) joined 21 : 28 : 25 MQT : Attempting connection ... 21 : 28 : 25 MQT : AWS IoT endpoint : xxxxxxxxxxxxx - ats . iot . eu - central - 1 . amazonaws . com 21 : 28 : 26 MQT : AWS IoT connected in 1279 ms 21 : 28 : 26 MQT : Connected 21 : 28 : 26 MQT : tele /tasmota/ LWT = Online 21 : 28 : 26 MQT : cmnd /tasmota/ POWER = 21 : 28 : 26 MQT : tele /tasmota/ INFO1 = { \"Module\" : \"Sonoff Basic\" , \"Version\" : \"6.5.0.14(sonoff)\" , \"FallbackTopic\" : \"cmnd/DVES_67B1E9_fb/\" , \"GroupTopic\" : \"sonoffs\" }","title":"9. Configure Tasmota device"},{"location":"AWS-IoT/#10-check-end-to-end-communication","text":"In the AWS IoT console, click on \" Test \" in the left panel. In the \" Subscription topic \" field, type +/sonoff/# then click on \" Subscribe to topic \". This will display all MQTT messages received. Type a command in the Web Tasmota console, you should see MQTT message flow. Enjoy!","title":"10. Check end-to-end communication"},{"location":"AWS-IoT/#for-implementation-details-see-here","text":"","title":"For implementation details, see here"},{"location":"AWS-IoT/#appendix-fingerprint-validation","text":"If you don't use #define USE_MQTT_TLS_CA_CERT , Tasmota will check the fingerprint of the public key of the server. To ease configuration you are advised to activate the 'learn on first connect feature'. Tasmota will learn the fingerprint during the first connection. To do so use: MqttFingerprint1 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 Alternatively you can completely disable fingerprint validation and accept any server. Keep in mind that this allows Man-in-the-Middle interception of your data. To do so use: MqttFingerprint1 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF","title":"Appendix: Fingerprint validation"},{"location":"AZ-7798/","text":"!> This feature is not included in precompiled binaries. To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_AZ7798 #define USE_AZ7798 // Add support for AZ-Instrument 7798 CO2 datalogger (+1k6 code) #endif The AZ7798 CO 2 Meter/Datalogger appears to be made by AZ Instrument , but other branded versions exist. The CO 2 meter is already provided with a PC interface in the form of a logic-level (3V3) serial port, accessible through a 2.5mm stereo jack on the back. The Wemos D1 Mini is connected to this serial port instead, and the PC interface is no longer available. Configuration ~ Connecting the AZ7798 to a Wemos D1 Mini ~ The Wemos D1 Mini is fitted inside the meter enclosure. This requires the enclosure to be opened. There are four screws. Two of the screws are hidden behind the type label. Use the tip of a small knife to cut holes in the label. There are also two clips at the top of the enclosure. To release those, gently pry apart the bottom of the enclosure a small amount. The grey band between the two halves can now be lifted up and pushed aside a little and expose the clips near the top. A push with a flat-blade screwdriver will then release the clips. Once the enclosure is opened, disconnect the two serial port wires from the socket on the back panel. The black wire (0V) can remain connected. Now connect these two wires to TX and RX of the Wemos D1 Mini. Wemos D1 Mini AZ7798 TX wire with stripe RX wire without stripe The power supply for the Wemos D1 Mini is taken directly from the power supply for the meter, which is a 5V external power supply. Solder two wires to the incoming power supply and connect the other ends to the 5V and G terminals on the Wemos D1 Mini. Make a small right-angle bracket for mounting the Wemos D1 Mini to the meter board. Use double-sided tape to hold everything together. Tasmota Settings ~ In the Configuration -> Configure Module page assign: D1 TX to AZ Tx (117) D3 RX to AZ Rx (118) After reboot of the device the AZ7798 measurements are shown.","title":"AZ 7798"},{"location":"AZ-7798/#configuration","text":"","title":"Configuration"},{"location":"AZ-7798/#connecting-the-az7798-to-a-wemos-d1-mini","text":"The Wemos D1 Mini is fitted inside the meter enclosure. This requires the enclosure to be opened. There are four screws. Two of the screws are hidden behind the type label. Use the tip of a small knife to cut holes in the label. There are also two clips at the top of the enclosure. To release those, gently pry apart the bottom of the enclosure a small amount. The grey band between the two halves can now be lifted up and pushed aside a little and expose the clips near the top. A push with a flat-blade screwdriver will then release the clips. Once the enclosure is opened, disconnect the two serial port wires from the socket on the back panel. The black wire (0V) can remain connected. Now connect these two wires to TX and RX of the Wemos D1 Mini. Wemos D1 Mini AZ7798 TX wire with stripe RX wire without stripe The power supply for the Wemos D1 Mini is taken directly from the power supply for the meter, which is a 5V external power supply. Solder two wires to the incoming power supply and connect the other ends to the 5V and G terminals on the Wemos D1 Mini. Make a small right-angle bracket for mounting the Wemos D1 Mini to the meter board. Use double-sided tape to hold everything together.","title":"Connecting the AZ7798 to a Wemos D1 Mini"},{"location":"AZ-7798/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: D1 TX to AZ Tx (117) D3 RX to AZ Rx (118) After reboot of the device the AZ7798 measurements are shown.","title":"Tasmota Settings"},{"location":"About/","text":"Alternative firmware for ESP8266 based devices with easy configuration using webUI, OTA updates, automation using timers or rules, expandability and entirely local control over MQTT, HTTP, Serial or KNX . Written for Arduino IDE and PlatformIO.","title":"About"},{"location":"Alexa/","text":"This feature is included only in builds: tasmota and tasmota-sensors To use in other builds you must compile your own build . Add the following to user_config_override.h : #ifndef EMULATION #define EMULATION EMUL_NONE // [ Emulation ] Select Belkin WeMo ( single relay / light ) or Hue Bridge emulation ( multi relay / light ) ( EMUL_NONE , EMUL_WEMO or EMUL_HUE ) #endif EMUL_NONE = disables emulation EMUL_WEMO = enables Belking WeMo emulation EMUL_HUE = enables Hue Bridge emulation Connecting to Alexa ~ You can interact with Tasmota using Amazon Alexa through its Echo devices . In Configuration - Configure Other page in the webUI select emulation type. Warning Alexa Hue integration requires a physical Alexa device. The app alone is not enough. Belkin WeMo Emulation Use Belkin WeMo for devices with a single relay or Hue Bridge for devices with one or more relays or for lights. Tasmota devices will be discovered by the Alexa app. Hue Bridge Emulation For control of lights, color control (introduced in version 6.5.0.9), on/off, and dimming is supported. Enable Hue Bridge emulation and perform a device discovery in the Alexa app. No skill needs to be added to Alexa. Select Hue Bridge V1 as the device type. Relays and lights with friendly names beginning with a dollar sign ( $ ) will cause Tasmota to not \"announce\" them (i.e., be hidden) to Alexa. If they were previously discovered, they will still continue to work. As there are only four friendly names provided in Tasmota, if FriendlyName4 begins with $ , component 4 and all higher numbered discoverable components will not be discovered by Alexa. [!NOTE] Hue Bridge emulation does not support sensors.**","title":"Alexa"},{"location":"Alexa/#connecting-to-alexa","text":"You can interact with Tasmota using Amazon Alexa through its Echo devices . In Configuration - Configure Other page in the webUI select emulation type. Warning Alexa Hue integration requires a physical Alexa device. The app alone is not enough.","title":"Connecting to Alexa"},{"location":"Arduino-IDE/","text":"Download Arduino IDE ~ Download Arduino IDE from https://www.arduino.cc/en/main/software It is recommended to use a dedicated standalone version of the IDE allowing easy ESP8266 file manipulation and library management. This can be achieved by downloading the Arduino IDE ZIP file for non admin install. Install Arduino IDE ~ Windows: Unzip the installation file to a known folder. Mac: Move the .app file into your Applications folder. IMPORTANT: For Windows users, before executing arduino.exe add an empty folder called portable in the known folder. Install ESP8266 Board Definitions ~ Open Arduino IDE and select File \u2192 Preferences ( Arduino \u2192 Preferences on Mac) and use the following text for field Additional Boards Manager URLs: https://github.com/esp8266/Arduino/releases/download/2.6.1/package_esp8266com_index.json and select OK . Open Tools \u2192 Boards... \u2192 Boards Manager... and scroll down and click on esp8266 by ESP8266 Community . Click the Install button to download and install the latest ESP8266 board software. Select Close . Copy Files ~ Remove default compile options for floating point printf and scanf which are not being used by Tasmota and save 15k code space. Replace in Arduino IDE folder portable\\packages\\esp8266\\hardware\\esp8266\\2.6.1 file platform.txt with the Tasmota Source code file arduino\\version 2.6.1\\platform.txt . Download Tasmota ~ Download the latest Tasmota release Source code from https://github.com/arendst/Tasmota and unzip to another known folder. Copy all files from the Tasmota release Source code folder lib into your sketchbook\\libraries folder. About the issue of missing header files and/or libraries while compiling that users had, it is possible that the library folder is in the wrong place. That issue can be happen if you installed your Arduino IDE in a virtual environment. This came up after some tests (6) of an installation in VM-Ware Workstation 14 Pro - 14.1.1 build-7528167 with not all current updates from VM-Ware. The library folder was placed in /portable/libraries and not in /portable/sketchbook/libraries . We can't say why that happens but there is the possibilty. So please check it when you get compile errors with missing header files and/or libaries. After updating VM-Ware and a new installation of Arduino IDE 1.8.8 the issue was gone. The installation of Arduino IDE 1.8.8 on windows 7 pro were 100% ok without any issue. Right now the newer version of Arduino IDE is available. Version 1.8.9 Copy the Tasmota release Source code folder tasmota to your sketchbook . Note: your sketchbook location can be found in the Arduino IDE preferences, default on the Mac is ~/Documents/Arduino . Configure Arduino IDE ~ Select Tools and verify the following settings for All Tasmota devices . ESP8266 Board version 2.6.1: Compile Tasmota ~ Open Arduino IDE and select file tasmota.ino from your sketchbook\\tasmota folder. Compile Tasmota with Sketch - Verify/Compile . Upload Tasmota to Device ~ Arduino IDE uses the serial interface to upload the firmware to your device. On Windows these interfaces are named COM1, COM2 etc. On Linux these interfaces are called /dev/ttyUSB0, /dev/ttyUSB1 etc. In the following commands I use COM5 as an example. Before using Arduino IDE upload make sure you know to which serial interface name your device is connected to. Put device in Firmware Upload Mode ~ When performing a firmware upload do not connect the device to AC but use the power supply provided by your (FTDI type) serial interface. Put the device in firmware upload mode by grounding pin GPIO00 while applying power. Grounding pin GPIO00 can often be achieved by pressing button 1 on the Sonoff device or using a wire between GPIO00 and Gnd if the button is not available. Deviations may apply. Connect the serial interface of your PC to the device while GPIO00 to Gnd. Perform Serial Upload ~ Make the correct serial interface selection in the Arduino IDE via Tools - Port: \"COM5\" . Upload the compiled firmware with Sketch - Upload . NOTE: For a proper device initialization after first firmware upload power down and power up the device.","title":"Arduino IDE"},{"location":"Arduino-IDE/#download-arduino-ide","text":"Download Arduino IDE from https://www.arduino.cc/en/main/software It is recommended to use a dedicated standalone version of the IDE allowing easy ESP8266 file manipulation and library management. This can be achieved by downloading the Arduino IDE ZIP file for non admin install.","title":"Download Arduino IDE"},{"location":"Arduino-IDE/#install-arduino-ide","text":"Windows: Unzip the installation file to a known folder. Mac: Move the .app file into your Applications folder. IMPORTANT: For Windows users, before executing arduino.exe add an empty folder called portable in the known folder.","title":"Install Arduino IDE"},{"location":"Arduino-IDE/#install-esp8266-board-definitions","text":"Open Arduino IDE and select File \u2192 Preferences ( Arduino \u2192 Preferences on Mac) and use the following text for field Additional Boards Manager URLs: https://github.com/esp8266/Arduino/releases/download/2.6.1/package_esp8266com_index.json and select OK . Open Tools \u2192 Boards... \u2192 Boards Manager... and scroll down and click on esp8266 by ESP8266 Community . Click the Install button to download and install the latest ESP8266 board software. Select Close .","title":"Install ESP8266 Board Definitions"},{"location":"Arduino-IDE/#copy-files","text":"Remove default compile options for floating point printf and scanf which are not being used by Tasmota and save 15k code space. Replace in Arduino IDE folder portable\\packages\\esp8266\\hardware\\esp8266\\2.6.1 file platform.txt with the Tasmota Source code file arduino\\version 2.6.1\\platform.txt .","title":"Copy Files"},{"location":"Arduino-IDE/#download-tasmota","text":"Download the latest Tasmota release Source code from https://github.com/arendst/Tasmota and unzip to another known folder. Copy all files from the Tasmota release Source code folder lib into your sketchbook\\libraries folder. About the issue of missing header files and/or libraries while compiling that users had, it is possible that the library folder is in the wrong place. That issue can be happen if you installed your Arduino IDE in a virtual environment. This came up after some tests (6) of an installation in VM-Ware Workstation 14 Pro - 14.1.1 build-7528167 with not all current updates from VM-Ware. The library folder was placed in /portable/libraries and not in /portable/sketchbook/libraries . We can't say why that happens but there is the possibilty. So please check it when you get compile errors with missing header files and/or libaries. After updating VM-Ware and a new installation of Arduino IDE 1.8.8 the issue was gone. The installation of Arduino IDE 1.8.8 on windows 7 pro were 100% ok without any issue. Right now the newer version of Arduino IDE is available. Version 1.8.9 Copy the Tasmota release Source code folder tasmota to your sketchbook . Note: your sketchbook location can be found in the Arduino IDE preferences, default on the Mac is ~/Documents/Arduino .","title":"Download Tasmota"},{"location":"Arduino-IDE/#configure-arduino-ide","text":"Select Tools and verify the following settings for All Tasmota devices .","title":"Configure Arduino IDE"},{"location":"Arduino-IDE/#compile-tasmota","text":"Open Arduino IDE and select file tasmota.ino from your sketchbook\\tasmota folder. Compile Tasmota with Sketch - Verify/Compile .","title":"Compile Tasmota"},{"location":"Arduino-IDE/#upload-tasmota-to-device","text":"Arduino IDE uses the serial interface to upload the firmware to your device. On Windows these interfaces are named COM1, COM2 etc. On Linux these interfaces are called /dev/ttyUSB0, /dev/ttyUSB1 etc. In the following commands I use COM5 as an example. Before using Arduino IDE upload make sure you know to which serial interface name your device is connected to.","title":"Upload Tasmota to Device"},{"location":"Arduino-IDE/#put-device-in-firmware-upload-mode","text":"When performing a firmware upload do not connect the device to AC but use the power supply provided by your (FTDI type) serial interface. Put the device in firmware upload mode by grounding pin GPIO00 while applying power. Grounding pin GPIO00 can often be achieved by pressing button 1 on the Sonoff device or using a wire between GPIO00 and Gnd if the button is not available. Deviations may apply. Connect the serial interface of your PC to the device while GPIO00 to Gnd.","title":"Put device in Firmware Upload Mode"},{"location":"Arduino-IDE/#perform-serial-upload","text":"Make the correct serial interface selection in the Arduino IDE via Tools - Port: \"COM5\" . Upload the compiled firmware with Sketch - Upload . NOTE: For a proper device initialization after first firmware upload power down and power up the device.","title":"Perform Serial Upload"},{"location":"BH1750/","text":"The BH1750 is a digital ambient light sensor module which uses I 2 C to communicate. The BH1750 provides you with a digital value in lux (Lx) over a range of 1 - 65535 lx. See Digital 16bit Serial Output Type Ambient Light Sensor IC for more information. Configuration ~ Wiring ~ BH1750 ESP8266 GND GND VCC 3.3V SDA GPIOx SCL GPIOy Tasmota Settings ~ In the Configuration -> Configure Module page assign: 1. GPIOx to I2C SDA (6) 2. GPIOy to I2C SCL (5) After a reboot the driver will detect BH1750 automatically and display Illuminance. Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2019-11-03T20:45:37\" , \"BH1750\" :{ \"Illuminance\" : 79 }} Breakout Boards ~","title":"BH1750"},{"location":"BH1750/#configuration","text":"","title":"Configuration"},{"location":"BH1750/#wiring","text":"BH1750 ESP8266 GND GND VCC 3.3V SDA GPIOx SCL GPIOy","title":"Wiring"},{"location":"BH1750/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: 1. GPIOx to I2C SDA (6) 2. GPIOy to I2C SCL (5) After a reboot the driver will detect BH1750 automatically and display Illuminance. Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2019-11-03T20:45:37\" , \"BH1750\" :{ \"Illuminance\" : 79 }}","title":"Tasmota Settings"},{"location":"BH1750/#breakout-boards","text":"","title":"Breakout Boards"},{"location":"BME280/","text":"!> This feature is included only in tasmota-sensors.bin BME280 sensor, an environmental sensor with temperature, barometric pressure and humidity\" See BME280 Temperature, Humidity and Pressure Sensor for more information. BME280 driver also supports BMP085 , BMP180 and BMP280 sensors. Configuration ~ Wiring ~ BME280 ESP8266 GND GND VCC 3.3V SDA GPIOx SCL GPIOy Sonoff Basic wiring If you are using breakout boards which break out pins CSB please ensure that you connect this pin to VCC to ensure that the chip stays in I 2 C mode. This is due to some manufacturers of breakout boards add pull-up resistors to allow for SPI compatibility (some would default to SPI, others to I 2 C)_ Connect the SDO pin to GND or VCC to ensure required I 2 C address is used by the chip - Again some manufacturers add resistors to provide external bias but due to them wanting to retain SPI compatibility such pulldown resistors may not be sufficient to ensure that the pin levels are at the correct transition during power-up / reset state._ Since the chip supports both SPI and I 2 C, but in Tasmota only I 2 C is supported you want to make sure that the chip is in I 2 C mode during reset/power-on and remain in that state during operation otherwise unexpected behaviour may result when the Tasmota firmware polls the chip for sensor data. After a reboot the driver will detect BME280 automatically and display temperature, humidity and pressure measured. Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2019-11-03T19:34:28\" , \"BME280\" : { \"Temperature\" : 21.7 , \"Humidity\" : 66.6 , \"Pressure\" : 988.6 }, \"PressureUnit\" : \"hPa\" , \"TempUnit\" : \"C\" } From v6.1.2.20 you can use multiple BMP Sensors ( #4195 ) Limit is 2 sensors and you have to change the address of one sensor. Than connect your sensor SCL and SDA parallel to the device. BME280 address change example: Commands ~ TempOffset can be used for calibrating the measured temperature. This setting affects all temperature sensors on the device. Breakout boards ~","title":"BMP280 pressure sensor"},{"location":"BME280/#configuration","text":"","title":"Configuration"},{"location":"BME280/#wiring","text":"BME280 ESP8266 GND GND VCC 3.3V SDA GPIOx SCL GPIOy Sonoff Basic wiring If you are using breakout boards which break out pins CSB please ensure that you connect this pin to VCC to ensure that the chip stays in I 2 C mode. This is due to some manufacturers of breakout boards add pull-up resistors to allow for SPI compatibility (some would default to SPI, others to I 2 C)_ Connect the SDO pin to GND or VCC to ensure required I 2 C address is used by the chip - Again some manufacturers add resistors to provide external bias but due to them wanting to retain SPI compatibility such pulldown resistors may not be sufficient to ensure that the pin levels are at the correct transition during power-up / reset state._ Since the chip supports both SPI and I 2 C, but in Tasmota only I 2 C is supported you want to make sure that the chip is in I 2 C mode during reset/power-on and remain in that state during operation otherwise unexpected behaviour may result when the Tasmota firmware polls the chip for sensor data. After a reboot the driver will detect BME280 automatically and display temperature, humidity and pressure measured. Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2019-11-03T19:34:28\" , \"BME280\" : { \"Temperature\" : 21.7 , \"Humidity\" : 66.6 , \"Pressure\" : 988.6 }, \"PressureUnit\" : \"hPa\" , \"TempUnit\" : \"C\" } From v6.1.2.20 you can use multiple BMP Sensors ( #4195 ) Limit is 2 sensors and you have to change the address of one sensor. Than connect your sensor SCL and SDA parallel to the device. BME280 address change example:","title":"Wiring"},{"location":"BME280/#commands","text":"TempOffset can be used for calibrating the measured temperature. This setting affects all temperature sensors on the device.","title":"Commands"},{"location":"BME280/#breakout-boards","text":"","title":"Breakout boards"},{"location":"BME680/","text":"This feature is included only in tasmota-sensors.bin Otherwise you must compile your build . Add the following to user_config_override.h : #ifndef USE_BME680 #define USE_BME680 // Enable support for BME680 sensor using Bosch BME680 library (+4k code) #endif BME680 sensor, an environmental I 2 C sensor with temperature, humidity, barometric pressure and gas. The BME680 takes those sensors to the next step in that it contains a small MOX sensor. The heated metal oxide changes resistance based on the volatile organic compounds (VOC) in the air, so it can be used to detect gasses & alcohols such as Ethanol, Alcohol and Carbon Monoxide, and perform air quality measurements. Note it will give you one resistance value, with overall VOC content, but it cannot differentiate gasses or alcohols. See BME680 - Temperature, Humidity, Pressure and Gas Sensor for more information. Configuration ~ Wiring ~ BME680 ESP8266 GND GND VCC 3.3V SDA GPIOx SCL GPIOy Tasmota Settings ~ In the Configuration -> Configure Module page assign: - GPIOx to I2C SDA (6) - GPIOy to I2C SCL (5) After a reboot the driver will detect BME680 automatically and display temperature, humidity, pressure and gas resistance measured. Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2019-11-03T21:25:53\" , \"BME680\" : { \"Temperature\" : 27.7 , \"Humidity\" : 65.2 , \"Pressure\" : 989 , \"Gas\" : 346.24 }, \"PressureUnit\" : \"hPa\" , \"TempUnit\" : \"C\" } Commands ~ TempOffset can be used for calibrating the measured temperature. This setting affects all temperature sensors on the device. Breakout Boards ~ Buy from: - Adafruit - AliExpress","title":"BME680"},{"location":"BME680/#configuration","text":"","title":"Configuration"},{"location":"BME680/#wiring","text":"BME680 ESP8266 GND GND VCC 3.3V SDA GPIOx SCL GPIOy","title":"Wiring"},{"location":"BME680/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: - GPIOx to I2C SDA (6) - GPIOy to I2C SCL (5) After a reboot the driver will detect BME680 automatically and display temperature, humidity, pressure and gas resistance measured. Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2019-11-03T21:25:53\" , \"BME680\" : { \"Temperature\" : 27.7 , \"Humidity\" : 65.2 , \"Pressure\" : 989 , \"Gas\" : 346.24 }, \"PressureUnit\" : \"hPa\" , \"TempUnit\" : \"C\" }","title":"Tasmota Settings"},{"location":"BME680/#commands","text":"TempOffset can be used for calibrating the measured temperature. This setting affects all temperature sensors on the device.","title":"Commands"},{"location":"BME680/#breakout-boards","text":"Buy from: - Adafruit - AliExpress","title":"Breakout Boards"},{"location":"Blinds-and-Shutters/","text":"!> This feature is not included in precompiled binaries. To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_SHUTTER #define USE_SHUTTER // Add Shutter support (+6k code) #endif ?> Control blinds and roller shades connected to regular ON/OFF motors or stepper motors. The device must have at least two relays (e.g., a Sonoff Dual R2 ). Otherwise the shutter feature will not work. Commands ~ First enable shutter support with SetOption80 1 Complete list of commands is available at Blinds, Shutters and Roller Shades Commands . Shutter Modes ~ There are three shutter modes which are defined according to the PulseTime and Interlock settings. The examples below are for a ShutterRelay1 1 configuration (using Relay1 and Relay2). 1. ShutterMode 0 - Normal Operation First relay: OFF/DOWN, Second relay: OFF/UP - Backlog PulseTime1 0; PulseTime2 0 - Backlog Interlock 1,2; Interlock ON (Interlocked relay pair) ShutterMode 1 - Circuit Safe First relay: ON/OFF, Second relay: UP/DOWN Backlog PulseTime1 0; PulseTime2 0 Interlock OFF ShutterMode 2 - Pulse Motors First relay: OFF/DOWN PULSE, Second relay: OFF/UP PULSE Backlog PulseTime1 2; PulseTime2 2 Backlog Interlock 1,2; Interlock ON (Interlocked relay pair) ShutterMode 3 - Stepper Motors First relay: ON/OFF, Second relay: UP/DOWN PWM: Stepper signal, COUNTER: Stepper position signal Backlog PulseTime1 0; PulseTime2 0 Interlock OFF PWM and COUNTER defined Wiring diagrams for Normal, Stepper motor, and Short Circuit-Safe configurations are available at the end of this page. Even if the shutter does not have two motors, three wires have to be connected. Note After setting the options for shutter mode, the device must be rebooted. Otherwise, the sliders won't be available in the web UI, and the ShutterOpenDuration<x> and ShutterCloseDuration<x> commands will report \"Shutter unknown\". Issue ShutterRelay<x> 1 command and check in console which ShutterMode is displayed: Shutter accuracy digits: 1 Shutter 0 (Relay:1): Init. Pos: 20000 [100 %], Open Vel.: 100 Close Vel.: 100 , Max Way: 20000, Opentime 10.0 [s], Closetime 10.0 [s], CoedffCalc: c0: 0, c1 200, c2: 200, c3: 0, c4: 0, binmask 3, is inverted 1, ShutterMode 0 , motordelay 0 Operation ~ Turning a device relay on or off directly (i.e., using Power ) will function to affect a shutter's movement. In momentary mode (i.e., stepper motor), the relays start or stop the motor. The driver takes care of the direction and proper update of the shutter position. The shutter reports its position and can also be sent to a dedicated position. ShutterPosition = 0 means the shutter is closed and ShutterPosition = 100 means the shutter is open. If you need the position values reversed ( 0 = open, 100 = closed), define and calibrate your shutter as documented below . Then tell Tasmota to reverse the shutter position meaning via the ShutterInvert<x> 1 command. All internal calculations are the same (the log output is the same). Only the interaction with the user and other systems changes. Now ShutterPosition<x> 0 will open the shutter and ShutterPosition<x> 100 will close the shutter. By default, only Shutter1 is enabled when SetOption80 1 is invoked. A maximum of four shutters per device are supported. To enable additional shutters, ShutterRelay<x> <value> must be executed for each additional shutter. Additional shutter declarations must be sequentially numbered, and without gaps (i.e., second shutter is 2, then shutter 3, and finally shutter 4). Disabling a shutter in the middle of the defined set of shutters will disable all other higher numbered shutters. If the disabled shutter is restored, the higher numbered shutters previously declared will also be restored. When a shutter is added or removed, a list of the active shutters, with their parameters, is output to the log. If you intend to remove shutters, explicitly remove each one beginning with the highest numbered shutter. With four shutters, eight Relay<x> components are needed. If manual operation switches ( Switch<x> or Button<x> pairs) are also used, additional input GPIO are required. The ESP82xx device may not have enough free GPIO to support all the shutter connections required. A GPIO expander such as a PCF8574 or MCP230xx can be used. Using manual operation Switch<x> pairs may require setting SwitchMode<x> 4 (inverse follow) for proper switch behavior. Any shutter positioning can be locked ShutterLock<x> 1 . Once executed an ongoing movement is finished while further positioning commands like ShutterOpen<x> , ShutterClose<x> , ShutterStop<x> , and ShutterPosition<x> , as well as web UI buttons, web UI sliders, and shutter buttons are disabled. This can be used to lock an outdoor blind in case of high wind or rain. You may also disable shutter positioning games by your children. Shutter positioning can be unlocked using ShutterLock<x> 0 . Please be aware that the shutter can still be moved by direct relay control (i.e., power<x> ), or physical switches and buttons. Use hte ShutterButton<x> command prior to ShutterLock to be able to lock buttons. Pulse Motor Support ~ There are shutters that have two relays but only need a pulse to start or stop. Depending on the current situation a pulse will stop the shutter or send it into a specific direction. To use these kinds of shutters a PulseTime must be defined on each relay. The minimum setting that seems to make it work consistently is 2 . A setting of 1 does not work. If the shutter moves too fast and does not react to a stop command, increase the setting to 3 or 4 . Stepper Motor Support ~ Stepper motors can also be used to operate shutters and blinds. Additionally you can operate sliding doors with this configuration. Please refer to Shutters and Steppers for details. Calibration ~ Shutter calibration video tutorial Set the ShutterOpenDuration<x> to the time the shutter needs to open completely. Set the ShutterCloseDuration<x> at least to the time the shutter needs to close completely. If the shutter does not close completely or runs too long, the calibration point of a closed shutter can be defined with ShutterSetClose<x> . Move the shutter to the close position and execute ShutterSetClose<x> command. ShutterPosition<x> will be reset to 0 ( ShutterClose<x> ). Set the 50% open position of the shutter. Some shutters need some time from totally closed until they begin moving the bottom-most part and opening. This often results a shutter that is less than 50% open when the shutter has been operating for 50% of the set duration. This can be corrected by using ShutterSetHalfway<x> . Use this procedure to calibrate the half-open position: ShutterClose<x> (confirm that the shutter is completely closed) ShutterSetHalfway<x> 50 (reset to default) Move the shutter to actual 50% open position. Use ShutterPosition<x> to inquire the shutter's current position and record the value. This value is a percentage of the total opening (e.g., 63 = 63% of opening). ShutterClose<x> ShutterSetHalfway<x> 63 (using the value from step #4 above) Restart 1 After calibration you might want to enable an additional 1s motor movement by ShutterEnableEndStopTime<x> 1 when the shutter is asked to move to its end positions (0% and 100%). By this you can guarantee that end positions are still reached in case of inaccuracies. Take care to disable this by ShutterEnableEndStopTime<x> 0 before further open or close duration measurements. Increasing Calibration Granularity ~ If you desire that the %-opening closely match what ShutterPosition<x> and web UI indicate, there is a granular calibration matrix available. Ensure that ShutterClose<x> and ShutterOpen<x> moves the shutter more or less to the limit positions and follow this procedure: - ShutterSetHalfway<x> 50 (reset to default) - ShutterCalibration<x> 30 50 70 90 100 - Restart 1 - ShutterClose<x> - Move the shutter to each of the following opening percentages and measure the shutter's position for each. - ShutterPosition<x> 30 (e.g., measurement = 15 ) - ShutterPosition<x> 50 (e.g., measurement = 50 ) - ShutterPosition<x> 70 (e.g., measurement = 100 ) - ShutterPosition<x> 90 (e.g., measurement = 150 ) - ShutterPosition<x> 100 (e.g., measurement = 180 ) - Finally, enter the position measurements as the calibration values: ShutterCalibration<x> 15 50 100 150 180 ShutterCalibration<x> takes position measurements ( not the time it takes to move). During calibration you position the shutter to an indicated percentage (e.g., 30% ) of opening and measure the shutter position (e.g., 15 ). Use the same unit of measure for all your measurements (e.g., centimeters, inches, etc.). After calibration ShutterPosition<x> 30 will move to 30% opening which will correspond to the position you provided ( 15 ). Notice that there is no calibration for the 10\\% position. On many shutters, there is no movement during the initial phase (i.e., nearly 10% of total time). Therefore the opening could be 0 . This measurement would cause an execution DIV 0 exception. Therefore the first calibration point is 30%. In most cases this is not a large opening so the calibration will be near enough. Yes, until ~10%, the position will be a bit \"off\" but not enough for concern. Motor Movement Delays ~ Some motors need up to one second after power is turned on before they start moving. You can confirm if you are having this issue if opening and closing as a single action works properly but doing this in smaller steps result in a shift of the position. 1. Shutterposition<x> 30 Measure the shutter position. This is the reference_position 2. Shutterposition<x> 80 Measure the shutter position. This is the max_position 3. Shutterposition<x> 30 Return the shutter to starting position. This must be the same position as measured in step #1 ( reference_position ). If not, ShutterCloseDuration must be adjusted. 4. Shutterposition<x> 50 5. Shutterposition<x> 70 6. Shutterposition<x> 80 If you do not reach max_position you have a motor delay problem. Measure the shutter position. This is the real_max . Use this value in the calculation below. 7. ShutterMotorDelay<x> <delay> Motor <delay> calculation - fine tune in 0.05 second increments (e.g. 0.65 ) as required. <delay> = ((max_position-real_max) / 2) / (((100/80) * max_position) / ShutterOpenDuration) Close the shutter and repeat this procedure until the motor delay is set properly. Button control ~ When shutter is running in normal ShutterMode: 0 , you already have basic control over the shutter movement using tasmota switches or tasmota buttons in the module configuration to directly drive the shutter relays. For short circuit safe operation ShutterMode: 1 direct control of the relays will not give you a nice user interface since you have to 1st set the direction with one switch or button and 2nd switch on the power by the other switch or button. To have shutter mode independent button control over the shutter and not over its relays one can use the ShutterButton<x> command. It also introduces some more features, see below: ShutterButton<x> <button> <func> <mqtt> This assigns a tasmota button <button> to control your shutter <x> having functionality <func> . The tasmota button <button> must already be configured in the module configuration. You can assign multiple buttons to a single shutter. Any button can only control one shutter (beside the <mqtt> broadcast feature, see description below). Any press of the button while the shutter is moving will immediately stop the shutter. One can remove all button control for shutter <x> by ShutterButton<x> 0 . The assigned button can have one of the following functionalities: Setup for an \"up\" button: ShutterButton<x> <button> up <mqtt> Single press will move shutter to 100%, double press to 50% and tripple press to 74%. Holding the button for more than the hold time (SetOption32) moves all shutters with same <grouptopic> to 100% when <mqtt> is equal to 1 . When <mqtt> is equal to 0 hold action of this button is same as single press. Setup for a \"down\" button: ShutterButton<x> <button> down <mqtt> Single press will move shutter to 0%, double press to 50% and tripple press to 24%. Holding the button for more than the hold time (SetOption32) moves all shutters with same <grouptopic> to 0% when <mqtt> is equal to 1 . When <mqtt> is equal to 0 hold action of this button is same as single press. Setup for an \"updown\" button: ShutterButton<x> <button> updown <mqtt> Single press will move shutter to 100%, double press down to 0% and tripple press to 50%. No hold action and no other shutter control by MQTT, <mqtt> is don't care here. More advanced control of the button press actions is given by the following ShutterButton<x> command syntax: ShutterButton<x> <button> <p1> <p2> <p3> <ph> <m1> <m2> <m3> <mh> <mi> <button> 1..4 : Button number, 0/- : disable buttons for this shutter <p1> 0..100 : single press position, - : disable <p2> 0..100 : double press position, - : disable <p3> 0..100 : tripple press position, - : disable <ph> 0..100 : hold press position, - : disable <m1> 1 : enable single press position MQTT broadcast, 0/- : disable <m2> 1 : enable double press position MQTT broadcast, 0/- : disable <m3> 1 : enable tripple press position MQTT broadcast, 0/- : disable <mh> 1 : enable hold press position MQTT broadcast, 0/- : disable <mi> 1 : enable MQTT broadcast to all shutter indices, 0/- : disable Any parameters are optional: when missing all subsequent parameters are set to disable . By a button single press the shutter is set to position <p1> . Double press will drive the shutter to position <p2> and tripple press to position <p3> . Holding the button for more than the SetOption32 time sets the shutter position to <ph> . Any button action <p1> to <ph> can be disabled by setting the parameter to - . Independent from configuration <p1> to <ph> any press of the button while the shutter is moving will immediately stop the shutter. Global steering of all your shutters at home is supported by additional MQTT broadcast. By any button action a corresponding MQTT command can be initiated to the <grouptopic> of the device. For single press this can be enabled by <m1> equal to 1 , disabling is indicated by - . Double to hold MQTT configurations are given by <m2> to <mh> , correspondingly. When <mi> is equal to - only cmnd/<grouptopic>/Shutterposition<x> <p1..h> is fired. When <mi> is equal to 1 , <x> = 1..4 is used to control any shutter number of a tasmota device having same <grouptopic> . Examples: - ShutterButton<x> <button> 100 50 74 100 0 0 0 1 1 is same as ShutterButton<x> <button> up 1 . - ShutterButton<x> <button> 0 50 24 0 0 0 0 1 1 is same as ShutterButton<x> <button> down 1 . - ShutterButton<x> <button> 100 0 50 - 0 0 0 0 0 is same as ShutterButton<x> <button> updown 0 . Module WiFi setup, restart, upgrade and reset according to Buttons and Switches are supported \"child and fool save\" only when no button restriction (SetOption1) is given and when all configured shutter buttons of that shutter are pressed 5x, 6x, 7x times or hold long simultaneously. Configuration ~ Sonoff Dual R2 Required Configuration If using a Sonoff Dual R2, use the following Template: {\"NAME\":\"Sonoff Dual R2\",\"GPIO\":[17,255,0,255,0,22,18,0,21,56,0,0,0,0],\"FLAG\":0,\"BASE\":39} Checklist ~ Ensure that the first relay opens the shutter Ensure that the second relay closes the shutter Set ShutterRelay<x> Set ShutterOpenDuration<x> Set ShutterCloseDuration<x> Set ShutterSetHalfway<x> (optional) Set ShutterInvert<x> (optional) Set ShutterInvertWebButtons<x> (optional) (eg. useful for horizontal awnings) If the shutter uses a pulse motor instead of a motors with one wire for each direction (i.e., duration based), define PulseTime<x> 2 on both relays. The driver's behavior will change to a pulse motor that needs pulses to start and stop. Rules ~ Tasmota rule triggers: - Shutter<x>#Position is triggered at start and and of movement reporting actual position - Shutter<x>#Direction is triggered at start and and of movement reporting actual direction - Shutter<x>#Target is triggered at start and and of movement reporting current target - Shutter<x>#Open and Shutter<x>#Close - Shutter#Moving is triggered every second if the shutter is moving - Shutter#Moved is triggered ONCE after the shutter stopped - Shutter<x>#Button<button>=0 is triggered when button is hold - Shutter<x>#Button<button>=<n> is triggered when button is pressed n times - Shutter<x>#Button0=0 is triggered when all buttons of that shutter are hold simultaneously - Shutter<x>#Button0=<n> is triggered when all buttons of that shutter are pressed simultaneously n times With #Direction and var1..var4 you can store the movement ofa shutter and get information which shutter is moving Examples: - Publish a message with the position of the shutter: Rule1 ON Shutter1#Position DO Publish status/%topic%/level {\"%value%\"} ENDON Open/Close or set a specific position for a shutter. This example drives the second shutter to the same position as the first shutter: Rule1 ON Shutter1#Position DO ShutterPosition2 %value%\" ENDON Jarolift Shutter Support ~ Jarolift shutters operates by the 3 commands up/stop/down. Compile with the KeeLoq Option and provide the extracted master keys to communicate. Please see KeeLog description how to do that. After this create a rule to allow the shutter to control the Jarolift devices. Shutter must be in ShutterMode 0. Rule1 On Power1#state=0 DO KeeloqSendButton 4 endon On Power2#state=0 DO KeeloqSendButton 4 endon on Power1#state=1 DO KeeloqSendButton 8 endon on Power2#State=1 DO KeeloqSendButton 2 endon Home Assistant Support ~ For shutter position to persist in Home Assistant through device reboots, execute PowerRetain 1 . These sample configurations should allow the shutter work in Home Assistant. Change the device MQTT topic and templates to match your settings. This is only an example and may need further modification to work in your environment. The configuration requirements changed starting with Home Assistant version 0.82.0. This example uses a new configuration for roller shutters with options for positioning. It assumes that %prefix%/%topic%/ is configured in the Tasmota Full Topic MQTT parameter. cover : - platform : mqtt name : \"Balcony Blinds\" availability_topic : \"tele/%topic%/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" position_topic : stat/%topic%/Shutter1 position_open : 100 position_closed : 0 set_position_topic : \"cmnd/%topic%/ShutterPosition1\" command_topic : \"cmnd/%topic%/Backlog\" payload_open : \"ShutterOpen1\" payload_close : \"ShutterClose1\" payload_stop : \"ShutterStop1\" retain : false optimistic : false qos : 1 Check Issue 130 for more information about this configuration. Another Home Assistant integration example: cover : - platform : mqtt name : \"Test\" availability_topic : \"tele/%topic%/LWT\" state_topic : \"stat/%topic%/RESULT\" command_topic : \"cmnd/%topic%/Backlog\" value_template : '{{ value | int }}' qos : 1 retain : false payload_open : \"ShutterOpen1\" payload_close : \"ShutterClose1\" payload_stop : \"ShutterStop1\" state_open : \"ON\" state_closed : \"OFF\" payload_available : \"Online\" payload_not_available : \"Offline\" optimistic : false tilt_command_topic : 'cmnd/%topic%/ShutterPosition1' tilt_status_topic : 'cmnd/%topic%/ShutterPosition1' set_position_topic : 'cmnd/%topic%/ShutterPosition1' position_topic : \"stat/%topic%/SHUTTER1\" tilt_min : 0 tilt_max : 100 tilt_closed_value : 0 tilt_opened_value : 100 Another Home Assistant integration example with position update while movement (Tasmota versions >= v8.1.0.5): cover : - platform : mqtt name : \"Balcony Blinds\" availability_topic : \"tele/%topic%/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" position_topic : \"stat/%topic%/RESULT\" value_template : > {% if ('Shutter1' in value_json) and ('Position' in value_json.Shutter1) %} {{ value_json.Shutter1.Position }} {% else %} {% if is_state('cover.balcony_blinds', 'unknown') %} 50 {% else %} {{ state_attr('cover.balcony_blinds','current_position') }} {% endif %} {% endif %} position_open : 100 position_closed : 0 set_position_topic : \"cmnd/%topic%/ShutterPosition1\" command_topic : \"cmnd/%topic%/Backlog\" payload_open : \"ShutterOpen1\" payload_close : \"ShutterClose1\" payload_stop : \"ShutterStop1\" retain : false optimistic : false qos : 1 In addition, add to your home assistant start up automation a query for the current shutter position: - alias : \"Power state on HA start-up\" trigger : platform : homeassistant event : start action : - service : mqtt.publish data : topic : \"cmnd/%shutters grouptopic%/shutterposition\" payload : \"\" This example works with Home Assistant versions prior to 0.82 : cover : - platform : template covers : studio_shutter : friendly_name : \"Studio Shutter\" position_template : \"{{ states.sensor.studio_shutter_position.state | int }}\" open_cover : service : mqtt.publish data : topic : 'cmnd/%topic%/ShutterOpen1' close_cover : service : mqtt.publish data : topic : 'cmnd/%topic%/ShutterClose1' stop_cover : service : mqtt.publish data : topic : 'cmnd/%topic%/shutterstop1' set_cover_position : service : mqtt.publish data_template : topic : 'cmnd/%topic%/ShutterPosition1' payload : '{{position}}' Wiring Diagrams ~ Normal wire configuration with a PCF as digital I/O ~ Short Circuit safe wire configuration with a PCF as digital I/O ~ Sample Log Output ~ Typical log output (log level 3 ) when starting from ShutterOpen1 . The first command is ShutterClose1 . After closing, open it to 50% with ShutterPosition1 50 SHT : Accuracy digits : 1 SHT : Shutter 0 ( Relay : 1 ) : Init . Pos : 20000 [ 100 % ] , Open Vel . : 100 Close Vel . : 100 , Max Way : 20000 , Opentime 10.0 [ s ] , Closetime 10.0 [ s ] , CoedffCalc : c0 : 0 , c1 200 , c2 : 200 , c3 : 0 , c4 : 0 , binmask 3 , is inverted 0 , ShutterMode 0 .... CMD : ShutterClose SRC : Serial SHT : Position in : payload 0 , index 1 , source 7 SHT : lastsource 7 : , realpos 20000 , target 0 , payload 0 SHT : Start shutter in direction - 1 SRC : Shutter MQT : stat /% topic %/ RESULT = { \"POWER2\" : \"ON\" } MQT : stat /% topic %/ POWER2 = ON MQT : stat /% topic %/ RESULT = { \"ShutterClose1\" : 0 } SHT : Shutter 0 : Real Pos : 19000 , Target 0 , source : Shutter , start - pos : 100 % , direction : - 1 , rtcshutter : 0.5 [ s ] CFG : Saved to flash at F5 , Count 725 , Bytes 4096 SHT : Shutter 0 : Real Pos : 17000 , Target 0 , source : Shutter , start - pos : 100 % , direction : - 1 , rtcshutter : 1.5 [ s ] SHT : Shutter 0 : Real Pos : 15000 , Target 0 , source : Shutter , start - pos : 100 % , direction : - 1 , rtcshutter : 2.5 [ s ] SHT : Shutter 0 : Real Pos : 13000 , Target 0 , source : Shutter , start - pos : 100 % , direction : - 1 , rtcshutter : 3.5 [ s ] SHT : Shutter 0 : Real Pos : 11000 , Target 0 , source : Shutter , start - pos : 100 % , direction : - 1 , rtcshutter : 4.5 [ s ] SHT : Shutter 0 : Real Pos : 9000 , Target 0 , source : Shutter , start - pos : 100 % , direction : - 1 , rtcshutter : 5.5 [ s ] SHT : Shutter 0 : Real Pos : 7000 , Target 0 , source : Shutter , start - pos : 100 % , direction : - 1 , rtcshutter : 6.5 [ s ] SHT : Shutter 0 : Real Pos : 5000 , Target 0 , source : Shutter , start - pos : 100 % , direction : - 1 , rtcshutter : 7.5 [ s ] SHT : Shutter 0 : Real Pos : 3000 , Target 0 , source : Shutter , start - pos : 100 % , direction : - 1 , rtcshutter : 8.5 [ s ] SHT : Shutter 0 : Real Pos : 1000 , Target 0 , source : Shutter , start - pos : 100 % , direction : - 1 , rtcshutter : 9.5 [ s ] SHT : Shutter 0 : Real Pos . 0 , Stoppos : 0 , relay : 1 , direction - 1 , pulsetimer : 0 , rtcshutter : 10.1 [ s ] , operationtime 0 MQT : stat /% topic %/ SHUTTER1 = 0 SRC : Shutter MQT : stat /% topic %/ RESULT = { \"POWER2\" : \"OFF\" } MQT : stat /% topic %/ POWER2 = OFF MQT : tele /% topic %/ RESULT = { \"Shutter1\" :{ \"Position\" : 0 , \"direction\" : 0 }} CFG : Saved to flash at F4 , Count 726 , Bytes 4096 .... CMD : ShutterPosition 50 SRC : Serial SHT : Position in : payload 50 , index 1 , source 23 SHT : lastsource 23 : , realpos 0 , target 10000 , payload 50 SHT : Start shutter in direction 1 SRC : Shutter MQT : stat /% topic %/ RESULT = { \"POWER1\" : \"ON\" } MQT : stat /% topic %/ POWER1 = ON MQT : stat /% topic %/ RESULT = { \"ShutterPosition1\" : 50 } SHT : Shutter 0 : Real Pos : 1500 , Target 10000 , source : Shutter , start - pos : 0 % , direction : 1 , rtcshutter : 0.8 [ s ] CFG : Saved to flash at FB , Count 727 , Bytes 4096 SHT : Shutter 0 : Real Pos : 3500 , Target 10000 , source : Shutter , start - pos : 0 % , direction : 1 , rtcshutter : 1.8 [ s ] SHT : Shutter 0 : Real Pos : 5500 , Target 10000 , source : Shutter , start - pos : 0 % , direction : 1 , rtcshutter : 2.7 [ s ] SHT : Shutter 0 : Real Pos : 7500 , Target 10000 , source : Shutter , start - pos : 0 % , direction : 1 , rtcshutter : 3.7 [ s ] SHT : Shutter 0 : Real Pos : 9500 , Target 10000 , source : Shutter , start - pos : 0 % , direction : 1 , rtcshutter : 4.7 [ s ] SHT : Shutter 0 : Real Pos . 10000 , Stoppos : 50 , relay : 0 , direction 1 , pulsetimer : 0 , rtcshutter : 5.0 [ s ] , operationtime 2 MQT : stat /% topic %/ SHUTTER1 = 50 SRC : Shutter MQT : stat /% topic %/ RESULT = { \"POWER1\" : \"OFF\" } MQT : stat /% topic %/ POWER1 = OFF MQT : tele /% topic %/ RESULT = { \"Shutter1\" :{ \"Position\" : 50 , \"direction\" : 0 }} CFG : Saved to flash at FA , Count 728 , Bytes 4096","title":"Blinds and Shutters"},{"location":"Blinds-and-Shutters/#commands","text":"First enable shutter support with SetOption80 1 Complete list of commands is available at Blinds, Shutters and Roller Shades Commands .","title":"Commands"},{"location":"Blinds-and-Shutters/#shutter-modes","text":"There are three shutter modes which are defined according to the PulseTime and Interlock settings. The examples below are for a ShutterRelay1 1 configuration (using Relay1 and Relay2). 1. ShutterMode 0 - Normal Operation First relay: OFF/DOWN, Second relay: OFF/UP - Backlog PulseTime1 0; PulseTime2 0 - Backlog Interlock 1,2; Interlock ON (Interlocked relay pair) ShutterMode 1 - Circuit Safe First relay: ON/OFF, Second relay: UP/DOWN Backlog PulseTime1 0; PulseTime2 0 Interlock OFF ShutterMode 2 - Pulse Motors First relay: OFF/DOWN PULSE, Second relay: OFF/UP PULSE Backlog PulseTime1 2; PulseTime2 2 Backlog Interlock 1,2; Interlock ON (Interlocked relay pair) ShutterMode 3 - Stepper Motors First relay: ON/OFF, Second relay: UP/DOWN PWM: Stepper signal, COUNTER: Stepper position signal Backlog PulseTime1 0; PulseTime2 0 Interlock OFF PWM and COUNTER defined Wiring diagrams for Normal, Stepper motor, and Short Circuit-Safe configurations are available at the end of this page. Even if the shutter does not have two motors, three wires have to be connected. Note After setting the options for shutter mode, the device must be rebooted. Otherwise, the sliders won't be available in the web UI, and the ShutterOpenDuration<x> and ShutterCloseDuration<x> commands will report \"Shutter unknown\". Issue ShutterRelay<x> 1 command and check in console which ShutterMode is displayed: Shutter accuracy digits: 1 Shutter 0 (Relay:1): Init. Pos: 20000 [100 %], Open Vel.: 100 Close Vel.: 100 , Max Way: 20000, Opentime 10.0 [s], Closetime 10.0 [s], CoedffCalc: c0: 0, c1 200, c2: 200, c3: 0, c4: 0, binmask 3, is inverted 1, ShutterMode 0 , motordelay 0","title":"Shutter Modes"},{"location":"Blinds-and-Shutters/#operation","text":"Turning a device relay on or off directly (i.e., using Power ) will function to affect a shutter's movement. In momentary mode (i.e., stepper motor), the relays start or stop the motor. The driver takes care of the direction and proper update of the shutter position. The shutter reports its position and can also be sent to a dedicated position. ShutterPosition = 0 means the shutter is closed and ShutterPosition = 100 means the shutter is open. If you need the position values reversed ( 0 = open, 100 = closed), define and calibrate your shutter as documented below . Then tell Tasmota to reverse the shutter position meaning via the ShutterInvert<x> 1 command. All internal calculations are the same (the log output is the same). Only the interaction with the user and other systems changes. Now ShutterPosition<x> 0 will open the shutter and ShutterPosition<x> 100 will close the shutter. By default, only Shutter1 is enabled when SetOption80 1 is invoked. A maximum of four shutters per device are supported. To enable additional shutters, ShutterRelay<x> <value> must be executed for each additional shutter. Additional shutter declarations must be sequentially numbered, and without gaps (i.e., second shutter is 2, then shutter 3, and finally shutter 4). Disabling a shutter in the middle of the defined set of shutters will disable all other higher numbered shutters. If the disabled shutter is restored, the higher numbered shutters previously declared will also be restored. When a shutter is added or removed, a list of the active shutters, with their parameters, is output to the log. If you intend to remove shutters, explicitly remove each one beginning with the highest numbered shutter. With four shutters, eight Relay<x> components are needed. If manual operation switches ( Switch<x> or Button<x> pairs) are also used, additional input GPIO are required. The ESP82xx device may not have enough free GPIO to support all the shutter connections required. A GPIO expander such as a PCF8574 or MCP230xx can be used. Using manual operation Switch<x> pairs may require setting SwitchMode<x> 4 (inverse follow) for proper switch behavior. Any shutter positioning can be locked ShutterLock<x> 1 . Once executed an ongoing movement is finished while further positioning commands like ShutterOpen<x> , ShutterClose<x> , ShutterStop<x> , and ShutterPosition<x> , as well as web UI buttons, web UI sliders, and shutter buttons are disabled. This can be used to lock an outdoor blind in case of high wind or rain. You may also disable shutter positioning games by your children. Shutter positioning can be unlocked using ShutterLock<x> 0 . Please be aware that the shutter can still be moved by direct relay control (i.e., power<x> ), or physical switches and buttons. Use hte ShutterButton<x> command prior to ShutterLock to be able to lock buttons.","title":"Operation"},{"location":"Blinds-and-Shutters/#pulse-motor-support","text":"There are shutters that have two relays but only need a pulse to start or stop. Depending on the current situation a pulse will stop the shutter or send it into a specific direction. To use these kinds of shutters a PulseTime must be defined on each relay. The minimum setting that seems to make it work consistently is 2 . A setting of 1 does not work. If the shutter moves too fast and does not react to a stop command, increase the setting to 3 or 4 .","title":"Pulse Motor Support"},{"location":"Blinds-and-Shutters/#stepper-motor-support","text":"Stepper motors can also be used to operate shutters and blinds. Additionally you can operate sliding doors with this configuration. Please refer to Shutters and Steppers for details.","title":"Stepper Motor Support"},{"location":"Blinds-and-Shutters/#calibration","text":"Shutter calibration video tutorial Set the ShutterOpenDuration<x> to the time the shutter needs to open completely. Set the ShutterCloseDuration<x> at least to the time the shutter needs to close completely. If the shutter does not close completely or runs too long, the calibration point of a closed shutter can be defined with ShutterSetClose<x> . Move the shutter to the close position and execute ShutterSetClose<x> command. ShutterPosition<x> will be reset to 0 ( ShutterClose<x> ). Set the 50% open position of the shutter. Some shutters need some time from totally closed until they begin moving the bottom-most part and opening. This often results a shutter that is less than 50% open when the shutter has been operating for 50% of the set duration. This can be corrected by using ShutterSetHalfway<x> . Use this procedure to calibrate the half-open position: ShutterClose<x> (confirm that the shutter is completely closed) ShutterSetHalfway<x> 50 (reset to default) Move the shutter to actual 50% open position. Use ShutterPosition<x> to inquire the shutter's current position and record the value. This value is a percentage of the total opening (e.g., 63 = 63% of opening). ShutterClose<x> ShutterSetHalfway<x> 63 (using the value from step #4 above) Restart 1 After calibration you might want to enable an additional 1s motor movement by ShutterEnableEndStopTime<x> 1 when the shutter is asked to move to its end positions (0% and 100%). By this you can guarantee that end positions are still reached in case of inaccuracies. Take care to disable this by ShutterEnableEndStopTime<x> 0 before further open or close duration measurements.","title":"Calibration"},{"location":"Blinds-and-Shutters/#increasing-calibration-granularity","text":"If you desire that the %-opening closely match what ShutterPosition<x> and web UI indicate, there is a granular calibration matrix available. Ensure that ShutterClose<x> and ShutterOpen<x> moves the shutter more or less to the limit positions and follow this procedure: - ShutterSetHalfway<x> 50 (reset to default) - ShutterCalibration<x> 30 50 70 90 100 - Restart 1 - ShutterClose<x> - Move the shutter to each of the following opening percentages and measure the shutter's position for each. - ShutterPosition<x> 30 (e.g., measurement = 15 ) - ShutterPosition<x> 50 (e.g., measurement = 50 ) - ShutterPosition<x> 70 (e.g., measurement = 100 ) - ShutterPosition<x> 90 (e.g., measurement = 150 ) - ShutterPosition<x> 100 (e.g., measurement = 180 ) - Finally, enter the position measurements as the calibration values: ShutterCalibration<x> 15 50 100 150 180 ShutterCalibration<x> takes position measurements ( not the time it takes to move). During calibration you position the shutter to an indicated percentage (e.g., 30% ) of opening and measure the shutter position (e.g., 15 ). Use the same unit of measure for all your measurements (e.g., centimeters, inches, etc.). After calibration ShutterPosition<x> 30 will move to 30% opening which will correspond to the position you provided ( 15 ). Notice that there is no calibration for the 10\\% position. On many shutters, there is no movement during the initial phase (i.e., nearly 10% of total time). Therefore the opening could be 0 . This measurement would cause an execution DIV 0 exception. Therefore the first calibration point is 30%. In most cases this is not a large opening so the calibration will be near enough. Yes, until ~10%, the position will be a bit \"off\" but not enough for concern.","title":"Increasing Calibration Granularity"},{"location":"Blinds-and-Shutters/#motor-movement-delays","text":"Some motors need up to one second after power is turned on before they start moving. You can confirm if you are having this issue if opening and closing as a single action works properly but doing this in smaller steps result in a shift of the position. 1. Shutterposition<x> 30 Measure the shutter position. This is the reference_position 2. Shutterposition<x> 80 Measure the shutter position. This is the max_position 3. Shutterposition<x> 30 Return the shutter to starting position. This must be the same position as measured in step #1 ( reference_position ). If not, ShutterCloseDuration must be adjusted. 4. Shutterposition<x> 50 5. Shutterposition<x> 70 6. Shutterposition<x> 80 If you do not reach max_position you have a motor delay problem. Measure the shutter position. This is the real_max . Use this value in the calculation below. 7. ShutterMotorDelay<x> <delay> Motor <delay> calculation - fine tune in 0.05 second increments (e.g. 0.65 ) as required. <delay> = ((max_position-real_max) / 2) / (((100/80) * max_position) / ShutterOpenDuration) Close the shutter and repeat this procedure until the motor delay is set properly.","title":"Motor Movement Delays"},{"location":"Blinds-and-Shutters/#button-control","text":"When shutter is running in normal ShutterMode: 0 , you already have basic control over the shutter movement using tasmota switches or tasmota buttons in the module configuration to directly drive the shutter relays. For short circuit safe operation ShutterMode: 1 direct control of the relays will not give you a nice user interface since you have to 1st set the direction with one switch or button and 2nd switch on the power by the other switch or button. To have shutter mode independent button control over the shutter and not over its relays one can use the ShutterButton<x> command. It also introduces some more features, see below: ShutterButton<x> <button> <func> <mqtt> This assigns a tasmota button <button> to control your shutter <x> having functionality <func> . The tasmota button <button> must already be configured in the module configuration. You can assign multiple buttons to a single shutter. Any button can only control one shutter (beside the <mqtt> broadcast feature, see description below). Any press of the button while the shutter is moving will immediately stop the shutter. One can remove all button control for shutter <x> by ShutterButton<x> 0 . The assigned button can have one of the following functionalities: Setup for an \"up\" button: ShutterButton<x> <button> up <mqtt> Single press will move shutter to 100%, double press to 50% and tripple press to 74%. Holding the button for more than the hold time (SetOption32) moves all shutters with same <grouptopic> to 100% when <mqtt> is equal to 1 . When <mqtt> is equal to 0 hold action of this button is same as single press. Setup for a \"down\" button: ShutterButton<x> <button> down <mqtt> Single press will move shutter to 0%, double press to 50% and tripple press to 24%. Holding the button for more than the hold time (SetOption32) moves all shutters with same <grouptopic> to 0% when <mqtt> is equal to 1 . When <mqtt> is equal to 0 hold action of this button is same as single press. Setup for an \"updown\" button: ShutterButton<x> <button> updown <mqtt> Single press will move shutter to 100%, double press down to 0% and tripple press to 50%. No hold action and no other shutter control by MQTT, <mqtt> is don't care here. More advanced control of the button press actions is given by the following ShutterButton<x> command syntax: ShutterButton<x> <button> <p1> <p2> <p3> <ph> <m1> <m2> <m3> <mh> <mi> <button> 1..4 : Button number, 0/- : disable buttons for this shutter <p1> 0..100 : single press position, - : disable <p2> 0..100 : double press position, - : disable <p3> 0..100 : tripple press position, - : disable <ph> 0..100 : hold press position, - : disable <m1> 1 : enable single press position MQTT broadcast, 0/- : disable <m2> 1 : enable double press position MQTT broadcast, 0/- : disable <m3> 1 : enable tripple press position MQTT broadcast, 0/- : disable <mh> 1 : enable hold press position MQTT broadcast, 0/- : disable <mi> 1 : enable MQTT broadcast to all shutter indices, 0/- : disable Any parameters are optional: when missing all subsequent parameters are set to disable . By a button single press the shutter is set to position <p1> . Double press will drive the shutter to position <p2> and tripple press to position <p3> . Holding the button for more than the SetOption32 time sets the shutter position to <ph> . Any button action <p1> to <ph> can be disabled by setting the parameter to - . Independent from configuration <p1> to <ph> any press of the button while the shutter is moving will immediately stop the shutter. Global steering of all your shutters at home is supported by additional MQTT broadcast. By any button action a corresponding MQTT command can be initiated to the <grouptopic> of the device. For single press this can be enabled by <m1> equal to 1 , disabling is indicated by - . Double to hold MQTT configurations are given by <m2> to <mh> , correspondingly. When <mi> is equal to - only cmnd/<grouptopic>/Shutterposition<x> <p1..h> is fired. When <mi> is equal to 1 , <x> = 1..4 is used to control any shutter number of a tasmota device having same <grouptopic> . Examples: - ShutterButton<x> <button> 100 50 74 100 0 0 0 1 1 is same as ShutterButton<x> <button> up 1 . - ShutterButton<x> <button> 0 50 24 0 0 0 0 1 1 is same as ShutterButton<x> <button> down 1 . - ShutterButton<x> <button> 100 0 50 - 0 0 0 0 0 is same as ShutterButton<x> <button> updown 0 . Module WiFi setup, restart, upgrade and reset according to Buttons and Switches are supported \"child and fool save\" only when no button restriction (SetOption1) is given and when all configured shutter buttons of that shutter are pressed 5x, 6x, 7x times or hold long simultaneously.","title":"Button control"},{"location":"Blinds-and-Shutters/#configuration","text":"","title":"Configuration"},{"location":"Blinds-and-Shutters/#checklist","text":"Ensure that the first relay opens the shutter Ensure that the second relay closes the shutter Set ShutterRelay<x> Set ShutterOpenDuration<x> Set ShutterCloseDuration<x> Set ShutterSetHalfway<x> (optional) Set ShutterInvert<x> (optional) Set ShutterInvertWebButtons<x> (optional) (eg. useful for horizontal awnings) If the shutter uses a pulse motor instead of a motors with one wire for each direction (i.e., duration based), define PulseTime<x> 2 on both relays. The driver's behavior will change to a pulse motor that needs pulses to start and stop.","title":"Checklist"},{"location":"Blinds-and-Shutters/#rules","text":"Tasmota rule triggers: - Shutter<x>#Position is triggered at start and and of movement reporting actual position - Shutter<x>#Direction is triggered at start and and of movement reporting actual direction - Shutter<x>#Target is triggered at start and and of movement reporting current target - Shutter<x>#Open and Shutter<x>#Close - Shutter#Moving is triggered every second if the shutter is moving - Shutter#Moved is triggered ONCE after the shutter stopped - Shutter<x>#Button<button>=0 is triggered when button is hold - Shutter<x>#Button<button>=<n> is triggered when button is pressed n times - Shutter<x>#Button0=0 is triggered when all buttons of that shutter are hold simultaneously - Shutter<x>#Button0=<n> is triggered when all buttons of that shutter are pressed simultaneously n times With #Direction and var1..var4 you can store the movement ofa shutter and get information which shutter is moving Examples: - Publish a message with the position of the shutter: Rule1 ON Shutter1#Position DO Publish status/%topic%/level {\"%value%\"} ENDON Open/Close or set a specific position for a shutter. This example drives the second shutter to the same position as the first shutter: Rule1 ON Shutter1#Position DO ShutterPosition2 %value%\" ENDON","title":"Rules"},{"location":"Blinds-and-Shutters/#jarolift-shutter-support","text":"Jarolift shutters operates by the 3 commands up/stop/down. Compile with the KeeLoq Option and provide the extracted master keys to communicate. Please see KeeLog description how to do that. After this create a rule to allow the shutter to control the Jarolift devices. Shutter must be in ShutterMode 0. Rule1 On Power1#state=0 DO KeeloqSendButton 4 endon On Power2#state=0 DO KeeloqSendButton 4 endon on Power1#state=1 DO KeeloqSendButton 8 endon on Power2#State=1 DO KeeloqSendButton 2 endon","title":"Jarolift Shutter Support"},{"location":"Blinds-and-Shutters/#home-assistant-support","text":"For shutter position to persist in Home Assistant through device reboots, execute PowerRetain 1 . These sample configurations should allow the shutter work in Home Assistant. Change the device MQTT topic and templates to match your settings. This is only an example and may need further modification to work in your environment. The configuration requirements changed starting with Home Assistant version 0.82.0. This example uses a new configuration for roller shutters with options for positioning. It assumes that %prefix%/%topic%/ is configured in the Tasmota Full Topic MQTT parameter. cover : - platform : mqtt name : \"Balcony Blinds\" availability_topic : \"tele/%topic%/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" position_topic : stat/%topic%/Shutter1 position_open : 100 position_closed : 0 set_position_topic : \"cmnd/%topic%/ShutterPosition1\" command_topic : \"cmnd/%topic%/Backlog\" payload_open : \"ShutterOpen1\" payload_close : \"ShutterClose1\" payload_stop : \"ShutterStop1\" retain : false optimistic : false qos : 1 Check Issue 130 for more information about this configuration. Another Home Assistant integration example: cover : - platform : mqtt name : \"Test\" availability_topic : \"tele/%topic%/LWT\" state_topic : \"stat/%topic%/RESULT\" command_topic : \"cmnd/%topic%/Backlog\" value_template : '{{ value | int }}' qos : 1 retain : false payload_open : \"ShutterOpen1\" payload_close : \"ShutterClose1\" payload_stop : \"ShutterStop1\" state_open : \"ON\" state_closed : \"OFF\" payload_available : \"Online\" payload_not_available : \"Offline\" optimistic : false tilt_command_topic : 'cmnd/%topic%/ShutterPosition1' tilt_status_topic : 'cmnd/%topic%/ShutterPosition1' set_position_topic : 'cmnd/%topic%/ShutterPosition1' position_topic : \"stat/%topic%/SHUTTER1\" tilt_min : 0 tilt_max : 100 tilt_closed_value : 0 tilt_opened_value : 100 Another Home Assistant integration example with position update while movement (Tasmota versions >= v8.1.0.5): cover : - platform : mqtt name : \"Balcony Blinds\" availability_topic : \"tele/%topic%/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" position_topic : \"stat/%topic%/RESULT\" value_template : > {% if ('Shutter1' in value_json) and ('Position' in value_json.Shutter1) %} {{ value_json.Shutter1.Position }} {% else %} {% if is_state('cover.balcony_blinds', 'unknown') %} 50 {% else %} {{ state_attr('cover.balcony_blinds','current_position') }} {% endif %} {% endif %} position_open : 100 position_closed : 0 set_position_topic : \"cmnd/%topic%/ShutterPosition1\" command_topic : \"cmnd/%topic%/Backlog\" payload_open : \"ShutterOpen1\" payload_close : \"ShutterClose1\" payload_stop : \"ShutterStop1\" retain : false optimistic : false qos : 1 In addition, add to your home assistant start up automation a query for the current shutter position: - alias : \"Power state on HA start-up\" trigger : platform : homeassistant event : start action : - service : mqtt.publish data : topic : \"cmnd/%shutters grouptopic%/shutterposition\" payload : \"\" This example works with Home Assistant versions prior to 0.82 : cover : - platform : template covers : studio_shutter : friendly_name : \"Studio Shutter\" position_template : \"{{ states.sensor.studio_shutter_position.state | int }}\" open_cover : service : mqtt.publish data : topic : 'cmnd/%topic%/ShutterOpen1' close_cover : service : mqtt.publish data : topic : 'cmnd/%topic%/ShutterClose1' stop_cover : service : mqtt.publish data : topic : 'cmnd/%topic%/shutterstop1' set_cover_position : service : mqtt.publish data_template : topic : 'cmnd/%topic%/ShutterPosition1' payload : '{{position}}'","title":"Home Assistant Support"},{"location":"Blinds-and-Shutters/#wiring-diagrams","text":"","title":"Wiring Diagrams"},{"location":"Blinds-and-Shutters/#normal-wire-configuration-with-a-pcf-as-digital-io","text":"","title":"Normal wire configuration with a PCF as digital I/O"},{"location":"Blinds-and-Shutters/#short-circuit-safe-wire-configuration-with-a-pcf-as-digital-io","text":"","title":"Short Circuit safe wire configuration with a PCF as digital I/O"},{"location":"Blinds-and-Shutters/#sample-log-output","text":"Typical log output (log level 3 ) when starting from ShutterOpen1 . The first command is ShutterClose1 . After closing, open it to 50% with ShutterPosition1 50 SHT : Accuracy digits : 1 SHT : Shutter 0 ( Relay : 1 ) : Init . Pos : 20000 [ 100 % ] , Open Vel . : 100 Close Vel . : 100 , Max Way : 20000 , Opentime 10.0 [ s ] , Closetime 10.0 [ s ] , CoedffCalc : c0 : 0 , c1 200 , c2 : 200 , c3 : 0 , c4 : 0 , binmask 3 , is inverted 0 , ShutterMode 0 .... CMD : ShutterClose SRC : Serial SHT : Position in : payload 0 , index 1 , source 7 SHT : lastsource 7 : , realpos 20000 , target 0 , payload 0 SHT : Start shutter in direction - 1 SRC : Shutter MQT : stat /% topic %/ RESULT = { \"POWER2\" : \"ON\" } MQT : stat /% topic %/ POWER2 = ON MQT : stat /% topic %/ RESULT = { \"ShutterClose1\" : 0 } SHT : Shutter 0 : Real Pos : 19000 , Target 0 , source : Shutter , start - pos : 100 % , direction : - 1 , rtcshutter : 0.5 [ s ] CFG : Saved to flash at F5 , Count 725 , Bytes 4096 SHT : Shutter 0 : Real Pos : 17000 , Target 0 , source : Shutter , start - pos : 100 % , direction : - 1 , rtcshutter : 1.5 [ s ] SHT : Shutter 0 : Real Pos : 15000 , Target 0 , source : Shutter , start - pos : 100 % , direction : - 1 , rtcshutter : 2.5 [ s ] SHT : Shutter 0 : Real Pos : 13000 , Target 0 , source : Shutter , start - pos : 100 % , direction : - 1 , rtcshutter : 3.5 [ s ] SHT : Shutter 0 : Real Pos : 11000 , Target 0 , source : Shutter , start - pos : 100 % , direction : - 1 , rtcshutter : 4.5 [ s ] SHT : Shutter 0 : Real Pos : 9000 , Target 0 , source : Shutter , start - pos : 100 % , direction : - 1 , rtcshutter : 5.5 [ s ] SHT : Shutter 0 : Real Pos : 7000 , Target 0 , source : Shutter , start - pos : 100 % , direction : - 1 , rtcshutter : 6.5 [ s ] SHT : Shutter 0 : Real Pos : 5000 , Target 0 , source : Shutter , start - pos : 100 % , direction : - 1 , rtcshutter : 7.5 [ s ] SHT : Shutter 0 : Real Pos : 3000 , Target 0 , source : Shutter , start - pos : 100 % , direction : - 1 , rtcshutter : 8.5 [ s ] SHT : Shutter 0 : Real Pos : 1000 , Target 0 , source : Shutter , start - pos : 100 % , direction : - 1 , rtcshutter : 9.5 [ s ] SHT : Shutter 0 : Real Pos . 0 , Stoppos : 0 , relay : 1 , direction - 1 , pulsetimer : 0 , rtcshutter : 10.1 [ s ] , operationtime 0 MQT : stat /% topic %/ SHUTTER1 = 0 SRC : Shutter MQT : stat /% topic %/ RESULT = { \"POWER2\" : \"OFF\" } MQT : stat /% topic %/ POWER2 = OFF MQT : tele /% topic %/ RESULT = { \"Shutter1\" :{ \"Position\" : 0 , \"direction\" : 0 }} CFG : Saved to flash at F4 , Count 726 , Bytes 4096 .... CMD : ShutterPosition 50 SRC : Serial SHT : Position in : payload 50 , index 1 , source 23 SHT : lastsource 23 : , realpos 0 , target 10000 , payload 50 SHT : Start shutter in direction 1 SRC : Shutter MQT : stat /% topic %/ RESULT = { \"POWER1\" : \"ON\" } MQT : stat /% topic %/ POWER1 = ON MQT : stat /% topic %/ RESULT = { \"ShutterPosition1\" : 50 } SHT : Shutter 0 : Real Pos : 1500 , Target 10000 , source : Shutter , start - pos : 0 % , direction : 1 , rtcshutter : 0.8 [ s ] CFG : Saved to flash at FB , Count 727 , Bytes 4096 SHT : Shutter 0 : Real Pos : 3500 , Target 10000 , source : Shutter , start - pos : 0 % , direction : 1 , rtcshutter : 1.8 [ s ] SHT : Shutter 0 : Real Pos : 5500 , Target 10000 , source : Shutter , start - pos : 0 % , direction : 1 , rtcshutter : 2.7 [ s ] SHT : Shutter 0 : Real Pos : 7500 , Target 10000 , source : Shutter , start - pos : 0 % , direction : 1 , rtcshutter : 3.7 [ s ] SHT : Shutter 0 : Real Pos : 9500 , Target 10000 , source : Shutter , start - pos : 0 % , direction : 1 , rtcshutter : 4.7 [ s ] SHT : Shutter 0 : Real Pos . 10000 , Stoppos : 50 , relay : 0 , direction 1 , pulsetimer : 0 , rtcshutter : 5.0 [ s ] , operationtime 2 MQT : stat /% topic %/ SHUTTER1 = 50 SRC : Shutter MQT : stat /% topic %/ RESULT = { \"POWER1\" : \"OFF\" } MQT : stat /% topic %/ POWER1 = OFF MQT : tele /% topic %/ RESULT = { \"Shutter1\" :{ \"Position\" : 50 , \"direction\" : 0 }} CFG : Saved to flash at FA , Count 728 , Bytes 4096","title":"Sample Log Output"},{"location":"Bluetooth/","text":"?> Presence detection with iBeacons or BLE sensor gateway using HM-1x or nRF24L01(+) peripherals iBeacon ~ This feature is included only in tasmota-sensors.bin Otherwise you must compile your build . Add the following to user_config_override.h : #ifndef USE_IBEACON #define USE_IBEACON // Add support for bluetooth LE passive scan of ibeacon devices #endif Tasmota uses a BLE 4.x module to scan for iBeacon devices. This driver is working with HM-10 and clones and HM16/HM17 Bluetooth modules and potentially with other HM-1x modules depending on firmware capabilities. Features ~ For a list of all available commands see Sensor52 command. This driver reports all beacons found during a scan with its ID (derived from beacon's MAC address) prefixed with IBEACON_ and RSSI value. Every beacon report is published as an MQTT tele/%topic%/SENSOR in a separate message: tele/ibeacon/SENSOR = { \"Time\" : \"2020-03-24T20:09:40\" , \"IBEACON_FF34C21G2174\" :{ \"RSSI\" : -81 }} tele/ibeacon/SENSOR = { \"Time\" : \"2020-03-24T20:09:42\" , \"IBEACON_DEAABC788BC1\" :{ \"RSSI\" : -60 }} If the beacon can no longer be found during a scan and the timeout interval has passed the beacon's RSSI is set to zero (0) and it is no longer displayed in the webUI tele/ibeacon/SENSOR = { \"Time\" : \"2020-03-24T20:05:00\" , \"IBEACON_DEAABC788BC1\" :{ \"RSSI\" : -0 }} Tip When first connected some modules will be in peripheral mode. You have to change it to central mode using commands Sensor52 1 and Sensor52 2 . Supported Devices ~ All Apple compatible iBeacon devices should be discoverable. Various nRF51822 beacons should be fully Apple compatible, programmable and their battery lasts about a year. Amazon.com Aliexpress Cheap \"iTag\" beacons with a beeper. The battery on these lasts only about a month. Aliexpress eBay Amazon.com Tip You can activate a beacon with a beeper using command IBEACON_%BEACONID%_RSSI 99 (ID is visible in webUI and SENSOR reports). This command can freeze the Bluetooth module and beacon scanning will stop. After a reboot of Tasmota the beacon will start beeping and scanning will resume. BLE Sensors using HM-1x ~ !> This feature is included only in tasmota-sensors.bin Otherwise you must compile your build . Add the following to user_config_override.h : #ifndef USE_HM10 #define USE_HM10 // Add support for HM-1x as a BLE-bridge (+5k1 code) #endif Features ~ Supported sensors will be connected to at a set interval (default interval equals TelePeriod). A subscription is established for 5 seconds and data (e.g. temperature, humidity and battery) is read and reported to an mqtt topic (Dew point is calculated): tele/%topic%/SENSOR = { \"Time\" : \"2020-03-24T12:47:51\" , \"LYWSD03-52680f\" :{ \"Temperature\" : 21.1 , \"Humidity\" : 58.0 , \"DewPoint\" : 12.5 , \"Battery\" : 100 }, \"LYWSD02-a2fd09\" :{ \"Temperature\" : 21.4 , \"Humidity\" : 57.0 , \"DewPoint\" : 12.5 , \"Battery\" : 2 }, \"MJ_HT_V1-d8799d\" :{ \"Temperature\" : 21.4 , \"Humidity\" : 54.6 , \"DewPoint\" : 11.9 }, \"TempUnit\" : \"C\" } After a completed discovery scan, the driver will report the number of found sensors. As Tasmota can not know how many sensors are meant to be discovered you have to force a re-scan until the desired number of devices is found. Rule1 ON HM10 # Found < 6 DO Add1 1 ENDON ON Var1 # State <= 3 DO HM10Scan ENDON This will re-scan up to 3 times if less than 6 sensors are found. Commands Command Parameters HM10Scan Start a new device discovery scan HM10Period Show interval in seconds between sensor read cycles. Set to TelePeriod value at boot. HM10Baud Show ESP8266 serial interface baudrate ( Not HM-10 baudrate ) <value> = set baudrate HM10AT <command> = send AT commands to HM-10. See list HM10Time <n> = set time time of a LYWSD02 only sensor to Tasmota UTC time and timezone. <n> is the sensor number in order of discovery starting with 0 (topmost sensor in the webUI list). HM10Auto <value> = start an automatic discovery scan with an interval of <value> seconds to receive data in BLE advertisements periodically. This is an active scan and it should be used only if necessary . At the moment that is the case just with MJ_HT_V1. This can change if a future HM-10 firmware starts supporting passive scan. Supported Devices ~ MJ_HT_V1 LYWSD02 LYWSD03MMC CGD1 MiFlora temperature, humidity, battery temperature, humidity, battery temperature, humidity, battery temperature, humidity, battery temperature, illuminance, soil humidity, soil fertility, battery set time using \"HM10Time\" unsupported time or alarm Unconfirmed Devices CGG1 ClearGrass Temperature and Humidity Monitor should be found and may give readings via MiBeacons, but is untested. BLE Sensors using nRF24L01(+) ~ Configuration ~ Sensors will be discriminated by using the Product-ID of the MiBeacon. A human readable short product name will be shown instead of the company-assigned ID of the BLE Public Device Address (= the \"lower\" 24 bits). A TELE message could like look this: 10 : 13 : 38 RSL : stat /tasmota/ STATUS8 = { \"StatusSNS\" :{ \"Time\" : \"2019-12-18T10:13:38\" , \"Flora-6ab577\" :{ \"Temperature\" : 21.7 , \"Illuminance\" : 21 , \"Humidity\" : 0 , \"Fertility\" : 0 }, \"MJ_HT_V1-3108be\" :{ \"Temperature\" : 22.3 , \"Humidity\" : 56.1 }, \"TempUnit\" : \"C\" }} As the NRF24L01 can only read BLE-advertisements, only the data in these advertisements is accessible. All sensors have an additional GATT-interface with more data in it, but it can not be read with a NRF24l01. As we can not use a checksum to test data integrity of the packet, only data of sensors whose adresses showed up more than once (default = 3 times) will be published. Internally from time to time \"fake\" sensors will be created, when there was data corruption in the address bytes. These will be removed automatically. Supported Devices ~ !> It can not be ruled out, that changes in the device firmware may break the functionality of this driver completely! The naming conventions in the product range of bluetooth sensors in XIAOMI-universe can be a bit confusing. The exact same sensor can be advertised under slightly different names depending on the seller (Mijia, Xiaomi, Cleargrass, ...). MJ_HT_V1 LYWSD02 CGG1 CGD1 MiFlora temperature, humidity, battery temperature, humidity temperature, humidity, battery temperature, humidity temperature, illuminance, soil humidity, soil fertility, battery Unsupported Devices For LYWSD03MMC the sensor data in the advertisements is encrypted. It is highly unlikely to read data with the NRF24L01 out-of-the-box in the future. You can use an HM-1x module for this sensor. Getting data from BT Xiaomi Devices ~ Different vendors offer BT-solutions with different accessibilities under the MIJIA-brand. A common solution is the use of so-called \u201eMiBeacons\u201c which are BLE advertisement packets with a certain data structure, which are broadcasted by the devices automatically. These packets already contain the sensor data and can be passively received by other devices. Most of the \u201eolder\u201c BT-sensor-devices use unencrypted messages, which can be read by all kinds of BLE-devices or even a NRF24L01. The big advantage is the power efficiency as no active bi-directional connection has to be established. This is therefore the preferred option, if technically possible (= for the supported sensors). With the arrival of the (cheap) LYWSD03 came the problem of encrypted data in MiBeacons, which to date has only been successfully decrypted in open source projects in a quite complicated way (getting the 16-byte-key with 3rd-party-software while pairing the device with the original Xiaomi Apps). At least the device allows the use of a simple BLE connection without any encrypted authentication and the reading of the sensor data using normal subscription methods to GATT-services. This is more power hungry than the passive reading of BLE advertisements. Working principle of both Tasmota drivers (>8.2.0.1) The idea is to provide drivers with as many automatic functions as possible. Besides the hardware setup, there are zero or very few things to configure. The sensor namings are based on the original sensor names and shortened if appropriate (Flower care -> Flora). A part of the MAC will be added to the name as a suffix. All sensors are treated as if they are physically connected to the ESP8266 device.","title":"Bluetooth"},{"location":"Bluetooth/#ibeacon","text":"This feature is included only in tasmota-sensors.bin Otherwise you must compile your build . Add the following to user_config_override.h : #ifndef USE_IBEACON #define USE_IBEACON // Add support for bluetooth LE passive scan of ibeacon devices #endif Tasmota uses a BLE 4.x module to scan for iBeacon devices. This driver is working with HM-10 and clones and HM16/HM17 Bluetooth modules and potentially with other HM-1x modules depending on firmware capabilities.","title":"iBeacon"},{"location":"Bluetooth/#features","text":"For a list of all available commands see Sensor52 command. This driver reports all beacons found during a scan with its ID (derived from beacon's MAC address) prefixed with IBEACON_ and RSSI value. Every beacon report is published as an MQTT tele/%topic%/SENSOR in a separate message: tele/ibeacon/SENSOR = { \"Time\" : \"2020-03-24T20:09:40\" , \"IBEACON_FF34C21G2174\" :{ \"RSSI\" : -81 }} tele/ibeacon/SENSOR = { \"Time\" : \"2020-03-24T20:09:42\" , \"IBEACON_DEAABC788BC1\" :{ \"RSSI\" : -60 }} If the beacon can no longer be found during a scan and the timeout interval has passed the beacon's RSSI is set to zero (0) and it is no longer displayed in the webUI tele/ibeacon/SENSOR = { \"Time\" : \"2020-03-24T20:05:00\" , \"IBEACON_DEAABC788BC1\" :{ \"RSSI\" : -0 }} Tip When first connected some modules will be in peripheral mode. You have to change it to central mode using commands Sensor52 1 and Sensor52 2 .","title":"Features"},{"location":"Bluetooth/#supported-devices","text":"All Apple compatible iBeacon devices should be discoverable. Various nRF51822 beacons should be fully Apple compatible, programmable and their battery lasts about a year. Amazon.com Aliexpress Cheap \"iTag\" beacons with a beeper. The battery on these lasts only about a month. Aliexpress eBay Amazon.com Tip You can activate a beacon with a beeper using command IBEACON_%BEACONID%_RSSI 99 (ID is visible in webUI and SENSOR reports). This command can freeze the Bluetooth module and beacon scanning will stop. After a reboot of Tasmota the beacon will start beeping and scanning will resume.","title":"Supported Devices"},{"location":"Bluetooth/#ble-sensors-using-hm-1x","text":"!> This feature is included only in tasmota-sensors.bin Otherwise you must compile your build . Add the following to user_config_override.h : #ifndef USE_HM10 #define USE_HM10 // Add support for HM-1x as a BLE-bridge (+5k1 code) #endif","title":"BLE Sensors using HM-1x"},{"location":"Bluetooth/#features_1","text":"Supported sensors will be connected to at a set interval (default interval equals TelePeriod). A subscription is established for 5 seconds and data (e.g. temperature, humidity and battery) is read and reported to an mqtt topic (Dew point is calculated): tele/%topic%/SENSOR = { \"Time\" : \"2020-03-24T12:47:51\" , \"LYWSD03-52680f\" :{ \"Temperature\" : 21.1 , \"Humidity\" : 58.0 , \"DewPoint\" : 12.5 , \"Battery\" : 100 }, \"LYWSD02-a2fd09\" :{ \"Temperature\" : 21.4 , \"Humidity\" : 57.0 , \"DewPoint\" : 12.5 , \"Battery\" : 2 }, \"MJ_HT_V1-d8799d\" :{ \"Temperature\" : 21.4 , \"Humidity\" : 54.6 , \"DewPoint\" : 11.9 }, \"TempUnit\" : \"C\" } After a completed discovery scan, the driver will report the number of found sensors. As Tasmota can not know how many sensors are meant to be discovered you have to force a re-scan until the desired number of devices is found. Rule1 ON HM10 # Found < 6 DO Add1 1 ENDON ON Var1 # State <= 3 DO HM10Scan ENDON This will re-scan up to 3 times if less than 6 sensors are found.","title":"Features"},{"location":"Bluetooth/#supported-devices_1","text":"MJ_HT_V1 LYWSD02 LYWSD03MMC CGD1 MiFlora temperature, humidity, battery temperature, humidity, battery temperature, humidity, battery temperature, humidity, battery temperature, illuminance, soil humidity, soil fertility, battery set time using \"HM10Time\" unsupported time or alarm","title":"Supported Devices"},{"location":"Bluetooth/#ble-sensors-using-nrf24l01","text":"","title":"BLE Sensors using nRF24L01(+)"},{"location":"Bluetooth/#configuration","text":"Sensors will be discriminated by using the Product-ID of the MiBeacon. A human readable short product name will be shown instead of the company-assigned ID of the BLE Public Device Address (= the \"lower\" 24 bits). A TELE message could like look this: 10 : 13 : 38 RSL : stat /tasmota/ STATUS8 = { \"StatusSNS\" :{ \"Time\" : \"2019-12-18T10:13:38\" , \"Flora-6ab577\" :{ \"Temperature\" : 21.7 , \"Illuminance\" : 21 , \"Humidity\" : 0 , \"Fertility\" : 0 }, \"MJ_HT_V1-3108be\" :{ \"Temperature\" : 22.3 , \"Humidity\" : 56.1 }, \"TempUnit\" : \"C\" }} As the NRF24L01 can only read BLE-advertisements, only the data in these advertisements is accessible. All sensors have an additional GATT-interface with more data in it, but it can not be read with a NRF24l01. As we can not use a checksum to test data integrity of the packet, only data of sensors whose adresses showed up more than once (default = 3 times) will be published. Internally from time to time \"fake\" sensors will be created, when there was data corruption in the address bytes. These will be removed automatically.","title":"Configuration"},{"location":"Bluetooth/#supported-devices_2","text":"!> It can not be ruled out, that changes in the device firmware may break the functionality of this driver completely! The naming conventions in the product range of bluetooth sensors in XIAOMI-universe can be a bit confusing. The exact same sensor can be advertised under slightly different names depending on the seller (Mijia, Xiaomi, Cleargrass, ...). MJ_HT_V1 LYWSD02 CGG1 CGD1 MiFlora temperature, humidity, battery temperature, humidity temperature, humidity, battery temperature, humidity temperature, illuminance, soil humidity, soil fertility, battery","title":"Supported Devices"},{"location":"Bluetooth/#getting-data-from-bt-xiaomi-devices","text":"Different vendors offer BT-solutions with different accessibilities under the MIJIA-brand. A common solution is the use of so-called \u201eMiBeacons\u201c which are BLE advertisement packets with a certain data structure, which are broadcasted by the devices automatically. These packets already contain the sensor data and can be passively received by other devices. Most of the \u201eolder\u201c BT-sensor-devices use unencrypted messages, which can be read by all kinds of BLE-devices or even a NRF24L01. The big advantage is the power efficiency as no active bi-directional connection has to be established. This is therefore the preferred option, if technically possible (= for the supported sensors). With the arrival of the (cheap) LYWSD03 came the problem of encrypted data in MiBeacons, which to date has only been successfully decrypted in open source projects in a quite complicated way (getting the 16-byte-key with 3rd-party-software while pairing the device with the original Xiaomi Apps). At least the device allows the use of a simple BLE connection without any encrypted authentication and the reading of the sensor data using normal subscription methods to GATT-services. This is more power hungry than the passive reading of BLE advertisements.","title":"Getting data from BT Xiaomi Devices"},{"location":"Builds/","text":"There are many available features programmed into Tasmota. Not all devices need all of the available features. ESP based devices have a limited amount of memory available. To ensure that there is enough memory available to flash the firmware, it is best to keep the total size as small as possible, and definitely under 625K total to ensure OTA updates are possible. For this reason, Tasmota makes available the ability to create different firmware binary files to suit each particular device's requirements (e.g., sensors) and each application's needs (e.g., Rules, Timers, etc.). Once features such as support for sensors, rules, timers, etc. is compiled into the firmware binary, the features themselves can be configured at run-time, or, for some features, configured at compile time as well. Many times one just needs to download a pre-compiled binary and perform the necessary run-time configuration. It is not necessary to compile your own binary if these pre-compiled builds meet your needs. These available files provide a simpler approach to get up and going with Tasmota quickly. The binary files available on GitHub are for the current master release version only. These master release binaries are also available from the OTA server . However, the latest development branch code binaries are only available from the OTA server . Features that are not available in any release build have to be enabled in source code and compiled yourself. Read more about compiling your own build . Firmware Variants ~ tasmota.bin supports most features. THIS IS THE RECOMMENDED BINARY tasmota-BG.bin to tasmota-TW.bin the same features as tasmota.bin with localized language support. (Note: tasmota-UK.bin is for the Ukrainian language) tasmota-sensors.bin enables the same features as tasmota.bin and includes support for connectable sensors tasmota-lite.bin has a stripped down feature set. This reduces the required CPU cycles in order to reduce power draw to allow devices with a weak power supply to run reliably. Note This is similar to the pre-compiled Tasmota binary that comes bundled within the Tuya-Convert package when you install their OTA flashing tool. If you used Tuya-Convert to flash your device, it is strongly recommended to update to tasmota.bin . Otherwise some crucial features (e.g., energy monitoring, auto-discovery, etc.) will not work. tasmota-minimal.bin is a specialised build to subsequently allow OTA uploads. This version should NOT be used for initial installation! tasmota-knx.bin includes KNX support but omits some features. If you need additional features, compile your own firmware (e.g., Gitpod ). tasmota-display.bin built for connecting displays but omits some features such as energy monitoring. If you need additional features, compile your own firmware (e.g., Gitpod ). tasmota-ir.bin provides almost all IRremoteESP8266 protocols. If you need additional features, compile your own firmware (e.g., Gitpod ) to compile ircustom . Available Features and Sensors ~ Feature or Sensor minimal lite tasmota knx sensors ir display Remarks MY_LANGUAGE en-GB x x x x x x x USE_ARDUINO_OTA - - - - - - - USE_DOMOTICZ - - x x x x - USE_HOME_ASSISTANT - - x x x x - USE_MQTT_TLS - - - - - - - USE_MQTT_TLS_CA_CERT - - - - - - - USE_MQTT_AWS_IOT - - - - - - - USE_4K_RSA - - - - - - - USE_KNX - - - x - - - USE_WEBSERVER x x x x x x x USE_JAVASCRIPT_ES6 - - - - - - - USE_WEBSEND_RESPONSE - - - - - - - USE_EMULATION_HUE - x x - x - - USE_EMULATION_WEMO - x x - x - - USE_DISCOVERY - - x x - - x WEBSERVER_ADVERTISE - - x x - - x MQTT_HOST_DISCOVERY - - x x - - x USE_TIMERS - x x x x x x USE_TIMERS_WEB - x x x x x x USE_SUNRISE - x x x x x x USE_RULES - x x x x x x USE_SCRIPT - - - - - - - USE_EXPRESSION - - - - - - - SUPPORT_IF_STATEMENT - - - - - - - USE_HOTPLUG - - - - - - - Feature or Sensor minimal lite tasmota knx sensors ir display Remarks ROTARY_V1 - - - - - - - USE_SONOFF_RF - - x x x - - USE_RF_FLASH - - x x x - - USE_SONOFF_SC - - x x x - - USE_TUYA_MCU - x x x x - x USE_ARMTRONIX_DIMMERS - - x x - - - USE_PS_16_DZ - - x x - - - USE_SONOFF_IFAN - - x x - - - USE_BUZZER - - x x x - - USE_ARILUX_RF - - x x - - - USE_SHUTTER - - x x - - - USE_DEEPSLEEP - - x - x - - USE_EXS_DIMMER - - x x - - - USE_DEVICE_GROUPS - - x - - - - USE_PWM_DIMMER - - x x - - - USE_KEELOQ - - - - - - - USE_SONOFF_D1 - - x x - - - Feature or Sensor minimal lite tasmota knx sensors ir display Remarks USE_LIGHT - x x x x x x USE_WS2812 - - x x x - x USE_WS2812_DMA - - - - - - - USE_MY92X1 - - x x x - x USE_SM16716 - - x x x - x USE_SM2135 - - x x x - x USE_SONOFF_L1 - - x x x - x USE_ELECTRIQ_MOODL - - x x x - x USE_ENERGY_SENSOR - x x x x - - USE_PZEM004T - - x x x - - USE_PZEM_AC - - x x x - - USE_PZEM_DC - - x x x - - USE_MCP39F501 - x x x x - - USE_SDM120 - - - - x - - USE_SDM630 - - - - x - - USE_DDS2382 - - - - x - - USE_DDSU666 - - - - x - - USE_SOLAX_X1 - - - - - - - USE_LE01MR - - - - - - - USE_ADC_VCC x x - - - - - USE_COUNTER - - x x x x x USE_DS18x20 - - x x x x x USE_DHT - - x x x x x USE_MAX31855 - - - - x - - USE_MAX31865 - - - - - - - Feature or Sensor minimal lite tasmota knx sensors ir display Remarks USE_I2C - - x x x - x USE_SHT - - - - x - - USE_HTU - - - - x - - USE_BMP - - - - x - - USE_BME680 - - - - x - - USE_BH1750 - - - - x - - USE_VEML6070 - - - - x - - USE_ADS1115 - - - - x - - USE_INA219 - - - - x - - USE_INA226 - - - - - - - USE_SHT3X - - - - x - - USE_TSL2561 - - - - x - - USE_TSL2591 - - - - - - - USE_MGS - - - - x - - USE_SGP30 - - - - x - - USE_SI1145 - - - - - - - USE_LM75AD - - - - x - - USE_APDS9960 - - - - - - - USE_MCP230xx - - - - - - - USE_PCA9685 - - - - - - - USE_MPR121 - - - - - - - USE_CCS811 - - - - x - - USE_MPU6050 - - - - - - - USE_DS3231 - - - - - - - USE_MGC3130 - - - - - - - USE_MAX44009 - - - - - - - USE_SCD30 - - - - x - - USE_SPS30 - - - - - - - USE_ADE7953 - - x x x - x USE_VL53L0X - - - - - - - USE_MLX90614 - - - - - - - USE_CHIRP - - - - - - - USE_PAJ7620 - - - - - - - USE_PCF8574 - - - - - - - USE_HIH6 - - - - x - - USE_DHT12 - - - - x - - USE_DS1624 - - - - x - - USE_AHT1x - - - - - - - USE_HDC1080 - - - - - - - USE_WEMOS_MOTOR_V1 - - - - x - - Feature or Sensor minimal lite tasmota knx sensors ir display Remarks USE_SPI - - - - - - x USE_MHZ19 - - - - x - - USE_SENSEAIR - - - - x - - USE_PMS5003 - - - - x - - USE_NOVA_SDS - - - - x - - USE_HPMA - - - - x - - USE_SERIAL_BRIDGE - - x x x - x USE_MP3_PLAYER - - - - x - - USE_AZ7798 - - - - - - - USE_PN532_HSU - - - - x - - USE_RDM6300 - - - - x - - USE_IBEACON - - - - x - - USE_GPS - - - - - - - USE_HM10 - - - - x - - USE_HRXL - - - - x - - USE_NRF24 - - - - - - - USE_MIBLE - - - - - - - USE_ZIGBEE - - - - - - - USE_IR_REMOTE - - x x x x x USE_IR_RECEIVE - - x x x x x USE_IR_REMOTE_FULL - - - - - x - Enable ALL protocols USE_SR04 - - - - x - - USE_TM1638 - - - - x - - USE_HX711 - - - - x - - USE_TX2x_WIND_SENSOR - - - - - - - USE_RC_SWITCH - - - - x - - USE_RF_SENSOR - - - - x - - AlectoV2 only USE_HRE - - - - x - - USE_A4988_STEPPER - - - - - - - USE_TASMOTA_SLAVE - - - - - - - Experimental Feature or Sensor minimal lite tasmota knx sensors ir display Remarks USE_DISPLAY - - - - - - x USE_DISPLAY_LCD - - - - - - x USE_DISPLAY_SSD1306 - - - - - - x USE_DISPLAY_MATRIX - - - - - - x USE_DISPLAY_SH1106 - - - - - - x USE_DISPLAY_ILI9341 - - - - - - x USE_DISPLAY_EPAPER_29 - - - - - - x USE_DISPLAY_EPAPER_42 - - - - - - x USE_DISPLAY_ILI9488 - - - - - - - USE_DISPLAY_SSD1351 - - - - - - - USE_DISPLAY_RA8876 - - - - - - -","title":"Builds"},{"location":"Builds/#firmware-variants","text":"tasmota.bin supports most features. THIS IS THE RECOMMENDED BINARY tasmota-BG.bin to tasmota-TW.bin the same features as tasmota.bin with localized language support. (Note: tasmota-UK.bin is for the Ukrainian language) tasmota-sensors.bin enables the same features as tasmota.bin and includes support for connectable sensors tasmota-lite.bin has a stripped down feature set. This reduces the required CPU cycles in order to reduce power draw to allow devices with a weak power supply to run reliably. Note This is similar to the pre-compiled Tasmota binary that comes bundled within the Tuya-Convert package when you install their OTA flashing tool. If you used Tuya-Convert to flash your device, it is strongly recommended to update to tasmota.bin . Otherwise some crucial features (e.g., energy monitoring, auto-discovery, etc.) will not work. tasmota-minimal.bin is a specialised build to subsequently allow OTA uploads. This version should NOT be used for initial installation! tasmota-knx.bin includes KNX support but omits some features. If you need additional features, compile your own firmware (e.g., Gitpod ). tasmota-display.bin built for connecting displays but omits some features such as energy monitoring. If you need additional features, compile your own firmware (e.g., Gitpod ). tasmota-ir.bin provides almost all IRremoteESP8266 protocols. If you need additional features, compile your own firmware (e.g., Gitpod ) to compile ircustom .","title":"Firmware Variants"},{"location":"Builds/#available-features-and-sensors","text":"Feature or Sensor minimal lite tasmota knx sensors ir display Remarks MY_LANGUAGE en-GB x x x x x x x USE_ARDUINO_OTA - - - - - - - USE_DOMOTICZ - - x x x x - USE_HOME_ASSISTANT - - x x x x - USE_MQTT_TLS - - - - - - - USE_MQTT_TLS_CA_CERT - - - - - - - USE_MQTT_AWS_IOT - - - - - - - USE_4K_RSA - - - - - - - USE_KNX - - - x - - - USE_WEBSERVER x x x x x x x USE_JAVASCRIPT_ES6 - - - - - - - USE_WEBSEND_RESPONSE - - - - - - - USE_EMULATION_HUE - x x - x - - USE_EMULATION_WEMO - x x - x - - USE_DISCOVERY - - x x - - x WEBSERVER_ADVERTISE - - x x - - x MQTT_HOST_DISCOVERY - - x x - - x USE_TIMERS - x x x x x x USE_TIMERS_WEB - x x x x x x USE_SUNRISE - x x x x x x USE_RULES - x x x x x x USE_SCRIPT - - - - - - - USE_EXPRESSION - - - - - - - SUPPORT_IF_STATEMENT - - - - - - - USE_HOTPLUG - - - - - - - Feature or Sensor minimal lite tasmota knx sensors ir display Remarks ROTARY_V1 - - - - - - - USE_SONOFF_RF - - x x x - - USE_RF_FLASH - - x x x - - USE_SONOFF_SC - - x x x - - USE_TUYA_MCU - x x x x - x USE_ARMTRONIX_DIMMERS - - x x - - - USE_PS_16_DZ - - x x - - - USE_SONOFF_IFAN - - x x - - - USE_BUZZER - - x x x - - USE_ARILUX_RF - - x x - - - USE_SHUTTER - - x x - - - USE_DEEPSLEEP - - x - x - - USE_EXS_DIMMER - - x x - - - USE_DEVICE_GROUPS - - x - - - - USE_PWM_DIMMER - - x x - - - USE_KEELOQ - - - - - - - USE_SONOFF_D1 - - x x - - - Feature or Sensor minimal lite tasmota knx sensors ir display Remarks USE_LIGHT - x x x x x x USE_WS2812 - - x x x - x USE_WS2812_DMA - - - - - - - USE_MY92X1 - - x x x - x USE_SM16716 - - x x x - x USE_SM2135 - - x x x - x USE_SONOFF_L1 - - x x x - x USE_ELECTRIQ_MOODL - - x x x - x USE_ENERGY_SENSOR - x x x x - - USE_PZEM004T - - x x x - - USE_PZEM_AC - - x x x - - USE_PZEM_DC - - x x x - - USE_MCP39F501 - x x x x - - USE_SDM120 - - - - x - - USE_SDM630 - - - - x - - USE_DDS2382 - - - - x - - USE_DDSU666 - - - - x - - USE_SOLAX_X1 - - - - - - - USE_LE01MR - - - - - - - USE_ADC_VCC x x - - - - - USE_COUNTER - - x x x x x USE_DS18x20 - - x x x x x USE_DHT - - x x x x x USE_MAX31855 - - - - x - - USE_MAX31865 - - - - - - - Feature or Sensor minimal lite tasmota knx sensors ir display Remarks USE_I2C - - x x x - x USE_SHT - - - - x - - USE_HTU - - - - x - - USE_BMP - - - - x - - USE_BME680 - - - - x - - USE_BH1750 - - - - x - - USE_VEML6070 - - - - x - - USE_ADS1115 - - - - x - - USE_INA219 - - - - x - - USE_INA226 - - - - - - - USE_SHT3X - - - - x - - USE_TSL2561 - - - - x - - USE_TSL2591 - - - - - - - USE_MGS - - - - x - - USE_SGP30 - - - - x - - USE_SI1145 - - - - - - - USE_LM75AD - - - - x - - USE_APDS9960 - - - - - - - USE_MCP230xx - - - - - - - USE_PCA9685 - - - - - - - USE_MPR121 - - - - - - - USE_CCS811 - - - - x - - USE_MPU6050 - - - - - - - USE_DS3231 - - - - - - - USE_MGC3130 - - - - - - - USE_MAX44009 - - - - - - - USE_SCD30 - - - - x - - USE_SPS30 - - - - - - - USE_ADE7953 - - x x x - x USE_VL53L0X - - - - - - - USE_MLX90614 - - - - - - - USE_CHIRP - - - - - - - USE_PAJ7620 - - - - - - - USE_PCF8574 - - - - - - - USE_HIH6 - - - - x - - USE_DHT12 - - - - x - - USE_DS1624 - - - - x - - USE_AHT1x - - - - - - - USE_HDC1080 - - - - - - - USE_WEMOS_MOTOR_V1 - - - - x - - Feature or Sensor minimal lite tasmota knx sensors ir display Remarks USE_SPI - - - - - - x USE_MHZ19 - - - - x - - USE_SENSEAIR - - - - x - - USE_PMS5003 - - - - x - - USE_NOVA_SDS - - - - x - - USE_HPMA - - - - x - - USE_SERIAL_BRIDGE - - x x x - x USE_MP3_PLAYER - - - - x - - USE_AZ7798 - - - - - - - USE_PN532_HSU - - - - x - - USE_RDM6300 - - - - x - - USE_IBEACON - - - - x - - USE_GPS - - - - - - - USE_HM10 - - - - x - - USE_HRXL - - - - x - - USE_NRF24 - - - - - - - USE_MIBLE - - - - - - - USE_ZIGBEE - - - - - - - USE_IR_REMOTE - - x x x x x USE_IR_RECEIVE - - x x x x x USE_IR_REMOTE_FULL - - - - - x - Enable ALL protocols USE_SR04 - - - - x - - USE_TM1638 - - - - x - - USE_HX711 - - - - x - - USE_TX2x_WIND_SENSOR - - - - - - - USE_RC_SWITCH - - - - x - - USE_RF_SENSOR - - - - x - - AlectoV2 only USE_HRE - - - - x - - USE_A4988_STEPPER - - - - - - - USE_TASMOTA_SLAVE - - - - - - - Experimental Feature or Sensor minimal lite tasmota knx sensors ir display Remarks USE_DISPLAY - - - - - - x USE_DISPLAY_LCD - - - - - - x USE_DISPLAY_SSD1306 - - - - - - x USE_DISPLAY_MATRIX - - - - - - x USE_DISPLAY_SH1106 - - - - - - x USE_DISPLAY_ILI9341 - - - - - - x USE_DISPLAY_EPAPER_29 - - - - - - x USE_DISPLAY_EPAPER_42 - - - - - - x USE_DISPLAY_ILI9488 - - - - - - - USE_DISPLAY_SSD1351 - - - - - - - USE_DISPLAY_RA8876 - - - - - - -","title":"Available Features and Sensors"},{"location":"Buttons-and-Switches/","text":"?> Buttons and switches are primarily used to toggle (turn ON or OFF) relays or lights. A typical device usually has at least one button (exception being bulbs and some lights) to control the power state(s). Additional buttons and switches can be wired to a free GPIO and configured in Module or Template settings. [!NOTE] Other than relays/lights, Tasmota does not publish the state of components (switches, buttons, sensors, etc.) in real-time. State of components is transmitted automatically each TelePeriod via the SENSORS message. Button vs. Switch ~ A button (also called a push-button) is a momentary or non-latching switch which causes a temporary change in the state of an electrical circuit only while the switch is pressed. An automatic mechanism (i.e. a spring) returns the switch to its default position immediately afterwards, restoring the initial circuit condition. A switch (more precisely a latching or toggle switch), when activated by the user, remains in that state until activated again. Learn more about buttons and switches in this video . Both have a similar function, but Tasmota distinguishes between a \"Button\" and a \"Switch\" in other ways. Switch ~ In Tasmota a Switch is any switch or push-button additionally connected to a free GPIO. Some possibilities include: mechanical toggle switch - also called a rocker switch capacitive touch switch reed switch PIR - even though it's technically a sensor it is configured as a switch in Tasmota mechanical push-button By default a switch toggles the corresponding power state (f.e. Switch1 controls Power1 ). Every time the switch gets flipped the power state changes (ON or OFF). Instead of the default toggling of the power state, switches can be configured to send messages to different MQTT topics or send commands to other Tasmota devices. To ignore the default behaviour define a rule which triggers on Switch<x>#State or use Switchtopic . Take note: If the rule matches only certain states, default switch behaviour is supressed only for those states. [!EXAMPLE] Make Switch1 publish its value to cmnd/custom-topic/SWITCH and not control Power1 Backlog SwitchMode1 ; SwitchTopic 0 Rule1 on Switch1 # state do Publish cmnd / custom - topic / SWITCH % value % endon Rule1 1 [!ATTENTION] If you define a switch with a number higher than available power outputs it will default to controlling Power1 . Example: Switch4 on a device with Power1 and Power2 will control Power1 . And now, to make everything completely confusing: A push-button can be configured as a Switch and a toggle switch can be configured as a Button . Configuring a toggle switch as a Button is not recommended! SwitchMode ~ To change the behavior of a physical input peripheral configured as a Tasmota Switch<x> component, whether a toggle switch or a momentary switch (i.e., a push-button), use the SwitchMode command. If there is more than one Switch<x> component, use SwitchMode<x> where <x> is the number of your switch from the Tasmota GPIO configuration. SwitchMode, as the name implies, applies ONLY to GPIO configured in Tasmota as a Switch<x> component (9-16 & 82-89). SwitchMode has NO impact on the behavior of GPIO configured as Button<x> components (17-20, 90-93, & 112-129). SwitchMode sets the desired behavior of a Switch<x> component based on whether it's a switch or a push-button (i.e., a momentary switch) that is physically connected to the GPIO. SwitchMode 0 Default mode Set switch to toggle mode ( 0 = TOGGLE , 1 = TOGGLE ). Tasmota sends TOGGLE command each time the state of the circuit changes (closing or opening). In case of a push button attached Tasmota will send a TOGGLE command when pressed and another TOGGLE command when released. [!EXAMPLE] When the button is pressed, toggle the power to ring the doorbell; when the button is released, ring the doorbell again. SwitchMode 1 Set switch to follow mode ( 0 = OFF , 1 = ON ) At the time when the circuit is closed, Tasmota will send ON and opening the circuit sends OFF . Tip You want to use SwitchMode 1 when connecting a toggle switch (e.g. a classic light switch) to your device. This way the \"software switch\" will mirror the state of the \"hardware switch\". If the real switch is in the \"ON\" position, the state in Tasmota is ON as well. SwitchMode 2 Set switch to inverted follow mode ( 0 = ON , 1 = OFF ) At the time when the circuit is closed, Tasmota will send OFF and opening the circuit sends ON . Tip When connecting a momentary switch (i.e., a push-button) you will want to use SwitchMode 3..7 . SwitchMode 3 Set push-button mode ( 0 = TOGGLE , 1 = ON ( default )) Tasmota will send a TOGGLE command when the button is released (opening the circuit). When pressing the button (closing the circuit) nothing will happen. Default state is ON and when pressed it's OFF. (This trigger is known as falling-edge ) SwitchMode 4 Set inverted push-button mode ( 0 = OFF ( default ), 1 = TOGGLE ) Tasmota will send a TOGGLE command when the button is pressed (closing the circuit). When the button is released (opening the circuit) nothing will happen. Default state is OFF and when pressed it's ON. (This trigger is known as rising-edge ) SwitchMode 5 Set push-button with long press mode ( 0 = TOGGLE , 1 = ON ( default ), long press = HOLD ) Tasmota will send a TOGGLE command when the button is released (opening the circuit). When pressing the button (closing the circuit) nothing will happen. Default state is ON and when pressed it's OFF. When held for the time set in SetOption32 ( default = 4s ), Tasmota sends HOLD (use Switch<x>#state=3 in rules). SwitchMode 6 Set inverted push-button with long press mode ( 0 = OFF ( default ), 1 = TOGGLE , long press = HOLD ) Tasmota will send a TOGGLE command when the button pressed (closing the circuit). When the button is released (opening the circuit) nothing will happen. Default state is OFF and when pressed it's ON. When held for the time set in SetOption32 ( default = 4s ), Tasmota sends HOLD (use Switch<x>#state=3 in rules). Tip Long press or hold can be used in conjunction with rules to create additional features or to control another Tasmota device. SwitchMode 7 Set toggle push-button mode. Same as SwitchMode 0 . SwitchMode 8 Set switch to multi change toggle mode ( 0 = TOGGLE , 1 = TOGGLE , 2x change = HOLD ). Same as SwitchMode 0 but when the state of the circuit changes within 0.5s twice no TOGGLE commands are send but Tasmota sends HOLD (use Switch<x>#state=3 in rules). Warning When you change switch states fast (within 0.5s) some extra actions can be triggered using rules. ON/OFFpower state is only changed when there is no second switch change within 0.5s. SwitchMode 9 Set switch to multi change follow mode ( 0 = OFF , 1 = ON , 2x change = HOLD ) Same as SwitchMode 1 but when the state of the circuit changes within 0.5s twice no OFF/ON commands are send but Tasmota sends HOLD (use Switch<x>#state=3 in rules). Warning When you change switch states fast (within 0.5s) some extra actions can be triggered using rules. ON/OFFpower state is only changed when there is no second switch change within 0.5s. SwitchMode 10 Set switch to multi change inverted follow mode ( 0 = ON , 1 = OFF , 2x change = HOLD ) Same as SwitchMode 2 but when the state of the circuit changes within 0.5s twice no ON/OFF commands are send but Tasmota sends HOLD (use Switch<x>#state=3 in rules). Warning When you change switch states fast (within 0.5s) some extra actions can be triggered using rules. ON/OFFpower state is only changed when there is no second switch change within 0.5s. SwitchMode 11 Set switch to pushbutton with dimmer mode Tasmota will send a TOGGLE command (use Switch #state=2 in rules) when the button is pressed for a short time and is then released. When pressing the button (closing the circuit) for a long time (set in SetOption32 ) Tasmota sends repeated INC_DEC (increment or decrement the dimmer) commands (use Switch #state=4 in rules) as long as the button is pressed. Releasing the button starts a internal timer, the time is set in SetOption32 . When released for the time set in SetOption32 Tasmota sends a CLEAR command (use Switch #state=6 in rules). If the button is pressed again before the timeout Tasmota sends a INV command (use Switch #state=5 in rules). The INV command is for the controlling sortware (home assistant) to switch between incrementing and decrementing the dimmer. Tip The dimmer mode can be used in conjunction with rules to create additional features or to control another Tasmota device. Tip The dimmer mode can be used to turn a media player on and off and to control the volume of a media player with one switch. SwitchMode 12 Set switch to inverted pushbutton with dimmer mode. The same as Switchmode 11 but with inverted behaviour. SwitchMode 13 Set switch to \"push to on\" mode ( 1 = ON , 0 = nothing ) Tasmota will send an ON command when the button pressed (closing the circuit). When the button is released (opening the circuit) nothing will happen. Switch off using PulseTime . SwitchMode 14 Set switch to inverted \"push to on\" mode ( 0 = ON , 1 = nothing ) Tip This mode is useful with PIR sensor switches SwitchTopic ~ Warning When using SwitchTopic 1 or 2 (or ButtonTopic 1 or 2 ) and your MQTT broker becomes unavailable, Tasmota falls back to default SwitchTopic 0 (or ButtonTopic 0 ), which is not optimal. To avoid this, we recommend using rules . They simply always work! If you still need to use SwitchTopic read on! SwitchTopic 0 Default mode By default a switch controls the corresponding power state and doesn't send any MQTT messages itself. No MQTT message will be published on account of the new switch state. The message you see in console is the new power state that is controlled and not the switch state. SwitchTopic 1 Sets MQTT switch topic to device %topic% When changing the state of the switch an MQTT message is sent to the device topic with the payload according to SwitchMode set. [!EXAMPLE] Device topic tasmota with SwitchMode 3 yields the following message: MQT: cmnd/tasmota/POWER = TOGGLE Notice the cmnd instead of the stat at the beginning. This is the same as sending an MQTT commands to this device, the device power state will be set to the defined state. SwitchTopic <value> Set switch topic to a custom topic (32 characters max) This will send an MQTT message to a custom defined topic similarly to option 1. In the following example, we set the topic to tasmota02 with SwitchTopic tasmota02 . [!EXAMPLE] Device topic tasmota with SwitchMode 1 and custom topic tasmota02 yields the following message: MQT: cmnd/tasmota02/POWER = ON If you have another device with the topic tasmota02 this action will turn on its power while not affecting anything on the tasmota device. SwitchTopic Summary SwitchTopic 0 controls the power state directly. SwitchTopic 1 sends an MQTT message to the device topic. This sets the state of the devices power accordingly. SwitchTopic <value> sends an MQTT message command to the custom topic. This does not change the state of the devices power. Button ~ For Tasmota, a Button is typically a momentary push-button (or a capacitive touch button in some light switches). By default a button toggles the corresponding power state. Every time the button gets pressed a relay or light changes its Power state (ON or OFF). Besides toggling the Power state, a button is also used to activate multi press button functions , to do long press (HOLD) actions, or send messages to different MQTT topics. A push-to-make button should use a Button<x> component while a push-to-break button should use Button<x>i (i.e., inverted). To ignore default button behaviour define a rule which triggers on Button<x>#State or use ButtonTopic . Take note: If the rule matches only certain states, default button behaviour is supressed only for those states. [!EXAMPLE] Make Button1 publish its value to cmnd/custom-topic/BUTTON and not control Power1 Backlog ButtonTopic 0 Rule1 on Button1 # state do Publish cmnd / custom - topic / BUTTON % value % endon Rule1 1 Multi-Press Functions ~ Multipress functions for 2 and more presses cannot be changed using SetOptions or rules. Danger If you have changed ButtonTopic , SetOption1 , SetOption11 or SetOption13 some of the listed functionality will be changed or removed. 1 short press ~ Toggles the power state. This will blink the LED twice and send an MQTT status message like stat/tasmota/POWER1 ON . If cmnd/tasmota/ButtonRetain on has been used the MQTT message will also contain the MQTT retain flag. 2 short presses ~ Toggles the second power state (if available on the device). This will blink the LED twice and send an MQTT status message like stat/tasmota/POWER2 on . Any device with more than one power output can be configured to act on a double press to switch the second power state (or for Blitzwolf SHP5 the USB power). To be sure not to activate accidental three button press it is wise to set SetOption1 1 . 3 short presses ~ Start Wi-Fi smart config allowing for SSID and password configuration using an Android mobile phone with the ESP8266 SmartConfig app. The LED will blink during the config period. A single button press during this period will abort and restart the device. Only in tasmota-classic.bin OBSOLETED 4 short presses ~ Start Wi-Fi manager providing an Access Point with IP address 192.168.4.1 and a web server allowing the configuration of Wi-Fi. The LED will blink during the config period. A single button press during this period will abort and restart the device. 5 short presses ~ Start Wi-Fi Protected Setup (WPS) allowing for SSID and password configuration using the router's WPS button or web page. The LED will blink during the config period. A single button press during this period will abort and restart the device. Only in tasmota-classic.bin OBSOLETED 6 short presses ~ Restarts the device. 7 short presses ~ Start OTA update of firmware using OtaUrl . The green LED is lit during the update. Long press ~ There are two separate functions associated with a button long press based on how long it is held: 1. When held continuously for 40 seconds (Configurable with SetOption32 , value is 10x the configured hold time) Tasmota will reset to firmware defaults and restart. 2. If enabled, button pressed for 4 seconds (Configurable with SetOption32 ) creates a HOLD action. Check table below on how to enable this function. [!DANGER] When a button is configured with a Switchmode that keeps it as ON while depressed it activates the reset to firmware defaults function. Change that button to switch or change switchmode to avoid repeated resets to defaults. ButtonTopic ~ ButtonTopic 0 Default option By default a button controls the corresponding power state and doesn't send any MQTT messages itself. No MQTT message will be published on account of the new button state. The message you see in console is the new power state that is controlled and not the button state. ButtonTopic 1 Sets MQTT button topic to device %topic%. When changing the state of the button an MQTT message is sent to the device topic with the payload according to SwitchMode set. [!EXAMPLE] Device topic tasmota with SwitchMode 3 yields the following message: MQT: cmnd/tasmota/POWER = ON Notice the cmnd instead of the stat at the beginning. This is the same as sending an MQTT command to this device, the device power state will be set to the defined state. ButtonTopic <value> Set button topic to a custom topic (32 characters max). This will send an MQTT message to a custom defined topic similarly to option 1. [!EXAMPLE] For example, we set the topic to tasmota02 with ButtonTopic tasmota02 . With SwitchMode 1 the device yields the following message: MQT: cmnd/tasmota02/POWER = TOGGLE If you have another device with the topic tasmota02 this action will toggle its power state while not affecting anything on the tasmota device. ButtonTopic Summary ButtonTopic 0 controls the power state directly. ButtonTopic 1 sends an MQTT message to the device topic. This sets the state of the devices power state accordingly. ButtonTopic <value> sends an MQTT message command to the custom topic. This does not change the state of the devices power state. Changing Default Functionality ~ If a ButtonTopic (and if SetOption1 1 ) or SwitchTopic 1 is defined (and SwitchMode is set to 5 or 6 ) and a button is pressed longer than defined Key Hold Time ( SetOption32 default 4 seconds) an MQTT message like cmnd/%topic%/POWER HOLD will be sent. HOLD can be changed with StateText4 . Command SetOption11 allows for swapping the functionality of the push button. These changes result in the following: ![Action matrix]_media/button-matrix.png \":size=300\") Example You can control a ceiling fan from a Sonoff Touch: If your standard topic of Sonoff Touch is light and the ceiling fan topic is ceilingfan issue these commands on the Sonoff Touch to activate the double press feature. ButtonTopic ceilingfan SetOption11 1 All of the above is easier accomplished using Rules ! Example using Rules For a practical application of everything mentioned in this article read about this excellent LEGO nightstand switch project .","title":"Buttons and Switches"},{"location":"Buttons-and-Switches/#button-vs-switch","text":"A button (also called a push-button) is a momentary or non-latching switch which causes a temporary change in the state of an electrical circuit only while the switch is pressed. An automatic mechanism (i.e. a spring) returns the switch to its default position immediately afterwards, restoring the initial circuit condition. A switch (more precisely a latching or toggle switch), when activated by the user, remains in that state until activated again. Learn more about buttons and switches in this video . Both have a similar function, but Tasmota distinguishes between a \"Button\" and a \"Switch\" in other ways.","title":"Button vs. Switch"},{"location":"Buttons-and-Switches/#switch","text":"In Tasmota a Switch is any switch or push-button additionally connected to a free GPIO. Some possibilities include: mechanical toggle switch - also called a rocker switch capacitive touch switch reed switch PIR - even though it's technically a sensor it is configured as a switch in Tasmota mechanical push-button By default a switch toggles the corresponding power state (f.e. Switch1 controls Power1 ). Every time the switch gets flipped the power state changes (ON or OFF). Instead of the default toggling of the power state, switches can be configured to send messages to different MQTT topics or send commands to other Tasmota devices. To ignore the default behaviour define a rule which triggers on Switch<x>#State or use Switchtopic . Take note: If the rule matches only certain states, default switch behaviour is supressed only for those states. [!EXAMPLE] Make Switch1 publish its value to cmnd/custom-topic/SWITCH and not control Power1 Backlog SwitchMode1 ; SwitchTopic 0 Rule1 on Switch1 # state do Publish cmnd / custom - topic / SWITCH % value % endon Rule1 1 [!ATTENTION] If you define a switch with a number higher than available power outputs it will default to controlling Power1 . Example: Switch4 on a device with Power1 and Power2 will control Power1 . And now, to make everything completely confusing: A push-button can be configured as a Switch and a toggle switch can be configured as a Button . Configuring a toggle switch as a Button is not recommended!","title":"Switch"},{"location":"Buttons-and-Switches/#switchmode","text":"To change the behavior of a physical input peripheral configured as a Tasmota Switch<x> component, whether a toggle switch or a momentary switch (i.e., a push-button), use the SwitchMode command. If there is more than one Switch<x> component, use SwitchMode<x> where <x> is the number of your switch from the Tasmota GPIO configuration. SwitchMode, as the name implies, applies ONLY to GPIO configured in Tasmota as a Switch<x> component (9-16 & 82-89). SwitchMode has NO impact on the behavior of GPIO configured as Button<x> components (17-20, 90-93, & 112-129). SwitchMode sets the desired behavior of a Switch<x> component based on whether it's a switch or a push-button (i.e., a momentary switch) that is physically connected to the GPIO. SwitchMode 0 Default mode Set switch to toggle mode ( 0 = TOGGLE , 1 = TOGGLE ). Tasmota sends TOGGLE command each time the state of the circuit changes (closing or opening). In case of a push button attached Tasmota will send a TOGGLE command when pressed and another TOGGLE command when released. [!EXAMPLE] When the button is pressed, toggle the power to ring the doorbell; when the button is released, ring the doorbell again. SwitchMode 1 Set switch to follow mode ( 0 = OFF , 1 = ON ) At the time when the circuit is closed, Tasmota will send ON and opening the circuit sends OFF . Tip You want to use SwitchMode 1 when connecting a toggle switch (e.g. a classic light switch) to your device. This way the \"software switch\" will mirror the state of the \"hardware switch\". If the real switch is in the \"ON\" position, the state in Tasmota is ON as well. SwitchMode 2 Set switch to inverted follow mode ( 0 = ON , 1 = OFF ) At the time when the circuit is closed, Tasmota will send OFF and opening the circuit sends ON . Tip When connecting a momentary switch (i.e., a push-button) you will want to use SwitchMode 3..7 . SwitchMode 3 Set push-button mode ( 0 = TOGGLE , 1 = ON ( default )) Tasmota will send a TOGGLE command when the button is released (opening the circuit). When pressing the button (closing the circuit) nothing will happen. Default state is ON and when pressed it's OFF. (This trigger is known as falling-edge ) SwitchMode 4 Set inverted push-button mode ( 0 = OFF ( default ), 1 = TOGGLE ) Tasmota will send a TOGGLE command when the button is pressed (closing the circuit). When the button is released (opening the circuit) nothing will happen. Default state is OFF and when pressed it's ON. (This trigger is known as rising-edge ) SwitchMode 5 Set push-button with long press mode ( 0 = TOGGLE , 1 = ON ( default ), long press = HOLD ) Tasmota will send a TOGGLE command when the button is released (opening the circuit). When pressing the button (closing the circuit) nothing will happen. Default state is ON and when pressed it's OFF. When held for the time set in SetOption32 ( default = 4s ), Tasmota sends HOLD (use Switch<x>#state=3 in rules). SwitchMode 6 Set inverted push-button with long press mode ( 0 = OFF ( default ), 1 = TOGGLE , long press = HOLD ) Tasmota will send a TOGGLE command when the button pressed (closing the circuit). When the button is released (opening the circuit) nothing will happen. Default state is OFF and when pressed it's ON. When held for the time set in SetOption32 ( default = 4s ), Tasmota sends HOLD (use Switch<x>#state=3 in rules). Tip Long press or hold can be used in conjunction with rules to create additional features or to control another Tasmota device. SwitchMode 7 Set toggle push-button mode. Same as SwitchMode 0 . SwitchMode 8 Set switch to multi change toggle mode ( 0 = TOGGLE , 1 = TOGGLE , 2x change = HOLD ). Same as SwitchMode 0 but when the state of the circuit changes within 0.5s twice no TOGGLE commands are send but Tasmota sends HOLD (use Switch<x>#state=3 in rules). Warning When you change switch states fast (within 0.5s) some extra actions can be triggered using rules. ON/OFFpower state is only changed when there is no second switch change within 0.5s. SwitchMode 9 Set switch to multi change follow mode ( 0 = OFF , 1 = ON , 2x change = HOLD ) Same as SwitchMode 1 but when the state of the circuit changes within 0.5s twice no OFF/ON commands are send but Tasmota sends HOLD (use Switch<x>#state=3 in rules). Warning When you change switch states fast (within 0.5s) some extra actions can be triggered using rules. ON/OFFpower state is only changed when there is no second switch change within 0.5s. SwitchMode 10 Set switch to multi change inverted follow mode ( 0 = ON , 1 = OFF , 2x change = HOLD ) Same as SwitchMode 2 but when the state of the circuit changes within 0.5s twice no ON/OFF commands are send but Tasmota sends HOLD (use Switch<x>#state=3 in rules). Warning When you change switch states fast (within 0.5s) some extra actions can be triggered using rules. ON/OFFpower state is only changed when there is no second switch change within 0.5s. SwitchMode 11 Set switch to pushbutton with dimmer mode Tasmota will send a TOGGLE command (use Switch #state=2 in rules) when the button is pressed for a short time and is then released. When pressing the button (closing the circuit) for a long time (set in SetOption32 ) Tasmota sends repeated INC_DEC (increment or decrement the dimmer) commands (use Switch #state=4 in rules) as long as the button is pressed. Releasing the button starts a internal timer, the time is set in SetOption32 . When released for the time set in SetOption32 Tasmota sends a CLEAR command (use Switch #state=6 in rules). If the button is pressed again before the timeout Tasmota sends a INV command (use Switch #state=5 in rules). The INV command is for the controlling sortware (home assistant) to switch between incrementing and decrementing the dimmer. Tip The dimmer mode can be used in conjunction with rules to create additional features or to control another Tasmota device. Tip The dimmer mode can be used to turn a media player on and off and to control the volume of a media player with one switch. SwitchMode 12 Set switch to inverted pushbutton with dimmer mode. The same as Switchmode 11 but with inverted behaviour. SwitchMode 13 Set switch to \"push to on\" mode ( 1 = ON , 0 = nothing ) Tasmota will send an ON command when the button pressed (closing the circuit). When the button is released (opening the circuit) nothing will happen. Switch off using PulseTime . SwitchMode 14 Set switch to inverted \"push to on\" mode ( 0 = ON , 1 = nothing ) Tip This mode is useful with PIR sensor switches","title":"SwitchMode"},{"location":"Buttons-and-Switches/#switchtopic","text":"Warning When using SwitchTopic 1 or 2 (or ButtonTopic 1 or 2 ) and your MQTT broker becomes unavailable, Tasmota falls back to default SwitchTopic 0 (or ButtonTopic 0 ), which is not optimal. To avoid this, we recommend using rules . They simply always work! If you still need to use SwitchTopic read on! SwitchTopic 0 Default mode By default a switch controls the corresponding power state and doesn't send any MQTT messages itself. No MQTT message will be published on account of the new switch state. The message you see in console is the new power state that is controlled and not the switch state. SwitchTopic 1 Sets MQTT switch topic to device %topic% When changing the state of the switch an MQTT message is sent to the device topic with the payload according to SwitchMode set. [!EXAMPLE] Device topic tasmota with SwitchMode 3 yields the following message: MQT: cmnd/tasmota/POWER = TOGGLE Notice the cmnd instead of the stat at the beginning. This is the same as sending an MQTT commands to this device, the device power state will be set to the defined state. SwitchTopic <value> Set switch topic to a custom topic (32 characters max) This will send an MQTT message to a custom defined topic similarly to option 1. In the following example, we set the topic to tasmota02 with SwitchTopic tasmota02 . [!EXAMPLE] Device topic tasmota with SwitchMode 1 and custom topic tasmota02 yields the following message: MQT: cmnd/tasmota02/POWER = ON If you have another device with the topic tasmota02 this action will turn on its power while not affecting anything on the tasmota device.","title":"SwitchTopic"},{"location":"Buttons-and-Switches/#button","text":"For Tasmota, a Button is typically a momentary push-button (or a capacitive touch button in some light switches). By default a button toggles the corresponding power state. Every time the button gets pressed a relay or light changes its Power state (ON or OFF). Besides toggling the Power state, a button is also used to activate multi press button functions , to do long press (HOLD) actions, or send messages to different MQTT topics. A push-to-make button should use a Button<x> component while a push-to-break button should use Button<x>i (i.e., inverted). To ignore default button behaviour define a rule which triggers on Button<x>#State or use ButtonTopic . Take note: If the rule matches only certain states, default button behaviour is supressed only for those states. [!EXAMPLE] Make Button1 publish its value to cmnd/custom-topic/BUTTON and not control Power1 Backlog ButtonTopic 0 Rule1 on Button1 # state do Publish cmnd / custom - topic / BUTTON % value % endon Rule1 1","title":"Button"},{"location":"Buttons-and-Switches/#multi-press-functions","text":"Multipress functions for 2 and more presses cannot be changed using SetOptions or rules. Danger If you have changed ButtonTopic , SetOption1 , SetOption11 or SetOption13 some of the listed functionality will be changed or removed.","title":"Multi-Press Functions"},{"location":"Buttons-and-Switches/#1-short-press","text":"Toggles the power state. This will blink the LED twice and send an MQTT status message like stat/tasmota/POWER1 ON . If cmnd/tasmota/ButtonRetain on has been used the MQTT message will also contain the MQTT retain flag.","title":"1 short press"},{"location":"Buttons-and-Switches/#2-short-presses","text":"Toggles the second power state (if available on the device). This will blink the LED twice and send an MQTT status message like stat/tasmota/POWER2 on . Any device with more than one power output can be configured to act on a double press to switch the second power state (or for Blitzwolf SHP5 the USB power). To be sure not to activate accidental three button press it is wise to set SetOption1 1 .","title":"2 short presses"},{"location":"Buttons-and-Switches/#3-short-presses","text":"Start Wi-Fi smart config allowing for SSID and password configuration using an Android mobile phone with the ESP8266 SmartConfig app. The LED will blink during the config period. A single button press during this period will abort and restart the device. Only in tasmota-classic.bin OBSOLETED","title":"3 short presses"},{"location":"Buttons-and-Switches/#4-short-presses","text":"Start Wi-Fi manager providing an Access Point with IP address 192.168.4.1 and a web server allowing the configuration of Wi-Fi. The LED will blink during the config period. A single button press during this period will abort and restart the device.","title":"4 short presses"},{"location":"Buttons-and-Switches/#5-short-presses","text":"Start Wi-Fi Protected Setup (WPS) allowing for SSID and password configuration using the router's WPS button or web page. The LED will blink during the config period. A single button press during this period will abort and restart the device. Only in tasmota-classic.bin OBSOLETED","title":"5 short presses"},{"location":"Buttons-and-Switches/#6-short-presses","text":"Restarts the device.","title":"6 short presses"},{"location":"Buttons-and-Switches/#7-short-presses","text":"Start OTA update of firmware using OtaUrl . The green LED is lit during the update.","title":"7 short presses"},{"location":"Buttons-and-Switches/#long-press","text":"There are two separate functions associated with a button long press based on how long it is held: 1. When held continuously for 40 seconds (Configurable with SetOption32 , value is 10x the configured hold time) Tasmota will reset to firmware defaults and restart. 2. If enabled, button pressed for 4 seconds (Configurable with SetOption32 ) creates a HOLD action. Check table below on how to enable this function. [!DANGER] When a button is configured with a Switchmode that keeps it as ON while depressed it activates the reset to firmware defaults function. Change that button to switch or change switchmode to avoid repeated resets to defaults.","title":"Long press"},{"location":"Buttons-and-Switches/#buttontopic","text":"ButtonTopic 0 Default option By default a button controls the corresponding power state and doesn't send any MQTT messages itself. No MQTT message will be published on account of the new button state. The message you see in console is the new power state that is controlled and not the button state. ButtonTopic 1 Sets MQTT button topic to device %topic%. When changing the state of the button an MQTT message is sent to the device topic with the payload according to SwitchMode set. [!EXAMPLE] Device topic tasmota with SwitchMode 3 yields the following message: MQT: cmnd/tasmota/POWER = ON Notice the cmnd instead of the stat at the beginning. This is the same as sending an MQTT command to this device, the device power state will be set to the defined state. ButtonTopic <value> Set button topic to a custom topic (32 characters max). This will send an MQTT message to a custom defined topic similarly to option 1. [!EXAMPLE] For example, we set the topic to tasmota02 with ButtonTopic tasmota02 . With SwitchMode 1 the device yields the following message: MQT: cmnd/tasmota02/POWER = TOGGLE If you have another device with the topic tasmota02 this action will toggle its power state while not affecting anything on the tasmota device.","title":"ButtonTopic"},{"location":"Buttons-and-Switches/#changing-default-functionality","text":"If a ButtonTopic (and if SetOption1 1 ) or SwitchTopic 1 is defined (and SwitchMode is set to 5 or 6 ) and a button is pressed longer than defined Key Hold Time ( SetOption32 default 4 seconds) an MQTT message like cmnd/%topic%/POWER HOLD will be sent. HOLD can be changed with StateText4 . Command SetOption11 allows for swapping the functionality of the push button. These changes result in the following: ![Action matrix]_media/button-matrix.png \":size=300\")","title":"Changing Default Functionality"},{"location":"Buzzer/","text":"\u00bb6.6.0.4 Tasmota gives you the option to control the sound pattern of a buzzer. [!NOTE] A device LED can be assigned as a Buzzer component to display a blink pattern. Buzzer command ~ Parameters for the Buzzer command can be <count>,<beep>,<silence>,<tune> all parameters are optional. (default is 1,1,1 (one 100 millisecond beep)) . <count> number of beeps -1 for infinite, -2 to follow state of LED1;\u00bb v8.1.0.6 <beep> duration of one beep in 100 millisecond steps <silence> duration of silence between beeps 100 millisecond steps <tune> is a 32-bit bitmask where a 1 bit beeps and a 0 bit is silence according to <beep> and <silence> , respectively. The tune is played from most significant bit (MSB) to least significant bit (LSB). Leading and trailing 0 bits are ignored. If <tune> is specified, <count> is ignored ( <count> for <tune> supported in \u00bb v8.1.0.6). If <tune> is 0 , it is ignored. Examples: 3 - Beep three times with 100 milliseconds duration and 100 milliseconds pause 2,3 - Beep twice with 300 milliseconds duration and 100 milliseconds pause 2,3,4 - Beep twice with 300 milliseconds duration and 400 milliseconds pause 1,2,3,0xF54 (0000 0000 0000 0000 0000 1111 0101 0100). Each 1 bit beeps for 200 milliseconds and each bounded 0 bit pauses for 300 milliseconds 0 = stop active buzzer cycle \u2003\u00bb v6.6.0.18","title":"Buzzer"},{"location":"Buzzer/#buzzer-command","text":"Parameters for the Buzzer command can be <count>,<beep>,<silence>,<tune> all parameters are optional. (default is 1,1,1 (one 100 millisecond beep)) . <count> number of beeps -1 for infinite, -2 to follow state of LED1;\u00bb v8.1.0.6 <beep> duration of one beep in 100 millisecond steps <silence> duration of silence between beeps 100 millisecond steps <tune> is a 32-bit bitmask where a 1 bit beeps and a 0 bit is silence according to <beep> and <silence> , respectively. The tune is played from most significant bit (MSB) to least significant bit (LSB). Leading and trailing 0 bits are ignored. If <tune> is specified, <count> is ignored ( <count> for <tune> supported in \u00bb v8.1.0.6). If <tune> is 0 , it is ignored. Examples: 3 - Beep three times with 100 milliseconds duration and 100 milliseconds pause 2,3 - Beep twice with 300 milliseconds duration and 100 milliseconds pause 2,3,4 - Beep twice with 300 milliseconds duration and 400 milliseconds pause 1,2,3,0xF54 (0000 0000 0000 0000 0000 1111 0101 0100). Each 1 bit beeps for 200 milliseconds and each bounded 0 bit pauses for 300 milliseconds 0 = stop active buzzer cycle \u2003\u00bb v6.6.0.18","title":"Buzzer command"},{"location":"CC2530/","text":"?> The CC2530 is a system-on-chip (SoC) for Zigbee communication. Complete setup of a CC2530 module is covered in the Zigbee article Breakout Boards ~ List of fully compatible CC2530 boards is maintained here [!DANGER] You cannot use an CC2531 based device with Tasmota! CC2531 supports USB communication and not serial communication required by Zigbee2Tasmota.","title":"CC2530"},{"location":"CC2530/#breakout-boards","text":"List of fully compatible CC2530 boards is maintained here [!DANGER] You cannot use an CC2531 based device with Tasmota! CC2531 supports USB communication and not serial communication required by Zigbee2Tasmota.","title":"Breakout Boards"},{"location":"Codes-for-IR-Remotes-%28for-YTF-IR-Bridge%29/","text":"The IR Codes can be used with any devicewith an IR sender. The codes will also fit other devices from same manufacturer or series. Please try out... Feel free to contribute this list TV's ~ IR Codes TV Panasonic TX65FXW784 ~ Example received Code: tele/sonoffIRBridge_1/RESULT = {\"IrReceived\":{\"Protocol\":\"PANASONIC\",\"Bits\":48,\"Data\":\"0x100BCBD\"}} Example IRsend Command: IRsend {\"Protocol\":\"PANASONIC\",\"Bits\":48,\"Data\":0x100BCBD} 0x40040100BCBD=\"ON/OFF\" 0x400401004C4D=\"Mute\" 0x400401000405=\"Vol+\" 0x400401008485=\"Vol-\" 0x400401002C2D=\"P+\" 0x40040100ACAD=\"P-\" 0x400401007273=\"Left\" 0x40040100F2F3=\"Right\" 0x400401005253=\"Up\" 0x40040100D2D3=\"Down\" 0x400401009293=\"OK\" 0x400401004A4B=\"Menu\" 0x400401000E0F=\"Red\" 0x400401004E4F=\"Yellow\" 0x400401008E8F=\"Green\" 0x40040100CECF=\"Blue\" 0x40040100ECED=\"Last View\" 0x400401206D4C=\"My App\" 0x400401904FDE=\"Netflix\" 0x40040190F160=\"Apps\" 0x400401900392=\"Play\" 0x400401908312=\"Pause\" 0x4004019043D2=\"Stop\" 0x40040190C352=\"Forward\" 0x4004019023B2=\"Back\" 0x400401000809=\"Key 1\" 0x400401008889=\"Key 2\" 0x400401004849=\"Key 3\" 0x40040100C8C9=\"Key 4\" 0x400401002829=\"Key 5\" 0x40040100A8A9=\"Key 6\" 0x400401006869=\"Key 7\" 0x40040100E8E9=\"Key 8\" 0x400401001819=\"Key 9\" 0x400401009899=\"Key 0\" 0x40040190BB2A=\"Title forward\" 0x400401903BAA=\"Title back\" 0x40040190A332=\"Record\" 0x40040190E170=\"Guide\" 0x40040100CBCA=\"Exit\" 0x400401002B2A=\"Back\" 0x40040190E574=\"Option\" 0x400401009C9D=\"Info\" 0x400401400C4D=\"TV\" 0x40040100A0A1=\"AV\" 0x40040180C041=\"Text\" 0x40040180A021=\"STTL\" 0x400401000A0B=\"Picture\" 0x400401003534=\"Help\" IR Remote Codes Sony KDL-EX540 ~ Common buttons should work across multiple models Input {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xA50\"} Power On {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x750\"} Power Off {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xF50\"} Power Toggle {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xA90\"} Vol + {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x490\"} Vol - {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xC90\"} Mute {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x290\"} Ch + {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x090\"} Ch - {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x890\"} Theatre Mode {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x03EE\"} Play/Pause {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x2CE9\"} Stop {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x0CE9\"} Rew {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x6CE9\"} Fwd {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x1CE9\"} Sync Menu {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x0D58\"} Prev {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x1EE9\"} Next {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x5EE9\"} i-Manual {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x6F58\"} Scene {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x0F58\"} Aspect {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x5E25\"} Digital/Analog {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x58EE\"} PIP {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x7725\"} Internet Video {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x4F58\"} Favourite {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x37EE\"} Guide {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x6D25\"} Info {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x5D0\"} Return {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x62E9\"} Options {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x36E9\"} Home {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x070\"} Up {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x2F0\"} Down {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xAF0\"} Left {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x2D0\"} Right {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xCD0\"} Enter {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xA70\"} Red {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x52E9\"} Green {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x32E9\"} Yellow {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x72E9\"} Blue {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x12E9\"} 1 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x010\"} 2 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x810\"} 3 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x410\"} 4 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xC10\"} 5 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x210\"} 6 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xA10\"} 7 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x610\"} 8 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xE10\"} 9 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x110\"} Text {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xFD0\"} 0 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x110\"} Subtitles {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x0AE9\"} Audio Track {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xE90\"} HDMI 1 {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x2D58\"} HDMI 2 {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x6D58\"} HDMI 3 {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x1D58\"} HDMI 4 {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x5D58\"} Video 1 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x030\"} Video 2 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x830\"} Video 3/Component 1 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x430\"} PC {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xC30\"} Digital TV {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x25EE\"} IR Codes TV LG 55UH8509 ~ Example received Code: tele/sonoffIRBridge_1/RESULT = {\"IrReceived\":{\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x20DF10EF\"}} Example IRsend Command: IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":0x20DF10EF} or with mosquitto_pub: mosquitto_pub -q 2 -t cmnd/sonoffIRBridge_1/IRSend -m '{\"protocol\": \"NEC\",\"bits\": 32, \"data\": 0x20DF10EF}' 0x20DF10EF=\"ON/OFF\" 0x20DF0FF0=\"TV\" 0x20DF9E61=\"Ratio\" 0x20DFD02F=\"Input\" 0x20DFA956=\"Energy\" 0x20DF8877=\"Key 1\" 0x20DF48B7=\"Key 2\" 0x20DFC837=\"Key 3\" 0x20DF28D7=\"Key 4\" 0x20DFA857=\"Key 5\" 0x20DF6897=\"Key 6\" 0x20DFE817=\"Key 7\" 0x20DF18E7=\"Key 8\" 0x20DF9867=\"Key 9\" 0x20DFCA35=\"List\" 0x20DF08F7=\"Key 0\" 0x20DF58A7=\"Q.View\" 0x20DF40BF=\"Vol+\" 0x20DFC03F=\"Vol-\" 0x20DFCE31=\"Vol-\" 0x20DF7887=\"Fav\" 0x20DF3BC4=\"3D\" 0x20DF906F=\"Mute\" 0x20DF00FF=\"P+\" 0x20DF807F=\"P-\" 0x20DFC23D=\"Settings\" 0x20DF55AA=\"Info\" 0x20DFA25D=\"Q.Menu\" 0x20DFE01F=\"Left\" 0x20DF609F=\"Right\" 0x20DF02FD=\"Up\" 0x20DF827D=\"Down\" 0x20DF22DD=\"OK\" 0x20DF14EB=\"Back\" 0x20DFD52A=\"Guide\" 0x20DFDA25=\"Exit\" 0x20DF4EB1=\"Red\" 0x20DF8E71=\"Green\" 0x20DFC639=\"Yellow\" 0x20DF8679=\"Blue\" 0x20DF04FB=\"Text\" 0x20DF847B=\"T.Opt\" 0x20DF9C63=\"Subtitle\" 0x20DF8D72=\"Stop\" 0x20DF0DF2=\"Play\" 0x20DF5DA2=\"Pause\" 0x20DFF10E=\"Backward\" 0x20DF718E=\"Forward\" 0x20DF7E81=\"Simplink\" 0x20DF8976=\"AD\" 0x20DF0CF3=\"AV Mode\" 0x20DF3EC1=\"Live TV\" 0x20DF42BD=\"Live TV\" 0x20DF35CA=\"Status\" 0x20DF50AF=\"Audio Language\" 0x20DF57A8=\"Shortmenu\" 0x20DF5AA5=\"AV\" 0x20DF5EA1=\"online manual\" 0x20DF619E=\"Volume to 50\" 0x20DF21DE=\"Volume to 80\" 0x20DFE11E=\"Volume to 100\" 0x20DF6B94=\"Radio/TV\" 0x20DF708F=\"doze function\" 0x20DFA35C=\"Display off\" 0x20DFD728=\"Standby\" 0x20DF23DC=\"Power on\" 0x20DFB44B=\"Settings of remote\" 0x20DF956A=\"Program guide\" 0x20DFF00F=\"Radio/TV\" 0x20DF738C=\"HDMI 1\" 0x20DF33CC=\"HDMI 2\" 0x20DF9768=\"HDMI 3\" 0x20DFFD02=\"Component\" 0x20DFF50A=\"Live Zoom\" 0x20DFF20D=\"Input info\" 0x20DFB24D=\"Picture mode\" 0x20DF09F6=\"Recordings\" 0x20DF4AB5=\"Audio mode\" 0x20DF7B84=\"Register magic remote\" 0x20DFAE51=\"directly register magic remote\" 0x20DF1CE3=\"Subtitles\" 0x20DFCC33=\"Presentation in shop\" 0x20DFBD42=\"Start recording\" 0x20DFAD52=\"LG TV Plus\" 0x20DFDD22=\"Sports mode\" 0x20DF1EE1=\"Search\" 0x20DFDF20=\"Warning: instart\" 0x20DF7F80=\"Warning: Poweronly\" 0x20DFFF00=\"Warning: Easy adjust\" 0x20DF5FA0=\"Warning: instop\" 0x20DF5FA0=\"Enter Password\" 0x20DF3FC0=\"Warning: Reset to factory\" Set-top Boxes ~ IR Codes for VU+ Duo2 ~ Example received Code: tele/sonoffIRBridge_1/RESULT = {\"IrReceived\":{\"Protocol\":\"RC6\",\"Bits\":36,\"Data\":\"0x8052900C\"} Example IRsend Command: IRsend {\"Protocol\":\"RC6\",\"Bits\":36,\"Data\":0x8052900C} 0xC8052900C=\"ON/OFF\" 0xC8052100D=\"Mute\" 0xC80529010=\"Vol+\" 0xC80521011=\"Vol-\" 0xC80529020=\"P+\" 0xC80529021=\"P+\" 0xC8052105A=\"Left\" 0xC8052905B=\"Right\" 0xC80529058=\"Up\" 0xC80529059=\"Down\" 0xC8052905C=\"OK\" 0xC80529054=\"Men\" 0xC8052906D=\"Red\" 0xC8052906F=\"Yellow\" 0xC8052906E=\"Green\" 0xC80529070=\"Blue\" 0xC8052902D=\"Play/Pause\" 0xC80529031=\"Stop\" 0xC80529028=\"Forward\" 0xC80529029=\"Back\" 0xC80529001=\"Key 1\" 0xC80529002=\"Key 2\" 0xC80529003=\"Key 3\" 0xC80529004=\"Key 4\" 0xC80529005=\"Key 5\" 0xC80529006=\"Key 6\" 0xC80529007=\"Key 7\" 0xC80529008=\"Key 8\" 0xC80529009=\"Key 9\" 0xC80529000=\"Key 0\" 0xC805290BB=\"Key <\" 0xC805290BC=\"Key >\" 0xC80529037=\"Record\" 0xC805290CC=\"EPG\" 0xC80529055=\"Exit\" 0xC805290E5=\"Audio\" 0xC805290F2=\"Radio\" 0xC805290E4=\"TV\" 0xC80521049=\"Context\" 0xC80529081=\"Help\" IR Remote Codes AppleTV Gen4 ~ Up {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x77E15080\"} Down {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x77E13080\"} Left {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x77E19080\"} Right {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x77E16080\"} Ok {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x77E13A80\"} Menu {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x77E1C080\"} Play/Pause {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x77E1FA80\"} Home {\"Protocol\":\"NEC\",\"Bits\":0,\"Data\":\"0xFFFFFFFFFFFFFFFF\"} IR Remote Codes Humax HMS-1000T DVB-T2 DVR PAL 4-Tune ~ Power {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000800FF\"} TV Apps {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008D22D\"} Text {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00087689\"} Wide {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008728D\"} Play {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000816E9\"} Pause {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000846B9\"} Rew {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008A659\"} Fwd {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000826D9\"} Stop {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008C639\"} Record {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00088679\"} Search {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008E21D\"} Plus {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000842BD\"} Exit {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00086897\"} Back {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008827D\"} Up {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00088877\"} Down {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008A857\"} Left {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000848B7\"} Right {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000828D7\"} Enter {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008C837\"} Vol + {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008F807\"} Vol - {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000802FD\"} Mute {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000818E7\"} Home {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008708F\"} Guide {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008D827\"} Ch + {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000808F7\"} Ch - {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008F00F\"} Red {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000838C7\"} Green {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008B847\"} Yellow {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000858A7\"} Blue {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00087887\"} 1 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008C03F\"} 2 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000820DF\"} 3 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008A05F\"} 4 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008609F\"} 5 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008E01F\"} 6 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000810EF\"} 7 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008906F\"} 8 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000850AF\"} 9 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008D02F\"} 0 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000830CF\"} TV/Radio {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008B04F\"} IR Remote Codes FetchTV Mini(Hybroad H626T) ~ Power Toggle {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662BA45\"} Keyboard Select {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26624CB3\"} Ch + {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26627B84\"} Ch - {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662DB24\"} TV Guide {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x266207F8\"} Red {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662738C\"} Green {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662936C\"} Yellow {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662E31C\"} Blue {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x266213EC\"} Info {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26628B74\"} Search {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26622CD3\"} Apps {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662CC33\"} Menu {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26629B64\"} Up {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26629B64\"} Down {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x266223DC\"} Left {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662837C\"} Right {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662C33C\"} Enter {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26621CE3\"} Back {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662AB54\"} Exit {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x266227D8\"} Rew {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662BB44\"} Play/Pause {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26625BA4\"} Fwd {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26625BA4\"} Stop {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662B34C\"} Record {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26624BB4\"} Smart Reveiver VX/CX ~ button code on/off {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF30CF\",\"DataLSB\":\"0x00FF0CF3\",\"Repeat\":0} mute {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFB04F\",\"DataLSB\":\"0x00FF0DF2\",\"Repeat\":0} FORMAT {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF1CE3\",\"DataLSB\":\"0x00FF38C7\",\"Repeat\":0} 16:9 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFC13E\",\"DataLSB\":\"0x00FF837C\",\"Repeat\":0} AUDIO {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFFA05\",\"DataLSB\":\"0x00FF5FA0\",\"Repeat\":0} 1 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF807F\",\"DataLSB\":\"0x00FF01FE\",\"Repeat\":0} 2 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF40BF\",\"DataLSB\":\"0x00FF02FD\",\"Repeat\":0} 3 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFC03F\",\"DataLSB\":\"0x00FF03FC\",\"Repeat\":0} 4 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF20DF\",\"DataLSB\":\"0x00FF04FB\",\"Repeat\":0} 5 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFA05F\",\"DataLSB\":\"0x00FF05FA\",\"Repeat\":0} 6 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF609F\",\"DataLSB\":\"0x00FF06F9\",\"Repeat\":0} 7 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFE01F\",\"DataLSB\":\"0x00FF07F8\",\"Repeat\":0} 8 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF10EF\",\"DataLSB\":\"0x00FF08F7\",\"Repeat\":0} 9 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF906F\",\"DataLSB\":\"0x00FF09F6\",\"Repeat\":0} TV/R {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFA25D\",\"DataLSB\":\"0x00FF45BA\",\"Repeat\":0} 0 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF00FF\",\"DataLSB\":\"0x00FF00FF\",\"Repeat\":0} RECALL {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF19E6\",\"DataLSB\":\"0x00FF9867\",\"Repeat\":0} volume + {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF5AA5\",\"DataLSB\":\"0x00FF5AA5\",\"Repeat\":0} volume - {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFDA25\",\"DataLSB\":\"0x00FF5BA4\",\"Repeat\":0} P - {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFBA45\",\"DataLSB\":\"0x00FF5DA2\",\"Repeat\":0} P + {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF3AC5\",\"DataLSB\":\"0x00FF5CA3\",\"Repeat\":0} red {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFEC13\",\"DataLSB\":\"0x00FF37C8\",\"Repeat\":0} green {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF6C93\",\"DataLSB\":\"0x00FF36C9\",\"Repeat\":0} yellow {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF4CB3\",\"DataLSB\":\"0x00FF32CD\",\"Repeat\":0} blue {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF2CD3\",\"DataLSB\":\"0x00FF34CB\",\"Repeat\":0} MENU {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF4AB5\",\"DataLSB\":\"0x00FF52AD\",\"Repeat\":0} BACK {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF44BB\",\"DataLSB\":\"0x00FF22DD\",\"Repeat\":0} EXIT {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFB44B\",\"DataLSB\":\"0x00FF2DD2\",\"Repeat\":0} up {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF04FB\",\"DataLSB\":\"0x00FF20DF\",\"Repeat\":0} left {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF8877\",\"DataLSB\":\"0x00FF11EE\",\"Repeat\":0} OK {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFEA15\",\"DataLSB\":\"0x00FF57A8\",\"Repeat\":0} right {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF08F7\",\"DataLSB\":\"0x00FF10EF\",\"Repeat\":0} down {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF847B\",\"DataLSB\":\"0x00FF21DE\",\"Repeat\":0} INFO {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF34CB\",\"DataLSB\":\"0x00FF2CD3\",\"Repeat\":0} FAV {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF8679\",\"DataLSB\":\"0x00FF619E\",\"Repeat\":0} TXT {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF7A85\",\"DataLSB\":\"0x00FF5EA1\",\"Repeat\":0} EPG {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF06F9\",\"DataLSB\":\"0x00FF609F\",\"Repeat\":0} FR {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF8976\",\"DataLSB\":\"0x00FF916E\",\"Repeat\":0} REC {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF619E\",\"DataLSB\":\"0x00FF8679\",\"Repeat\":0} FF {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF29D6\",\"DataLSB\":\"0x00FF946B\",\"Repeat\":0} PREV {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF09F6\",\"DataLSB\":\"0x00FF906F\",\"Repeat\":0} Play/Pause {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFE916\",\"DataLSB\":\"0x00FF9768\",\"Repeat\":0} NEXT {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFC936\",\"DataLSB\":\"0x00FF936C\",\"Repeat\":0} (none left) {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF4BB4\",\"DataLSB\":\"0x00FFD22D\",\"Repeat\":0} STOP {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF718E\",\"DataLSB\":\"0x00FF8E71\",\"Repeat\":0} (none right) {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF8976\",\"DataLSB\":\"0x00FF916E\",\"Repeat\":0} USB {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFFB04\",\"DataLSB\":\"0x00FFDF20\",\"Repeat\":0} HELP {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF54AB\",\"DataLSB\":\"0x00FF2AD5\",\"Repeat\":0} DVD {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFDB24\",\"DataLSB\":\"0x00FFDB24\",\"Repeat\":0} BD/DVD players ~ IR Remote Codes Sony BD-S1500 ~ Common buttons should work across multiple models Eject {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x68B47\"} Power {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xA8B47\"} Red {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xE6B47\"} Green {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x16B47\"} Yellow {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x96B47\"} Bue {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x66B47\"} Top Menu {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x34B47\"} Popup/Menu {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x94B47\"} Return {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xC2B47\"} Options {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xFCB47\"} Home {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x42B47\"} Up {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x9CB47\"} Down {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x5CB47\"} Left {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xDCB47\"} Right {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x3CB47\"} Enter {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xBCB47\"} Favourites {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xBCB47\"} Netflix {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xD2B47\"} Play {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x58B47\"} Pause {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x98B47\"} Rew {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xD8B47\"} Fwd {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x38B47\"} Prev {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xEAB47\"} Next {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x6AB47\"} Stop {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x18B47\"} Subtitles {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xC6B47\"} Audio Track {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x26B47\"} Vol + {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x490\"} Vol - {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xC90\"} Mute {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x290\"} Projectors ~ IR Remote Codes Acer K132 ~ IR Remote Codes for Acer K132 projector (and possibly other models using a remote with Model No. M1820) ON/OFF {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8E11E\"} * Freeze {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8718E\"} * Hide {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8F10E\"} * Ratio {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C806F9\"} * Zoom {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8D12E\"} * Mode {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C801FE\"} * Source {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C831CE\"} * Back {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C832CD\"} * Up {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C841BE\"} * Down {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8A15E\"} * Left {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8C13E\"} * Right {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8817E\"} * Enter {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8B24D\"} * Menu {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C821DE\"} * Vol+ {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8C639\"} * Vol- {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C826D9\"} * Sound {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8AD52\"} * Mute {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C88679\"} Soundbars ~ IR Codes Soundbar Panasonic SCALL70T ~ Example received Code: tele/sonoffIRBridge_1/RESULT = {\"IrReceived\":{\"Protocol\":\"PANASONIC\",\"Bits\":48,\"Data\":\"0x40040500BCB9\"}} Example IRsend Command: IRsend {\"Protocol\":\"PANASONIC\",\"Bits\":48,\"Data\":0x40040500BCB9} 0x40040500BCB9=\"ON/OFF\" 0x400405004C49=\"Mute\" 0x400405000401=\"Vol+\" 0x400405008481=\"Vol-\" 0x40040538DFE2=\"OK\" 0x400405383F02=\"Up\" 0x40040538BF82=\"Down\" 0x40040538AD90=\"Setup\" 0x400405280D20=\"Sound\" 0x400405380538=\"Bluetooth\" 0x400405006164=\"Input\" Vacuum Cleaners ~ IR Codes Vacuum Cleaner Ecovacs Deebot Slim2 ~ Example received Code: tele/sonoffIRBridge_1/RESULT = {\"IrReceived\":{\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFD02F\"}} Example IRsend Command: IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":0x00FFD02F} 0x00FFD02F=\"Automatic Mode/Pause\" 0x00FF609F=\"Edge Cleaning\" 0x00FF40BF=\"Spot Cleaning\" 0x00FF708F=\"Back to Charging Base\" 0x00FFC837=\"Forward\" 0x00FFE01F=\"Left\" 0x00FFF00F=\"Right\" 0x00FFC03F=\"Back/Turn around\" Ventilation ~ IR Codes Prana 150 energy recovery ventilation ~ See device https://prana.org.ua/models/prana_150 (Ukrainian) Example received Code: MQT: tele/sonoffir/RESULT = {\"IrReceived\":{\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF00FF\"}} Example IRsend Command: IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF00FF\"} {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF00FF\"}=\"Power\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF807F\"}=\"Screen/LED Brightness\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF30CF\"}=\"Heat OFF\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF906F\"}=\"Heat ON\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF50AF\"}=\"Fan\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFA857\"}=\"Anti freeze\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFB04F\"}=\"Night Mode\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF708F\"}=\"Fan -\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF28D7\"}=\"Fan +\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF609F\"}=\"Night Mode Fan -\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF10EF\"}=\"Night Mode Fan +\" Christmas candle - Weihnachtsbeleuchtung ~ Krinner Lumix IR Remote ~ Remote control has two buttons and three channels. Button 1 is to switch on Button 0 is to switch off Double click on button 1 is flicker mode No usable protocol found yet, but raw mode does it. off channel A irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000, 400,1000, 400,1000, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000, 400,1000, 400,1000, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000, 400,1000, 400,1000, 400,2000,5600 on channel A irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,2000,5600 flicker channel A irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000, 400,1100,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000, 400,1100,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000, 400,1100,1000, 400, 400,2000,5600 off channel B irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,1000, 400,1000, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,1000, 400,1000, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,1000, 400,1000, 400,2000,5600 on channel B irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400,1000, 400,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400,1000, 400,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400,1000, 400,1000, 400, 400,2000,5600 flicker channel B irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,1100,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,1100,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,1100,1000, 400, 400,2000,5600 off channel C irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400, 400,1000, 400,1000, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400, 400,1000, 400,1000, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400, 400,1000, 400,1000, 400,2000,5600 on channel C irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,2000,5600 flicker channel C irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400, 400,1100,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400, 400,1100,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400, 400,1100,1000, 400, 400,2000,5600","title":"Codes for IR Remotes (for YTF IR Bridge)"},{"location":"Codes-for-IR-Remotes-%28for-YTF-IR-Bridge%29/#tvs","text":"","title":"TV's"},{"location":"Codes-for-IR-Remotes-%28for-YTF-IR-Bridge%29/#ir-codes-tv-panasonic-tx65fxw784","text":"Example received Code: tele/sonoffIRBridge_1/RESULT = {\"IrReceived\":{\"Protocol\":\"PANASONIC\",\"Bits\":48,\"Data\":\"0x100BCBD\"}} Example IRsend Command: IRsend {\"Protocol\":\"PANASONIC\",\"Bits\":48,\"Data\":0x100BCBD} 0x40040100BCBD=\"ON/OFF\" 0x400401004C4D=\"Mute\" 0x400401000405=\"Vol+\" 0x400401008485=\"Vol-\" 0x400401002C2D=\"P+\" 0x40040100ACAD=\"P-\" 0x400401007273=\"Left\" 0x40040100F2F3=\"Right\" 0x400401005253=\"Up\" 0x40040100D2D3=\"Down\" 0x400401009293=\"OK\" 0x400401004A4B=\"Menu\" 0x400401000E0F=\"Red\" 0x400401004E4F=\"Yellow\" 0x400401008E8F=\"Green\" 0x40040100CECF=\"Blue\" 0x40040100ECED=\"Last View\" 0x400401206D4C=\"My App\" 0x400401904FDE=\"Netflix\" 0x40040190F160=\"Apps\" 0x400401900392=\"Play\" 0x400401908312=\"Pause\" 0x4004019043D2=\"Stop\" 0x40040190C352=\"Forward\" 0x4004019023B2=\"Back\" 0x400401000809=\"Key 1\" 0x400401008889=\"Key 2\" 0x400401004849=\"Key 3\" 0x40040100C8C9=\"Key 4\" 0x400401002829=\"Key 5\" 0x40040100A8A9=\"Key 6\" 0x400401006869=\"Key 7\" 0x40040100E8E9=\"Key 8\" 0x400401001819=\"Key 9\" 0x400401009899=\"Key 0\" 0x40040190BB2A=\"Title forward\" 0x400401903BAA=\"Title back\" 0x40040190A332=\"Record\" 0x40040190E170=\"Guide\" 0x40040100CBCA=\"Exit\" 0x400401002B2A=\"Back\" 0x40040190E574=\"Option\" 0x400401009C9D=\"Info\" 0x400401400C4D=\"TV\" 0x40040100A0A1=\"AV\" 0x40040180C041=\"Text\" 0x40040180A021=\"STTL\" 0x400401000A0B=\"Picture\" 0x400401003534=\"Help\"","title":"IR Codes TV Panasonic TX65FXW784"},{"location":"Codes-for-IR-Remotes-%28for-YTF-IR-Bridge%29/#ir-remote-codes-sony-kdl-ex540","text":"Common buttons should work across multiple models Input {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xA50\"} Power On {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x750\"} Power Off {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xF50\"} Power Toggle {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xA90\"} Vol + {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x490\"} Vol - {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xC90\"} Mute {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x290\"} Ch + {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x090\"} Ch - {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x890\"} Theatre Mode {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x03EE\"} Play/Pause {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x2CE9\"} Stop {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x0CE9\"} Rew {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x6CE9\"} Fwd {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x1CE9\"} Sync Menu {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x0D58\"} Prev {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x1EE9\"} Next {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x5EE9\"} i-Manual {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x6F58\"} Scene {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x0F58\"} Aspect {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x5E25\"} Digital/Analog {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x58EE\"} PIP {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x7725\"} Internet Video {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x4F58\"} Favourite {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x37EE\"} Guide {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x6D25\"} Info {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x5D0\"} Return {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x62E9\"} Options {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x36E9\"} Home {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x070\"} Up {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x2F0\"} Down {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xAF0\"} Left {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x2D0\"} Right {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xCD0\"} Enter {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xA70\"} Red {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x52E9\"} Green {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x32E9\"} Yellow {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x72E9\"} Blue {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x12E9\"} 1 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x010\"} 2 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x810\"} 3 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x410\"} 4 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xC10\"} 5 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x210\"} 6 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xA10\"} 7 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x610\"} 8 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xE10\"} 9 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x110\"} Text {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xFD0\"} 0 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x110\"} Subtitles {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x0AE9\"} Audio Track {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xE90\"} HDMI 1 {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x2D58\"} HDMI 2 {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x6D58\"} HDMI 3 {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x1D58\"} HDMI 4 {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x5D58\"} Video 1 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x030\"} Video 2 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x830\"} Video 3/Component 1 {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x430\"} PC {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xC30\"} Digital TV {\"Protocol\":\"SONY\",\"Bits\":15,\"Data\":\"0x25EE\"}","title":"IR Remote Codes Sony KDL-EX540"},{"location":"Codes-for-IR-Remotes-%28for-YTF-IR-Bridge%29/#ir-codes-tv-lg-55uh8509","text":"Example received Code: tele/sonoffIRBridge_1/RESULT = {\"IrReceived\":{\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x20DF10EF\"}} Example IRsend Command: IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":0x20DF10EF} or with mosquitto_pub: mosquitto_pub -q 2 -t cmnd/sonoffIRBridge_1/IRSend -m '{\"protocol\": \"NEC\",\"bits\": 32, \"data\": 0x20DF10EF}' 0x20DF10EF=\"ON/OFF\" 0x20DF0FF0=\"TV\" 0x20DF9E61=\"Ratio\" 0x20DFD02F=\"Input\" 0x20DFA956=\"Energy\" 0x20DF8877=\"Key 1\" 0x20DF48B7=\"Key 2\" 0x20DFC837=\"Key 3\" 0x20DF28D7=\"Key 4\" 0x20DFA857=\"Key 5\" 0x20DF6897=\"Key 6\" 0x20DFE817=\"Key 7\" 0x20DF18E7=\"Key 8\" 0x20DF9867=\"Key 9\" 0x20DFCA35=\"List\" 0x20DF08F7=\"Key 0\" 0x20DF58A7=\"Q.View\" 0x20DF40BF=\"Vol+\" 0x20DFC03F=\"Vol-\" 0x20DFCE31=\"Vol-\" 0x20DF7887=\"Fav\" 0x20DF3BC4=\"3D\" 0x20DF906F=\"Mute\" 0x20DF00FF=\"P+\" 0x20DF807F=\"P-\" 0x20DFC23D=\"Settings\" 0x20DF55AA=\"Info\" 0x20DFA25D=\"Q.Menu\" 0x20DFE01F=\"Left\" 0x20DF609F=\"Right\" 0x20DF02FD=\"Up\" 0x20DF827D=\"Down\" 0x20DF22DD=\"OK\" 0x20DF14EB=\"Back\" 0x20DFD52A=\"Guide\" 0x20DFDA25=\"Exit\" 0x20DF4EB1=\"Red\" 0x20DF8E71=\"Green\" 0x20DFC639=\"Yellow\" 0x20DF8679=\"Blue\" 0x20DF04FB=\"Text\" 0x20DF847B=\"T.Opt\" 0x20DF9C63=\"Subtitle\" 0x20DF8D72=\"Stop\" 0x20DF0DF2=\"Play\" 0x20DF5DA2=\"Pause\" 0x20DFF10E=\"Backward\" 0x20DF718E=\"Forward\" 0x20DF7E81=\"Simplink\" 0x20DF8976=\"AD\" 0x20DF0CF3=\"AV Mode\" 0x20DF3EC1=\"Live TV\" 0x20DF42BD=\"Live TV\" 0x20DF35CA=\"Status\" 0x20DF50AF=\"Audio Language\" 0x20DF57A8=\"Shortmenu\" 0x20DF5AA5=\"AV\" 0x20DF5EA1=\"online manual\" 0x20DF619E=\"Volume to 50\" 0x20DF21DE=\"Volume to 80\" 0x20DFE11E=\"Volume to 100\" 0x20DF6B94=\"Radio/TV\" 0x20DF708F=\"doze function\" 0x20DFA35C=\"Display off\" 0x20DFD728=\"Standby\" 0x20DF23DC=\"Power on\" 0x20DFB44B=\"Settings of remote\" 0x20DF956A=\"Program guide\" 0x20DFF00F=\"Radio/TV\" 0x20DF738C=\"HDMI 1\" 0x20DF33CC=\"HDMI 2\" 0x20DF9768=\"HDMI 3\" 0x20DFFD02=\"Component\" 0x20DFF50A=\"Live Zoom\" 0x20DFF20D=\"Input info\" 0x20DFB24D=\"Picture mode\" 0x20DF09F6=\"Recordings\" 0x20DF4AB5=\"Audio mode\" 0x20DF7B84=\"Register magic remote\" 0x20DFAE51=\"directly register magic remote\" 0x20DF1CE3=\"Subtitles\" 0x20DFCC33=\"Presentation in shop\" 0x20DFBD42=\"Start recording\" 0x20DFAD52=\"LG TV Plus\" 0x20DFDD22=\"Sports mode\" 0x20DF1EE1=\"Search\" 0x20DFDF20=\"Warning: instart\" 0x20DF7F80=\"Warning: Poweronly\" 0x20DFFF00=\"Warning: Easy adjust\" 0x20DF5FA0=\"Warning: instop\" 0x20DF5FA0=\"Enter Password\" 0x20DF3FC0=\"Warning: Reset to factory\"","title":"IR Codes TV LG 55UH8509"},{"location":"Codes-for-IR-Remotes-%28for-YTF-IR-Bridge%29/#set-top-boxes","text":"","title":"Set-top Boxes"},{"location":"Codes-for-IR-Remotes-%28for-YTF-IR-Bridge%29/#ir-codes-for-vu-duo2","text":"Example received Code: tele/sonoffIRBridge_1/RESULT = {\"IrReceived\":{\"Protocol\":\"RC6\",\"Bits\":36,\"Data\":\"0x8052900C\"} Example IRsend Command: IRsend {\"Protocol\":\"RC6\",\"Bits\":36,\"Data\":0x8052900C} 0xC8052900C=\"ON/OFF\" 0xC8052100D=\"Mute\" 0xC80529010=\"Vol+\" 0xC80521011=\"Vol-\" 0xC80529020=\"P+\" 0xC80529021=\"P+\" 0xC8052105A=\"Left\" 0xC8052905B=\"Right\" 0xC80529058=\"Up\" 0xC80529059=\"Down\" 0xC8052905C=\"OK\" 0xC80529054=\"Men\" 0xC8052906D=\"Red\" 0xC8052906F=\"Yellow\" 0xC8052906E=\"Green\" 0xC80529070=\"Blue\" 0xC8052902D=\"Play/Pause\" 0xC80529031=\"Stop\" 0xC80529028=\"Forward\" 0xC80529029=\"Back\" 0xC80529001=\"Key 1\" 0xC80529002=\"Key 2\" 0xC80529003=\"Key 3\" 0xC80529004=\"Key 4\" 0xC80529005=\"Key 5\" 0xC80529006=\"Key 6\" 0xC80529007=\"Key 7\" 0xC80529008=\"Key 8\" 0xC80529009=\"Key 9\" 0xC80529000=\"Key 0\" 0xC805290BB=\"Key <\" 0xC805290BC=\"Key >\" 0xC80529037=\"Record\" 0xC805290CC=\"EPG\" 0xC80529055=\"Exit\" 0xC805290E5=\"Audio\" 0xC805290F2=\"Radio\" 0xC805290E4=\"TV\" 0xC80521049=\"Context\" 0xC80529081=\"Help\"","title":"IR Codes for VU+ Duo2"},{"location":"Codes-for-IR-Remotes-%28for-YTF-IR-Bridge%29/#ir-remote-codes-appletv-gen4","text":"Up {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x77E15080\"} Down {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x77E13080\"} Left {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x77E19080\"} Right {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x77E16080\"} Ok {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x77E13A80\"} Menu {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x77E1C080\"} Play/Pause {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x77E1FA80\"} Home {\"Protocol\":\"NEC\",\"Bits\":0,\"Data\":\"0xFFFFFFFFFFFFFFFF\"}","title":"IR Remote Codes AppleTV Gen4"},{"location":"Codes-for-IR-Remotes-%28for-YTF-IR-Bridge%29/#ir-remote-codes-humax-hms-1000t-dvb-t2-dvr-pal-4-tune","text":"Power {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000800FF\"} TV Apps {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008D22D\"} Text {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00087689\"} Wide {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008728D\"} Play {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000816E9\"} Pause {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000846B9\"} Rew {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008A659\"} Fwd {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000826D9\"} Stop {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008C639\"} Record {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00088679\"} Search {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008E21D\"} Plus {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000842BD\"} Exit {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00086897\"} Back {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008827D\"} Up {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00088877\"} Down {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008A857\"} Left {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000848B7\"} Right {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000828D7\"} Enter {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008C837\"} Vol + {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008F807\"} Vol - {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000802FD\"} Mute {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000818E7\"} Home {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008708F\"} Guide {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008D827\"} Ch + {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000808F7\"} Ch - {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008F00F\"} Red {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000838C7\"} Green {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008B847\"} Yellow {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000858A7\"} Blue {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00087887\"} 1 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008C03F\"} 2 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000820DF\"} 3 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008A05F\"} 4 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008609F\"} 5 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008E01F\"} 6 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000810EF\"} 7 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008906F\"} 8 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000850AF\"} 9 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008D02F\"} 0 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x000830CF\"} TV/Radio {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x0008B04F\"}","title":"IR Remote Codes Humax HMS-1000T DVB-T2 DVR PAL 4-Tune"},{"location":"Codes-for-IR-Remotes-%28for-YTF-IR-Bridge%29/#ir-remote-codes-fetchtv-minihybroad-h626t","text":"Power Toggle {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662BA45\"} Keyboard Select {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26624CB3\"} Ch + {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26627B84\"} Ch - {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662DB24\"} TV Guide {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x266207F8\"} Red {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662738C\"} Green {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662936C\"} Yellow {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662E31C\"} Blue {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x266213EC\"} Info {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26628B74\"} Search {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26622CD3\"} Apps {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662CC33\"} Menu {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26629B64\"} Up {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26629B64\"} Down {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x266223DC\"} Left {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662837C\"} Right {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662C33C\"} Enter {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26621CE3\"} Back {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662AB54\"} Exit {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x266227D8\"} Rew {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662BB44\"} Play/Pause {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26625BA4\"} Fwd {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26625BA4\"} Stop {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x2662B34C\"} Record {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x26624BB4\"}","title":"IR Remote Codes FetchTV Mini(Hybroad H626T)"},{"location":"Codes-for-IR-Remotes-%28for-YTF-IR-Bridge%29/#smart-reveiver-vxcx","text":"button code on/off {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF30CF\",\"DataLSB\":\"0x00FF0CF3\",\"Repeat\":0} mute {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFB04F\",\"DataLSB\":\"0x00FF0DF2\",\"Repeat\":0} FORMAT {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF1CE3\",\"DataLSB\":\"0x00FF38C7\",\"Repeat\":0} 16:9 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFC13E\",\"DataLSB\":\"0x00FF837C\",\"Repeat\":0} AUDIO {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFFA05\",\"DataLSB\":\"0x00FF5FA0\",\"Repeat\":0} 1 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF807F\",\"DataLSB\":\"0x00FF01FE\",\"Repeat\":0} 2 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF40BF\",\"DataLSB\":\"0x00FF02FD\",\"Repeat\":0} 3 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFC03F\",\"DataLSB\":\"0x00FF03FC\",\"Repeat\":0} 4 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF20DF\",\"DataLSB\":\"0x00FF04FB\",\"Repeat\":0} 5 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFA05F\",\"DataLSB\":\"0x00FF05FA\",\"Repeat\":0} 6 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF609F\",\"DataLSB\":\"0x00FF06F9\",\"Repeat\":0} 7 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFE01F\",\"DataLSB\":\"0x00FF07F8\",\"Repeat\":0} 8 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF10EF\",\"DataLSB\":\"0x00FF08F7\",\"Repeat\":0} 9 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF906F\",\"DataLSB\":\"0x00FF09F6\",\"Repeat\":0} TV/R {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFA25D\",\"DataLSB\":\"0x00FF45BA\",\"Repeat\":0} 0 {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF00FF\",\"DataLSB\":\"0x00FF00FF\",\"Repeat\":0} RECALL {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF19E6\",\"DataLSB\":\"0x00FF9867\",\"Repeat\":0} volume + {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF5AA5\",\"DataLSB\":\"0x00FF5AA5\",\"Repeat\":0} volume - {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFDA25\",\"DataLSB\":\"0x00FF5BA4\",\"Repeat\":0} P - {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFBA45\",\"DataLSB\":\"0x00FF5DA2\",\"Repeat\":0} P + {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF3AC5\",\"DataLSB\":\"0x00FF5CA3\",\"Repeat\":0} red {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFEC13\",\"DataLSB\":\"0x00FF37C8\",\"Repeat\":0} green {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF6C93\",\"DataLSB\":\"0x00FF36C9\",\"Repeat\":0} yellow {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF4CB3\",\"DataLSB\":\"0x00FF32CD\",\"Repeat\":0} blue {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF2CD3\",\"DataLSB\":\"0x00FF34CB\",\"Repeat\":0} MENU {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF4AB5\",\"DataLSB\":\"0x00FF52AD\",\"Repeat\":0} BACK {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF44BB\",\"DataLSB\":\"0x00FF22DD\",\"Repeat\":0} EXIT {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFB44B\",\"DataLSB\":\"0x00FF2DD2\",\"Repeat\":0} up {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF04FB\",\"DataLSB\":\"0x00FF20DF\",\"Repeat\":0} left {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF8877\",\"DataLSB\":\"0x00FF11EE\",\"Repeat\":0} OK {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFEA15\",\"DataLSB\":\"0x00FF57A8\",\"Repeat\":0} right {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF08F7\",\"DataLSB\":\"0x00FF10EF\",\"Repeat\":0} down {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF847B\",\"DataLSB\":\"0x00FF21DE\",\"Repeat\":0} INFO {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF34CB\",\"DataLSB\":\"0x00FF2CD3\",\"Repeat\":0} FAV {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF8679\",\"DataLSB\":\"0x00FF619E\",\"Repeat\":0} TXT {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF7A85\",\"DataLSB\":\"0x00FF5EA1\",\"Repeat\":0} EPG {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF06F9\",\"DataLSB\":\"0x00FF609F\",\"Repeat\":0} FR {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF8976\",\"DataLSB\":\"0x00FF916E\",\"Repeat\":0} REC {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF619E\",\"DataLSB\":\"0x00FF8679\",\"Repeat\":0} FF {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF29D6\",\"DataLSB\":\"0x00FF946B\",\"Repeat\":0} PREV {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF09F6\",\"DataLSB\":\"0x00FF906F\",\"Repeat\":0} Play/Pause {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFE916\",\"DataLSB\":\"0x00FF9768\",\"Repeat\":0} NEXT {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFC936\",\"DataLSB\":\"0x00FF936C\",\"Repeat\":0} (none left) {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF4BB4\",\"DataLSB\":\"0x00FFD22D\",\"Repeat\":0} STOP {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF718E\",\"DataLSB\":\"0x00FF8E71\",\"Repeat\":0} (none right) {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF8976\",\"DataLSB\":\"0x00FF916E\",\"Repeat\":0} USB {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFFB04\",\"DataLSB\":\"0x00FFDF20\",\"Repeat\":0} HELP {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF54AB\",\"DataLSB\":\"0x00FF2AD5\",\"Repeat\":0} DVD {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFDB24\",\"DataLSB\":\"0x00FFDB24\",\"Repeat\":0}","title":"Smart Reveiver VX/CX"},{"location":"Codes-for-IR-Remotes-%28for-YTF-IR-Bridge%29/#bddvd-players","text":"","title":"BD/DVD players"},{"location":"Codes-for-IR-Remotes-%28for-YTF-IR-Bridge%29/#ir-remote-codes-sony-bd-s1500","text":"Common buttons should work across multiple models Eject {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x68B47\"} Power {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xA8B47\"} Red {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xE6B47\"} Green {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x16B47\"} Yellow {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x96B47\"} Bue {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x66B47\"} Top Menu {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x34B47\"} Popup/Menu {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x94B47\"} Return {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xC2B47\"} Options {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xFCB47\"} Home {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x42B47\"} Up {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x9CB47\"} Down {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x5CB47\"} Left {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xDCB47\"} Right {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x3CB47\"} Enter {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xBCB47\"} Favourites {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xBCB47\"} Netflix {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xD2B47\"} Play {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x58B47\"} Pause {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x98B47\"} Rew {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xD8B47\"} Fwd {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x38B47\"} Prev {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xEAB47\"} Next {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x6AB47\"} Stop {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x18B47\"} Subtitles {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0xC6B47\"} Audio Track {\"Protocol\":\"SONY\",\"Bits\":20,\"Data\":\"0x26B47\"} Vol + {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x490\"} Vol - {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0xC90\"} Mute {\"Protocol\":\"SONY\",\"Bits\":12,\"Data\":\"0x290\"}","title":"IR Remote Codes Sony BD-S1500"},{"location":"Codes-for-IR-Remotes-%28for-YTF-IR-Bridge%29/#projectors","text":"","title":"Projectors"},{"location":"Codes-for-IR-Remotes-%28for-YTF-IR-Bridge%29/#ir-remote-codes-acer-k132","text":"IR Remote Codes for Acer K132 projector (and possibly other models using a remote with Model No. M1820) ON/OFF {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8E11E\"} * Freeze {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8718E\"} * Hide {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8F10E\"} * Ratio {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C806F9\"} * Zoom {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8D12E\"} * Mode {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C801FE\"} * Source {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C831CE\"} * Back {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C832CD\"} * Up {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C841BE\"} * Down {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8A15E\"} * Left {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8C13E\"} * Right {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8817E\"} * Enter {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8B24D\"} * Menu {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C821DE\"} * Vol+ {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8C639\"} * Vol- {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C826D9\"} * Sound {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C8AD52\"} * Mute {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x10C88679\"}","title":"IR Remote Codes Acer K132"},{"location":"Codes-for-IR-Remotes-%28for-YTF-IR-Bridge%29/#soundbars","text":"","title":"Soundbars"},{"location":"Codes-for-IR-Remotes-%28for-YTF-IR-Bridge%29/#ir-codes-soundbar-panasonic-scall70t","text":"Example received Code: tele/sonoffIRBridge_1/RESULT = {\"IrReceived\":{\"Protocol\":\"PANASONIC\",\"Bits\":48,\"Data\":\"0x40040500BCB9\"}} Example IRsend Command: IRsend {\"Protocol\":\"PANASONIC\",\"Bits\":48,\"Data\":0x40040500BCB9} 0x40040500BCB9=\"ON/OFF\" 0x400405004C49=\"Mute\" 0x400405000401=\"Vol+\" 0x400405008481=\"Vol-\" 0x40040538DFE2=\"OK\" 0x400405383F02=\"Up\" 0x40040538BF82=\"Down\" 0x40040538AD90=\"Setup\" 0x400405280D20=\"Sound\" 0x400405380538=\"Bluetooth\" 0x400405006164=\"Input\"","title":"IR Codes Soundbar Panasonic SCALL70T"},{"location":"Codes-for-IR-Remotes-%28for-YTF-IR-Bridge%29/#vacuum-cleaners","text":"","title":"Vacuum Cleaners"},{"location":"Codes-for-IR-Remotes-%28for-YTF-IR-Bridge%29/#ir-codes-vacuum-cleaner-ecovacs-deebot-slim2","text":"Example received Code: tele/sonoffIRBridge_1/RESULT = {\"IrReceived\":{\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFD02F\"}} Example IRsend Command: IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":0x00FFD02F} 0x00FFD02F=\"Automatic Mode/Pause\" 0x00FF609F=\"Edge Cleaning\" 0x00FF40BF=\"Spot Cleaning\" 0x00FF708F=\"Back to Charging Base\" 0x00FFC837=\"Forward\" 0x00FFE01F=\"Left\" 0x00FFF00F=\"Right\" 0x00FFC03F=\"Back/Turn around\"","title":"IR Codes Vacuum Cleaner Ecovacs Deebot Slim2"},{"location":"Codes-for-IR-Remotes-%28for-YTF-IR-Bridge%29/#ventilation","text":"","title":"Ventilation"},{"location":"Codes-for-IR-Remotes-%28for-YTF-IR-Bridge%29/#ir-codes-prana-150-energy-recovery-ventilation","text":"See device https://prana.org.ua/models/prana_150 (Ukrainian) Example received Code: MQT: tele/sonoffir/RESULT = {\"IrReceived\":{\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF00FF\"}} Example IRsend Command: IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF00FF\"} {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF00FF\"}=\"Power\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF807F\"}=\"Screen/LED Brightness\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF30CF\"}=\"Heat OFF\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF906F\"}=\"Heat ON\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF50AF\"}=\"Fan\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFA857\"}=\"Anti freeze\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FFB04F\"}=\"Night Mode\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF708F\"}=\"Fan -\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF28D7\"}=\"Fan +\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF609F\"}=\"Night Mode Fan -\" {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF10EF\"}=\"Night Mode Fan +\"","title":"IR Codes Prana 150 energy recovery ventilation"},{"location":"Codes-for-IR-Remotes-%28for-YTF-IR-Bridge%29/#christmas-candle-weihnachtsbeleuchtung","text":"","title":"Christmas candle - Weihnachtsbeleuchtung"},{"location":"Codes-for-IR-Remotes-%28for-YTF-IR-Bridge%29/#krinner-lumix-ir-remote","text":"Remote control has two buttons and three channels. Button 1 is to switch on Button 0 is to switch off Double click on button 1 is flicker mode No usable protocol found yet, but raw mode does it. off channel A irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000, 400,1000, 400,1000, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000, 400,1000, 400,1000, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000, 400,1000, 400,1000, 400,2000,5600 on channel A irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,2000,5600 flicker channel A irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000, 400,1100,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000, 400,1100,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400, 400,1000, 400,1100,1000, 400, 400,2000,5600 off channel B irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,1000, 400,1000, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,1000, 400,1000, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,1000, 400,1000, 400,2000,5600 on channel B irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400,1000, 400,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400,1000, 400,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400,1000, 400,1000, 400, 400,2000,5600 flicker channel B irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,1100,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,1100,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,1100,1000, 400, 400,2000,5600 off channel C irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400, 400,1000, 400,1000, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400, 400,1000, 400,1000, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400, 400,1000, 400,1000, 400,2000,5600 on channel C irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400,1000, 400,1000, 400, 400,2000,5600 flicker channel C irsend 0,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400, 400,1100,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400, 400,1100,1000, 400, 400,2000,5600,2000,1000, 400,1000, 400, 400,1000,1000, 400, 400,1000,1000, 400, 400,1100,1000, 400, 400,2000,5600","title":"Krinner Lumix IR Remote"},{"location":"Commands/","text":"Tasmota provides a powerful control interface using commands Commands can be issued using MQTT , web requests , webUI console and serial How to use ~ Every command used without a parameter (payload) returns the current setting . Power returns the status of first defined power output (usually Relay1)\" Instead of 0 you can use off or false and instead of 1 you can use on or true . Power ON turns first defined power output (usually Relay1) on Power1 1 also turns first defined power output (usually Relay1) on Power1 True also turns first defined power output (usually Relay1) on Replace <x> in a command with the appropriate index number. Leave it empty to use the first available. Power1 and Power both control first defined power output (usually Relay1) In commands with x..y value parameters use a number from x to y range. When a command mentions resetting to \"firmware default\" it means the setting will revert to the one in the flashed binary file. If you used user_config_override.h at compile time it will revert to those. Note Beside results initiated by a command (synchronous) you can get asynchronous results initiated by rule trigger, telemetry event, commands from other source or changed device values. Simply put, other messages may precede messages published as a result of your commands. Example A tele/%topic%/STATUS message (sent every 300 seconds by default) may appear exactly after you issue Power off command and before you receive stat/%topic%/RESULT = {\"POWER\":\"OFF\"} message. with MQTT ~ To send commands and view responses you'll need an MQTT client . Commands over MQTT are issued by using cmnd/%topic%/<command> <parameter> where %topic% is the topic of the device you're sending the command to. If there is no <parameter> (an empty MQTT message/payload), a query is sent for current status of the <command> . See MQTT article to find out more. with Web Requests ~ Commands can be executed via web (HTTP) requests, for example: http://<ip>/cm?cmnd=Power%20TOGGLE http://<ip>/cm?cmnd=Power%20On http://<ip>/cm?cmnd=Power%20off http://<ip>/cm?user=admin&password=joker&cmnd=Power%20Toggle Note Any spaces or special characters must be replaced with their ASCII hex codes . You must precede each hex code with % . Most used ones are: space = %20 and ; = %3B If you have set a password for web user interface access, this must be included (in plaintext) in the URL of the HTTP request, like so: http://<ip>/cm?&user=<username>&password=<password>&cmnd=Power%20On in Console in the Web UI ~ Console menu in the web UI is a convenient place to send commands and it behaves similar to a terminal connection via serial bridge. over Serial Bridge ~ If you flashed the device via serial method you can connect to it with a terminal application (e.g. Termite or Arduino IDE Serial Monitor) to issue commands and follow responses. This is a practical way to do a Backlog setup of your new device. Serial interface is set to 115200 bps except for devices that require a different baudrate the Power of Backlog ~ Backlog command allows executing up to 30 consecutive commands with a single command line. Each command is separated by a semicolon (\";\"). Backlog is a useful feature to avoid numerous restarts when setting up a new device. You can use it to: Set up both Wi-Fi AP's Backlog SSID1 < myssid > ; Password1 < mypassword > ; SSID2 < myssid2 > ; Password2 < mypassword2 > Configure MQTT broker address, MQTT credentials, device topic and activate a few custom options Backlog MqttHost < yourhost > ; MqttUser < user > ; MqttPassword < password > ; Topic < customtopic > ; SetOption53 1 ; PowerRetain on For specific power control, using backlog like a script Backlog Status 1 ; Power2 on ; Delay 20 ; Power2 off ; Status 4 When using web requests (You have to encode \"space\" as '%20' and \";\" as '%3B') http://<ip>/cm?user=admin&password=joker&cmnd=Backlog%20Power%20Toggle%3BPower1%20ff A Backlog command without an argument clears an possible existing Backlog queue. Example in case of command Backlog Power1 OFF; Delay 600; Power1 ON the usage of an additional Backlog command without any argument within the delay time of 1 minute will delete the whole queue Power1 OFF; Delay 600; Power1 ON . Therefore Power1 ON command will not be executed and the power would remain off. Commands List ~ Warning If you're using Tasmota versions earlier current release some of the commands might not work. Availability of some features and their associated commands depend on the firmware build. Please consult the builds table for a reference of which features are available for each firmware variant. Control ~ Command Parameters Backlog List of commands to be executed in sequence separated by ; See Using Backlog for examples. BlinkCount Number of relay toggles ( blinks ) (does not control the status LED) 0 = blink many times before restoring power state 1..32000 = set number of blinks (default = 10 ) BlinkTime 2..3600 set duration, in 0.1 second increments, to blink aka toggle Power (does not control the status LED) ButtonDebounce User control over button debounce timing 40..1000 = set button debounce time in milliseconds (default = 50 ) Buzzer 0 = stop active buzzer cycle <count>,<beep>,<silence>,<tune> = read more... 2,3 = Beep twice with 300 milliseconds duration and 100 milliseconds pause 2,3,4 = Beep twice with 300 milliseconds duration and 400 milliseconds pause 1,2,3,0xF54 (0000 0000 0000 0000 0000 1111 0101 0100). Each 1 bit beeps for 200 milliseconds and each bounded 0 bit pauses for 300 milliseconds -1 = infinite mode -2 = follow LED mode DevGroupShare Set incoming and outgoing shared item mask. <in>,<out> (default = 0xFFFFFFFF,0xFFFFFFFF) 1 = Power, 2 = Light brightness, 4 = Light fade/speed, 8 = Light scheme, 16 = Light color, 32 = Minimum brightness FanSpeed Fan speed control (iFan02/iFan03 only) 0 = turn fan OFF 1..3 = set fan speed + = increase fan speed - = decrease fan speed Interlock Relay interlock mode and group selection. 0 = disable relay interlock for all relays (i.e., each relay is self-locking) (default) 1 = set interlock mode for selected relays Add up to 8 relays in 1 to 4 interlock groups, each separated by a space. For example 1,2 3,4 = Group Relay1 and Relay2 in group 1 and Relay3 and Relay4 in group 2 ( note the space between the two groups ) 1,2,3 = group Relay1, Relay2 and Relay3 in a single interlock group 1 3 2,4 = Relay1 is in group 1, Relay3 in group 2, Relay2 and Relay4 in group 3 LedMask Set a bitmask specifiying which relays control the LED indicator. Read more... <bitmask> = bitwise value representing each relay. Values may be entered as either hexadecimal or decimal values (e.g., 0xFFFF = 65535). 0xFFFF (= 1111 1111 1111 1111) All relays control the power LED (default) LedState must be enabled (i.e., != 0 ) in order for LedMask to take effect. LedPower LED power state as on or off 0 = turn LED OFF and set LedState 0 1 = turn LED ON and set LedState 8 2 = toggle LED and set LedState 0 (Use Backlog LedPower 0; SetOption31 1 to disable LED even when Wi-Fi or MQTT is not connected) LedPower<x> LED<x> power state control. Enabled only when LedLink(i) is configured 0 = turn LED OFF and set LedState 0 1 = turn LED ON and set LedState 0 2 = toggle LED and set LedState 0 LedState Manage LED state 0 = disable use of LED as much as possible 1 = show power state on LED (LED on when power on) (default) (inverted for Sonoff Touch/T1) 2 = show MQTT subscriptions as a LED blink 3 = show power state and MQTT subscriptions as a LED blink 4 = show MQTT publications as a LED blink 5 = show power state and MQTT publications as a LED blink 6 = show all MQTT messages as a LED blink 7 = show power state and MQTT messages as a LED blink 8 = LED on when Wi-Fi and MQTT are connected. Cannot be issued directly and is only activated when LedPower is switched from 0 to 1 due to a software function Power0 Control the power state simultaneously for all power outputs on the device 0 / off = turn OFF 1 / on = turn ON 2 / toggle = if relay is ON switch to OFF and vice versa Power<x> Control the corresponding power state ( 1..8 ) (also restarts PulseTime)<x> 0 / off / false = turn OFF 1 / on / true = turn ON 2 / toggle = if power state is ON switch to OFF and vice versa 3 / blink = toggle power for BlinkCount times each BlinkTime duration (at the end of blink , power state is returned to pre-blink state) 4 / blinkoff = stop blink sequence and return power state to pre-blink state PowerOnState Control power state when the device is powered up . More information 0 / OFF = keep power(s) OFF after power up 1 / ON = turn power(s) ON after power up 2 / TOGGLE = toggle power(s) from last saved state 3 = switch power(s) to their last saved state (default) 4 = turn power(s) ON and disable further power control 5 = after a PulseTime period turn power(s) ON (acts as inverted PulseTime mode) PulseTime<x> Display the amount of PulseTime remaining on the corresponding Relay<x> <value> Set the duration to keep Relay<x> ON when Power<x> ON command is issued. After this amount of time, the power will be turned OFF . 0 / OFF = disable use of PulseTime for Relay<x> 1..111 = set PulseTime for Relay<x> in 0.1 second increments 112..64900 = set PulseTime for Relay<x>, offset by 100, in 1 second increments. Add 100 to desired interval in seconds, e.g., PulseTime 113 = 13 seconds and PulseTime 460 = 6 minutes (i.e., 360 seconds) SwitchDebounce User control over switch debounce timing 40..1000 = set switch debounce time in milliseconds (default = 50 ) SwitchMode<x> Switch mode 0 = toggle (default) 1 = follow (0 = off, 1 = on) 2 = inverted follow (0 = on, 1 = off) 3 = pushbutton (default 1, 0 = toggle) 4 = inverted pushbutton (default 0, 1 = toggle) 5 = pushbutton with hold (default 1, 0 = toggle, Hold = hold) 6 = inverted pushbutton with hold (default 0, 1 = toggle, hold = hold) 7 = pushbutton toggle (0 = toggle, 1 = toggle) 8 = multi change toggle (0 = toggle, 1 = toggle, 2x change = hold) 9 = multi change follow (0 = off, 1 = on, 2x change = hold) 10 = inverted multi change follow (0 = on, 1 = off, 2x change = hold) 11 = pushbutton with dimmer mode 12 = inverted pushbutton with dimmer mode 13 = pushon mode (1 = on, switch off using PulseTime ) 13 = inverted pushon mode (0 = on, switch off using PulseTime ) See also SetOption1 - Set button multipress mode SetOption11 - Swap pushbutton single and double press functionality SetOption13 - Allow immediate action on single button press SetOption26 - Use indexes even when only one relay is present SetOption31 - Disable Wi-Fi LED status blinking SetOption32 - Set hold interval before sending HOLD action SetOption40 - Stop detecting any input change on button GPIO SetOption67 - Enable/Disable Buzzer Management ~ Command Parameters Delay 2..3600 = set delay between two backlog commands with 0.1 second increment DeepSleepTime Time to enter deep sleep mode 0 = disable deep sleep mode (default) 10..86400 = set deep sleep mode time period in seconds Emulation 0 = disable emulation (default) 1 = enable Belkin WeMo emulation for Alexa 2 = enable Hue Bridge emulation for Alexa FriendlyName<x> 1 = Reset friendly name to firmware default <value> = set friendly name (32 char limit) Gpios Show list of available components by name and index 255 / All Show list of all components by name and index Gpio Show current component assignments of the Module's configurable GPIO 255 / All Show component assignments for all the devices available GPIO Gpio<x> For built-in Modules only. This command does not work for devices configured with a Template. <component> = assign a component to Gpio<x> I2Cscan Scan I 2 C bus and show addresses for found devices I2CDriver Enable / Disable I 2 C sensor drivers. Read more... LogHost 1 = reset syslog host to firmware default ( SYS_LOG_HOST ) <value> = set syslog host (32 chars max) LogPort 1 = reset syslog port to firmware default ( SYS_LOG_PORT ) 2..32766 = set syslog port Modules Show available modules by name and index Module Displays active module by name and index <x> = switch to Module<x> and restart 0 = switch to defined template and restart MqttLog 0 = disable logging via MQTT (default) 1 = show only error messages 2 = show error and info messages 3 = show error, info and debug messages 4 = show error, info and more debug messsages NtpServer<x> NTP server setup (x= 1..3 ) 0 = clear NtpServer<x> settings 1 = reset NtpServer<x> settings to firmware defaults <value> = set NtpServer<x> host or IP address (32 char limit) OtaUrl Display current OTA URL 1 = Reset OtaUrl to firmware default url = set address for OTA (100 char limit) Pwm<x> 0..1023 = set PWM value for channel PwmFrequency 1 = reset PWM frequency to 880Hz 100..4000 = set PWM frequency (100Hz to 4kHz) PwmRange 1 = reset maximum PWM range to 1023 255..1023 = set maximum PWM range Reset 1 = reset device settings to firmware defaults and restart 2 = erase flash, reset device settings to firmware defaults and restart 3 = erase System Parameter Area in flash (Wi-Fi calibration and related data) and restart 4 = reset device settings to firmware defaults but retain Wi-Fi credentials and restart 5 = erase all flash and reset parameters to firmware defaults but keep Wi-Fi settings and restart 6 = erase all flash and reset parameters to firmware defaults but keep Wi-Fi and MQTT settings and restart (Erase of flash can take a few seconds to complete and there is no output during the erase process on the serial or web console) 99 = reset device bootcount to zero Restart 1 = restart device with configuration saved to flash 99 = force restart device without configuration save For debug and testing stack trace dumps only: -1 = force an Exception (28) crash -2 = force a Soft WDT reset (after a freeze of 2 seconds) -3 = force an OS watchdog reset (after a freeze of 120 seconds, caution! ) SaveData 0 = save parameter changes only manually, e.g. with Restart 1 1 = save parameter changes every second (default) 2..3600 = save parameter changes every x second SerialLog Disable hardware serial bridge and 0 = disable serial logging 1 = show only error messages 2 = show error and info messages (default) 3 = show error, info and debug messages 4 = show error, info and more debug messages SerialLog will be disabled automatically 10 minutes after the device reboots. Sleep 0 = turn sleep off 1..250 = set sleep duration in milliseconds to enable energy saving (default = 50 ) State Display current device state and publish to %prefix%/%topic%/RESULT topic\u2003 \u00bb5.12.0 Status = show abbreviated status information 0 = show all status information (1 - 11) 1 = show device parameters information 2 = show firmware information 3 = show logging and telemetry information 4 = show memory information 5 = show network information 6 = show MQTT information 7 = show time information 8 = show connected sensor information 9 = show power thresholds (only on modules with power monitoring) 10 = same as Status 8 (retained for backwards compatibility) 11 = show information equal to TelePeriod state message 12 = in case of crash to dump the call stack saved in RT memory SysLog 0 = disable syslog logging (default) 1 = show only error messages 2 = show error and info messages 3 = show error, info and debug messages 4 = show error, info and more debug messages Template Show current Template 0 = create template from active module x = create template from a supported module 255 = merge current module and template settings into new template { ... } = store template in a JSON payload Does not activate the template. To activate use Module 0 . Time 0 = enable NTP (default) 1 = format JSON message timestamp in ISO format 2 = format JSON message timestamp in both ISO and Epoch format 3 = format JSON message timestamp in Epoch format <value> = disable NTP and set UTC time as epoch value if greater than 1451602800 (January 1, 2016) TimeSTD TimeDST Set policies for the beginning of daylight saving time (DST) and return back to standard time (STD)\u2003 \u00bb5.14.0 0 = reset parameters to firmware defaults H , W , M , D , h , T H = hemisphere ( 0 = northern hemisphere / 1 = southern hemisphere) W = week ( 0 = last week of month, 1..4 = first .. fourth) M = month ( 1..12 ) D = day of week ( 1..7 1 = sunday 7 = saturday) h = hour ( 0..23 ) T = timezone ( -780..780 ) (offset from UTC in MINUTES - 780min / 60min=13hrs) Example: TIMEDST 1,1,10,1,2,660 Timezone -13..+13 = set timezone offset from UTC in hours -13:00..+13:00 = set timezone offset from UTC in hours and minutes 99 = use timezone configured with TimeDST and TimeSTD TuyaMCU Used to map functions in TuyaMCU <fnId>,<dpId> = read more... <fnId>,0 = remove setting for fnId Upgrade 1 = download firmware from OtaUrl and restart <value> = download firmware from OtaUrl if \\<value> is higher than device version Upload 1 = download firmware from OtaUrl and restart <value> = download firmware from OtaUrl if \\<value> is higher than device version WebLog 0 = disable web logging 1 = show only error messages 2 = show error and info messages (default) 3 = show error, info and debug messages 4 = show error, info and more debug messages See also SetOption68 - PWM Channel control SetOption76 - DeepSleep disable bootcount incrementing Wi-Fi ~ Command Parameters AP 0 = switch to other Wi-Fi Access Point 1 = select Wi-Fi Access Point 1 2 = select Wi-Fi Access Point 2 CORS \" = disable CORS (Cross Origin Resource Sharing) (default) * = enable CORS for all locations value = Enable CORS for location. This needs to be complete url ex: http://tasui.shantur.com Hostname 1 = reset hostname to MQTT_TOPIC-<4digits> and restart <value> = set hostname (32 char limit) and restart. If hostname contains % it will be reset to the default instead. If using MQTT to issue this command, if it is used with the device GroupTopic , the command will not be executed. IPAddress<x> Set networking IP ( XXX.XXX.XXX.XXX ) addresses IPAddress1 = set device IP address 0.0.0.0 = use dynamic IP address (DHCP) XXX.XXX.XXX.XXX = set static IP address IPAddress2 = set gateway IP address IPAddress3 = set subnet mask IPAddress4 = set DNS server IP address follow IPAddress commands with restart 1 to apply changes Password<x> <x> = 1..2 <value> = set AP<x> Wi-Fi password and restart 1 = reset AP<x> Wi-Fi password to firmware default ( STA_PASS1 or STA_PASS2 ) and restart Passwords are limited to 64 characters. Do not use special characters or white spaces in the password . Note that Password and Password1 are equivalent commands. Ssid<x> <x> = 1..2 <value> = set AP<x> Wi-Fi SSID and restart 1 = reset AP<x> Wi-Fi SSID to firmware default ( STA_SSID1 or STA_SSID2 ) and restart SSID are limited to 32 characters. Do not use special characters or white spaces in the SSID WebColor<x> Configure Web GUI colors (x = 1..19 ) #RRGGBB = Set color for WebColor<x> 1 = Global text (Black) 2 = Global background (White) 3 = Form background (Greyish) 4 = Input text (Black) 5 = Input background (White) 6 = Console text (Black) 7 = Console background (White) 8 = Warning text (Red) 9 = Success text (Green) 10 = Button text (White) 11 = Button (Blueish) 12 = Button hovered over (Darker blueish) 13 = Restart/Reset/Delete button (Redish) 14 = Restart/Reset/Delete button hover (Darker reddish) 15 = Save button (Greenish) 16 = Save button hover (Darker greenish) 17 = Config timer tab text (White) 18 = Config timer tab background (Light grey) 19 = Module title and FriendlyName text (Whiteish) User themes WebPassword Show current web server password 0 = disable use of password for web UI 1 = reset password to firmware default ( WEB_PASSWORD ) <value> = set web UI password (32 char limit) for user WEB_USERNAME (Default WEB_USERNAME = admin ) WebRefresh Web page refresh 1000..10000 = set refresh time in milliseconds (default = 2345 ) WebSend Send a command to Tasmota host over http. If a command starts with a \\ it will be used as a link. [<host>:<port>,<user>:<password>] <command> <host> = hostname or IP address. <port> = port for the device if not the default 80 <user> = enter username of the device you're sending the command to <password> = enter password of the device you're sending the command to <command> = command and payload example: [<ip>] POWER1 ON sends http://<ip>/cm?cmnd=POWER1 ON WebSensor<x> Control display of sensor telemetry in the web UI 0 = Do not display sensor's telemetry 1 = Display sensor's telemetry ( default ) <x> = number corresponding to the sensor - listed in the sns section of the supported sensor spreadsheet <x> = 3 Energy telemetry Issue a Status 4 to obtain a list of sensor types enabled in the firmware loaded on the device. WebServer 0 = stop web server 1 = start web server in user mode 2 = start web server in admin mode WifiConfig 0 = disable Wi-Fi Manager and reboot (used with alternate AP) 2 = set Wi-Fi Manager as the current configuration tool and start Wi-Fi Manager (web server at 192.168.4.1) for 3 minutes, then reboot and try to connect Wi-Fi network 4 = disable Wi-Fi Manager but retry the other AP without rebooting 5 = disable Wi-Fi Manager and wait until that AP is available again without rebooting 6 = Wi-Fi parameters can only be entered via commands in the serial console 7 = set Wi-Fi Manager (web server at 192.168.4.1) as the current configuration tool restricted with the only option to reset settings. This setting is recommended for devices without an external control/reset button . \u2003 No longer supported 1 = set SmartConfig ( Android /iOS) as the current configuration tool, start SmartConfig for 3 minutes and reboot and try to connect to Wi-Fi 3 = set WPS as configuration tool, try WPS for 3 minutes and reboot and try to connect to Wi-Fi WifiPower set Wi-Fi transmit power level in decibel-milliwatts (dBm) (default = 17 ) See also SetOption55 - mDNS service control SetOption56 - Wi-Fi network scan to select strongest signal on restart SetOption57 - Wi-Fi network re-scan, alternate AP MQTT ~ Command Parameters ButtonRetain 0 = disable use of MQTT retain flag (default) 1 = enable MQTT retain flag on button press ButtonTopic <value> = set MQTT button topic (32 chars max) 0 = disable use of MQTT button topic 1 = set MQTT button topic to device %topic% 2 = reset MQTT button topic to firmware default ( MQTT_BUTTON_TOPIC ) (default = 0 ) If using MQTT to issue this command, if it is published to the device GroupTopic , the command will not be executed. FullTopic 1 = reset MQTT fulltopic to firmware default ( MQTT_FULLTOPIC ) and restart <value> = set MQTT fulltopic (100 chars max) and restart. Use of optional %prefix%, %topic%, %hostname%, and %id% substitution tokens is allowed. If using MQTT to issue this command, if it is published to the device GroupTopic , you must ensure uniqueness of the resulting fulltopic on each destination device by using one or more of these substitution tokens. GroupTopic<x> 1 = reset MQTT group <x> topic to firmware default ( MQTT_GRPTOPIC ) and restart <value> = set MQTT group <x> topic (32 chars max) and restart MqttClient 1 = reset MQTT client to firmware config ( MQTT_CLIENT_ID ) and restart <value> = set MQTT client (32 chars max) and restart. You can use the %06X substitution token to replace with last six characters of MAC address. If using MQTT to issue this command, if it is used with the device GroupTopic , the command will not be executed. MqttFingerprint TLS needs to be enabled in firmware for this command \u2003 \u00bb5.13.1 <value> = set current fingerprint as 20 space separated bytes (59 chars max) MqttHost 0 = clear MQTT host field and allow mDNS to find MQTT host 1 = reset MQTT host to firmware default ( MQTT_HOST ) and restart <value> = set MQTT host (32 chars max) and restart (do NOT use .local ) MqttPassword 0 = clear MQTT password 1 = reset MQTT password to firmware default ( MQTT_PASS ) and restart <value> = set MQTT password (32 chars max) and restart MqttPort 1 = reset MQTT port to firmware default ( MQTT_PORT ) and restart <value> = set MQTT port between 2 and 32766 and restart MqttRetry 10..32000 = set MQTT connection retry timer in seconds (default = 10 ) MqttUser 0 = clear MQTT user name 1 = reset MQTT user name to firmware default ( MQTT_USER ) and restart <value> = set MQTT user name (32 chars max) and restart PowerRetain MQTT power retain state 0 / off = disable MQTT power retain on status update (default) 1 / on = enable MQTT power retain on status update Prefix1 1 = reset MQTT command subscription prefix to firmware default ( SUB_PREFIX ) and restart <value> = set MQTT command subscription prefix (10 chars max) and restart Prefix2 1 = reset MQTT status prefix to firmware default ( PUB_PREFIX ) and restart <value> = set MQTT status prefix (10 chars max) and restart Prefix3 1 = Reset MQTT telemetry prefix to firmware default ( PUB_PREFIX2 ) and restart <value> = set MQTT telemetry prefix (10 chars max) and restart Publish <topic> <payload> = MQTT publish any topic and optional payload\u2003 \u00bb5.13.0 Publish2 <topic> <payload> = MQTT publish any topic and optional payload with retain flag SensorRetain 0 = disable use of sensor MQTT retain flag (default) 1 = enable MQTT retain flag on message tele/%topic%/SENSOR StateText1 <value> = set OFF state text (10 chars max) StateText2 <value> = set ON state text (10 chars max) StateText3 <value> = set TOGGLE state text (10 chars max) StateText4 <value> = set HOLD state text (10 chars max) SwitchRetain 0 = disable use of MQTT retain flag (default) 1 = enable MQTT retain flag on switch press Subscribe Subscribes to an MQTT topic and assigns an Event name to it. <eventName>, <mqttTopic> [, <key>] = Read more... = list all topics currently subscribed SwitchTopic <value> = set MQTT switch topic (32 chars max) 0 = disable use of MQTT switch topic 1 = set MQTT switch topic to device %topic% 2 = reset MQTT switch topic to firmware default ( MQTT_SWITCH_TOPIC ) (default = 0 ) Read more about this. If using MQTT to issue this command, if it is used with the device GroupTopic , the command will not be executed. TelePeriod 0 = disable telemetry messages 1 = reset telemetry period to firmware default ( TELE_PERIOD ) 10..3600 = set telemetry period in seconds (default = 300 ) Topic 1 = reset MQTT topic to firmware default ( MQTT_TOPIC ) and restart <value> = set MQTT topic (32 chars max) and ButtonTopic and restart. If using MQTT to issue this command, if it is used with the device GroupTopic , the command will not be executed. (Mqtt Topic can't be equal to Mqtt Client) Unsubscribe Unsubscribe from topics subsribed to with Subscribe = unsubscribe all topics <eventName> = unsubscribe from a specific MQTT topic See also SetOption3 - Disable//Enable MQTT SetOption4 - Return MQTT response as RESULT or %COMMAND% topic SetOption10 - Main topic change behavior Rules ~ Command Parameters Add<x> <value> = add value to Var<x> ( example ) CalcRes Current calculation resolution 0..7 = set number of decimal places to be used in Add , Sub , Mult and Scale Event Execute an event to trigger a rule as documented \u2003 \u00bb5.13.0 Mem<x> Manage up to 16 variables stored on flash (x = 1..16 ) Mem returns all current values. Mem<x> returns the variable's current value. <value> = store a string value in a variable \" = clear stored value in Mem<x> Mult<x> <value> = multiply value to Var<x> ( example ) Rule<x> Rules. Read more... 0 = disable Rule<x> 1 = enable Rule<x> 2 = toggle Rule<x> 4 = disable one-shot detection (perform commands as long as trigger is met) 5 = enable one-shot (e.g., sometimes used for slow changing sensors like temperature) detection 6 = toggle one-shot detection 8 = disable stop-on-error after exception restart 9 = enable stop-on-error after exception restart 10 = toggle stop-on-error after exception restart <value> = define Rule<x> +<value> = append to Rule<x> \" = clear Rule<x> RuleTimer<x> Up to eight timers to be used as countdown event (x = 1..8 )\u2003 \u00bb5.13.0 0..32766 = set countdown rule timer in seconds Scale<x> Scale value from a low and high limit to another low and high limits and save in Var<x> ( example ) v = value: the number to scale fl = fromLow: the lower bound of the value\u2019s current range fh = fromHigh: the upper bound of the value\u2019s current range tl = toLow: the lower bound of the value\u2019s target range th = toHigh: the upper bound of the value\u2019s target range Sub<x> <value> = subtract value to Var<x> ( example ) Var<x> Manage up to 16 variables stored in memory (x = 1..16 ) Var returns all current values. Var<x> returns the variable's current value. <string> = store a string value in a variable \" = clear stored value in Var<x> Timers ~ Command Parameters Latitude <value> = set latitude Longitude <value> = set longitude Timers Timers control 0 = disable all timers 1 = enable all timers 2 = toggle all timers Timer<x> Parameters for Timer<x> where x = 1..16 0 = clear parameters for Timer<x> 1..16 = copy Timer\\<y> parameters to Timer<x> { \"name\":value ; .. } = set all or individual parameters using JSON payload with names and values of data pairs from the table Information on sensors documented below is transmitted in the Tasmota telemetry message Sensors ~ Command Parameters AdcParam ADC0 analog input tuning parameters <sensor>, <param1>, <param2>, <param3>, <param4> <sensor> values: \u2003 2 = Temperature Steinhart-Hart thermistor equation parameters: <param1> = NTC Voltage bridge resistor in Ohms (default = 32000 ) <param2> = NTC Resistance in Ohms (default = 10000 ) <param3> = NTC Beta Coefficient (default = 3350 ) \u2003 3 = Light Lux equation parameters: <param1> = LDR Voltage bridge resistor in Ohms (default = 10000 ) <param2> = LDR Lux Scalar (default = 12518931 ) <param3> = LDR Lux Exponent (default = -1.4050 ) \u2003 6 = ADC linear range remapping parameters: <param1> = input range low value adcLow (default = 0 ) <param2> = input range high value adcHigh (default = 1023 ) <param3> = output range low value rangeLow (default = 0 ) <param4> = output range high value rangeHigh (default = 100 ) The range remapping perform the following calculation on the ADC value [0..1023] : Range = ((adcHigh - ADC) / (adcHigh - adcLow)) * (rangeLow - rangeHigh) + rangeHigh The calculation is performed in double resolution floating point but all 4 parameters as well as the range output are unsigned 16 bit integers. The calculation result must not exceed [0..65535]. Example to convert the ADC value on a D1-mini into millivolts (using the default resistor bridge of 220k/100k): AdcRange 6, 0, 1023, 0, 3200 Altitude -30000..30000 = altitude in meters AmpRes Current sensor resolution 0..3 = maximum number of decimal places Counter<x> 0 = reset Counter<x> 1..64900 = preset Counter<x> -1..-64900 = decrease Counter<x> +1..+64900 = increase Counter<x> In order to define and use a Counter, you must configure one of the free device GPIO as Counter<x> CounterDebounce 0 = turn off counter debounce 1..3200 = set counter debounce time in milliseconds CounterType<x> 0 = set Counter<x> as pulse Counter 1 = set Counter<x> as pulse Timer HumOffset -10.0..10.0 = Set calibraton offset value for reported humidity telemetry This setting affects all humidity sensors on the device. HumRes Humidity sensor resolution 0..3 = maximum number of decimal places PressRes Pressure sensor resolution 0..3 = maximum number of decimal places Sensor13 INA219 low voltage current sensor calibration mode Predefined modes to use with standard 0.1 ohm resistor: 0 = set INA219 calibration to max 32V and 2A 1 = set INA219 calibration to max 32V and 1A 2 = set INA219 calibration to max 16V and 0.4A 10 .. 255 : Define custom shunt resistor encoded as a decimal number RRM such that Rshunt = RR * 10^M milliohm Do not forget to choose a resistor adapted for the correct power dissipation and apply a 50% security margin ! Examples: 11 = 1 * 10^1 = 10 milliohm (Imax=32A => Pres=15W) 21 = 2 * 10^1 = 20 milliohm (Imax=16A => Pres=7W) 12 = 1 * 10^2 = 100 milliohm (default, Imax=3.2A => Pres=2W) 13 = 1 * 10^3 = 1000 milliohm = 1 ohm (Imax=0.320A => Pres=0,2W) Sensor15 Automatic Baseline Correction for MH-Z19B CO 2 sensor 0 = disabled 1 = enabled (default) 2 = disable and start manual calibration from 400 ppm of CO 2 9 = reset sensor to factory defaults 1000 = sets measurement range to 1000ppm CO 2 2000 = sets measurement range to 2000ppm CO 2 3000 = sets measurement range to 3000ppm CO 2 5000 = sets measurement range to 5000ppm CO 2 Sensor20 Nova Fitness SDS011 dust sensor. 1..255` = number of seconds before TelePeriod to poll the sensor Sensor27 APDS-9960 sensor commands 0 = enable light level and proximity sensor / disable gestures (default) 1 = enable gesture mode/ disable light level and proximity sensor 2 = enable gestures with half gain / disable light and proximity sensor 3..255 = Set ATIME register for different integration times Sensor29 MCP23008 / MCP23017 I 2 C GPIO Expander configuration. Read more... Reset<x> = reset all pins x = 1..6 1 = INPUT mode, no reporting, no pull-up 2 = INPUT mode, report on CHANGE, pull-up enabled 3 = INPUT mode, report on LOW, pull-up enabled 4 = INPUT mode, report on HIGH, pull-up enabled 5 = OUTPUT mode (if enabled by #define USE_MCP230xx_OUTPUT ) 6 = inverted OUTPUT mode (if enabled by #define USE_MCP230xx_OUTPUT ) pin,pinmode{,intpullup\\|outstate{,repmode}} Continue reading... Sensor34 HX711 load cell sensor calibration 1 = reset display to 0 2 = start calibration 2 <value> = set reference weight in grams and start calibration 3 = show reference weight in grams 3 <value> = set reference weight in grams 4 = show calibrated scale value 4 <value> = set calibrated scale value 5 = show max weight in gram 5 <value> = set max weight in grams 6 = show single item weight in grams 6 <value> = set single item weight in grams. Once the item weight is set, when items are added to the scale, the telemetry message will report Count as the number of items on the scale 7 = save current weight to be used as start weight on restart 8 0/1 \u2003 0 = disable JSON message on weight change over 4 grams \u2003 1 = enable JSON message on weight change (see below) 9 <value> = set minimum delta to trigger JSON message (see above). \u2003 0 = 4 grams (old default) \u2003 1..100 = set delta to 0-99 grams \u2003 101-255 = set delta to 110-1650 grams (10g increments) Sensor50 PAJ7620 gesture sensor 0 = sensor muted, no readings in Tasmota 1 = gesture mode 2 = proximity mode 3 = corner mode 4 = PIN mode 5 = cursor mode Sensor52 iBeacon driver with HM10 or HM17/HM16 1 and 2 = required only once to initialize the module u<x> = sets update interval in seconds (scan tags every \\<x> seconds) (default = 10) t<x> = set timeout interval in seconds (send RSSI=0 if tag is not detected after \\<x> seconds) (default = 30) d1 = enable debug mode (shows all serial traffic in console) d0 = disable debug mode_(default = 30)_ c = clears iBeacon list s AT+<command> = send native AT commands Sensor53 Smart Meter Interface r = reset the driver with a new descriptor specified with the Tasmota Scripting language. c<x> <value> = preset counter (x = 1..5 ) to value when the driver is set to counter mode d<x> = disable data decoding and dump meter (x = 1..5 ) data to the Console. This is used to decipher the meter's data format to define the variable encoding in the meter's descriptor. d0 = disable data dump mode and revert to decoding mode. Sensor54 INA226 Current Sensor 1 = rescan for devices and return the number of slaves found. 2 = save the configuration and restart 10 = return channel 1 shunt resistance and full scale current 11 <resistance> = set INA226 channel 1 shunt in ohms, floating point 12 <current> = set INA226 channel 1 full scale in amperes, floating point 20 = return channel 2 shunt resistance and full scale current 21 <resistance> = set INA226 channel 2 shunt in ohms, floating point 22 <current> = set INA226 channel 2 full scale in amperes, floating point 30 = return channel 1 shunt resistance and full scale current 31 <resistance> = set INA226 channel 1 shunt in ohms, floating point 32 <current> = set INA226 channel 1 full scale in amperes, floating point 40 = return channel 1 shunt resistance and full scale current 41 <resistance> = set INA226 channel 1 shunt in ohms, floating point 42 <current> = set INA226 channel 1 full scale in amperes, floating point Sensor60 GPS 0 = write to all available sectors, then restart and overwrite the older ones 1 = write to all available sectors, then restart and overwrite the older ones 2 = filter out horizontal drift noise 3 = turn off noise filter 4 = start recording, new data will be appended 5 = start new recording, old data will lost 6 = stop recording, download link will be visible in webUI 7 = send mqtt on new postion + TELE (consider to set TELE to a very high value) 8 = only TELE message 9 = start NTP server 10 = deactivate NTP server 11 = force update of Tasmota-system-UTC with every new GPS-time-message 12 = do not update of Tasmota-system-UTC with every new GPS-time-message 13 = set latitude and longitude in settings 14 = open virtual serial port over TCP, usable for u-center 15 = pause virtual serial port over TCP SpeedUnit TX20/TX23 anemometer speed unit 1 = m/s 2 = km/h 3 = kn 4 = mph 5 = ft/s 6 = yd/s TempRes Temperature sensor resolution 0..3 = maximum number of decimal places TempOffset -12.6..12.6 = Set calibraton offset value for reported temperature telemetry This setting affects all temperature sensors on the device. VoltRes Voltage sensor resolution 0..3 = maximum number of decimal places WattRes Power sensor resolution 0..3 = maximum number of decimal places WeightRes Load cell sensor resolution 0..3 = maximum number of decimal places See also SetOption8 - Show temperature in Celsius (default) or Fahrenheit SetOption18 - Set status of signal light paired with CO 2 sensor SetOption24 - Set pressure units Power Monitoring ~ Command Parameters AmpRes Current sensor resolution 0..3 = maximum number of decimal places CurrentCal 1100..32767 (default = 3500 ) Set calibration offset value for reported Current telemetry Allows finer calibration for HLW8012, HJL01, and BL0937 energy monitoring devices CurrentHigh 0 = disable current high threshold (default) <value> = set current high threshold value in milliamps CurrentLow 0 = disable current low threshold (default) <value> = set current low threshold value in milliamps CurrentSet <value> = calibrate current to target value in mA EnergyRes Energy sensor resolution 0..5 = maximum number of decimal places EnergyReset<x> 0..42500 (for 3 , Total, upper limit is 4250000 ) in watt-hours (Wh) x = 1..5 1 <value> = ((p)re)set values for Today 2 <value> = ((p)re)set values for Yesterday 3 <value> = ((p)re)set values for Total 4 <standard> {, <off-peak> } = ((p)re)set tariff period values for Totals 5 <standard> {, <off-peak> } = ((p)re)set tariff period values for Exported FreqRes Frequency sensor resolution 0..3 = maximum number of decimal places FrequencySet <value> = calibrate frequency to a target value in Hz MaxPower 0 = disable use maximum power monitoring <value> = set maximum allowed power in watts MaxPowerHold 1 = set default time to 10 seconds to stay over MaxPower before power off <value> = set time in seconds to stay over MaxPower before power off MaxPowerWindow 1 = set default time to 30 seconds to stay power off before re-applying power up to 5 times <value> = set time in seconds to stay power off before re-applying power up to 5 times ModuleAddress Set the address of a PZEM module 1..3 = the last octet of the PZEM-004T serial address <address> = the last octet of the slave address on MODBUS PZEM energy monitoring modules Prior to setting the module address, the PZEM must be connected to both RX and TX, and AC voltage. Connect one PZEM at a time and issue this command. Repeat for each PZEM to be connected for multi-phase monitoring. The command without an argument cannot be used to read the address of the connected PZEM. PowerCal 4000..32767 (default = 12530 ) Set calibration offset value for reported Power telemetry reading Allows finer calibration for HLW8012, HJL01, and BL0937 energy monitoring devices PowerDelta Set maximum delta for energy monitoring devices to report on active power load change while the power is ON. PowerDelta will not report when the power turns off.\u2003 \u00bb5.13.0 0 = disable reporting on power change 1..100 = set reporting on percentage power change to send an MQTT telemetry message 101..32000 = set reporting on absolute power change to send an MQTT telemetry message (offset by 100, e.g., 101 =1W, 207 =107W) PowerHigh 0 = disable power high threshold (default) <value> = set power high threshold value in watts to send an MQTT telemetry message PowerLow 0 = disable power low threshold (default) <value> = set power low threshold value in watts to send an MQTT telemetry message PowerSet <value> = calibrate power to a target value in watts\u2003 \u00bb5.12.0 Status 8 = show power usage 9 = show power thresholds Tariff<x> P1 Smart Meter tariff configuration x = 1, 2, 9 1 STD,DST Start times for off-peak tariff 2 STD,DST End times for off-peak tariff 9 0/1 \u2003 0 = use Start/End times also on weekends. \u2003 1 = use off-peak tariff all weekend. STD and DST may be specified as: \u2003 <hour> = 0..23 or \u2003 <time> = 00:00..23:59 or \u2003 <minutes> = 0..1439 (since midnight) If both Tariff1 STD and Tariff2 STD are equal, all tariffs are disabled. VoltageCal Set calibration offset value for reported Voltage telemetry reading 1000..32767 (default = 1950 ) Allows finer calibration for HLW8012, HJL01, and BL0937 energy monitoring devices VoltageHigh 0 = disable voltage high threshold (default) <value> = set voltage high threshold value in V VoltageLow 0 = disable voltage low threshold (default) <value> = set voltage low threshold value in V VoltageSet <value> = calibrate voltage to a target value in V\u2003 \u00bb5.12.0 VoltRes Voltage sensor resolution 0..3 = maximum number of decimal places WattRes Power sensor resolution 0..3 = maximum number of decimal places See Also SetOption21 - Energy monitoring when power is off SetOption33 - Configure power monitoring Max_Power_Retry count number SetOption39 - Control handling of invalid power measurements SetOption72 - Set reference used for total energy Light ~ Command Parameters Channel<x> 0..100 = set PWM channel dimmer value from 0 to 100%\u2003 \u00bb5.13.0 + = increase by 10 - = decrease by 10 When SetOption68 is set to 1 Channel<x> will follow Power<x> numbering with Relays first then PWM. Example : 2 Relays and 3 PWM: Relay1 = Power1 ; Relay2 = Power2 ; PWM1 = Power3 and Channel3 ; PWM2 = Power4 and Channel4 ; PWM3 = Power5 and Channel5 Color<x> x = 1..6 \u2003 1 = Set color \u2003 2 = Set color adjusted to current Dimmer value \u2003 3 = Set clock seconds hand color ( Scheme 5 only) \u2003 4 = Set clock minutes hand color ( Scheme 5 only) \u2003 5 = Set clock hour hand color ( Scheme 5 only) \u2003 6 = Set clock hour marker color <value> r,g,b = set color by decimal value ( 0..255 ) #CWWW = set hex color value for CT lights #RRGGBB = set hex color value for RGB lights #RRGGBBWW = set hex color value for RGBW lights #RRGGBBCWWW = set hex color value for RGBCCT lights (5 PWM channels) Note : Just append an = instead of the remaining color codes, this way they wont get changed. For example a command like Color #00ff= would update the RGB part to disable red and enable geen, but would omit to update blue or any white channel. CT 153..500 = set color temperature from 153 (cold) to 500 (warm) for CT lights + = increase CT value by 10 - = decrease CT value by 10 Dimmer 0..100 = set dimmer value from 0 to 100% + = increase by 10 - = decrease by 10 Dimmer<x> Commands available only when SetOption37 >= 128 ( #6819 ) <value> same as in Dimmer Dimmer0 <value> = set dimming for all channels Dimmer1 <value> = set dimming for RGB channels Dimmer2 <value> = set dimming for white channels DimmerRange Change dimming range. Works only with TuyaMCU and PS_16_DZ serial dimmers. <dimmerMin>,<dimmerMax> = set dimming range from minimum to maximum value Does not change Dimmer command behavior Fade 0 = do not use fade (default) 1 = use fade HsbColor <hue>,<sat>,<bri> = set color by hue, saturation and brightness HsbColor1 0..360 = set hue HsbColor2 0..100 = set saturation HsbColor3 0..100 = set brightness Led<x> #RRGGBB = set hex color value where <x> is the pixel number of the LED (applies only to addressable LEDs) LedTable 0 = do not use LED gamma correction (default \u00ab6.5.0.9) 1 = use gamma correction (default \u00bb6.5.0.9) Pixels 1..512 = set amount of pixels in strip or ring and reset Rotation (applies only to addressable LEDs) RGBWWTable Control compensation of unbalanced PWM channels or White Blend Mode PWM1,PWM2,PWM3,PWM4,PWM5 = channel range with values 0..255 (default = 255,255,255,255,255 ) Range adjustment is computed after Gamma correction. Rotation <value> = set amount of pixels to rotate (up to Pixels value) (applies only to addressable LEDs) Scheme Light effects + = next scheme - = previous scheme 0 = single color for LED light (default) 1 = start wake up sequence (same as Wakeup ) 2 = cycle up through colors using Speed option 3 = cycle down through colors using Speed option 4 = random cycle through colors using Speed and Fade Use <value>, <startcolor> if you want to set the starting color of selected scheme Speed 1..40 = set fade speed from fast 1 to very slow 40 + = increase speed - = decrease speed The Speed value represents the time in 0.5s to fade from 0 to 100% (or the reverse). Example: Speed 4 takes 2.0s to fade from full brightness to black, or 0.5s to move from 75% to 100%. Wakeup Start wake up sequence from OFF to stored Dimmer value 0..100 = Start wake up sequence from OFF to provided Dimmer value WakeupDuration 1..3000 = set wake up duration in seconds White 1..100 = set white channel brightness in single white channel lights (single W or RGBW lights) Width<x> x = 1..4 1 = 0..4 = LED group width ( Scheme 6..12 only) 2 = 0..32 = seconds hand width ( Scheme 5 only) 3 = 0..32 = minutes hand width ( Scheme 5 only) 4 = 0..32 = hour hand width ( Scheme 5 only) See also SetOption15 , SetOption16 , SetOption17 , SetOption20 , SetOption37 and SetOption68 RF Bridge ~ Command Parameters RfCode Show last sent 24-bit user code 1..8388607 = send 24-bit user code #1..#7FFFFF = send 24-bit hexadecimal user code using RfSync, RfLow and RfHigh timing RfHigh 1 = reset high pulse time to 840 microseconds 2..32767 = set high pulse time in microseconds #2..#7FFF = set high pulse time in hexadecimal microseconds RfHost Show 16-bit host part of user code 1 = reset 16-bit host part of user code to 11802 (#2E1A) 2..32767 = set 16-bit host part of user code #2..7FFF = set 16-bit host part of user code in hexadecimal RfKey<x> Send learned or default RF data for RfKey<x> (x = 1 \u2013 16 ) 1 = send default RF data for RfKey<x> using RfSync, RfLow, RfHigh and RfHost parameters 2 = learn RF data for RfKey<x> 3 = unlearn RF data for RfKey<x> 4 = save RF data using RfSync, RfLow, RfHigh and last RfCode parameters 5 = show default or learned RF data 6 = send learned RF data RfLow 1 = reset low pulse time to 270 microseconds 2..32767 = set low pulse time in microseconds #2..#7FFF = set low pulse time in hexadecimal microseconds RfRaw This command only works when the firmware has been updated with Portisch firmware . Refer to the Portisch wiki for details. Learning and Decoding RF Codes with Portisch Firmware 0 = Set iTead default firmware support and messages (default on restart) 1 = set Portisch firmware support and messages 166 or AAA655 = start sniffing/reading RF signals disabling iTead default RF handling 167 or AAA755 = stop sniffing/reading RF signals enabling iTead default RF handling 168 or AAA855 = transmitting iTead default RF protocols 169 or AAA955 = start sniffing and learning predefined protocols 176 or AAB055 = bucket Transmitting using command 0xB0 177 or AAB155 = start Bucket sniffing using command 0xB1 192 or AAC000C055 = beep ( 00C0 is the length of the sound) 255 or AAFF55 = show Rf firmware version (result AA02FF means Version 02) <value> = hexadecimal data to be sent to RF chip. This must be immediately followed by the RfRaw 0 command (e.g., Backlog RfRaw <value>; RfRaw 0 RfSync 1 = reset start sync pulse time to 8470 microseconds 2..32767 = set start sync pulse time in microseconds #2..#7FFF = set start sync pulse time in hexadecimal microseconds See also SetOption28 - Set RF received data format IR Remote ~ Command Parameters IRsend <x> Send an IR remote control code as a decimal or hexadecimal string in a JSON payload. In order to send IR data, you must configure one of the free device GPIO as IRsend (8) . GPIO01 nor GPIO03 can be used. <x> [ optional ] = number of times the IR message is sent. If not specified or 0..1 , the message is sent only once (i.e., not repeated) (default) >1 = emulate a long-press on the remote control, sending the message <x> times, or sending a repeat message for specific protocols (like NEC) {\"Protocol\":\"<value>\",\"Bits\":<value>,\"Data\":<value>} \"Protocol\" (select one of the following): \"NEC\" \"SONY\" \"RC5\" \"RC6\" \"DISH\" \"JVC\" \"PANASONIC\" \"SAMSUNG\" \"PIONEER\" \"Bits\":1..32 = required number of data bits for PANASONIC protocol this parameter is the the address, not the number of bits \"Data\":1..(2^32)-1 = data frame as 32 bit decimal. e.g., IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":2170978686} or \"Data\":0x1..0xFFFFFFFF = data frame as 32 bit hexadecimal. e.g., IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":0x8166817E} Alternatively, you can send IR remote control codes using RAW command encoding . Information on Receiving Infrared Data IRhvac Send HVAC IR remote control code as JSON payload {\"Vendor\":\"<value>\",\"Power\":<value>,\"Mode\":\u201d<value>\u201d, \"FanSpeed\":\u201d<value>\u201d,\"Temp\":<value>} \"Vendor\":\"Toshiba\"\\|\"Mitsubishi\"\\|\"LG\"\\|\"Fujitsu\" \"Power\":0\\|1 \"Mode\":\"Hot\"\\|\"Cold\"\\|\"Dry\"\\|\"Auto\" \"FanSpeed\":\"1\"\\|\"2\"\\|\"3\"\\|\"4\"\\|\"5\"\\|\"Auto\"\\|\"Silence\" \"Temp\":17..30 See also SetOptions ~ Command Parameters SetOption0 Save power state and use after restart (=SaveState) 0 = disable 1 = enable (default) SetOption1 Set button multipress mode to 0 = allow all button actions (default) 1 = restrict to single, double and hold actions (i.e., disable inadvertent reset due to long press) SetOption3 MQTT 0 = disable MQTT 1 = enable MQTT (default) SetOption4 Return MQTT response as 0 = RESULT topic (default) 1 = %COMMAND% topic SetOption8 Show temperature in 0 = Celsius (default) 1 = Fahrenheit SetOption10 When the device MQTT topic changes 0 = remove retained message on old topic LWT (default) 1 = send \"Offline\" to old topic LWT SetOption11 Swap button single and double press functionality 0 = disabled (default) 1 = enabled SetOption12 Configuration saving to flash option 0 = allow dynamic flash save slot rotation (default) 1 = use fixed eeprom flash slot SetOption13 Allow immediate action on single button press 0 = single, multi-press and hold button actions (default) 1 = only single press action for immediate response (i.e., disable multipress detection). Disable by holding for 4 x button hold time (see SetOption32 ). SetOption15 Set PWM control for LED lights 0 = basic PWM control 1 = control with Color or Dimmer commands (default) SetOption16 Set addressable LED Clock scheme parameter 0 = clock-wise mode (default) 1 = counter-clock-wise mode SetOption17 Show Color string as 0 = hex string (default) 1 = comma-separated decimal string SetOption18 Set status of signal light paired with CO 2 sensor 0 = disable light (default) 1 = enable light The light will be green below CO2_LOW and red above CO2_HIGH (transition yellow/orange between). The default levels are: 800ppm for low and 1200ppm for high but these can be set in user_config_override.h . SetOption19 Home Assistant automatic discovery. WARNING On version 6.4.1.x enabling may cause a watchdog reset if used on a device with a configured sensor 0 = disabled (default) 1 = enabled and also sets SetOption59 1 If you enable and then disable SetOption19 , doing so does not set SetOption59 = 0 and does not revert to default %prefix%/%topic%/ FullTopic SetOption20 Update of Dimmer/Color/CT without turning power on 0 = disabled (default) 1 = enabled SetOption21 Energy monitoring when power is off 0 = disabled (default) 1 = enabled SetOption24 Set pressure units 0 = hPa (default) 1 = mmHg SetOption26 Use indexes even when only one relay is present 0 = messages use POWER (default) 1 = messages use POWER1 SetOption28 RF received data format 0 = hex (default) 1 = decimal SetOption29 IR received data format 0 = hex (default) 1 = decimal SetOption30 Enforce Home Assistant auto-discovery as light 0 = relays are announced as a switch and PWM as a light (default) 1 = both relays and PWM are announced as light SetOption31 Set status LED blinking during Wi-Fi and MQTT connection problems. LedPower must be set to 0 for this feature to work 0 = Enabled (default) 1 = Disabled SetOption32 Number of 0.1 seconds to hold button before sending HOLD action message. 1..100 to set button hold time (default = 40 ) . This option also affects the time required to perform a firmware defaults reset (10x HOLD action time) SetOption33 Number of seconds for which the maximum power limit can be exceeded before the power is turned off 1..250 = set number of seconds (default = 5 ) SetOption34 0..255 = set Backlog inter-command delay in milliseconds (default = 200 ) SetOption36 Boot loop defaults restoration control. 0 = disable boot loop control 1..200 = set number of boot loops (a restart caused by any exception or watchdog timer within less than BOOT_LOOP_TIME (default 10 seconds) before beginning to restore settings (default = 1 ) . Once this number is reached, subsequent restarts will: 1 st restart: disable ESP8285 generic GPIOs interfering with flash SPI 2 nd restart: disable rules causing boot loop 3 rd restart: disable all rules 4 th restart: reset user defined GPIOs to disable any attached peripherals 5 th restart: reset module to Sonoff Basic (1) SetOption37 Color remapping for led channels, also provides an option for allowing independent handling of RGB and white channels. Setting changes require a device reboot. 0 = disabled 1..119 = according to this table 120..127 = invalid (results in same as 0 ) 128..255 = same as 0..127 but with independent channel handling enabled SetOption38 6..255 = set IRReceive protocol detection sensitivity minimizing UNKNOWN protocols SetOption39 Control handling of invalid power measurements. Read more... 0 = reset to default on next restart 1..255 = number of invalid power readings before reporting no load (default = 128 ) . SetOption40 Stop detecting input change on the button GPIO. Solves #5449 Active only when SetOption1 1 and SetOption13 0 . This disables all long press functionality. 0..250 = button hold time in 0.1 seconds after which button functionality is disabled. (default = 1 ) Example: Backlog SetOption1 1; SetOption13 0; SetOption40 10 = discard any button press over 1 second SetOption42 0..255 = set over-temperature (Celsius only) threshold resulting in power off on all energy monitoring devices (default = 90 ) SetOption43 Deprecated in favor of DimmerRange 0..255 = set maximum dimming value ( details ) (default = 100 ) Available for Tuya and PS_16_DZ dimmers SetOption51 Enable GPIO9 and GPIO10 component selections in Module Configuration WARNING Do not use on ESP8266 devices! 0 = disable (default) 1 = enable SetOption52 Control display of optional time offset from UTC in JSON payloads 0 = disable (default) 1 = enable SetOption53 Display hostname and IP address in GUI 0 = disable (default) 1 = enable SetOption54 Apply SetOption20 settings to commands from Tuya device 0 = disable (default) 1 = enable SetOption55 mDNS service 0 = disable (default) 1 = enable SetOption56 Wi-Fi network scan to select strongest signal on restart (network has to be visible) 0 = disable (default) 1 = enable SetOption57 Wi-Fi network re-scan every 44 minutes with alternate to +10dB stronger signal if detected (only visible networks) 0 = disable (default) 1 = enable SetOption58 IR Raw data in JSON payload 0 = disable (default) 1 = enable SetOption59 Send tele/%topic%/STATE in addition to stat/%topic%/RESULT for commands: State , Power and any command causing a light to be turned on. 0 = disable (default) 1 = enable SetOption60 Set sleep mode 0 = dynamic sleep (default) 1 = normal sleep SetOption61 Force local operation when ButtonTopic or SwitchTopic is set. 0 = disable (default) 1 = enable SetOption62 Set retain on Button or Switch hold messages 0 = disable (default) 1 = don't use retain flag on HOLD messages SetOption63 Set relay state feedback scan at restart ( #5594 , #5663 ) 0 = Scan power state at restart (default) 1 = Disable power state scanning at restart SetOption64 Switch between - or _ as sensor name separator 0 = sensor name index separator is - (hyphen) (default) 1 = sensor name index separator is _ (underscore) Affects DS18X20, DHT, BMP and SHT3X sensor names in tele messages SetOption65 Device recovery using fast power cycle detection 0 = enabled (default) 1 = disabled SetOption66 Set publishing TuyaReceived to MQTT 0 = disable publishing TuyaReceived over MQTT (default) 1 = enable publishing TuyaReceived over MQTT SetOption67 iFan03 Buzzer control 0 = disable Sonoff iFan03 buzzer (default) 1 = enable Sonoff iFan03 buzzer SetOption68 Multi-channel PWM instead of a single light 0 = Treat PWM as a single light (default) 1 = Treat PWM as separate channels. In this mode, use Power<x> to turn lights on and off, and Channel<x> to change the value of each channel. Color still works to set all channels at once. Requires restart after change SetOption69 Deprecated in favor of DimmerRange By default Tuya dimmers won't dim below 10% because some don't function very well that way. 0 = disable Tuya dimmer 10% lower limit 1 = enable Tuya dimmer 10% lower limit (default) SetOption71 Set DDS238 Modbus register for active energy 0 = set primary register (default) 1 = set alternate register SetOption72 Set reference used for total energy 0 = use firmware counter (default) 1 = use energy monitor (e.g., PZEM-0xx, SDM120, SDM630, DDS238, DDSU666) hardware counter SetOption73 Deprecated in version 7.1.2.4 in favor of CORS command Set HTTP Cross-Origin Resource Sharing (CORS) 0 = disable CORS (default) 1 = enable CORS SetOption74 Enable internal pullup for single DS18x20 sensor 0 = disabled (default) 1 = internal pullup enabled SetOption75 Set grouptopic behaviour ( #6779 ) 0 = GroupTopic using FullTopic replacing %topic% (default) 1 = GroupTopic is cmnd/%grouptopic%/ SetOption76 Bootcount incrementing when DeepSleep is enabled ( #6930 ) 0 = disable bootcount incrementing (default) 1 = enable bootcount incrementing SetOption77 Do not power off if a slider is moved to far left 0 = disabled (default) 1 = enabled SetOption78 Version check on Tasmota upgrade 0 = enabled (default) 1 = disabled SetOption79 Reset counters at TelePeriod time 0 = disabled (default) 1 = enabled SetOption80 Blinds and shutters support 0 = disable blinds and shutters support (default) 1 = enable blinds and shutters support SetOption81 Set PCF8574 component behavior for all ports 0 = set as regular state (default) 1 = set as inverted state SetOption82 Reduce the CT range from 153..500 to 200.380 to accomodate with Alexa range 0 = CT ranges from 153 to 500 (default) 1 = CT ranges from 200 to 380 (although you can still set in from 153 to 500) SetOption83 Uses Zigbee device friendly name instead of 16 bits short addresses as JSON key when reporting values and commands 0 = JSON key as short address 1 = JSON key as friendly name See ZbName <device>,<name> SetOption84 (Experimental) When using AWS IoT, sends a device shadow update (alternative to retained) 0 = don't update device shadow (default) 1 = update device shadow Note: if the Topic contains '/' they are replaced with '_' SetOption85 Device group support 0 = disabled (default) 1 = enabled SetOption86 PWM Dimmer only! Turn brightness LED's off 5 seconds after last change 0 = disabled (default) 1 = enabled SetOption87 PWM Dimmer only! Turn red LED on when powered off 0 = disabled (default) 1 = enabled SetOption88 PWM Dimmer only! Buttons control remote devices 0 = disabled (default) 1 = enabled SetOption89 Configure MQTT topic for Zigbee devices (also see SensorRetain ) 0 = single tele/%topic%/SENSOR topic (default) 1 = unique device topic based on Zigbee device ShortAddr Example: tele/Zigbee/5ADF/SENSOR = {\"ZbReceived\":{\"0x5ADF\":{\"Dimmer\":254,\"Endpoint\":1,\"LinkQuality\":70}}} Serial Bridge ~ Both hardware and software Serial Bridge are supported. Hardware Serial Bridge uses GPIO1 (Tx) and GPIO3 (Rx) or GPIO13 (Tx) and GPIO15 (Rx) pins of your device. Software Serial Bridge can use any other GPIO to be configured as components Serial Tx and Serial Rx (or SerBr Tx and SerBr Rx ). If Tx and Rx components are not assigned in the Template or Module, GPIO1 and GPIO3 will be used. Note that changing serial logging ( SerialLog 0) will disable the hardware Serial Bridge. Information received by Tasmota over the serial bridge is captured automatically. Before data will be received, a properly formatted SerialSend<x> or SSerialSend<x> command must be executed. This must be done any time the device restarts (e.g., via a System#Boot triggered rule). This command is required in order to set how the expected serial data will be formatted and interpreted (i.e., which <x> option). A {\"SSerialReceived\":{\"Data\":\"<string>\"}} message will be posted. You can use a rule to process the string which will be contained in SSerialReceived#Data . Expect possible communication errors when additional sensors are configured. Command Parameters Baudrate 1 = set hardware serial bridge to default baud rate of 115200 bps <value> = set baud rate. The set rate will be a multiple of 300. The maximum baud rate possible is 19,660,500. SBaudrate 1 = set software serial bridge to default baud rate of 9600 bps <value> = set baud rate. The set rate will be a multiple of 300. The maximum baud rate possible is 19,660,500. SerialConfig value = set serial protocol using data/parity/stop conventional notation (example: 8N1 or 702 ) 0..23 = set serial protocol ( 3 equals 8N1 ) SerialDelimiter <value> = set serial delimiter to escape character code or ASCII character 1..127 = set serial delimiter to decimal ASCII 128 = only allow ASCII characters 32 to 127 in response text 129..255 = disable serial delimiter SerialSend<x> <string> Disable serial logging and send using hardware serial x = 1..5 1 = send appending \\n (newline) () 2 = send 3 = replace escape characters and send 4 = send as binary. Data in serial response messages is encoded as hex strings 5 = send as hex. Data in serial response messages is encoded as hex strings SSerialSend<x> <string> Send using software serial protocol x = 1..5 1 = send appending \\n (newline) () 2 = send 3 = replace escape characters and send 4 = send as binary data. Data in serial response messages is encoded as hex strings 5 = send as hex. Data in serial response messages is encoded as hex strings TuyaSend<x> Send data to MCU with TuyaMCU x = 1..4 TuyaSend1 <dpId>,<boolean> = send boolean ( 0 / 1 ) data type to dpId (1 byte max length) TuyaSend2 <dpId>,<int> = send integer data to dpId (4 bytes max length) TuyaSend2 <dpId>,<0xAABBCCDD> = send 4 byte data to dpId (4 bytes max length) TuyaSend3 <dpId>,<value> = send any data type to dpId (unknown max length) TuyaSend4 <dpId>,<enum> = send enumerated ( 0 / 1 / 2 / 3 / 4 / 5 ) data type to dpId (1 byte max length) Domoticz ~ Command Parameters DomoticzIdx<x> Show Domoticz Relay idx <x> (x = 1..4 ) 0 = disable use of Relay idx <x> (default) <value> = Show Relay idx <x> DomoticzKeyIdx<x> Show Domoticz Key idx <x> (x = 1..4 ) 0 = disable use of Key idx <x> (default) <value> = Show Key idx <x> (to use enable ButtonTopic ) DomoticzSensorIdx<x> Show Domoticz Sensor idx <x> (x = 1..5 ) 0 = disable use of Sensor idx <x> (default) <value> = Show Sensor idx <x> DomoticzSwitchIdx<x> Show Domoticz Switch idx <x> (x = 1..4 ) 0 = disable use of Switch idx <x> (default) <value> = Show Switch idx <x> (to use enable SwitchTopic ) DomoticzUpdateTimer Show current update timer value in seconds 0 = disable sending interim Domoticz status (default) 1..3600 = send status to Domoticz in defined intervals KNX ~ Command Parameters KnxTx_Cmnd<x> 0 or 1 = send command using slot <x> set in KNX Menu at KNX_TX KnxTx_Val<x> <value> = send float value using slot <x> set in KNX Menu at KNX_TX KNX_ENABLED Status of KNX Communications 0 = set to Disable 1 = set to Enable KNX_ENHANCED Status of Enhanced mode for KNX Communications 0 = set to Disable 1 = set to Enable KNX_PA KNX Physical Address 0.0.0 = address not set x.x.x = set the device address (example 1.1.0 ) KNX_GA Return the amount of Group Address to Send Data/Commands configured KNX_GA<x> Setup Group Address to Send Data/Commands (<x> = KNX Group Address number) 1 = return configuration of GA<x> <option>, <area>, <line>, <member> to set configuration of GA<x> <option> = see table below for OPTION list <area>, <line>, <member> = KNX Address to Send Data/Commands KNX_CB Return the amount of Group Address to Receive Data/Commands configured KNX_CB<x> Setup Group Address to Receive Data/Commands 1 = return configuration of CB<x> <option>, <area>, <line>, <member> to set configuration of CB<x> <option> = see table below for OPTION list <area>, <line>, <member> = KNX Address to Receive Data/Commands OPTION OPTION Value OPTION OPTION Value 1 Relay 1 17 TEMPERATURE 2 Relay 2 18 HUMIDITY 3 Relay 3 19 ENERGY_VOLTAGE 4 Relay 4 20 ENERGY_CURRENT 5 Relay 5 21 ENERGY_POWER 6 Relay 6 22 ENERGY_POWERFACTOR 7 Relay 7 23 ENERGY_DAILY 8 Relay 8 24 ENERGY_START 9 Button 1 25 ENERGY_TOTAL 10 Button 2 26 KNX_SLOT1 11 Button 3 27 KNX_SLOT2 12 Button 4 28 KNX_SLOT3 13 Button 5 29 KNX_SLOT4 14 Button 6 30 KNX_SLOT5 15 Button 7 255 EMPTY 16 Button 8 Displays ~ Command Parameters Display Show current display setting as a JSON payload DisplayAddress 0..255 Set display module address DisplayDimmer 0 Turn the display off 1..100 Turn the display on 0..100 Set display luminosity (only on 8x8 Dot-Matrix displays) DisplayMode 0..5 Set to display predefined content according to display type DisplayModel Set display model: 1 = I 2 C LCD Display (default addresses 0x27 , 0x3F ) 2 = SSD1306 OLED 128x32/128x64 (default I 2 C addresses 0x3C , 0x3D ) 3 = HT16K33 8x8 Dot-Matrix 4 = ILI9341 TFT LCD 5 = 2.9 inch E-Paper Display 296x128 (software 3-wire SPI) 6 = 4.2 inch E-Paper Display 400x300 (software 3-wire SPI) 7 = SH1106 OLED 128x64 (default I 2 C address 0x3c ) 8 = ILI9488 TFT 480x320 (capacitive touch, hardware 3-wire SPI) 9 = SSD1351 color OLED 128x128 (hardware 3-wire SPI) 10 = RA8867 TFT LCD 1024x600 (capacitive touch, hardware 4-wire SPI) DisplayRefresh 1..7 Set time in seconds to update predefined content when using DisplayMode \u2260 0 DisplaySize 1..4 Set display scale-up size (SSD1306 and ILI9341 only) DisplayRotate Set rotation angle 0 = 0\u00b0 1 = 90\u00b0 2 = 180\u00b0 3 = 270\u00b0 DisplayText <value> = See DisplayText use DisplayCols 1..44 Set number of display columns (for display modes>0) DisplayRows 1..32 Set number of display rows (for display modes>0) DisplayFont Specify the current font 0 use classic GFX font 1 = 12 2 = 24 3 = 8 (opt) 7 use RA8876 internal font DisplayWidth Specify the display width in pixels (SSD1306 only) DisplayHeight Specify the display height in pixels (SSD1306 only) Stepper Motors ~ Command Parameters MotorMIS 1,2,4,8,16 Set micro stepping increment - 1/1 (full steps) to 1/16 (default = 1 ) MotorSPR integer Set the number of steps the given motor needs for one revolution (default = 200 ) This is dependent on the type of motor and micro stepping. Most common motors are 1.8\u00b0 per step. MotorRPM 1..300 Set revolutions per minute (default = 30 ) MotorMove integer Move the motor the given number of steps (positive values: clockwise, negative values: counterclockwise) MotorRotate integer Rotate the motor the given number of degrees (positive values: clockwise, negative values: counterclockwise) MotorTurn float Spin the motor the given number of turns (positive values: clockwise, negative values: counterclockwise) Blinds, Shutters and Rollers ~ Command (x = 1..4 ) Parameters ShutterButton<x> <button> <func> <mqtt> Assign a button to control the shutter. For more details please refer to Blinds and Shutters support <button> \u2003 0 : disable buttons for this shutter \u2003 1..4 : Button number <func> up / down / updown : function to assign to the button <mqtt> 1 / 0 : enable/disable MQTT publish for button hold action For example: To control shutter #1 by two buttons: Backlog ShutterButton1 1 up 1; ShutterButton1 2 down 1 assigns button #1 to act as an \"up\" button and button #2 to act as an \"down\" button for shutter #1 including MQTT publish. To control shutter #1 by a single button: ShutterButton1 1 updown 0 assigns button #1 to act as an \"up and down\" button. ShutterCalibration<x> Granular shutter position calibration. The measured opening position of the shutter at the 30, 50, 70, 90, and 100 percent opened locations. For example: ShutterCalibration<x> 23 38 56 74 82 ShutterCloseDuration<x> 1..255 (default = 10 ) time, in seconds, it takes to fully close the shutter. A fraction of a second can be specified (e.g. 45.7 ). ShutterClose<x> Engage the relay to close the shutter. This action can be requested at any time. Number of shutter can be the index or the arguement ShutterFrequency<x> 0..10,000 Hz (default = 1000 ) the maximum frequency at which the stepper motor can operate reliably. Typically this is up to 2,000Hz with a 12V power supply and up to 5,000Hz with a 24V power supply. ShutterEnableEndStopTime<x> 0 = no additional shutter end stop time (default) 1 = 1 s additional shutter end stop time ShutterInvert<x> 0 = use default shutter positioning ( 0 = Closed, 100 = Open) 1 = invert shutter positioning ( 100 = Closed, 0 = Open) (e.g., if used with KNX) ShutterInvertWebButtons<x> 0 = use default button icons (\u25b2 for open, \u25bc for close) 1 = invert button icons (\u25bc for open, \u25b2 for close) (e.g., if used with horizontal awning: where open means rolling-down fabric material and close rolling-up in a protect position) ShutterLock<x> 0 = unlock shutter positioning (default) 1 = lock shutter positioning ShutterMotorDelay<x> 0.00 .. 12.75 (default = 0 ) time, in seconds, it takes the motor to start moving once power is turned on; i.e., motor lag time. When used with stepper motors, this setting defines the ramp up/down speed (i.e., acceleration/deceleration) before the motor reaches its target speed for gradual starting and stopping. ShutterOpenDuration<x> 1..255 (default = 10 ) time, in seconds, it takes to fully open the shutter. A fraction of a second can be specified (e.g. 45.7 ). ShutterOpen<x> Engage the relay to open the shutter. This action can be requested at any time. Number of shutter can be index or the arguement ShutterPosition<x> 0..100 , UP , DOWN , STOP A shutter position change can be requested at any time. The shutter will stop and revert or update to the requested position. The shutter's actual position will be saved after the movement is completed. In this case, the position will be restored during reboot. An interruption during shutter movement (e.g., a device restart) will lose the current position. ShutterRelay<x> <value> 0 = disable this and all higher numbered shutters 1,3,5,7,... (must be an odd number) = Relay<value> component used to open the shutter. This relay's mate, the next higher numbered relay, closes the shutter. Depending on the shutter mode, the relays may need to be interlocked using the Interlock command. The ShutterRelay command must be executed first before any other shutter commands for Shutter<x> can be executed. ShutterSetClose<x> shutter closed position. ShutterPosition will be reset to fully closed value (e.g., 0 when ShutterInvert = 0 , 100 otherwise). ShutterSetHalfway<x> 0..100 (default = 50 ) Define shutter half open position (in percent) ShutterStop<x> Disengage the relays to stop the shutter. Number of shutter can be the index or the argument See also SetOption80 - Enable shutter support Zigbee ~ See the Complete Zigbee guide Command Parameters ZbBind Binds one Zigbee device to another device or to a groups. This allows one device to directly send commands, like a remote to a bulb, without any action on the coordinator. {\"Device\":\"<device>\", \"Endpoint\":<endpoint>, \"Cluster\":<cluster>, \"ToDevice\":\"<to_device>\", \"ToEndpoint\":<to_endpoint>, \"ToGroup\":<to_group> } \u2003 <device> = the device sending the messages (mandatory) \u2003 <endpoint> = the source endpoint (mandatory) \u2003 <cluster> = the source cluster id (mandatory) \u2003 <to_device> = the target device (optional) \u2003 <to_endpoint> = the target endpoint (optional if it can be inferred from ZbStatus3 ) \u2003 <to_group> = the target group id (optional) Note1: you must specify either \"ToDevice\" or \"ToGroup\" but not both Note2: Z2T must know the IEEE address of the target device, see ZbStatus2 to verify, and ZbProbe to have Z2T query the address ZbForget Removes a device from the Tasmota flash memory. To be used for devices that are no more used and are still visible in ZbStatus \u2003 <device> ZbLight Zigbee Hue Emulation for use with Alexa: this command sets or reads the light type to be emulated. \u2003 <device>,<light_type> sets the light type \u2003 <device>,-1 removes the device from Philips Hue emulation \u2003 <device> displays the current status of the Light (Z2T tracks all changes to the light) Light_type is a integer 0..5 corresponding to the number of channels (from On/Off to RGBCW) ZbName Sets or reads the Zigbee device friendly name (up to 32 characters). \u2003 <device>,<name> sets the new friendly name \u2003 <device>, (empty name) clears the friendly name \u2003 <device> displays the current friendly name See SetOption83 1 to enable friendly names as JSON keys instead of short addresses ZbPermitJoin Sets new device pairing mode 0 = disable pairing 1 = enable pairing for 60 seconds 99 = enable pairing until device reboot Leaving your Zigbee network pairing open to join will allow any Zigbee device to connect and retrieve your network encryption key. This can lead to a compromise of your Zigbee network. ZbPing Test the availability of a Zigbee device. If the device is connected and not sleeping, you should receive a ZbPing message within the next second. \u2003 <device> Ex: ZbPing 0x5ADF {\"ZbPing\":{\"Device\":\"0x5ADF\",\"IEEEAddr\":\"0x90FD9FFFFE03B051\"}} ZbSend {\"Device\":\"<shortaddr>\", \"Endpoint\":\"<endpoint>\", \"Send\":{\"<sendcmd>\":<sendparam>}} \u2003 <shortaddr> the short address of the Zigbee device on the network. \u2003 <endpoint> the target endpoint on the device ( understandig endpoints ) \u2003 \"<sendcmd>\":<sendparam> the command and parameters to send ( Zigbee Device Commands ) Note: Use ZbZNPSend to send a raw form low-level message Ex: ZigbeeSend { \"Device\":\"0x1234\", \"Endpoint\":\"0x03\", \"Send\":{\"Power\":\"on\"} } ZbStatus<x> Display Zigbee devices seen on the network since boot <device> (optional) = all devices This command provides three levels of increasing detail according to <x> ZbStatus1 Display Short Address, and Friendly Name ZbStatus2 Also include Manufacturer ID and Model ID ZbStatus3 Also include a list of endpoints and the clusterIds supported by each endpoint Ex: ZbStatus3 1 requests all details for device number 1 The information requested may exceed the maximum result size allowed by Tasmota. In this case, the output will be truncated. To get all of the desired information, request results for a specific device individually. Zigbee Debug Functions Do not use unless you know exactly what you are doing. Command Parameters ZbModelId Manually force the ModelId field of a Zigbee device. This is used to simulate devicesnot physically present on the network, for debugging only. \u2003 <device>,<modelid> sets the new ModelId \u2003 <device>, (empty modelid) clears the ModelId \u2003 <device> displays the current ModelId, also displayed in ZbStatus2 ZbProbe Probe a Zigbee device to get additional information including its IEEEaddress, vendor and model names, endpoints, and supported clusters per endpoint. <device> A device probe is performed automatically when a new Zigbee device connects. Battery powered Zigbee devices can generally not be probed because they are in sleep mode most of the time. ZbRead Read Zigbee device attributes { \"Device\":\"<shortaddr>\", \"Endpoint\":\"<endpoint>\", \"Cluster\":\"<cluster>\", \"Read\":[<attrlist>] } \u2003 <shortaddr> the short address of the Zigbee device on the network. \u2003 <endpoint> the target endpoint on the device ( understandig endpoints ) \u2003 <cluster> the cluster number of the attributes \u2003 <attrlist> requested attributes array Ex: ZbRead { \"device\":\"0x69CF\", \"endpoint\":\"0x03\", \"cluster\":\"0x0006\", \"read\":[\"0x0000\"] } ZbReset 1 = perform a factory reset and reconfiguration of the CC2530 chip. You will need to re-pair all Zigbee devices ZbRestore Restores a device configuration previously dumped with ZbStatus2 . This command does not pair a device, but lets you get back device configuration like ModelId or IEEEAddress. \u2003 <json> where json contains the fields dumped with ZbStatus2 . <json> can contain multiple devices (if they fit). ZbSave Forces saving the Zigbee device information to Flash. Auto-saving happens 10 seconds after a new Device parameter was changed, this command is normally not useful ZbZNPSend Send a raw ZCL message to a Zigbee device. This is a low-level command, and requires to manually build the ZCL parameters. Most common usage will be provided as high-level functions. ZbZNPReceive Simulates a received message \u2003 <hex> = hex string of the simulated message, same format as ZbZNPReceived debug logs HM-1x ~ Command Parameters HM10Scan Start a new device discovery scan HM10Period Show interval in seconds between sensor read cycles. Set to TelePeriod value at boot. HM10Baud Show ESP8266 serial interface baudrate ( Not HM-10 baudrate ) <value> = set baudrate HM10AT <command> = send AT commands to HM-10. See list HM10Time <n> = set time time of a LYWSD02 only sensor to Tasmota UTC time and timezone. <n> is the sensor number in order of discovery starting with 0 (topmost sensor in the webUI list). HM10Auto <value> = start an automatic discovery scan with an interval of <value> seconds to receive data in BLE advertisements periodically. This is an active scan and it should be used only if necessary . At the moment that is the case just with MJ_HT_V1. This can change if a future HM-10 firmware starts supporting passive scan. MP3 Player ~ The MP3 Player driver is based on the one from DFRobot. They named it DFPlayer mini . All MP3 Players with the identical Serial Control Command structure can be used. Command Parameters MP3DAC 0 = DAC on (default) 1 = DAC off MP3Device Specify playback device 1 = USB 2 = SD Card (default (also defaults on reset or power cycle)) MP3EQ Set equalizer mode: 0 = normal 1 = pop 2 = rock 3 = jazz 4 = classic 5 = bass) MP3Pause Pause MP3Play Play, works as a normal play on a real MP3 Player, starts at first MP3 file MP3Reset Reset the MP3 player to defaults MP3Stop Stop MP3Track x = play track <x> MP3Volume 0..100 = set Volume","title":"Commands"},{"location":"Commands/#how-to-use","text":"Every command used without a parameter (payload) returns the current setting . Power returns the status of first defined power output (usually Relay1)\" Instead of 0 you can use off or false and instead of 1 you can use on or true . Power ON turns first defined power output (usually Relay1) on Power1 1 also turns first defined power output (usually Relay1) on Power1 True also turns first defined power output (usually Relay1) on Replace <x> in a command with the appropriate index number. Leave it empty to use the first available. Power1 and Power both control first defined power output (usually Relay1) In commands with x..y value parameters use a number from x to y range. When a command mentions resetting to \"firmware default\" it means the setting will revert to the one in the flashed binary file. If you used user_config_override.h at compile time it will revert to those. Note Beside results initiated by a command (synchronous) you can get asynchronous results initiated by rule trigger, telemetry event, commands from other source or changed device values. Simply put, other messages may precede messages published as a result of your commands. Example A tele/%topic%/STATUS message (sent every 300 seconds by default) may appear exactly after you issue Power off command and before you receive stat/%topic%/RESULT = {\"POWER\":\"OFF\"} message.","title":"How to use"},{"location":"Commands/#with-mqtt","text":"To send commands and view responses you'll need an MQTT client . Commands over MQTT are issued by using cmnd/%topic%/<command> <parameter> where %topic% is the topic of the device you're sending the command to. If there is no <parameter> (an empty MQTT message/payload), a query is sent for current status of the <command> . See MQTT article to find out more.","title":"with MQTT"},{"location":"Commands/#with-web-requests","text":"Commands can be executed via web (HTTP) requests, for example: http://<ip>/cm?cmnd=Power%20TOGGLE http://<ip>/cm?cmnd=Power%20On http://<ip>/cm?cmnd=Power%20off http://<ip>/cm?user=admin&password=joker&cmnd=Power%20Toggle Note Any spaces or special characters must be replaced with their ASCII hex codes . You must precede each hex code with % . Most used ones are: space = %20 and ; = %3B If you have set a password for web user interface access, this must be included (in plaintext) in the URL of the HTTP request, like so: http://<ip>/cm?&user=<username>&password=<password>&cmnd=Power%20On","title":"with Web Requests"},{"location":"Commands/#in-console-in-the-web-ui","text":"Console menu in the web UI is a convenient place to send commands and it behaves similar to a terminal connection via serial bridge.","title":"in Console in the Web UI"},{"location":"Commands/#over-serial-bridge","text":"If you flashed the device via serial method you can connect to it with a terminal application (e.g. Termite or Arduino IDE Serial Monitor) to issue commands and follow responses. This is a practical way to do a Backlog setup of your new device. Serial interface is set to 115200 bps except for devices that require a different baudrate","title":"over Serial Bridge"},{"location":"Commands/#the-power-of-backlog","text":"Backlog command allows executing up to 30 consecutive commands with a single command line. Each command is separated by a semicolon (\";\"). Backlog is a useful feature to avoid numerous restarts when setting up a new device. You can use it to: Set up both Wi-Fi AP's Backlog SSID1 < myssid > ; Password1 < mypassword > ; SSID2 < myssid2 > ; Password2 < mypassword2 > Configure MQTT broker address, MQTT credentials, device topic and activate a few custom options Backlog MqttHost < yourhost > ; MqttUser < user > ; MqttPassword < password > ; Topic < customtopic > ; SetOption53 1 ; PowerRetain on For specific power control, using backlog like a script Backlog Status 1 ; Power2 on ; Delay 20 ; Power2 off ; Status 4 When using web requests (You have to encode \"space\" as '%20' and \";\" as '%3B') http://<ip>/cm?user=admin&password=joker&cmnd=Backlog%20Power%20Toggle%3BPower1%20ff A Backlog command without an argument clears an possible existing Backlog queue. Example in case of command Backlog Power1 OFF; Delay 600; Power1 ON the usage of an additional Backlog command without any argument within the delay time of 1 minute will delete the whole queue Power1 OFF; Delay 600; Power1 ON . Therefore Power1 ON command will not be executed and the power would remain off.","title":"the Power of Backlog"},{"location":"Commands/#commands-list","text":"Warning If you're using Tasmota versions earlier current release some of the commands might not work. Availability of some features and their associated commands depend on the firmware build. Please consult the builds table for a reference of which features are available for each firmware variant.","title":"Commands List"},{"location":"Commands/#control","text":"Command Parameters Backlog List of commands to be executed in sequence separated by ; See Using Backlog for examples. BlinkCount Number of relay toggles ( blinks ) (does not control the status LED) 0 = blink many times before restoring power state 1..32000 = set number of blinks (default = 10 ) BlinkTime 2..3600 set duration, in 0.1 second increments, to blink aka toggle Power (does not control the status LED) ButtonDebounce User control over button debounce timing 40..1000 = set button debounce time in milliseconds (default = 50 ) Buzzer 0 = stop active buzzer cycle <count>,<beep>,<silence>,<tune> = read more... 2,3 = Beep twice with 300 milliseconds duration and 100 milliseconds pause 2,3,4 = Beep twice with 300 milliseconds duration and 400 milliseconds pause 1,2,3,0xF54 (0000 0000 0000 0000 0000 1111 0101 0100). Each 1 bit beeps for 200 milliseconds and each bounded 0 bit pauses for 300 milliseconds -1 = infinite mode -2 = follow LED mode DevGroupShare Set incoming and outgoing shared item mask. <in>,<out> (default = 0xFFFFFFFF,0xFFFFFFFF) 1 = Power, 2 = Light brightness, 4 = Light fade/speed, 8 = Light scheme, 16 = Light color, 32 = Minimum brightness FanSpeed Fan speed control (iFan02/iFan03 only) 0 = turn fan OFF 1..3 = set fan speed + = increase fan speed - = decrease fan speed Interlock Relay interlock mode and group selection. 0 = disable relay interlock for all relays (i.e., each relay is self-locking) (default) 1 = set interlock mode for selected relays Add up to 8 relays in 1 to 4 interlock groups, each separated by a space. For example 1,2 3,4 = Group Relay1 and Relay2 in group 1 and Relay3 and Relay4 in group 2 ( note the space between the two groups ) 1,2,3 = group Relay1, Relay2 and Relay3 in a single interlock group 1 3 2,4 = Relay1 is in group 1, Relay3 in group 2, Relay2 and Relay4 in group 3 LedMask Set a bitmask specifiying which relays control the LED indicator. Read more... <bitmask> = bitwise value representing each relay. Values may be entered as either hexadecimal or decimal values (e.g., 0xFFFF = 65535). 0xFFFF (= 1111 1111 1111 1111) All relays control the power LED (default) LedState must be enabled (i.e., != 0 ) in order for LedMask to take effect. LedPower LED power state as on or off 0 = turn LED OFF and set LedState 0 1 = turn LED ON and set LedState 8 2 = toggle LED and set LedState 0 (Use Backlog LedPower 0; SetOption31 1 to disable LED even when Wi-Fi or MQTT is not connected) LedPower<x> LED<x> power state control. Enabled only when LedLink(i) is configured 0 = turn LED OFF and set LedState 0 1 = turn LED ON and set LedState 0 2 = toggle LED and set LedState 0 LedState Manage LED state 0 = disable use of LED as much as possible 1 = show power state on LED (LED on when power on) (default) (inverted for Sonoff Touch/T1) 2 = show MQTT subscriptions as a LED blink 3 = show power state and MQTT subscriptions as a LED blink 4 = show MQTT publications as a LED blink 5 = show power state and MQTT publications as a LED blink 6 = show all MQTT messages as a LED blink 7 = show power state and MQTT messages as a LED blink 8 = LED on when Wi-Fi and MQTT are connected. Cannot be issued directly and is only activated when LedPower is switched from 0 to 1 due to a software function Power0 Control the power state simultaneously for all power outputs on the device 0 / off = turn OFF 1 / on = turn ON 2 / toggle = if relay is ON switch to OFF and vice versa Power<x> Control the corresponding power state ( 1..8 ) (also restarts PulseTime)<x> 0 / off / false = turn OFF 1 / on / true = turn ON 2 / toggle = if power state is ON switch to OFF and vice versa 3 / blink = toggle power for BlinkCount times each BlinkTime duration (at the end of blink , power state is returned to pre-blink state) 4 / blinkoff = stop blink sequence and return power state to pre-blink state PowerOnState Control power state when the device is powered up . More information 0 / OFF = keep power(s) OFF after power up 1 / ON = turn power(s) ON after power up 2 / TOGGLE = toggle power(s) from last saved state 3 = switch power(s) to their last saved state (default) 4 = turn power(s) ON and disable further power control 5 = after a PulseTime period turn power(s) ON (acts as inverted PulseTime mode) PulseTime<x> Display the amount of PulseTime remaining on the corresponding Relay<x> <value> Set the duration to keep Relay<x> ON when Power<x> ON command is issued. After this amount of time, the power will be turned OFF . 0 / OFF = disable use of PulseTime for Relay<x> 1..111 = set PulseTime for Relay<x> in 0.1 second increments 112..64900 = set PulseTime for Relay<x>, offset by 100, in 1 second increments. Add 100 to desired interval in seconds, e.g., PulseTime 113 = 13 seconds and PulseTime 460 = 6 minutes (i.e., 360 seconds) SwitchDebounce User control over switch debounce timing 40..1000 = set switch debounce time in milliseconds (default = 50 ) SwitchMode<x> Switch mode 0 = toggle (default) 1 = follow (0 = off, 1 = on) 2 = inverted follow (0 = on, 1 = off) 3 = pushbutton (default 1, 0 = toggle) 4 = inverted pushbutton (default 0, 1 = toggle) 5 = pushbutton with hold (default 1, 0 = toggle, Hold = hold) 6 = inverted pushbutton with hold (default 0, 1 = toggle, hold = hold) 7 = pushbutton toggle (0 = toggle, 1 = toggle) 8 = multi change toggle (0 = toggle, 1 = toggle, 2x change = hold) 9 = multi change follow (0 = off, 1 = on, 2x change = hold) 10 = inverted multi change follow (0 = on, 1 = off, 2x change = hold) 11 = pushbutton with dimmer mode 12 = inverted pushbutton with dimmer mode 13 = pushon mode (1 = on, switch off using PulseTime ) 13 = inverted pushon mode (0 = on, switch off using PulseTime ) See also SetOption1 - Set button multipress mode SetOption11 - Swap pushbutton single and double press functionality SetOption13 - Allow immediate action on single button press SetOption26 - Use indexes even when only one relay is present SetOption31 - Disable Wi-Fi LED status blinking SetOption32 - Set hold interval before sending HOLD action SetOption40 - Stop detecting any input change on button GPIO SetOption67 - Enable/Disable Buzzer","title":"Control"},{"location":"Commands/#management","text":"Command Parameters Delay 2..3600 = set delay between two backlog commands with 0.1 second increment DeepSleepTime Time to enter deep sleep mode 0 = disable deep sleep mode (default) 10..86400 = set deep sleep mode time period in seconds Emulation 0 = disable emulation (default) 1 = enable Belkin WeMo emulation for Alexa 2 = enable Hue Bridge emulation for Alexa FriendlyName<x> 1 = Reset friendly name to firmware default <value> = set friendly name (32 char limit) Gpios Show list of available components by name and index 255 / All Show list of all components by name and index Gpio Show current component assignments of the Module's configurable GPIO 255 / All Show component assignments for all the devices available GPIO Gpio<x> For built-in Modules only. This command does not work for devices configured with a Template. <component> = assign a component to Gpio<x> I2Cscan Scan I 2 C bus and show addresses for found devices I2CDriver Enable / Disable I 2 C sensor drivers. Read more... LogHost 1 = reset syslog host to firmware default ( SYS_LOG_HOST ) <value> = set syslog host (32 chars max) LogPort 1 = reset syslog port to firmware default ( SYS_LOG_PORT ) 2..32766 = set syslog port Modules Show available modules by name and index Module Displays active module by name and index <x> = switch to Module<x> and restart 0 = switch to defined template and restart MqttLog 0 = disable logging via MQTT (default) 1 = show only error messages 2 = show error and info messages 3 = show error, info and debug messages 4 = show error, info and more debug messsages NtpServer<x> NTP server setup (x= 1..3 ) 0 = clear NtpServer<x> settings 1 = reset NtpServer<x> settings to firmware defaults <value> = set NtpServer<x> host or IP address (32 char limit) OtaUrl Display current OTA URL 1 = Reset OtaUrl to firmware default url = set address for OTA (100 char limit) Pwm<x> 0..1023 = set PWM value for channel PwmFrequency 1 = reset PWM frequency to 880Hz 100..4000 = set PWM frequency (100Hz to 4kHz) PwmRange 1 = reset maximum PWM range to 1023 255..1023 = set maximum PWM range Reset 1 = reset device settings to firmware defaults and restart 2 = erase flash, reset device settings to firmware defaults and restart 3 = erase System Parameter Area in flash (Wi-Fi calibration and related data) and restart 4 = reset device settings to firmware defaults but retain Wi-Fi credentials and restart 5 = erase all flash and reset parameters to firmware defaults but keep Wi-Fi settings and restart 6 = erase all flash and reset parameters to firmware defaults but keep Wi-Fi and MQTT settings and restart (Erase of flash can take a few seconds to complete and there is no output during the erase process on the serial or web console) 99 = reset device bootcount to zero Restart 1 = restart device with configuration saved to flash 99 = force restart device without configuration save For debug and testing stack trace dumps only: -1 = force an Exception (28) crash -2 = force a Soft WDT reset (after a freeze of 2 seconds) -3 = force an OS watchdog reset (after a freeze of 120 seconds, caution! ) SaveData 0 = save parameter changes only manually, e.g. with Restart 1 1 = save parameter changes every second (default) 2..3600 = save parameter changes every x second SerialLog Disable hardware serial bridge and 0 = disable serial logging 1 = show only error messages 2 = show error and info messages (default) 3 = show error, info and debug messages 4 = show error, info and more debug messages SerialLog will be disabled automatically 10 minutes after the device reboots. Sleep 0 = turn sleep off 1..250 = set sleep duration in milliseconds to enable energy saving (default = 50 ) State Display current device state and publish to %prefix%/%topic%/RESULT topic\u2003 \u00bb5.12.0 Status = show abbreviated status information 0 = show all status information (1 - 11) 1 = show device parameters information 2 = show firmware information 3 = show logging and telemetry information 4 = show memory information 5 = show network information 6 = show MQTT information 7 = show time information 8 = show connected sensor information 9 = show power thresholds (only on modules with power monitoring) 10 = same as Status 8 (retained for backwards compatibility) 11 = show information equal to TelePeriod state message 12 = in case of crash to dump the call stack saved in RT memory SysLog 0 = disable syslog logging (default) 1 = show only error messages 2 = show error and info messages 3 = show error, info and debug messages 4 = show error, info and more debug messages Template Show current Template 0 = create template from active module x = create template from a supported module 255 = merge current module and template settings into new template { ... } = store template in a JSON payload Does not activate the template. To activate use Module 0 . Time 0 = enable NTP (default) 1 = format JSON message timestamp in ISO format 2 = format JSON message timestamp in both ISO and Epoch format 3 = format JSON message timestamp in Epoch format <value> = disable NTP and set UTC time as epoch value if greater than 1451602800 (January 1, 2016) TimeSTD TimeDST Set policies for the beginning of daylight saving time (DST) and return back to standard time (STD)\u2003 \u00bb5.14.0 0 = reset parameters to firmware defaults H , W , M , D , h , T H = hemisphere ( 0 = northern hemisphere / 1 = southern hemisphere) W = week ( 0 = last week of month, 1..4 = first .. fourth) M = month ( 1..12 ) D = day of week ( 1..7 1 = sunday 7 = saturday) h = hour ( 0..23 ) T = timezone ( -780..780 ) (offset from UTC in MINUTES - 780min / 60min=13hrs) Example: TIMEDST 1,1,10,1,2,660 Timezone -13..+13 = set timezone offset from UTC in hours -13:00..+13:00 = set timezone offset from UTC in hours and minutes 99 = use timezone configured with TimeDST and TimeSTD TuyaMCU Used to map functions in TuyaMCU <fnId>,<dpId> = read more... <fnId>,0 = remove setting for fnId Upgrade 1 = download firmware from OtaUrl and restart <value> = download firmware from OtaUrl if \\<value> is higher than device version Upload 1 = download firmware from OtaUrl and restart <value> = download firmware from OtaUrl if \\<value> is higher than device version WebLog 0 = disable web logging 1 = show only error messages 2 = show error and info messages (default) 3 = show error, info and debug messages 4 = show error, info and more debug messages See also SetOption68 - PWM Channel control SetOption76 - DeepSleep disable bootcount incrementing","title":"Management"},{"location":"Commands/#wi-fi","text":"Command Parameters AP 0 = switch to other Wi-Fi Access Point 1 = select Wi-Fi Access Point 1 2 = select Wi-Fi Access Point 2 CORS \" = disable CORS (Cross Origin Resource Sharing) (default) * = enable CORS for all locations value = Enable CORS for location. This needs to be complete url ex: http://tasui.shantur.com Hostname 1 = reset hostname to MQTT_TOPIC-<4digits> and restart <value> = set hostname (32 char limit) and restart. If hostname contains % it will be reset to the default instead. If using MQTT to issue this command, if it is used with the device GroupTopic , the command will not be executed. IPAddress<x> Set networking IP ( XXX.XXX.XXX.XXX ) addresses IPAddress1 = set device IP address 0.0.0.0 = use dynamic IP address (DHCP) XXX.XXX.XXX.XXX = set static IP address IPAddress2 = set gateway IP address IPAddress3 = set subnet mask IPAddress4 = set DNS server IP address follow IPAddress commands with restart 1 to apply changes Password<x> <x> = 1..2 <value> = set AP<x> Wi-Fi password and restart 1 = reset AP<x> Wi-Fi password to firmware default ( STA_PASS1 or STA_PASS2 ) and restart Passwords are limited to 64 characters. Do not use special characters or white spaces in the password . Note that Password and Password1 are equivalent commands. Ssid<x> <x> = 1..2 <value> = set AP<x> Wi-Fi SSID and restart 1 = reset AP<x> Wi-Fi SSID to firmware default ( STA_SSID1 or STA_SSID2 ) and restart SSID are limited to 32 characters. Do not use special characters or white spaces in the SSID WebColor<x> Configure Web GUI colors (x = 1..19 ) #RRGGBB = Set color for WebColor<x> 1 = Global text (Black) 2 = Global background (White) 3 = Form background (Greyish) 4 = Input text (Black) 5 = Input background (White) 6 = Console text (Black) 7 = Console background (White) 8 = Warning text (Red) 9 = Success text (Green) 10 = Button text (White) 11 = Button (Blueish) 12 = Button hovered over (Darker blueish) 13 = Restart/Reset/Delete button (Redish) 14 = Restart/Reset/Delete button hover (Darker reddish) 15 = Save button (Greenish) 16 = Save button hover (Darker greenish) 17 = Config timer tab text (White) 18 = Config timer tab background (Light grey) 19 = Module title and FriendlyName text (Whiteish) User themes WebPassword Show current web server password 0 = disable use of password for web UI 1 = reset password to firmware default ( WEB_PASSWORD ) <value> = set web UI password (32 char limit) for user WEB_USERNAME (Default WEB_USERNAME = admin ) WebRefresh Web page refresh 1000..10000 = set refresh time in milliseconds (default = 2345 ) WebSend Send a command to Tasmota host over http. If a command starts with a \\ it will be used as a link. [<host>:<port>,<user>:<password>] <command> <host> = hostname or IP address. <port> = port for the device if not the default 80 <user> = enter username of the device you're sending the command to <password> = enter password of the device you're sending the command to <command> = command and payload example: [<ip>] POWER1 ON sends http://<ip>/cm?cmnd=POWER1 ON WebSensor<x> Control display of sensor telemetry in the web UI 0 = Do not display sensor's telemetry 1 = Display sensor's telemetry ( default ) <x> = number corresponding to the sensor - listed in the sns section of the supported sensor spreadsheet <x> = 3 Energy telemetry Issue a Status 4 to obtain a list of sensor types enabled in the firmware loaded on the device. WebServer 0 = stop web server 1 = start web server in user mode 2 = start web server in admin mode WifiConfig 0 = disable Wi-Fi Manager and reboot (used with alternate AP) 2 = set Wi-Fi Manager as the current configuration tool and start Wi-Fi Manager (web server at 192.168.4.1) for 3 minutes, then reboot and try to connect Wi-Fi network 4 = disable Wi-Fi Manager but retry the other AP without rebooting 5 = disable Wi-Fi Manager and wait until that AP is available again without rebooting 6 = Wi-Fi parameters can only be entered via commands in the serial console 7 = set Wi-Fi Manager (web server at 192.168.4.1) as the current configuration tool restricted with the only option to reset settings. This setting is recommended for devices without an external control/reset button . \u2003 No longer supported 1 = set SmartConfig ( Android /iOS) as the current configuration tool, start SmartConfig for 3 minutes and reboot and try to connect to Wi-Fi 3 = set WPS as configuration tool, try WPS for 3 minutes and reboot and try to connect to Wi-Fi WifiPower set Wi-Fi transmit power level in decibel-milliwatts (dBm) (default = 17 ) See also SetOption55 - mDNS service control SetOption56 - Wi-Fi network scan to select strongest signal on restart SetOption57 - Wi-Fi network re-scan, alternate AP","title":"Wi-Fi"},{"location":"Commands/#mqtt","text":"Command Parameters ButtonRetain 0 = disable use of MQTT retain flag (default) 1 = enable MQTT retain flag on button press ButtonTopic <value> = set MQTT button topic (32 chars max) 0 = disable use of MQTT button topic 1 = set MQTT button topic to device %topic% 2 = reset MQTT button topic to firmware default ( MQTT_BUTTON_TOPIC ) (default = 0 ) If using MQTT to issue this command, if it is published to the device GroupTopic , the command will not be executed. FullTopic 1 = reset MQTT fulltopic to firmware default ( MQTT_FULLTOPIC ) and restart <value> = set MQTT fulltopic (100 chars max) and restart. Use of optional %prefix%, %topic%, %hostname%, and %id% substitution tokens is allowed. If using MQTT to issue this command, if it is published to the device GroupTopic , you must ensure uniqueness of the resulting fulltopic on each destination device by using one or more of these substitution tokens. GroupTopic<x> 1 = reset MQTT group <x> topic to firmware default ( MQTT_GRPTOPIC ) and restart <value> = set MQTT group <x> topic (32 chars max) and restart MqttClient 1 = reset MQTT client to firmware config ( MQTT_CLIENT_ID ) and restart <value> = set MQTT client (32 chars max) and restart. You can use the %06X substitution token to replace with last six characters of MAC address. If using MQTT to issue this command, if it is used with the device GroupTopic , the command will not be executed. MqttFingerprint TLS needs to be enabled in firmware for this command \u2003 \u00bb5.13.1 <value> = set current fingerprint as 20 space separated bytes (59 chars max) MqttHost 0 = clear MQTT host field and allow mDNS to find MQTT host 1 = reset MQTT host to firmware default ( MQTT_HOST ) and restart <value> = set MQTT host (32 chars max) and restart (do NOT use .local ) MqttPassword 0 = clear MQTT password 1 = reset MQTT password to firmware default ( MQTT_PASS ) and restart <value> = set MQTT password (32 chars max) and restart MqttPort 1 = reset MQTT port to firmware default ( MQTT_PORT ) and restart <value> = set MQTT port between 2 and 32766 and restart MqttRetry 10..32000 = set MQTT connection retry timer in seconds (default = 10 ) MqttUser 0 = clear MQTT user name 1 = reset MQTT user name to firmware default ( MQTT_USER ) and restart <value> = set MQTT user name (32 chars max) and restart PowerRetain MQTT power retain state 0 / off = disable MQTT power retain on status update (default) 1 / on = enable MQTT power retain on status update Prefix1 1 = reset MQTT command subscription prefix to firmware default ( SUB_PREFIX ) and restart <value> = set MQTT command subscription prefix (10 chars max) and restart Prefix2 1 = reset MQTT status prefix to firmware default ( PUB_PREFIX ) and restart <value> = set MQTT status prefix (10 chars max) and restart Prefix3 1 = Reset MQTT telemetry prefix to firmware default ( PUB_PREFIX2 ) and restart <value> = set MQTT telemetry prefix (10 chars max) and restart Publish <topic> <payload> = MQTT publish any topic and optional payload\u2003 \u00bb5.13.0 Publish2 <topic> <payload> = MQTT publish any topic and optional payload with retain flag SensorRetain 0 = disable use of sensor MQTT retain flag (default) 1 = enable MQTT retain flag on message tele/%topic%/SENSOR StateText1 <value> = set OFF state text (10 chars max) StateText2 <value> = set ON state text (10 chars max) StateText3 <value> = set TOGGLE state text (10 chars max) StateText4 <value> = set HOLD state text (10 chars max) SwitchRetain 0 = disable use of MQTT retain flag (default) 1 = enable MQTT retain flag on switch press Subscribe Subscribes to an MQTT topic and assigns an Event name to it. <eventName>, <mqttTopic> [, <key>] = Read more... = list all topics currently subscribed SwitchTopic <value> = set MQTT switch topic (32 chars max) 0 = disable use of MQTT switch topic 1 = set MQTT switch topic to device %topic% 2 = reset MQTT switch topic to firmware default ( MQTT_SWITCH_TOPIC ) (default = 0 ) Read more about this. If using MQTT to issue this command, if it is used with the device GroupTopic , the command will not be executed. TelePeriod 0 = disable telemetry messages 1 = reset telemetry period to firmware default ( TELE_PERIOD ) 10..3600 = set telemetry period in seconds (default = 300 ) Topic 1 = reset MQTT topic to firmware default ( MQTT_TOPIC ) and restart <value> = set MQTT topic (32 chars max) and ButtonTopic and restart. If using MQTT to issue this command, if it is used with the device GroupTopic , the command will not be executed. (Mqtt Topic can't be equal to Mqtt Client) Unsubscribe Unsubscribe from topics subsribed to with Subscribe = unsubscribe all topics <eventName> = unsubscribe from a specific MQTT topic See also SetOption3 - Disable//Enable MQTT SetOption4 - Return MQTT response as RESULT or %COMMAND% topic SetOption10 - Main topic change behavior","title":"MQTT"},{"location":"Commands/#rules","text":"Command Parameters Add<x> <value> = add value to Var<x> ( example ) CalcRes Current calculation resolution 0..7 = set number of decimal places to be used in Add , Sub , Mult and Scale Event Execute an event to trigger a rule as documented \u2003 \u00bb5.13.0 Mem<x> Manage up to 16 variables stored on flash (x = 1..16 ) Mem returns all current values. Mem<x> returns the variable's current value. <value> = store a string value in a variable \" = clear stored value in Mem<x> Mult<x> <value> = multiply value to Var<x> ( example ) Rule<x> Rules. Read more... 0 = disable Rule<x> 1 = enable Rule<x> 2 = toggle Rule<x> 4 = disable one-shot detection (perform commands as long as trigger is met) 5 = enable one-shot (e.g., sometimes used for slow changing sensors like temperature) detection 6 = toggle one-shot detection 8 = disable stop-on-error after exception restart 9 = enable stop-on-error after exception restart 10 = toggle stop-on-error after exception restart <value> = define Rule<x> +<value> = append to Rule<x> \" = clear Rule<x> RuleTimer<x> Up to eight timers to be used as countdown event (x = 1..8 )\u2003 \u00bb5.13.0 0..32766 = set countdown rule timer in seconds Scale<x> Scale value from a low and high limit to another low and high limits and save in Var<x> ( example ) v = value: the number to scale fl = fromLow: the lower bound of the value\u2019s current range fh = fromHigh: the upper bound of the value\u2019s current range tl = toLow: the lower bound of the value\u2019s target range th = toHigh: the upper bound of the value\u2019s target range Sub<x> <value> = subtract value to Var<x> ( example ) Var<x> Manage up to 16 variables stored in memory (x = 1..16 ) Var returns all current values. Var<x> returns the variable's current value. <string> = store a string value in a variable \" = clear stored value in Var<x>","title":"Rules"},{"location":"Commands/#timers","text":"Command Parameters Latitude <value> = set latitude Longitude <value> = set longitude Timers Timers control 0 = disable all timers 1 = enable all timers 2 = toggle all timers Timer<x> Parameters for Timer<x> where x = 1..16 0 = clear parameters for Timer<x> 1..16 = copy Timer\\<y> parameters to Timer<x> { \"name\":value ; .. } = set all or individual parameters using JSON payload with names and values of data pairs from the table Information on sensors documented below is transmitted in the Tasmota telemetry message","title":"Timers"},{"location":"Commands/#sensors","text":"Command Parameters AdcParam ADC0 analog input tuning parameters <sensor>, <param1>, <param2>, <param3>, <param4> <sensor> values: \u2003 2 = Temperature Steinhart-Hart thermistor equation parameters: <param1> = NTC Voltage bridge resistor in Ohms (default = 32000 ) <param2> = NTC Resistance in Ohms (default = 10000 ) <param3> = NTC Beta Coefficient (default = 3350 ) \u2003 3 = Light Lux equation parameters: <param1> = LDR Voltage bridge resistor in Ohms (default = 10000 ) <param2> = LDR Lux Scalar (default = 12518931 ) <param3> = LDR Lux Exponent (default = -1.4050 ) \u2003 6 = ADC linear range remapping parameters: <param1> = input range low value adcLow (default = 0 ) <param2> = input range high value adcHigh (default = 1023 ) <param3> = output range low value rangeLow (default = 0 ) <param4> = output range high value rangeHigh (default = 100 ) The range remapping perform the following calculation on the ADC value [0..1023] : Range = ((adcHigh - ADC) / (adcHigh - adcLow)) * (rangeLow - rangeHigh) + rangeHigh The calculation is performed in double resolution floating point but all 4 parameters as well as the range output are unsigned 16 bit integers. The calculation result must not exceed [0..65535]. Example to convert the ADC value on a D1-mini into millivolts (using the default resistor bridge of 220k/100k): AdcRange 6, 0, 1023, 0, 3200 Altitude -30000..30000 = altitude in meters AmpRes Current sensor resolution 0..3 = maximum number of decimal places Counter<x> 0 = reset Counter<x> 1..64900 = preset Counter<x> -1..-64900 = decrease Counter<x> +1..+64900 = increase Counter<x> In order to define and use a Counter, you must configure one of the free device GPIO as Counter<x> CounterDebounce 0 = turn off counter debounce 1..3200 = set counter debounce time in milliseconds CounterType<x> 0 = set Counter<x> as pulse Counter 1 = set Counter<x> as pulse Timer HumOffset -10.0..10.0 = Set calibraton offset value for reported humidity telemetry This setting affects all humidity sensors on the device. HumRes Humidity sensor resolution 0..3 = maximum number of decimal places PressRes Pressure sensor resolution 0..3 = maximum number of decimal places Sensor13 INA219 low voltage current sensor calibration mode Predefined modes to use with standard 0.1 ohm resistor: 0 = set INA219 calibration to max 32V and 2A 1 = set INA219 calibration to max 32V and 1A 2 = set INA219 calibration to max 16V and 0.4A 10 .. 255 : Define custom shunt resistor encoded as a decimal number RRM such that Rshunt = RR * 10^M milliohm Do not forget to choose a resistor adapted for the correct power dissipation and apply a 50% security margin ! Examples: 11 = 1 * 10^1 = 10 milliohm (Imax=32A => Pres=15W) 21 = 2 * 10^1 = 20 milliohm (Imax=16A => Pres=7W) 12 = 1 * 10^2 = 100 milliohm (default, Imax=3.2A => Pres=2W) 13 = 1 * 10^3 = 1000 milliohm = 1 ohm (Imax=0.320A => Pres=0,2W) Sensor15 Automatic Baseline Correction for MH-Z19B CO 2 sensor 0 = disabled 1 = enabled (default) 2 = disable and start manual calibration from 400 ppm of CO 2 9 = reset sensor to factory defaults 1000 = sets measurement range to 1000ppm CO 2 2000 = sets measurement range to 2000ppm CO 2 3000 = sets measurement range to 3000ppm CO 2 5000 = sets measurement range to 5000ppm CO 2 Sensor20 Nova Fitness SDS011 dust sensor. 1..255` = number of seconds before TelePeriod to poll the sensor Sensor27 APDS-9960 sensor commands 0 = enable light level and proximity sensor / disable gestures (default) 1 = enable gesture mode/ disable light level and proximity sensor 2 = enable gestures with half gain / disable light and proximity sensor 3..255 = Set ATIME register for different integration times Sensor29 MCP23008 / MCP23017 I 2 C GPIO Expander configuration. Read more... Reset<x> = reset all pins x = 1..6 1 = INPUT mode, no reporting, no pull-up 2 = INPUT mode, report on CHANGE, pull-up enabled 3 = INPUT mode, report on LOW, pull-up enabled 4 = INPUT mode, report on HIGH, pull-up enabled 5 = OUTPUT mode (if enabled by #define USE_MCP230xx_OUTPUT ) 6 = inverted OUTPUT mode (if enabled by #define USE_MCP230xx_OUTPUT ) pin,pinmode{,intpullup\\|outstate{,repmode}} Continue reading... Sensor34 HX711 load cell sensor calibration 1 = reset display to 0 2 = start calibration 2 <value> = set reference weight in grams and start calibration 3 = show reference weight in grams 3 <value> = set reference weight in grams 4 = show calibrated scale value 4 <value> = set calibrated scale value 5 = show max weight in gram 5 <value> = set max weight in grams 6 = show single item weight in grams 6 <value> = set single item weight in grams. Once the item weight is set, when items are added to the scale, the telemetry message will report Count as the number of items on the scale 7 = save current weight to be used as start weight on restart 8 0/1 \u2003 0 = disable JSON message on weight change over 4 grams \u2003 1 = enable JSON message on weight change (see below) 9 <value> = set minimum delta to trigger JSON message (see above). \u2003 0 = 4 grams (old default) \u2003 1..100 = set delta to 0-99 grams \u2003 101-255 = set delta to 110-1650 grams (10g increments) Sensor50 PAJ7620 gesture sensor 0 = sensor muted, no readings in Tasmota 1 = gesture mode 2 = proximity mode 3 = corner mode 4 = PIN mode 5 = cursor mode Sensor52 iBeacon driver with HM10 or HM17/HM16 1 and 2 = required only once to initialize the module u<x> = sets update interval in seconds (scan tags every \\<x> seconds) (default = 10) t<x> = set timeout interval in seconds (send RSSI=0 if tag is not detected after \\<x> seconds) (default = 30) d1 = enable debug mode (shows all serial traffic in console) d0 = disable debug mode_(default = 30)_ c = clears iBeacon list s AT+<command> = send native AT commands Sensor53 Smart Meter Interface r = reset the driver with a new descriptor specified with the Tasmota Scripting language. c<x> <value> = preset counter (x = 1..5 ) to value when the driver is set to counter mode d<x> = disable data decoding and dump meter (x = 1..5 ) data to the Console. This is used to decipher the meter's data format to define the variable encoding in the meter's descriptor. d0 = disable data dump mode and revert to decoding mode. Sensor54 INA226 Current Sensor 1 = rescan for devices and return the number of slaves found. 2 = save the configuration and restart 10 = return channel 1 shunt resistance and full scale current 11 <resistance> = set INA226 channel 1 shunt in ohms, floating point 12 <current> = set INA226 channel 1 full scale in amperes, floating point 20 = return channel 2 shunt resistance and full scale current 21 <resistance> = set INA226 channel 2 shunt in ohms, floating point 22 <current> = set INA226 channel 2 full scale in amperes, floating point 30 = return channel 1 shunt resistance and full scale current 31 <resistance> = set INA226 channel 1 shunt in ohms, floating point 32 <current> = set INA226 channel 1 full scale in amperes, floating point 40 = return channel 1 shunt resistance and full scale current 41 <resistance> = set INA226 channel 1 shunt in ohms, floating point 42 <current> = set INA226 channel 1 full scale in amperes, floating point Sensor60 GPS 0 = write to all available sectors, then restart and overwrite the older ones 1 = write to all available sectors, then restart and overwrite the older ones 2 = filter out horizontal drift noise 3 = turn off noise filter 4 = start recording, new data will be appended 5 = start new recording, old data will lost 6 = stop recording, download link will be visible in webUI 7 = send mqtt on new postion + TELE (consider to set TELE to a very high value) 8 = only TELE message 9 = start NTP server 10 = deactivate NTP server 11 = force update of Tasmota-system-UTC with every new GPS-time-message 12 = do not update of Tasmota-system-UTC with every new GPS-time-message 13 = set latitude and longitude in settings 14 = open virtual serial port over TCP, usable for u-center 15 = pause virtual serial port over TCP SpeedUnit TX20/TX23 anemometer speed unit 1 = m/s 2 = km/h 3 = kn 4 = mph 5 = ft/s 6 = yd/s TempRes Temperature sensor resolution 0..3 = maximum number of decimal places TempOffset -12.6..12.6 = Set calibraton offset value for reported temperature telemetry This setting affects all temperature sensors on the device. VoltRes Voltage sensor resolution 0..3 = maximum number of decimal places WattRes Power sensor resolution 0..3 = maximum number of decimal places WeightRes Load cell sensor resolution 0..3 = maximum number of decimal places See also SetOption8 - Show temperature in Celsius (default) or Fahrenheit SetOption18 - Set status of signal light paired with CO 2 sensor SetOption24 - Set pressure units","title":"Sensors"},{"location":"Commands/#power-monitoring","text":"Command Parameters AmpRes Current sensor resolution 0..3 = maximum number of decimal places CurrentCal 1100..32767 (default = 3500 ) Set calibration offset value for reported Current telemetry Allows finer calibration for HLW8012, HJL01, and BL0937 energy monitoring devices CurrentHigh 0 = disable current high threshold (default) <value> = set current high threshold value in milliamps CurrentLow 0 = disable current low threshold (default) <value> = set current low threshold value in milliamps CurrentSet <value> = calibrate current to target value in mA EnergyRes Energy sensor resolution 0..5 = maximum number of decimal places EnergyReset<x> 0..42500 (for 3 , Total, upper limit is 4250000 ) in watt-hours (Wh) x = 1..5 1 <value> = ((p)re)set values for Today 2 <value> = ((p)re)set values for Yesterday 3 <value> = ((p)re)set values for Total 4 <standard> {, <off-peak> } = ((p)re)set tariff period values for Totals 5 <standard> {, <off-peak> } = ((p)re)set tariff period values for Exported FreqRes Frequency sensor resolution 0..3 = maximum number of decimal places FrequencySet <value> = calibrate frequency to a target value in Hz MaxPower 0 = disable use maximum power monitoring <value> = set maximum allowed power in watts MaxPowerHold 1 = set default time to 10 seconds to stay over MaxPower before power off <value> = set time in seconds to stay over MaxPower before power off MaxPowerWindow 1 = set default time to 30 seconds to stay power off before re-applying power up to 5 times <value> = set time in seconds to stay power off before re-applying power up to 5 times ModuleAddress Set the address of a PZEM module 1..3 = the last octet of the PZEM-004T serial address <address> = the last octet of the slave address on MODBUS PZEM energy monitoring modules Prior to setting the module address, the PZEM must be connected to both RX and TX, and AC voltage. Connect one PZEM at a time and issue this command. Repeat for each PZEM to be connected for multi-phase monitoring. The command without an argument cannot be used to read the address of the connected PZEM. PowerCal 4000..32767 (default = 12530 ) Set calibration offset value for reported Power telemetry reading Allows finer calibration for HLW8012, HJL01, and BL0937 energy monitoring devices PowerDelta Set maximum delta for energy monitoring devices to report on active power load change while the power is ON. PowerDelta will not report when the power turns off.\u2003 \u00bb5.13.0 0 = disable reporting on power change 1..100 = set reporting on percentage power change to send an MQTT telemetry message 101..32000 = set reporting on absolute power change to send an MQTT telemetry message (offset by 100, e.g., 101 =1W, 207 =107W) PowerHigh 0 = disable power high threshold (default) <value> = set power high threshold value in watts to send an MQTT telemetry message PowerLow 0 = disable power low threshold (default) <value> = set power low threshold value in watts to send an MQTT telemetry message PowerSet <value> = calibrate power to a target value in watts\u2003 \u00bb5.12.0 Status 8 = show power usage 9 = show power thresholds Tariff<x> P1 Smart Meter tariff configuration x = 1, 2, 9 1 STD,DST Start times for off-peak tariff 2 STD,DST End times for off-peak tariff 9 0/1 \u2003 0 = use Start/End times also on weekends. \u2003 1 = use off-peak tariff all weekend. STD and DST may be specified as: \u2003 <hour> = 0..23 or \u2003 <time> = 00:00..23:59 or \u2003 <minutes> = 0..1439 (since midnight) If both Tariff1 STD and Tariff2 STD are equal, all tariffs are disabled. VoltageCal Set calibration offset value for reported Voltage telemetry reading 1000..32767 (default = 1950 ) Allows finer calibration for HLW8012, HJL01, and BL0937 energy monitoring devices VoltageHigh 0 = disable voltage high threshold (default) <value> = set voltage high threshold value in V VoltageLow 0 = disable voltage low threshold (default) <value> = set voltage low threshold value in V VoltageSet <value> = calibrate voltage to a target value in V\u2003 \u00bb5.12.0 VoltRes Voltage sensor resolution 0..3 = maximum number of decimal places WattRes Power sensor resolution 0..3 = maximum number of decimal places See Also SetOption21 - Energy monitoring when power is off SetOption33 - Configure power monitoring Max_Power_Retry count number SetOption39 - Control handling of invalid power measurements SetOption72 - Set reference used for total energy","title":"Power Monitoring"},{"location":"Commands/#light","text":"Command Parameters Channel<x> 0..100 = set PWM channel dimmer value from 0 to 100%\u2003 \u00bb5.13.0 + = increase by 10 - = decrease by 10 When SetOption68 is set to 1 Channel<x> will follow Power<x> numbering with Relays first then PWM. Example : 2 Relays and 3 PWM: Relay1 = Power1 ; Relay2 = Power2 ; PWM1 = Power3 and Channel3 ; PWM2 = Power4 and Channel4 ; PWM3 = Power5 and Channel5 Color<x> x = 1..6 \u2003 1 = Set color \u2003 2 = Set color adjusted to current Dimmer value \u2003 3 = Set clock seconds hand color ( Scheme 5 only) \u2003 4 = Set clock minutes hand color ( Scheme 5 only) \u2003 5 = Set clock hour hand color ( Scheme 5 only) \u2003 6 = Set clock hour marker color <value> r,g,b = set color by decimal value ( 0..255 ) #CWWW = set hex color value for CT lights #RRGGBB = set hex color value for RGB lights #RRGGBBWW = set hex color value for RGBW lights #RRGGBBCWWW = set hex color value for RGBCCT lights (5 PWM channels) Note : Just append an = instead of the remaining color codes, this way they wont get changed. For example a command like Color #00ff= would update the RGB part to disable red and enable geen, but would omit to update blue or any white channel. CT 153..500 = set color temperature from 153 (cold) to 500 (warm) for CT lights + = increase CT value by 10 - = decrease CT value by 10 Dimmer 0..100 = set dimmer value from 0 to 100% + = increase by 10 - = decrease by 10 Dimmer<x> Commands available only when SetOption37 >= 128 ( #6819 ) <value> same as in Dimmer Dimmer0 <value> = set dimming for all channels Dimmer1 <value> = set dimming for RGB channels Dimmer2 <value> = set dimming for white channels DimmerRange Change dimming range. Works only with TuyaMCU and PS_16_DZ serial dimmers. <dimmerMin>,<dimmerMax> = set dimming range from minimum to maximum value Does not change Dimmer command behavior Fade 0 = do not use fade (default) 1 = use fade HsbColor <hue>,<sat>,<bri> = set color by hue, saturation and brightness HsbColor1 0..360 = set hue HsbColor2 0..100 = set saturation HsbColor3 0..100 = set brightness Led<x> #RRGGBB = set hex color value where <x> is the pixel number of the LED (applies only to addressable LEDs) LedTable 0 = do not use LED gamma correction (default \u00ab6.5.0.9) 1 = use gamma correction (default \u00bb6.5.0.9) Pixels 1..512 = set amount of pixels in strip or ring and reset Rotation (applies only to addressable LEDs) RGBWWTable Control compensation of unbalanced PWM channels or White Blend Mode PWM1,PWM2,PWM3,PWM4,PWM5 = channel range with values 0..255 (default = 255,255,255,255,255 ) Range adjustment is computed after Gamma correction. Rotation <value> = set amount of pixels to rotate (up to Pixels value) (applies only to addressable LEDs) Scheme Light effects + = next scheme - = previous scheme 0 = single color for LED light (default) 1 = start wake up sequence (same as Wakeup ) 2 = cycle up through colors using Speed option 3 = cycle down through colors using Speed option 4 = random cycle through colors using Speed and Fade Use <value>, <startcolor> if you want to set the starting color of selected scheme Speed 1..40 = set fade speed from fast 1 to very slow 40 + = increase speed - = decrease speed The Speed value represents the time in 0.5s to fade from 0 to 100% (or the reverse). Example: Speed 4 takes 2.0s to fade from full brightness to black, or 0.5s to move from 75% to 100%. Wakeup Start wake up sequence from OFF to stored Dimmer value 0..100 = Start wake up sequence from OFF to provided Dimmer value WakeupDuration 1..3000 = set wake up duration in seconds White 1..100 = set white channel brightness in single white channel lights (single W or RGBW lights) Width<x> x = 1..4 1 = 0..4 = LED group width ( Scheme 6..12 only) 2 = 0..32 = seconds hand width ( Scheme 5 only) 3 = 0..32 = minutes hand width ( Scheme 5 only) 4 = 0..32 = hour hand width ( Scheme 5 only) See also SetOption15 , SetOption16 , SetOption17 , SetOption20 , SetOption37 and SetOption68","title":"Light"},{"location":"Commands/#rf-bridge","text":"Command Parameters RfCode Show last sent 24-bit user code 1..8388607 = send 24-bit user code #1..#7FFFFF = send 24-bit hexadecimal user code using RfSync, RfLow and RfHigh timing RfHigh 1 = reset high pulse time to 840 microseconds 2..32767 = set high pulse time in microseconds #2..#7FFF = set high pulse time in hexadecimal microseconds RfHost Show 16-bit host part of user code 1 = reset 16-bit host part of user code to 11802 (#2E1A) 2..32767 = set 16-bit host part of user code #2..7FFF = set 16-bit host part of user code in hexadecimal RfKey<x> Send learned or default RF data for RfKey<x> (x = 1 \u2013 16 ) 1 = send default RF data for RfKey<x> using RfSync, RfLow, RfHigh and RfHost parameters 2 = learn RF data for RfKey<x> 3 = unlearn RF data for RfKey<x> 4 = save RF data using RfSync, RfLow, RfHigh and last RfCode parameters 5 = show default or learned RF data 6 = send learned RF data RfLow 1 = reset low pulse time to 270 microseconds 2..32767 = set low pulse time in microseconds #2..#7FFF = set low pulse time in hexadecimal microseconds RfRaw This command only works when the firmware has been updated with Portisch firmware . Refer to the Portisch wiki for details. Learning and Decoding RF Codes with Portisch Firmware 0 = Set iTead default firmware support and messages (default on restart) 1 = set Portisch firmware support and messages 166 or AAA655 = start sniffing/reading RF signals disabling iTead default RF handling 167 or AAA755 = stop sniffing/reading RF signals enabling iTead default RF handling 168 or AAA855 = transmitting iTead default RF protocols 169 or AAA955 = start sniffing and learning predefined protocols 176 or AAB055 = bucket Transmitting using command 0xB0 177 or AAB155 = start Bucket sniffing using command 0xB1 192 or AAC000C055 = beep ( 00C0 is the length of the sound) 255 or AAFF55 = show Rf firmware version (result AA02FF means Version 02) <value> = hexadecimal data to be sent to RF chip. This must be immediately followed by the RfRaw 0 command (e.g., Backlog RfRaw <value>; RfRaw 0 RfSync 1 = reset start sync pulse time to 8470 microseconds 2..32767 = set start sync pulse time in microseconds #2..#7FFF = set start sync pulse time in hexadecimal microseconds See also SetOption28 - Set RF received data format","title":"RF Bridge"},{"location":"Commands/#ir-remote","text":"Command Parameters IRsend <x> Send an IR remote control code as a decimal or hexadecimal string in a JSON payload. In order to send IR data, you must configure one of the free device GPIO as IRsend (8) . GPIO01 nor GPIO03 can be used. <x> [ optional ] = number of times the IR message is sent. If not specified or 0..1 , the message is sent only once (i.e., not repeated) (default) >1 = emulate a long-press on the remote control, sending the message <x> times, or sending a repeat message for specific protocols (like NEC) {\"Protocol\":\"<value>\",\"Bits\":<value>,\"Data\":<value>} \"Protocol\" (select one of the following): \"NEC\" \"SONY\" \"RC5\" \"RC6\" \"DISH\" \"JVC\" \"PANASONIC\" \"SAMSUNG\" \"PIONEER\" \"Bits\":1..32 = required number of data bits for PANASONIC protocol this parameter is the the address, not the number of bits \"Data\":1..(2^32)-1 = data frame as 32 bit decimal. e.g., IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":2170978686} or \"Data\":0x1..0xFFFFFFFF = data frame as 32 bit hexadecimal. e.g., IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":0x8166817E} Alternatively, you can send IR remote control codes using RAW command encoding . Information on Receiving Infrared Data IRhvac Send HVAC IR remote control code as JSON payload {\"Vendor\":\"<value>\",\"Power\":<value>,\"Mode\":\u201d<value>\u201d, \"FanSpeed\":\u201d<value>\u201d,\"Temp\":<value>} \"Vendor\":\"Toshiba\"\\|\"Mitsubishi\"\\|\"LG\"\\|\"Fujitsu\" \"Power\":0\\|1 \"Mode\":\"Hot\"\\|\"Cold\"\\|\"Dry\"\\|\"Auto\" \"FanSpeed\":\"1\"\\|\"2\"\\|\"3\"\\|\"4\"\\|\"5\"\\|\"Auto\"\\|\"Silence\" \"Temp\":17..30 See also","title":"IR Remote"},{"location":"Commands/#setoptions","text":"Command Parameters SetOption0 Save power state and use after restart (=SaveState) 0 = disable 1 = enable (default) SetOption1 Set button multipress mode to 0 = allow all button actions (default) 1 = restrict to single, double and hold actions (i.e., disable inadvertent reset due to long press) SetOption3 MQTT 0 = disable MQTT 1 = enable MQTT (default) SetOption4 Return MQTT response as 0 = RESULT topic (default) 1 = %COMMAND% topic SetOption8 Show temperature in 0 = Celsius (default) 1 = Fahrenheit SetOption10 When the device MQTT topic changes 0 = remove retained message on old topic LWT (default) 1 = send \"Offline\" to old topic LWT SetOption11 Swap button single and double press functionality 0 = disabled (default) 1 = enabled SetOption12 Configuration saving to flash option 0 = allow dynamic flash save slot rotation (default) 1 = use fixed eeprom flash slot SetOption13 Allow immediate action on single button press 0 = single, multi-press and hold button actions (default) 1 = only single press action for immediate response (i.e., disable multipress detection). Disable by holding for 4 x button hold time (see SetOption32 ). SetOption15 Set PWM control for LED lights 0 = basic PWM control 1 = control with Color or Dimmer commands (default) SetOption16 Set addressable LED Clock scheme parameter 0 = clock-wise mode (default) 1 = counter-clock-wise mode SetOption17 Show Color string as 0 = hex string (default) 1 = comma-separated decimal string SetOption18 Set status of signal light paired with CO 2 sensor 0 = disable light (default) 1 = enable light The light will be green below CO2_LOW and red above CO2_HIGH (transition yellow/orange between). The default levels are: 800ppm for low and 1200ppm for high but these can be set in user_config_override.h . SetOption19 Home Assistant automatic discovery. WARNING On version 6.4.1.x enabling may cause a watchdog reset if used on a device with a configured sensor 0 = disabled (default) 1 = enabled and also sets SetOption59 1 If you enable and then disable SetOption19 , doing so does not set SetOption59 = 0 and does not revert to default %prefix%/%topic%/ FullTopic SetOption20 Update of Dimmer/Color/CT without turning power on 0 = disabled (default) 1 = enabled SetOption21 Energy monitoring when power is off 0 = disabled (default) 1 = enabled SetOption24 Set pressure units 0 = hPa (default) 1 = mmHg SetOption26 Use indexes even when only one relay is present 0 = messages use POWER (default) 1 = messages use POWER1 SetOption28 RF received data format 0 = hex (default) 1 = decimal SetOption29 IR received data format 0 = hex (default) 1 = decimal SetOption30 Enforce Home Assistant auto-discovery as light 0 = relays are announced as a switch and PWM as a light (default) 1 = both relays and PWM are announced as light SetOption31 Set status LED blinking during Wi-Fi and MQTT connection problems. LedPower must be set to 0 for this feature to work 0 = Enabled (default) 1 = Disabled SetOption32 Number of 0.1 seconds to hold button before sending HOLD action message. 1..100 to set button hold time (default = 40 ) . This option also affects the time required to perform a firmware defaults reset (10x HOLD action time) SetOption33 Number of seconds for which the maximum power limit can be exceeded before the power is turned off 1..250 = set number of seconds (default = 5 ) SetOption34 0..255 = set Backlog inter-command delay in milliseconds (default = 200 ) SetOption36 Boot loop defaults restoration control. 0 = disable boot loop control 1..200 = set number of boot loops (a restart caused by any exception or watchdog timer within less than BOOT_LOOP_TIME (default 10 seconds) before beginning to restore settings (default = 1 ) . Once this number is reached, subsequent restarts will: 1 st restart: disable ESP8285 generic GPIOs interfering with flash SPI 2 nd restart: disable rules causing boot loop 3 rd restart: disable all rules 4 th restart: reset user defined GPIOs to disable any attached peripherals 5 th restart: reset module to Sonoff Basic (1) SetOption37 Color remapping for led channels, also provides an option for allowing independent handling of RGB and white channels. Setting changes require a device reboot. 0 = disabled 1..119 = according to this table 120..127 = invalid (results in same as 0 ) 128..255 = same as 0..127 but with independent channel handling enabled SetOption38 6..255 = set IRReceive protocol detection sensitivity minimizing UNKNOWN protocols SetOption39 Control handling of invalid power measurements. Read more... 0 = reset to default on next restart 1..255 = number of invalid power readings before reporting no load (default = 128 ) . SetOption40 Stop detecting input change on the button GPIO. Solves #5449 Active only when SetOption1 1 and SetOption13 0 . This disables all long press functionality. 0..250 = button hold time in 0.1 seconds after which button functionality is disabled. (default = 1 ) Example: Backlog SetOption1 1; SetOption13 0; SetOption40 10 = discard any button press over 1 second SetOption42 0..255 = set over-temperature (Celsius only) threshold resulting in power off on all energy monitoring devices (default = 90 ) SetOption43 Deprecated in favor of DimmerRange 0..255 = set maximum dimming value ( details ) (default = 100 ) Available for Tuya and PS_16_DZ dimmers SetOption51 Enable GPIO9 and GPIO10 component selections in Module Configuration WARNING Do not use on ESP8266 devices! 0 = disable (default) 1 = enable SetOption52 Control display of optional time offset from UTC in JSON payloads 0 = disable (default) 1 = enable SetOption53 Display hostname and IP address in GUI 0 = disable (default) 1 = enable SetOption54 Apply SetOption20 settings to commands from Tuya device 0 = disable (default) 1 = enable SetOption55 mDNS service 0 = disable (default) 1 = enable SetOption56 Wi-Fi network scan to select strongest signal on restart (network has to be visible) 0 = disable (default) 1 = enable SetOption57 Wi-Fi network re-scan every 44 minutes with alternate to +10dB stronger signal if detected (only visible networks) 0 = disable (default) 1 = enable SetOption58 IR Raw data in JSON payload 0 = disable (default) 1 = enable SetOption59 Send tele/%topic%/STATE in addition to stat/%topic%/RESULT for commands: State , Power and any command causing a light to be turned on. 0 = disable (default) 1 = enable SetOption60 Set sleep mode 0 = dynamic sleep (default) 1 = normal sleep SetOption61 Force local operation when ButtonTopic or SwitchTopic is set. 0 = disable (default) 1 = enable SetOption62 Set retain on Button or Switch hold messages 0 = disable (default) 1 = don't use retain flag on HOLD messages SetOption63 Set relay state feedback scan at restart ( #5594 , #5663 ) 0 = Scan power state at restart (default) 1 = Disable power state scanning at restart SetOption64 Switch between - or _ as sensor name separator 0 = sensor name index separator is - (hyphen) (default) 1 = sensor name index separator is _ (underscore) Affects DS18X20, DHT, BMP and SHT3X sensor names in tele messages SetOption65 Device recovery using fast power cycle detection 0 = enabled (default) 1 = disabled SetOption66 Set publishing TuyaReceived to MQTT 0 = disable publishing TuyaReceived over MQTT (default) 1 = enable publishing TuyaReceived over MQTT SetOption67 iFan03 Buzzer control 0 = disable Sonoff iFan03 buzzer (default) 1 = enable Sonoff iFan03 buzzer SetOption68 Multi-channel PWM instead of a single light 0 = Treat PWM as a single light (default) 1 = Treat PWM as separate channels. In this mode, use Power<x> to turn lights on and off, and Channel<x> to change the value of each channel. Color still works to set all channels at once. Requires restart after change SetOption69 Deprecated in favor of DimmerRange By default Tuya dimmers won't dim below 10% because some don't function very well that way. 0 = disable Tuya dimmer 10% lower limit 1 = enable Tuya dimmer 10% lower limit (default) SetOption71 Set DDS238 Modbus register for active energy 0 = set primary register (default) 1 = set alternate register SetOption72 Set reference used for total energy 0 = use firmware counter (default) 1 = use energy monitor (e.g., PZEM-0xx, SDM120, SDM630, DDS238, DDSU666) hardware counter SetOption73 Deprecated in version 7.1.2.4 in favor of CORS command Set HTTP Cross-Origin Resource Sharing (CORS) 0 = disable CORS (default) 1 = enable CORS SetOption74 Enable internal pullup for single DS18x20 sensor 0 = disabled (default) 1 = internal pullup enabled SetOption75 Set grouptopic behaviour ( #6779 ) 0 = GroupTopic using FullTopic replacing %topic% (default) 1 = GroupTopic is cmnd/%grouptopic%/ SetOption76 Bootcount incrementing when DeepSleep is enabled ( #6930 ) 0 = disable bootcount incrementing (default) 1 = enable bootcount incrementing SetOption77 Do not power off if a slider is moved to far left 0 = disabled (default) 1 = enabled SetOption78 Version check on Tasmota upgrade 0 = enabled (default) 1 = disabled SetOption79 Reset counters at TelePeriod time 0 = disabled (default) 1 = enabled SetOption80 Blinds and shutters support 0 = disable blinds and shutters support (default) 1 = enable blinds and shutters support SetOption81 Set PCF8574 component behavior for all ports 0 = set as regular state (default) 1 = set as inverted state SetOption82 Reduce the CT range from 153..500 to 200.380 to accomodate with Alexa range 0 = CT ranges from 153 to 500 (default) 1 = CT ranges from 200 to 380 (although you can still set in from 153 to 500) SetOption83 Uses Zigbee device friendly name instead of 16 bits short addresses as JSON key when reporting values and commands 0 = JSON key as short address 1 = JSON key as friendly name See ZbName <device>,<name> SetOption84 (Experimental) When using AWS IoT, sends a device shadow update (alternative to retained) 0 = don't update device shadow (default) 1 = update device shadow Note: if the Topic contains '/' they are replaced with '_' SetOption85 Device group support 0 = disabled (default) 1 = enabled SetOption86 PWM Dimmer only! Turn brightness LED's off 5 seconds after last change 0 = disabled (default) 1 = enabled SetOption87 PWM Dimmer only! Turn red LED on when powered off 0 = disabled (default) 1 = enabled SetOption88 PWM Dimmer only! Buttons control remote devices 0 = disabled (default) 1 = enabled SetOption89 Configure MQTT topic for Zigbee devices (also see SensorRetain ) 0 = single tele/%topic%/SENSOR topic (default) 1 = unique device topic based on Zigbee device ShortAddr Example: tele/Zigbee/5ADF/SENSOR = {\"ZbReceived\":{\"0x5ADF\":{\"Dimmer\":254,\"Endpoint\":1,\"LinkQuality\":70}}}","title":"SetOptions"},{"location":"Commands/#serial-bridge","text":"Both hardware and software Serial Bridge are supported. Hardware Serial Bridge uses GPIO1 (Tx) and GPIO3 (Rx) or GPIO13 (Tx) and GPIO15 (Rx) pins of your device. Software Serial Bridge can use any other GPIO to be configured as components Serial Tx and Serial Rx (or SerBr Tx and SerBr Rx ). If Tx and Rx components are not assigned in the Template or Module, GPIO1 and GPIO3 will be used. Note that changing serial logging ( SerialLog 0) will disable the hardware Serial Bridge. Information received by Tasmota over the serial bridge is captured automatically. Before data will be received, a properly formatted SerialSend<x> or SSerialSend<x> command must be executed. This must be done any time the device restarts (e.g., via a System#Boot triggered rule). This command is required in order to set how the expected serial data will be formatted and interpreted (i.e., which <x> option). A {\"SSerialReceived\":{\"Data\":\"<string>\"}} message will be posted. You can use a rule to process the string which will be contained in SSerialReceived#Data . Expect possible communication errors when additional sensors are configured. Command Parameters Baudrate 1 = set hardware serial bridge to default baud rate of 115200 bps <value> = set baud rate. The set rate will be a multiple of 300. The maximum baud rate possible is 19,660,500. SBaudrate 1 = set software serial bridge to default baud rate of 9600 bps <value> = set baud rate. The set rate will be a multiple of 300. The maximum baud rate possible is 19,660,500. SerialConfig value = set serial protocol using data/parity/stop conventional notation (example: 8N1 or 702 ) 0..23 = set serial protocol ( 3 equals 8N1 ) SerialDelimiter <value> = set serial delimiter to escape character code or ASCII character 1..127 = set serial delimiter to decimal ASCII 128 = only allow ASCII characters 32 to 127 in response text 129..255 = disable serial delimiter SerialSend<x> <string> Disable serial logging and send using hardware serial x = 1..5 1 = send appending \\n (newline) () 2 = send 3 = replace escape characters and send 4 = send as binary. Data in serial response messages is encoded as hex strings 5 = send as hex. Data in serial response messages is encoded as hex strings SSerialSend<x> <string> Send using software serial protocol x = 1..5 1 = send appending \\n (newline) () 2 = send 3 = replace escape characters and send 4 = send as binary data. Data in serial response messages is encoded as hex strings 5 = send as hex. Data in serial response messages is encoded as hex strings TuyaSend<x> Send data to MCU with TuyaMCU x = 1..4 TuyaSend1 <dpId>,<boolean> = send boolean ( 0 / 1 ) data type to dpId (1 byte max length) TuyaSend2 <dpId>,<int> = send integer data to dpId (4 bytes max length) TuyaSend2 <dpId>,<0xAABBCCDD> = send 4 byte data to dpId (4 bytes max length) TuyaSend3 <dpId>,<value> = send any data type to dpId (unknown max length) TuyaSend4 <dpId>,<enum> = send enumerated ( 0 / 1 / 2 / 3 / 4 / 5 ) data type to dpId (1 byte max length)","title":"Serial Bridge"},{"location":"Commands/#domoticz","text":"Command Parameters DomoticzIdx<x> Show Domoticz Relay idx <x> (x = 1..4 ) 0 = disable use of Relay idx <x> (default) <value> = Show Relay idx <x> DomoticzKeyIdx<x> Show Domoticz Key idx <x> (x = 1..4 ) 0 = disable use of Key idx <x> (default) <value> = Show Key idx <x> (to use enable ButtonTopic ) DomoticzSensorIdx<x> Show Domoticz Sensor idx <x> (x = 1..5 ) 0 = disable use of Sensor idx <x> (default) <value> = Show Sensor idx <x> DomoticzSwitchIdx<x> Show Domoticz Switch idx <x> (x = 1..4 ) 0 = disable use of Switch idx <x> (default) <value> = Show Switch idx <x> (to use enable SwitchTopic ) DomoticzUpdateTimer Show current update timer value in seconds 0 = disable sending interim Domoticz status (default) 1..3600 = send status to Domoticz in defined intervals","title":"Domoticz"},{"location":"Commands/#knx","text":"Command Parameters KnxTx_Cmnd<x> 0 or 1 = send command using slot <x> set in KNX Menu at KNX_TX KnxTx_Val<x> <value> = send float value using slot <x> set in KNX Menu at KNX_TX KNX_ENABLED Status of KNX Communications 0 = set to Disable 1 = set to Enable KNX_ENHANCED Status of Enhanced mode for KNX Communications 0 = set to Disable 1 = set to Enable KNX_PA KNX Physical Address 0.0.0 = address not set x.x.x = set the device address (example 1.1.0 ) KNX_GA Return the amount of Group Address to Send Data/Commands configured KNX_GA<x> Setup Group Address to Send Data/Commands (<x> = KNX Group Address number) 1 = return configuration of GA<x> <option>, <area>, <line>, <member> to set configuration of GA<x> <option> = see table below for OPTION list <area>, <line>, <member> = KNX Address to Send Data/Commands KNX_CB Return the amount of Group Address to Receive Data/Commands configured KNX_CB<x> Setup Group Address to Receive Data/Commands 1 = return configuration of CB<x> <option>, <area>, <line>, <member> to set configuration of CB<x> <option> = see table below for OPTION list <area>, <line>, <member> = KNX Address to Receive Data/Commands OPTION OPTION Value OPTION OPTION Value 1 Relay 1 17 TEMPERATURE 2 Relay 2 18 HUMIDITY 3 Relay 3 19 ENERGY_VOLTAGE 4 Relay 4 20 ENERGY_CURRENT 5 Relay 5 21 ENERGY_POWER 6 Relay 6 22 ENERGY_POWERFACTOR 7 Relay 7 23 ENERGY_DAILY 8 Relay 8 24 ENERGY_START 9 Button 1 25 ENERGY_TOTAL 10 Button 2 26 KNX_SLOT1 11 Button 3 27 KNX_SLOT2 12 Button 4 28 KNX_SLOT3 13 Button 5 29 KNX_SLOT4 14 Button 6 30 KNX_SLOT5 15 Button 7 255 EMPTY 16 Button 8","title":"KNX"},{"location":"Commands/#displays","text":"Command Parameters Display Show current display setting as a JSON payload DisplayAddress 0..255 Set display module address DisplayDimmer 0 Turn the display off 1..100 Turn the display on 0..100 Set display luminosity (only on 8x8 Dot-Matrix displays) DisplayMode 0..5 Set to display predefined content according to display type DisplayModel Set display model: 1 = I 2 C LCD Display (default addresses 0x27 , 0x3F ) 2 = SSD1306 OLED 128x32/128x64 (default I 2 C addresses 0x3C , 0x3D ) 3 = HT16K33 8x8 Dot-Matrix 4 = ILI9341 TFT LCD 5 = 2.9 inch E-Paper Display 296x128 (software 3-wire SPI) 6 = 4.2 inch E-Paper Display 400x300 (software 3-wire SPI) 7 = SH1106 OLED 128x64 (default I 2 C address 0x3c ) 8 = ILI9488 TFT 480x320 (capacitive touch, hardware 3-wire SPI) 9 = SSD1351 color OLED 128x128 (hardware 3-wire SPI) 10 = RA8867 TFT LCD 1024x600 (capacitive touch, hardware 4-wire SPI) DisplayRefresh 1..7 Set time in seconds to update predefined content when using DisplayMode \u2260 0 DisplaySize 1..4 Set display scale-up size (SSD1306 and ILI9341 only) DisplayRotate Set rotation angle 0 = 0\u00b0 1 = 90\u00b0 2 = 180\u00b0 3 = 270\u00b0 DisplayText <value> = See DisplayText use DisplayCols 1..44 Set number of display columns (for display modes>0) DisplayRows 1..32 Set number of display rows (for display modes>0) DisplayFont Specify the current font 0 use classic GFX font 1 = 12 2 = 24 3 = 8 (opt) 7 use RA8876 internal font DisplayWidth Specify the display width in pixels (SSD1306 only) DisplayHeight Specify the display height in pixels (SSD1306 only)","title":"Displays"},{"location":"Commands/#stepper-motors","text":"Command Parameters MotorMIS 1,2,4,8,16 Set micro stepping increment - 1/1 (full steps) to 1/16 (default = 1 ) MotorSPR integer Set the number of steps the given motor needs for one revolution (default = 200 ) This is dependent on the type of motor and micro stepping. Most common motors are 1.8\u00b0 per step. MotorRPM 1..300 Set revolutions per minute (default = 30 ) MotorMove integer Move the motor the given number of steps (positive values: clockwise, negative values: counterclockwise) MotorRotate integer Rotate the motor the given number of degrees (positive values: clockwise, negative values: counterclockwise) MotorTurn float Spin the motor the given number of turns (positive values: clockwise, negative values: counterclockwise)","title":"Stepper Motors"},{"location":"Commands/#blinds-shutters-and-rollers","text":"Command (x = 1..4 ) Parameters ShutterButton<x> <button> <func> <mqtt> Assign a button to control the shutter. For more details please refer to Blinds and Shutters support <button> \u2003 0 : disable buttons for this shutter \u2003 1..4 : Button number <func> up / down / updown : function to assign to the button <mqtt> 1 / 0 : enable/disable MQTT publish for button hold action For example: To control shutter #1 by two buttons: Backlog ShutterButton1 1 up 1; ShutterButton1 2 down 1 assigns button #1 to act as an \"up\" button and button #2 to act as an \"down\" button for shutter #1 including MQTT publish. To control shutter #1 by a single button: ShutterButton1 1 updown 0 assigns button #1 to act as an \"up and down\" button. ShutterCalibration<x> Granular shutter position calibration. The measured opening position of the shutter at the 30, 50, 70, 90, and 100 percent opened locations. For example: ShutterCalibration<x> 23 38 56 74 82 ShutterCloseDuration<x> 1..255 (default = 10 ) time, in seconds, it takes to fully close the shutter. A fraction of a second can be specified (e.g. 45.7 ). ShutterClose<x> Engage the relay to close the shutter. This action can be requested at any time. Number of shutter can be the index or the arguement ShutterFrequency<x> 0..10,000 Hz (default = 1000 ) the maximum frequency at which the stepper motor can operate reliably. Typically this is up to 2,000Hz with a 12V power supply and up to 5,000Hz with a 24V power supply. ShutterEnableEndStopTime<x> 0 = no additional shutter end stop time (default) 1 = 1 s additional shutter end stop time ShutterInvert<x> 0 = use default shutter positioning ( 0 = Closed, 100 = Open) 1 = invert shutter positioning ( 100 = Closed, 0 = Open) (e.g., if used with KNX) ShutterInvertWebButtons<x> 0 = use default button icons (\u25b2 for open, \u25bc for close) 1 = invert button icons (\u25bc for open, \u25b2 for close) (e.g., if used with horizontal awning: where open means rolling-down fabric material and close rolling-up in a protect position) ShutterLock<x> 0 = unlock shutter positioning (default) 1 = lock shutter positioning ShutterMotorDelay<x> 0.00 .. 12.75 (default = 0 ) time, in seconds, it takes the motor to start moving once power is turned on; i.e., motor lag time. When used with stepper motors, this setting defines the ramp up/down speed (i.e., acceleration/deceleration) before the motor reaches its target speed for gradual starting and stopping. ShutterOpenDuration<x> 1..255 (default = 10 ) time, in seconds, it takes to fully open the shutter. A fraction of a second can be specified (e.g. 45.7 ). ShutterOpen<x> Engage the relay to open the shutter. This action can be requested at any time. Number of shutter can be index or the arguement ShutterPosition<x> 0..100 , UP , DOWN , STOP A shutter position change can be requested at any time. The shutter will stop and revert or update to the requested position. The shutter's actual position will be saved after the movement is completed. In this case, the position will be restored during reboot. An interruption during shutter movement (e.g., a device restart) will lose the current position. ShutterRelay<x> <value> 0 = disable this and all higher numbered shutters 1,3,5,7,... (must be an odd number) = Relay<value> component used to open the shutter. This relay's mate, the next higher numbered relay, closes the shutter. Depending on the shutter mode, the relays may need to be interlocked using the Interlock command. The ShutterRelay command must be executed first before any other shutter commands for Shutter<x> can be executed. ShutterSetClose<x> shutter closed position. ShutterPosition will be reset to fully closed value (e.g., 0 when ShutterInvert = 0 , 100 otherwise). ShutterSetHalfway<x> 0..100 (default = 50 ) Define shutter half open position (in percent) ShutterStop<x> Disengage the relays to stop the shutter. Number of shutter can be the index or the argument See also SetOption80 - Enable shutter support","title":"Blinds, Shutters and Rollers"},{"location":"Commands/#zigbee","text":"See the Complete Zigbee guide Command Parameters ZbBind Binds one Zigbee device to another device or to a groups. This allows one device to directly send commands, like a remote to a bulb, without any action on the coordinator. {\"Device\":\"<device>\", \"Endpoint\":<endpoint>, \"Cluster\":<cluster>, \"ToDevice\":\"<to_device>\", \"ToEndpoint\":<to_endpoint>, \"ToGroup\":<to_group> } \u2003 <device> = the device sending the messages (mandatory) \u2003 <endpoint> = the source endpoint (mandatory) \u2003 <cluster> = the source cluster id (mandatory) \u2003 <to_device> = the target device (optional) \u2003 <to_endpoint> = the target endpoint (optional if it can be inferred from ZbStatus3 ) \u2003 <to_group> = the target group id (optional) Note1: you must specify either \"ToDevice\" or \"ToGroup\" but not both Note2: Z2T must know the IEEE address of the target device, see ZbStatus2 to verify, and ZbProbe to have Z2T query the address ZbForget Removes a device from the Tasmota flash memory. To be used for devices that are no more used and are still visible in ZbStatus \u2003 <device> ZbLight Zigbee Hue Emulation for use with Alexa: this command sets or reads the light type to be emulated. \u2003 <device>,<light_type> sets the light type \u2003 <device>,-1 removes the device from Philips Hue emulation \u2003 <device> displays the current status of the Light (Z2T tracks all changes to the light) Light_type is a integer 0..5 corresponding to the number of channels (from On/Off to RGBCW) ZbName Sets or reads the Zigbee device friendly name (up to 32 characters). \u2003 <device>,<name> sets the new friendly name \u2003 <device>, (empty name) clears the friendly name \u2003 <device> displays the current friendly name See SetOption83 1 to enable friendly names as JSON keys instead of short addresses ZbPermitJoin Sets new device pairing mode 0 = disable pairing 1 = enable pairing for 60 seconds 99 = enable pairing until device reboot Leaving your Zigbee network pairing open to join will allow any Zigbee device to connect and retrieve your network encryption key. This can lead to a compromise of your Zigbee network. ZbPing Test the availability of a Zigbee device. If the device is connected and not sleeping, you should receive a ZbPing message within the next second. \u2003 <device> Ex: ZbPing 0x5ADF {\"ZbPing\":{\"Device\":\"0x5ADF\",\"IEEEAddr\":\"0x90FD9FFFFE03B051\"}} ZbSend {\"Device\":\"<shortaddr>\", \"Endpoint\":\"<endpoint>\", \"Send\":{\"<sendcmd>\":<sendparam>}} \u2003 <shortaddr> the short address of the Zigbee device on the network. \u2003 <endpoint> the target endpoint on the device ( understandig endpoints ) \u2003 \"<sendcmd>\":<sendparam> the command and parameters to send ( Zigbee Device Commands ) Note: Use ZbZNPSend to send a raw form low-level message Ex: ZigbeeSend { \"Device\":\"0x1234\", \"Endpoint\":\"0x03\", \"Send\":{\"Power\":\"on\"} } ZbStatus<x> Display Zigbee devices seen on the network since boot <device> (optional) = all devices This command provides three levels of increasing detail according to <x> ZbStatus1 Display Short Address, and Friendly Name ZbStatus2 Also include Manufacturer ID and Model ID ZbStatus3 Also include a list of endpoints and the clusterIds supported by each endpoint Ex: ZbStatus3 1 requests all details for device number 1 The information requested may exceed the maximum result size allowed by Tasmota. In this case, the output will be truncated. To get all of the desired information, request results for a specific device individually.","title":"Zigbee"},{"location":"Commands/#hm-1x","text":"Command Parameters HM10Scan Start a new device discovery scan HM10Period Show interval in seconds between sensor read cycles. Set to TelePeriod value at boot. HM10Baud Show ESP8266 serial interface baudrate ( Not HM-10 baudrate ) <value> = set baudrate HM10AT <command> = send AT commands to HM-10. See list HM10Time <n> = set time time of a LYWSD02 only sensor to Tasmota UTC time and timezone. <n> is the sensor number in order of discovery starting with 0 (topmost sensor in the webUI list). HM10Auto <value> = start an automatic discovery scan with an interval of <value> seconds to receive data in BLE advertisements periodically. This is an active scan and it should be used only if necessary . At the moment that is the case just with MJ_HT_V1. This can change if a future HM-10 firmware starts supporting passive scan.","title":"HM-1x"},{"location":"Commands/#mp3-player","text":"The MP3 Player driver is based on the one from DFRobot. They named it DFPlayer mini . All MP3 Players with the identical Serial Control Command structure can be used. Command Parameters MP3DAC 0 = DAC on (default) 1 = DAC off MP3Device Specify playback device 1 = USB 2 = SD Card (default (also defaults on reset or power cycle)) MP3EQ Set equalizer mode: 0 = normal 1 = pop 2 = rock 3 = jazz 4 = classic 5 = bass) MP3Pause Pause MP3Play Play, works as a normal play on a real MP3 Player, starts at first MP3 file MP3Reset Reset the MP3 player to defaults MP3Stop Stop MP3Track x = play track <x> MP3Volume 0..100 = set Volume","title":"MP3 Player"},{"location":"Compile-your-build/","text":"Flash and memory space on an ESP82XX chip is limited and very valuable. Because of that our precompiled binaries include the most popular features of Tasmota but no build can include all of them. To include a feature you need (or build completely customized Tasmota) you will have to configure and compile your own version. First you will need Tasmota's source code (either development or master branch) and a compiling tool. Compiling Tools ~ If you want to modify the code or default settings you can use: PlatformIO - setup and configure PlatformIO for Tasmota compilation and upload PlatformIO CLI - how to flash Tasmota using the PlatformIO command line interface on Linux PlatformIO-Core - automate firmware builds using PlatformIO-Core and flash with esptool Visual Studio Code - setup and configure Visual Studio Code with PlatformIO for Tasmota Atom - beginner guide building Tasmota firmware using Atom with PlatformIO plugin Arduino IDE - setup and configure Arduino IDE for Tasmota compilation and upload Docker Tasmota - compile from a Docker container using PlatformIO Online Compilers Can only create a firmware binary. Use one of the tools to flash it to your device. Gitpod - compile your own binary in the cloud using Gitpod . TasmoCompiler - simple web GUI to compile Tasmota with your own settings Simplest way to compile is with GitPod , requires only a web browser. Once you have set up the development environment, unzip the source code into a folder. Navigate to where you unpacked Tasmota and into /tasmota folder. Open my_user_config.h and uncomment (remove // ) line with #define USE_CONFIG_OVERRIDE . It should look like this: #define USE_CONFIG_OVERRIDE // Uncomment to use user_config_override.h file. See README.md In PlatformIO you can edit platformio_override.ini instead. Go to root directory of source code, rename platformio_override_sample.ini to platformio_override.ini. By doing this you enable the settings done in this file. By default the file user_config_override.h is enabled and to build the standard tasmota variant. Create a new file in /tasmota folder called user_config_override.h . Open the file in chosen development environment for editing. Enter lines required to enable or disable desired feature. All features and their identifier can be found in my_user_config.h . Best practice to enable a feature is to use #ifndef %identifier% #define %identifier% #endif Directives Description #define %identifier% enables the feature #undef %identifier% disables the feature #ifdef %identifier% checks if the feature is defined in code #ifndef %identifier% checks if the feature is not defined #endif closes #if statement Example: enable blinds and shutters support #ifndef USE_SHUTTER #define USE_SHUTTER // Add Shutter support for up to 4 shutter with different motortypes (+6k code) #endif identifier = USE_SHUTTER check whether USE_SHUTTER is already defined and proceed if it is not this line copied from my_user_config.h then uncommented, tells the compiler to include (#define) shutter support close the IF statement from line 1 Example: disable Domoticz support #ifdef USE_DOMOTICZ #undef USE_DOMOTICZ #endif identifier = USE_DOMOTICZ check whether USE_DOMOTICZ is already defined and proceed if it is tell the compiler to remove (#undef) Domoticz support close the IF statement from line 1 It is not recommended to change my_user_config.h , use it only for reference Save file, compile the custom binary and flash it Note There are limits to how many features can be included! If you go overboard code might not compile due to features conflicting or might not be able to be flashed if it exceeds ESP8266 limits .","title":"Compiling"},{"location":"Compile-your-build/#compiling-tools","text":"If you want to modify the code or default settings you can use: PlatformIO - setup and configure PlatformIO for Tasmota compilation and upload PlatformIO CLI - how to flash Tasmota using the PlatformIO command line interface on Linux PlatformIO-Core - automate firmware builds using PlatformIO-Core and flash with esptool Visual Studio Code - setup and configure Visual Studio Code with PlatformIO for Tasmota Atom - beginner guide building Tasmota firmware using Atom with PlatformIO plugin Arduino IDE - setup and configure Arduino IDE for Tasmota compilation and upload Docker Tasmota - compile from a Docker container using PlatformIO","title":"Compiling Tools"},{"location":"Components/","text":"Component is anything wired to the ESP8266/ESP8255 chip to be controlled by or send data to it. Components can be: buttons, switches, relays, LEDs, sensors, displays, MCU units, etc. Every component is assigned in the device template to the GPIO it is wired (connected) to. Every Tasmota device has some components configured by default. Most often there is a relay, a button and a LED configured as is the case for a Sonoff Basic in the following image. Tip GPIOs configured as User (255) are the GPIOs that can be assigned to components in the Configure Module page. Assigning Components ~ If you wish to expand a device with a peripheral component, after properly wiring everything, you need to assign it to a free GPIO in Configure Module page or use command GPIO<x> . Read more about peripherals . Components List ~ Google Sheet of components by number and alphabetically # Name Description 255 User GPIO configurable in modules 0 None Not used 1 DHT11 DHT11 sensor 2 AM2301 AM230X, DHT21 and DHT22 sensor 3 SI7021 Only for Sonoff Si7021, not the i2c version 4 DS18x20 Dallas Semiconductor DS18b20 1-Wire temperature sensor 5 I2C SCL I2C serial clock pin, used with any I2C component (sensors, displays, ...) 6 I2C SDA I2C serial data pin, used with any I2C component (sensors, displays, ...) 7 WS2812 Addressable LEDs such as WS281X or Neopixel 8 IRsend IR Transmitter LED 9 Switch1 Switch 10 Switch2 Switch 11 Switch3 Switch 12 Switch4 Switch 13 Switch5 Switch 14 Switch6 Switch 15 Switch7 Switch 16 Switch8 Switch 17 Button1 Button 18 Button2 Button 19 Button3 Button 20 Button4 Button 21 Relay1 Relay 22 Relay2 Relay 23 Relay3 Relay 24 Relay4 Relay 25 Relay5 Relay 26 Relay6 Relay 27 Relay7 Relay 28 Relay8 Relay 29 Relay1i Relay inverted 30 Relay2i Relay inverted 31 Relay3i Relay inverted 32 Relay4i Relay inverted 33 Relay5i Relay inverted 34 Relay6i Relay inverted 35 Relay7i Relay inverted 36 Relay8i Relay inverted 37 PWM1 Pulse Width Modulated Output 38 PWM2 Pulse Width Modulated Output 39 PWM3 Pulse Width Modulated Output 40 PWM4 Pulse Width Modulated Output 41 PWM5 Pulse Width Modulated Output 42 Counter1 Counter Input 43 Counter2 Counter Input 44 Counter3 Counter Input 45 Counter4 Counter Input 46 PWM1i Pulse Width Modulated inverted Output 47 PWM2i Pulse Width Modulated inverted Output 48 PWM3i Pulse Width Modulated inverted Output 49 PWM4i Pulse Width Modulated inverted Output 50 PWM5i Pulse Width Modulated inverted Output 51 IRrecv IR Receiver Input (for example TSOP1838) 52 Led1 LED 53 Led2 LED 54 Led3 LED 55 Led4 LED 56 Led1i Inverted LED - default state ON 57 Led2i Inverted LED - default state ON 58 Led3i Inverted LED - default state ON 59 Led4i Inverted LED - default state ON 60 MHZ Rx MHZ 19 CO2 Sensor 61 MHZ Tx MHZ 19 CO2 Sensor 62 PZEM0XX Tx Peacefair Pzem-0XX Power Meter Tx pin 63 PZEM004 Rx Peacefair Pzem-004 Power Meter Rx pin 64 SAir Rx Sensor Senseair 65 SAir Tx Sensor Senseair 66 SPI CS SPI Interface (ePaper Display) 67 SPI DC SPI Interface (ePaper Display) 68 BkLight Backlight (Display) 69 PMS5003 PMS5003 Air Quality Sensor 70 SDS0X1 Rx Nova Fitness SDS011 Laser Dust Sensor Rx pin 71 SerBr Rx Serial Bridge Receive 72 SerBr Tx Serial Bridge Transmit 73 SR04 Tri Ultrasonic Sensor HC-SR04 Trigger pin 74 SR04 Ech Ultrasonic Sensor HC-SR04 Echo pin 75 SDMx20 Tx SDMx20-Modbus Multifunction Power Analyser Tx pin 76 SDMx20 Rx SDMx20-Modbus Multifunction Power Analyser Rx pin 77 SDM630 Tx SDM630-Modbus Multifunction Power Analyser Tx pin 78 SDM630 Rx SDM630-Modbus Multifunction Power Analyser Rx pin 79 TM16 CLK TM1638 Switch Module 80 TM16 DIO TM1638 Switch Module 81 TM16 STB TM1638 Switch Module 82 Switch1n Switch, no pullup resistor 83 Switch2n Switch, no pullup resistor 84 Switch3n Switch, no pullup resistor 85 Switch4n Switch, no pullup resistor 86 Switch5n Switch, no pullup resistor 87 Switch6n Switch, no pullup resistor 88 Switch7n Switch, no pullup resistor 89 Switch8n Switch, no pullup resistor 90 Button1n Button, no pullup resistor 91 Button2n Button, no pullup resistor 92 Button3n Button, no pullup resistor 93 Button4n Button, no pullup resistor 94 Counter1n Counter sensor, no pullup resistor 95 Counter2n Counter sensor, no pullup resistor 96 Counter3n Counter sensor, no pullup resistor 97 Counter4n Counter sensor, no pullup resistor 98 PZEM016 Rx Peacefair Pzem-016 Power Meter Rx pin 99 PZEM017 Rx Peacefair Pzem-017 Power Meter Rx pin 100 MP3 Player DF MP3 Player mini (Input) 101 SDS0X1 Tx Nova Fitness SDS011 Laser Dust Sensor Tx pin 102 HX711 SCK HX711 weight sensor serial clock input 103 HX711 DAT HX711 weight sensor data output 104 TX20 TX20 Wind Sensor Input (Tx from sensor) 105 RFSend RF Emitter (433Mhz module needed; Requires self-compile with RF_SENSOR and USE_RC_SWITCH) 106 RFrecv RF Receiver (433Mhz module needed; Requires self-compile with RF_SENSOR and USE_RC_SWITCH) 107 Tuya Tx Tuya Transfer pin 108 Tuya Rx Tuya Receive pin 109 MGC3130 Xfr MGC3130 E-field Xfr pin 110 MGC3130 Rst MGC3130 E-field Reset pin 111 SSPI MISO Software SPI MISO (Display) 112 SSPI MOSI Software SPI MOSI (Display) 113 SSPI SCLK Software SPI SCLK (Display) 114 SSPI CS Software SPI CS (Display) 115 SSPI DC Software SPI DC (Display) 116 RF Sensor Theo Arendst RF433 Sensor 117 AZ Rx AZ 7798 CO2 datalogger 118 AZ Tx AZ 7798 CO2 datalogger 119 MX31855 CS MAX31855 Thermocouple Sensor Chip Select pin 120 MX31855 CLK MAX31855 Thermocouple Sensor Serial Clock pin 121 MX31855 DO MAX31855 Thermocouple Sensor Digital Output pin 122 Button1i Button inverted 123 Button2i Button inverted 124 Button3i Button inverted 125 Button4i Button inverted 126 Button1in Button inverted, no pullup resistor 127 Button2in Button inverted, no pullup resistor 128 Button3in Button inverted, no pullup resistor 129 Button4in Button inverted, no pullup resistor 130 HLWBL SEL Energy Monitoring (for example Pow) 131 HLWBL SELi Energy Monitoring (for example Pow) 132 HLWBL CF1 Energy Monitoring (for example Pow) 133 HLW8012 CF HLW8012 Single Phase Energy Monitor Chip CF pin 134 BL0937 CF BL0937 Single Phase Energy Monitor Chip CF pin 135 MCP39F5 Tx Energy Monitoring (for example Shelly2) 136 MCP39F5 Rx Energy Monitoring (for example Shelly2) 137 MCP39F5 Rst Energy Monitoring (for example Shelly2) 138 PN532 Tx PN532 RFID/NFC Reader Tx pin 139 PN532 Rx PN532 RFID/NFC Reader Rx pin 140 SM16716 CLK SM16716 Pixel LED Serial Clock pin 141 SM16716 DAT SM16716 Pixel LED Data pin 142 SM16716 PWR SM16716 Pixel LED Power pin 143 MY92x1 DI Light Bulb with MY92x controller 144 MY92x1 DCKI Light Bulb with MY92x controller 145 CSE7766 Tx CSE7766 Single Phase Energy Monitor Chip Tx pin 146 CSE7766 Rx CSE7766 Single Phase Energy Monitor Chip Rx pin 147 ALux IrRcv AriLux RGB Controller IR receive (Input) 148 Serial Tx Serial Transfer pin 149 Serial Rx Serial Receive pin 150 Rotary1a Rotary Encoder (Mi Desk Lamp) 151 Rotary1b Rotary Encoder (Mi Desk Lamp) 152 Rotary1c Rotary Encoder (Mi Desk Lamp) 153 Rotary1d Rotary Encoder (Mi Desk Lamp) 154 HRE CLOCK Clock/Power line for HR-E Water Meter 155 HRE DATA Data line for HR-E Water Meter 156 ADE7953_IRQ ADE7953 IRQ 157 LedLink Device Status LED 158 LedLinki Device Status LED, inverted 159 ALux IrSel For AriLux devices - switches between IR/RF mode 160 Buzzer Sonoff iFan03 Buzzer 161 Buzzeri Sonoff iFan03 Buzzer inverted 162 OLED Reset OLED Display Reset 163 SolaxX1 Tx Solax Inverter Tx pin 164 SolaxX1 Rx Solax Inverter Rx pin 165 Zigbee Tx Zigbee Serial interface Tx 166 Zigbee Rx Zigbee Serial interface Rx 167 RDM6300 Rx RDM6300 RX 168 iBeacon Tx HM17 iBeacon Tx 169 iBeacon Rx HM17 iBeacon Rx 170 A4988 DIR A4988 Motor Direction 171 A4988 STP A4988 Step motor 172 A4988 ENA A4988 Enable motor 173 A4988 MS1 A4988 Microstep increment select pin1 174 A4988 MS2 A4988 Microstep increment select pin2 175 A4988 MS3 A4988 Microstep increment select pin3 176 DDS238-2 Tx DDS2382 Serial interface Tx 177 DDS238-2 Rx DDS2382 Serial interface Rx 178 DDSU666 Tx DDSU666 Serial interface Tx 179 DDSU666 Rx DDSU666 Serial interface Rx 180 SM2135 CLK SM2135 Clk 181 SM2135 DAT SM2135 Dat 182 DeepSleep DeepSleep wake switch 183 EXS Enable EXS Dimmer MCU Enable 184 Slave TX TasmotaSlave TX 185 Slave RX TasmotaSlave RX 186 Slave RST TasmotaSlave Reset Pin 187 Slave RSTi TasmotaSlave Reset Inverted 188 HPMA RX Honeywell HPMA115S0 Serial Rx 189 HPMA TX Honeywell HPMA115S0 Serial Tx 190 GPS RX GPS Serial Tx 191 GPS TX GPS Serial Tx 192 DSB OUT Pseudo Single wire DS18B20 or DS18S20 193 DHT11 OUT Pseudo Single wire DHT11, DHT21, DHT22, AM2301, AM2302, AM2321 194 HM10 RX HM10-BLE-Mijia-bridge Serial 195 HM10 TX HM10-BLE-Mijia-bridge Serial 196 LE01MR RX F&F LE-01MR Energy Meter Serial 197 LE01MR TX F&F LE-01MR Energy Meter Serial 198 CC1101 GDO0 CC1101 RX Pin 199 CC1101 GDO2 CC1101 TX Pin 200 HRXL RX Data from MaxBotix HRXL sonar range sensor 201 MOODL TX ElectriQ iQ-wifiMOODL Serial TX","title":"Components"},{"location":"Components/#assigning-components","text":"If you wish to expand a device with a peripheral component, after properly wiring everything, you need to assign it to a free GPIO in Configure Module page or use command GPIO<x> . Read more about peripherals .","title":"Assigning Components"},{"location":"Components/#components-list","text":"Google Sheet of components by number and alphabetically # Name Description 255 User GPIO configurable in modules 0 None Not used 1 DHT11 DHT11 sensor 2 AM2301 AM230X, DHT21 and DHT22 sensor 3 SI7021 Only for Sonoff Si7021, not the i2c version 4 DS18x20 Dallas Semiconductor DS18b20 1-Wire temperature sensor 5 I2C SCL I2C serial clock pin, used with any I2C component (sensors, displays, ...) 6 I2C SDA I2C serial data pin, used with any I2C component (sensors, displays, ...) 7 WS2812 Addressable LEDs such as WS281X or Neopixel 8 IRsend IR Transmitter LED 9 Switch1 Switch 10 Switch2 Switch 11 Switch3 Switch 12 Switch4 Switch 13 Switch5 Switch 14 Switch6 Switch 15 Switch7 Switch 16 Switch8 Switch 17 Button1 Button 18 Button2 Button 19 Button3 Button 20 Button4 Button 21 Relay1 Relay 22 Relay2 Relay 23 Relay3 Relay 24 Relay4 Relay 25 Relay5 Relay 26 Relay6 Relay 27 Relay7 Relay 28 Relay8 Relay 29 Relay1i Relay inverted 30 Relay2i Relay inverted 31 Relay3i Relay inverted 32 Relay4i Relay inverted 33 Relay5i Relay inverted 34 Relay6i Relay inverted 35 Relay7i Relay inverted 36 Relay8i Relay inverted 37 PWM1 Pulse Width Modulated Output 38 PWM2 Pulse Width Modulated Output 39 PWM3 Pulse Width Modulated Output 40 PWM4 Pulse Width Modulated Output 41 PWM5 Pulse Width Modulated Output 42 Counter1 Counter Input 43 Counter2 Counter Input 44 Counter3 Counter Input 45 Counter4 Counter Input 46 PWM1i Pulse Width Modulated inverted Output 47 PWM2i Pulse Width Modulated inverted Output 48 PWM3i Pulse Width Modulated inverted Output 49 PWM4i Pulse Width Modulated inverted Output 50 PWM5i Pulse Width Modulated inverted Output 51 IRrecv IR Receiver Input (for example TSOP1838) 52 Led1 LED 53 Led2 LED 54 Led3 LED 55 Led4 LED 56 Led1i Inverted LED - default state ON 57 Led2i Inverted LED - default state ON 58 Led3i Inverted LED - default state ON 59 Led4i Inverted LED - default state ON 60 MHZ Rx MHZ 19 CO2 Sensor 61 MHZ Tx MHZ 19 CO2 Sensor 62 PZEM0XX Tx Peacefair Pzem-0XX Power Meter Tx pin 63 PZEM004 Rx Peacefair Pzem-004 Power Meter Rx pin 64 SAir Rx Sensor Senseair 65 SAir Tx Sensor Senseair 66 SPI CS SPI Interface (ePaper Display) 67 SPI DC SPI Interface (ePaper Display) 68 BkLight Backlight (Display) 69 PMS5003 PMS5003 Air Quality Sensor 70 SDS0X1 Rx Nova Fitness SDS011 Laser Dust Sensor Rx pin 71 SerBr Rx Serial Bridge Receive 72 SerBr Tx Serial Bridge Transmit 73 SR04 Tri Ultrasonic Sensor HC-SR04 Trigger pin 74 SR04 Ech Ultrasonic Sensor HC-SR04 Echo pin 75 SDMx20 Tx SDMx20-Modbus Multifunction Power Analyser Tx pin 76 SDMx20 Rx SDMx20-Modbus Multifunction Power Analyser Rx pin 77 SDM630 Tx SDM630-Modbus Multifunction Power Analyser Tx pin 78 SDM630 Rx SDM630-Modbus Multifunction Power Analyser Rx pin 79 TM16 CLK TM1638 Switch Module 80 TM16 DIO TM1638 Switch Module 81 TM16 STB TM1638 Switch Module 82 Switch1n Switch, no pullup resistor 83 Switch2n Switch, no pullup resistor 84 Switch3n Switch, no pullup resistor 85 Switch4n Switch, no pullup resistor 86 Switch5n Switch, no pullup resistor 87 Switch6n Switch, no pullup resistor 88 Switch7n Switch, no pullup resistor 89 Switch8n Switch, no pullup resistor 90 Button1n Button, no pullup resistor 91 Button2n Button, no pullup resistor 92 Button3n Button, no pullup resistor 93 Button4n Button, no pullup resistor 94 Counter1n Counter sensor, no pullup resistor 95 Counter2n Counter sensor, no pullup resistor 96 Counter3n Counter sensor, no pullup resistor 97 Counter4n Counter sensor, no pullup resistor 98 PZEM016 Rx Peacefair Pzem-016 Power Meter Rx pin 99 PZEM017 Rx Peacefair Pzem-017 Power Meter Rx pin 100 MP3 Player DF MP3 Player mini (Input) 101 SDS0X1 Tx Nova Fitness SDS011 Laser Dust Sensor Tx pin 102 HX711 SCK HX711 weight sensor serial clock input 103 HX711 DAT HX711 weight sensor data output 104 TX20 TX20 Wind Sensor Input (Tx from sensor) 105 RFSend RF Emitter (433Mhz module needed; Requires self-compile with RF_SENSOR and USE_RC_SWITCH) 106 RFrecv RF Receiver (433Mhz module needed; Requires self-compile with RF_SENSOR and USE_RC_SWITCH) 107 Tuya Tx Tuya Transfer pin 108 Tuya Rx Tuya Receive pin 109 MGC3130 Xfr MGC3130 E-field Xfr pin 110 MGC3130 Rst MGC3130 E-field Reset pin 111 SSPI MISO Software SPI MISO (Display) 112 SSPI MOSI Software SPI MOSI (Display) 113 SSPI SCLK Software SPI SCLK (Display) 114 SSPI CS Software SPI CS (Display) 115 SSPI DC Software SPI DC (Display) 116 RF Sensor Theo Arendst RF433 Sensor 117 AZ Rx AZ 7798 CO2 datalogger 118 AZ Tx AZ 7798 CO2 datalogger 119 MX31855 CS MAX31855 Thermocouple Sensor Chip Select pin 120 MX31855 CLK MAX31855 Thermocouple Sensor Serial Clock pin 121 MX31855 DO MAX31855 Thermocouple Sensor Digital Output pin 122 Button1i Button inverted 123 Button2i Button inverted 124 Button3i Button inverted 125 Button4i Button inverted 126 Button1in Button inverted, no pullup resistor 127 Button2in Button inverted, no pullup resistor 128 Button3in Button inverted, no pullup resistor 129 Button4in Button inverted, no pullup resistor 130 HLWBL SEL Energy Monitoring (for example Pow) 131 HLWBL SELi Energy Monitoring (for example Pow) 132 HLWBL CF1 Energy Monitoring (for example Pow) 133 HLW8012 CF HLW8012 Single Phase Energy Monitor Chip CF pin 134 BL0937 CF BL0937 Single Phase Energy Monitor Chip CF pin 135 MCP39F5 Tx Energy Monitoring (for example Shelly2) 136 MCP39F5 Rx Energy Monitoring (for example Shelly2) 137 MCP39F5 Rst Energy Monitoring (for example Shelly2) 138 PN532 Tx PN532 RFID/NFC Reader Tx pin 139 PN532 Rx PN532 RFID/NFC Reader Rx pin 140 SM16716 CLK SM16716 Pixel LED Serial Clock pin 141 SM16716 DAT SM16716 Pixel LED Data pin 142 SM16716 PWR SM16716 Pixel LED Power pin 143 MY92x1 DI Light Bulb with MY92x controller 144 MY92x1 DCKI Light Bulb with MY92x controller 145 CSE7766 Tx CSE7766 Single Phase Energy Monitor Chip Tx pin 146 CSE7766 Rx CSE7766 Single Phase Energy Monitor Chip Rx pin 147 ALux IrRcv AriLux RGB Controller IR receive (Input) 148 Serial Tx Serial Transfer pin 149 Serial Rx Serial Receive pin 150 Rotary1a Rotary Encoder (Mi Desk Lamp) 151 Rotary1b Rotary Encoder (Mi Desk Lamp) 152 Rotary1c Rotary Encoder (Mi Desk Lamp) 153 Rotary1d Rotary Encoder (Mi Desk Lamp) 154 HRE CLOCK Clock/Power line for HR-E Water Meter 155 HRE DATA Data line for HR-E Water Meter 156 ADE7953_IRQ ADE7953 IRQ 157 LedLink Device Status LED 158 LedLinki Device Status LED, inverted 159 ALux IrSel For AriLux devices - switches between IR/RF mode 160 Buzzer Sonoff iFan03 Buzzer 161 Buzzeri Sonoff iFan03 Buzzer inverted 162 OLED Reset OLED Display Reset 163 SolaxX1 Tx Solax Inverter Tx pin 164 SolaxX1 Rx Solax Inverter Rx pin 165 Zigbee Tx Zigbee Serial interface Tx 166 Zigbee Rx Zigbee Serial interface Rx 167 RDM6300 Rx RDM6300 RX 168 iBeacon Tx HM17 iBeacon Tx 169 iBeacon Rx HM17 iBeacon Rx 170 A4988 DIR A4988 Motor Direction 171 A4988 STP A4988 Step motor 172 A4988 ENA A4988 Enable motor 173 A4988 MS1 A4988 Microstep increment select pin1 174 A4988 MS2 A4988 Microstep increment select pin2 175 A4988 MS3 A4988 Microstep increment select pin3 176 DDS238-2 Tx DDS2382 Serial interface Tx 177 DDS238-2 Rx DDS2382 Serial interface Rx 178 DDSU666 Tx DDSU666 Serial interface Tx 179 DDSU666 Rx DDSU666 Serial interface Rx 180 SM2135 CLK SM2135 Clk 181 SM2135 DAT SM2135 Dat 182 DeepSleep DeepSleep wake switch 183 EXS Enable EXS Dimmer MCU Enable 184 Slave TX TasmotaSlave TX 185 Slave RX TasmotaSlave RX 186 Slave RST TasmotaSlave Reset Pin 187 Slave RSTi TasmotaSlave Reset Inverted 188 HPMA RX Honeywell HPMA115S0 Serial Rx 189 HPMA TX Honeywell HPMA115S0 Serial Tx 190 GPS RX GPS Serial Tx 191 GPS TX GPS Serial Tx 192 DSB OUT Pseudo Single wire DS18B20 or DS18S20 193 DHT11 OUT Pseudo Single wire DHT11, DHT21, DHT22, AM2301, AM2302, AM2321 194 HM10 RX HM10-BLE-Mijia-bridge Serial 195 HM10 TX HM10-BLE-Mijia-bridge Serial 196 LE01MR RX F&F LE-01MR Energy Meter Serial 197 LE01MR TX F&F LE-01MR Energy Meter Serial 198 CC1101 GDO0 CC1101 RX Pin 199 CC1101 GDO2 CC1101 TX Pin 200 HRXL RX Data from MaxBotix HRXL sonar range sensor 201 MOODL TX ElectriQ iQ-wifiMOODL Serial TX","title":"Components List"},{"location":"Configuration-Procedure-for-New-Devices/","text":"If your device is not a built-in module listed in the module configuration menu, a user contributed device template ( explanation ) may be available. Otherwise, follow this procedure for configuring the ESP chip pins used by your device. Some smart devices have additional functionality which may be handled by codes sent to a separate MCU in the device. Devices with functions offloaded to a separate MCU require additional coding in the software or via rules. Certain supported Tasmota BASE devices have built-in code to handle MCU controlled devices. Using a template with an appropriate BASE device may have the programming logic required to manage the MCU commands for your device. If an existing BASE device with the logic for your device is not available, a modified device driver will be required. This case is outside of the scope of this article. If your device is similar to the existing built-in module (e.g., a particular MCU or power monitoring algorithm) it is best to use that as a starting point. When you are not sure which module is suitable for your device, use Generic module (18) . Begin this procedure by disabling power state saves. Some improper GPIO assignments can cause device reboots. Disabling this setting avoids repeated flash writes. Also, it is best to allow Tasmota to return to a fail safe state in case of a bad configuration. Ensure that boot loop control is not disabled. Backlog SetOption0 0; SetOption36 1 Assign every available GPIO to successive Relay<x> components. For the initial GPIO probe, exclude \"dedicated\" GPIO such as GPIO0/GPIO2 and Tx/Rx, etc. You can use a Template to easily perform these assignments: {\"NAME\":\"ID Components\",\"GPIO\":[0,0,0,0,21,22,0,0,23,24,25,26,27],\"FLAG\":0,\"BASE\":18} a. Save the configuration. Once the device reboots, use the virtual buttons on the web UI to find which of the assigned GPIO actually control the physical relays and LEDs on the device. Make note of which GPIO act on which device peripheral. - If you are unable to control some of the relays or LEDs on the device, they may be attached to the \"dedicated\" GPIO skipped in the initial probe. Now assign those GPIO: {\"NAME\":\"ID Components\",\"GPIO\":[21,22,23,24,0,0,0,0,0,0,0,0,0],\"FLAG\":0,\"BASE\":18} - Repeat step 2a . - If you device is based on the ESP8285 and you are still unable to control some of the relays or LEDs on the device, they may be attached to GPIO9 or GPIO10. Now assign those remaining GPIO: {\"NAME\":\"ID Components\",\"GPIO\":[0,0,0,0,0,0,21,22,0,0,0,0,0],\"FLAG\":0,\"BASE\":18} - Repeat step 2a . b. Once you have found which GPIOs control the relays and LEDs, set these \"active\" GPIO to associate them with the corresponding Relay<x> , LED<x> , or LEDLink (Some may require the use of inverted (i.e., Relay<x>i / LED<x>i / LEDLinki ) component). ** For proper operation , in the final device configuration , assignment of like components must begin from `1` and be assigned sequentially !** Regular and inverted components can be intermixed . ( e . g ., `Relay1` , then `Relay2` ; `Led1` , then `Led2i` and so on ) Now, assign every remaining GPIO (excluding, once again, remaining \"dedicated\" GPIO like GPIO0/GPIO2 and Tx/Rx, etc.) to successive Switch1 .. Switch8 components ( 9 .. 16 ). You can once again use a Template using 0 for the GPIO identified in step 2. a. Save the configuration. Once the device reboots, use the web UI Console to run the Status 8 (sensors) command. This will display the current state of each GPIO. b. Then, while either holding down the physical button or having flipped the position of the physical switch, display Status 8 again. Whichever GPIO changes state from what was shown in step 3a is the GPIO connected to the input. - If none of the GPIO change state, then assign the remaining GPIO and retry step _3a_. c. Once you have found which GPIO are connected to each input, change the GPIO setting in the configuration to a Button<x> or Switch<x> according to your input component or use case. Proper operation may dictate the use regular or inverted (i.e., Switch<x>i / Button<x>i ) settings. For buttons, you may need to determine whether the internal pull-up is used or not. If so, select Button<x> n , where n indicates no pull-up. - See [Button with single press, double press, and hold](Rulesbutton-with-single-press-double-press-and-hold.md) to control multiple devices with one button. Once you have determined which GPIO your device uses, set any remaining GPIO to None (0) . Save the configuration. Once the device reboots, set the device to save power state changes ( SetOption0 1 ). Your device hardware is configured for use. Since you have now configured a device not previously known to the Tasmota user base, you may want to export the template and contribute it to the templates repository . View this Digiblur DIY video for a tutorial on this procedure.","title":"Configuring unknown devices"},{"location":"Contributing/","text":"Any contribution helps our team and makes Tasmota better for the entire community! We need: tutorials on using Tasmota features that aren't covered yet guides on wiring and using sensors supported by Tasmota your DIY projects featuring Tasmota new device templates fixing spelling mistakes, broken links and other errors in the Wiki The information available is still needed for devices in the field (like Shelly 2) and loss of information makes them unusable in case of debugging or fault analysis. Writing guides ~ Whenever you feel is a good guide or an article that would help other users just click the New Page icon and write. Adding devices to the documentation ~ All new devices should be submitted through the Templates Repository . If you're adding a device with a comprehensive flashing or configuration tutorial you can create a new page in the Wiki and link to it in your template submission. You need a GitHub user account to be able to edit If you spot an error in an article use the pencil icon link at the top of the page, near the title, to correct it. This version of documentation uses strick markdown syntax with some enchancements. See Markdown Cheatsheet for all features You'll be taken to the GitHub repository page of that file. Click on the edit button (pencil icon). Edit/Add the text you wanted. When finished find the Propose file change button at the bottom and click it. Next you need to click Create pull request which is GitHub speak for propose changes. In the PR window add a small description of what you did and click Create pull request Now you wait for one of the Tasmota admins to approve your PR (or deny , no guarantees!) Congratulations ! You've made a contribution to the Tasmota project making it a better experience for all future users. Thank you!","title":"Contributing"},{"location":"Contributing/#writing-guides","text":"Whenever you feel is a good guide or an article that would help other users just click the New Page icon and write.","title":"Writing guides"},{"location":"Contributing/#adding-devices-to-the-documentation","text":"All new devices should be submitted through the Templates Repository . If you're adding a device with a comprehensive flashing or configuration tutorial you can create a new page in the Wiki and link to it in your template submission. You need a GitHub user account to be able to edit If you spot an error in an article use the pencil icon link at the top of the page, near the title, to correct it. This version of documentation uses strick markdown syntax with some enchancements. See Markdown Cheatsheet for all features You'll be taken to the GitHub repository page of that file. Click on the edit button (pencil icon). Edit/Add the text you wanted. When finished find the Propose file change button at the bottom and click it. Next you need to click Create pull request which is GitHub speak for propose changes. In the PR window add a small description of what you did and click Create pull request Now you wait for one of the Tasmota admins to approve your PR (or deny , no guarantees!) Congratulations ! You've made a contribution to the Tasmota project making it a better experience for all future users. Thank you!","title":"Adding devices to the documentation"},{"location":"Control-a-Sonoff-using-a-remote-button/","text":"REMOTE BUTTON ~ IMPORTANT: The ESP8266 needs GPIO0 and GPIO2 to be high (not connected to anything, or connected to 3.3V) during boot. GPIO0 and GPIO2 are the pins D3 and D4 on the Wemos D1 mini. D3 and D4 should only be used to connect push buttons (which are only low when pressed), not toggle switches. I have a cabin that is remote from my house, and I'm using a Sonoff to turn on/off the heaters remotely, so the place can be warm when I get there. The Sonoff(heater control) is located near the fuse box, and it controls a relay which switches the 120V/30A to the heaters. It's awkward to get at the Sonoff(heater control) to physically press the toggle button, so when I'm using it, I use MQTT commands to control the heaters. But I have some family members that are not comfortable with MQTT usage and certainly don't want to open the fuse box. So I built a small ESP-01 and a DHT22 and a push button, and used this project code to drive it (>rev 1.0.30). I use the cmnd/my_DHT/buttontopic to set the mqtt command to control the heaters. Yes, you can program a sonoff so that the button sends out any arbitrary command. In this case, I'm using the button to control the other sonoff. This ESP+DHT device is in the common area of the cabin, so my family members can simply push the button to toggle the heater. In other words, I'm using one trivial (DHT+button) wifi device to control the other (sonoff+heater relay). This technique uses Theo's flexible design, since buttontopic can be made different from topic . Schematic ~ NOTE: with this schematic, the DHT sensor is on GPIO2. You'll have to change the #define DHT_PIN in this project's source code from 14 to 2. Also, make sure you use the black ESP01 with 1MB of flash; most 2016 purchases should be ok. Of course you can use an ESP12 if you wish. The optional block shown attaches an LED to the DHT data line, so you can watch when the data is being fetched from the DHT device. Power regulator, 5V to 3.3V: search eBay for 5v/3.3v power 1117 ESP: search eBay for esp-01 and pick a black one DHT22: search eBay for dht22 ; any AM2302, DHT11 or DHT12 will do in its place; or you can omit the DHT and just use the button Cost (2016-09-05) USB-5V-adapter: CAD$1 + DC5V->3.3V: CAD$1 + ESP01: CAD$2.62 + DHT12: CAD$1.50 = CAD$6.12 = EUR 4.25 This little device has two inputs (DHT & button), and no output . You can use either the Sonoff or the ElectroDragon version of this project, but because this has no output, the following commands don't make any sense: power, light, ledstate . You may also want to change the #define APP_NAME and #define PROJECT to reflect that this isn't a real Sonoff. Pat B Update ~ 2017-11-12 This design still works with version 5.5.2 of the firmware. There's no need anymore to create a special build; the new design allows you to customize the code at runtime. For the above schematic, go into the Config Module menu and set - Module: 18 WeMos D1 mini - GPIO0: 09 Switch1 - GPIO2: 03 DHT22 and set switchtopic1 to the topic for the device you want to control, and switchmode1 to 3 (toggle). That's all you need to do :) I also discovered that the button must be a momentary pushbutton; don't use a switch, because both GPIO0 and GPIO2 must be floating at boot time. Another Update ~ 2017-09-22 I have installed the above device at my cabin in the woods, and I'm using a cellular modem to connect to the internet for data. If I set the Tasmota-Sonoff software with a teleperiod=3600 (once per hour), the MQTT traffic is about 6kB/hour, which is about 4.2MB/month. That includes the TCP keep-alives and the telemetry messages. So two devices (the main sonoff power switch and the esp-01 button device) takes 8.4MB/month, just below my economy 10MB/month sim card. Just FYI, I also have tried using a Raspberry PI at the cabin, and instructing it to SSH to my public-facing server, and creating a reverse tunnel back so that I can access my cabin from my public-facing server. The keep-alives on that connection is about 7.6MB/month. [The cellular phone company is probably using NAT, so I have to connect from cabin->server and not the other way around]","title":"Control a Sonoff using a remote button"},{"location":"Control-a-Sonoff-using-a-remote-button/#remote-button","text":"IMPORTANT: The ESP8266 needs GPIO0 and GPIO2 to be high (not connected to anything, or connected to 3.3V) during boot. GPIO0 and GPIO2 are the pins D3 and D4 on the Wemos D1 mini. D3 and D4 should only be used to connect push buttons (which are only low when pressed), not toggle switches. I have a cabin that is remote from my house, and I'm using a Sonoff to turn on/off the heaters remotely, so the place can be warm when I get there. The Sonoff(heater control) is located near the fuse box, and it controls a relay which switches the 120V/30A to the heaters. It's awkward to get at the Sonoff(heater control) to physically press the toggle button, so when I'm using it, I use MQTT commands to control the heaters. But I have some family members that are not comfortable with MQTT usage and certainly don't want to open the fuse box. So I built a small ESP-01 and a DHT22 and a push button, and used this project code to drive it (>rev 1.0.30). I use the cmnd/my_DHT/buttontopic to set the mqtt command to control the heaters. Yes, you can program a sonoff so that the button sends out any arbitrary command. In this case, I'm using the button to control the other sonoff. This ESP+DHT device is in the common area of the cabin, so my family members can simply push the button to toggle the heater. In other words, I'm using one trivial (DHT+button) wifi device to control the other (sonoff+heater relay). This technique uses Theo's flexible design, since buttontopic can be made different from topic .","title":"REMOTE BUTTON"},{"location":"Control-a-Sonoff-using-a-remote-button/#schematic","text":"NOTE: with this schematic, the DHT sensor is on GPIO2. You'll have to change the #define DHT_PIN in this project's source code from 14 to 2. Also, make sure you use the black ESP01 with 1MB of flash; most 2016 purchases should be ok. Of course you can use an ESP12 if you wish. The optional block shown attaches an LED to the DHT data line, so you can watch when the data is being fetched from the DHT device. Power regulator, 5V to 3.3V: search eBay for 5v/3.3v power 1117 ESP: search eBay for esp-01 and pick a black one DHT22: search eBay for dht22 ; any AM2302, DHT11 or DHT12 will do in its place; or you can omit the DHT and just use the button Cost (2016-09-05) USB-5V-adapter: CAD$1 + DC5V->3.3V: CAD$1 + ESP01: CAD$2.62 + DHT12: CAD$1.50 = CAD$6.12 = EUR 4.25 This little device has two inputs (DHT & button), and no output . You can use either the Sonoff or the ElectroDragon version of this project, but because this has no output, the following commands don't make any sense: power, light, ledstate . You may also want to change the #define APP_NAME and #define PROJECT to reflect that this isn't a real Sonoff. Pat B","title":"Schematic"},{"location":"Control-a-Sonoff-using-a-remote-button/#update","text":"","title":"Update"},{"location":"Control-a-Sonoff-using-a-remote-button/#another-update","text":"","title":"Another Update"},{"location":"Cool-Projects/","text":"Share your projects in our Discord server ! External Links to cool/amazing projects made with Tasmota ~ LEGO Nightstand Switch Tasmota based drop pin door lock Gallery of projects running Tasmota ~ Click on name for larger image Whole house heating Solar and battery power monitoring station Schematic Water tank monitor Multisensor Aquarium controller","title":"Cool Projects"},{"location":"Cool-Projects/#external-links-to-coolamazing-projects-made-with-tasmota","text":"LEGO Nightstand Switch Tasmota based drop pin door lock","title":"External Links to cool/amazing projects made with Tasmota"},{"location":"Cool-Projects/#gallery-of-projects-running-tasmota","text":"Click on name for larger image Whole house heating Solar and battery power monitoring station Schematic Water tank monitor Multisensor Aquarium controller","title":"Gallery of projects running Tasmota"},{"location":"Create-your-own-Firmware-Build-without-IDE/","text":"PlatformIO is not just an IDE. In fact, all its features are accessible from the command line, and the IDE is a convenience wrapper layer around it. Thus, we can build Tasmota using only this PlatformIO-Core, which may come handy for automated builds, or for those who feel more comfortable with the command line than with the IDE. The steps are surprisingly simple and straightforward: Provision a Linux VM ~ At least if you want to work in a cloud environment, but you may also choose to work on your physical machine as well. PlatformIO is based on python, so if we use python-virtualenv , then all the dependent packages will be confined to a separate folder, so it won't even taint the OS installation. As all of python , python-virtualenv and python-pip are available in most of the recent distros, you may pick your favourite one. Install python and tools ~ Install python and python-virtualenv , and python-pip , because we don't want to mess up the python ecosystem of the distro. Update pip by pip install --upgrade pip , and this was the last step done as root, the rest goes as a plain user. I used CentOS here, so if you prefer Debian-based distros, just substitute apt-get install -y ... for yum install -y ... . [tasmota_builder@jtest ~]$ sudo yum install -y python python-virtualenv python-pip Loaded plugins: fastestmirror Loading mirror speeds from cached hostfile ... Complete! You may update pip in the host environment, but we'll do it in the virtualenv as well, so it's optional: [tasmota_builder@jtest ~]$ sudo pip install --upgrade pip Collecting pip ... Successfully installed pip-18.1 Prepare a PlatformIO-Core environment contained in a folder ~ virtualenv creates a folder and prepares a whole self-contained python subsystem there. To activate it, so that all python-related things refer to this environment and not to the system global, you need to source the file bin/activate within it. NOTE : Not just execute in a subshell, but include it into the current one, so please note the . before bin/activate below: [ tasmota_builder@jtest ~ ] $ virtualenv platformio - core New python executable in / home / tasmota_builder / platformio - core / bin / python Installing setuptools , pip , wheel ... done . [ tasmota_builder@jtest ~ ] $ cd platformio - core [ tasmota_builder@jtest platformio-core ] $ . bin / activate ( platformio - core ) [ tasmota_builder@jtest platformio-core ] $ Now we are ready to install PlatformIO-Core into this small virtual environment: (platformio-core) [tasmota_builder@jtest platformio-core]$ pip install -U platformio Collecting platformio Downloading https://files.pythonhosted.org/packages/95/4a/3ccce45ba750dd9a8d48dcbe9b9080011ac2a5a248312b19552bbaec6b7d/platformio-3.6.3-py27-none-any.whl (160kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 163kB 4.5MB/s Collecting semantic-version<3,>=2.5.0 (from platformio) Downloading https://files.pythonhosted.org/packages/72/83/f76958017f3094b072d8e3a72d25c3ed65f754cc607fdb6a7b33d84ab1d5/semantic_version-2.6.0.tar.gz Collecting click<6,>=5 (from platformio) Downloading https://files.pythonhosted.org/packages/8f/98/14966b6d772fd5fba1eb3bb34a62a7f736d609572493397cdc5715c14514/click-5.1-py2.py3-none-any.whl (65kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 71kB 8.1MB/s Collecting colorama (from platformio) Downloading https://files.pythonhosted.org/packages/4f/a6/728666f39bfff1719fc94c481890b2106837da9318031f71a8424b662e12/colorama-0.4.1-py2.py3-none-any.whl Collecting requests<3,>=2.4.0 (from platformio) Downloading https://files.pythonhosted.org/packages/7d/e3/20f3d364d6c8e5d2353c72a67778eb189176f08e873c9900e10c0287b84b/requests-2.21.0-py2.py3-none-any.whl (57kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 61kB 7.9MB/s Collecting pyserial!=3.3,<4,>=3 (from platformio) Downloading https://files.pythonhosted.org/packages/0d/e4/2a744dd9e3be04a0c0907414e2a01a7c88bb3915cbe3c8cc06e209f59c30/pyserial-3.4-py2.py3-none-any.whl (193kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 194kB 4.7MB/s Collecting bottle<0.13 (from platformio) Downloading https://files.pythonhosted.org/packages/32/4e/ed046324d5ec980c252987c1dca191e001b9f06ceffaebf037eef469937c/bottle-0.12.16.tar.gz (72kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 81kB 8.8MB/s Collecting urllib3<1.25,>=1.21.1 (from requests<3,>=2.4.0->platformio) Downloading https://files.pythonhosted.org/packages/62/00/ee1d7de624db8ba7090d1226aebefab96a2c71cd5cfa7629d6ad3f61b79e/urllib3-1.24.1-py2.py3-none-any.whl (118kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 122kB 7.5MB/s Collecting chardet<3.1.0,>=3.0.2 (from requests<3,>=2.4.0->platformio) Downloading https://files.pythonhosted.org/packages/bc/a9/01ffebfb562e4274b6487b4bb1ddec7ca55ec7510b22e4c51f14098443b8/chardet-3.0.4-py2.py3-none-any.whl (133kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 143kB 6.8MB/s Collecting idna<2.9,>=2.5 (from requests<3,>=2.4.0->platformio) Downloading https://files.pythonhosted.org/packages/14/2c/cd551d81dbe15200be1cf41cd03869a46fe7226e7450af7a6545bfc474c9/idna-2.8-py2.py3-none-any.whl (58kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 61kB 7.8MB/s Collecting certifi>=2017.4.17 (from requests<3,>=2.4.0->platformio) Downloading https://files.pythonhosted.org/packages/9f/e0/accfc1b56b57e9750eba272e24c4dddeac86852c2bebd1236674d7887e8a/certifi-2018.11.29-py2.py3-none-any.whl (154kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 163kB 5.9MB/s Building wheels for collected packages: semantic-version, bottle Running setup.py bdist_wheel for semantic-version ... done Stored in directory: /home/tasmota_builder/.cache/pip/wheels/60/bb/50/215d669d31f992767f5dd8d3c974e79261707ee7f898f0dc10 Running setup.py bdist_wheel for bottle ... done Stored in directory: /home/tasmota_builder/.cache/pip/wheels/0c/68/ac/1546dcb27101ca6c4e50c5b5da92dbd3307f07cda5d88e81c7 Successfully built semantic-version bottle Installing collected packages: semantic-version, click, colorama, urllib3, chardet, idna, certifi, requests, pyserial, bottle, platformio Successfully installed bottle-0.12.16 certifi-2018.11.29 chardet-3.0.4 click-5.1 colorama-0.4.1 idna-2.8 platformio-3.6.3 pyserial-3.4 requests-2.21.0 semantic-version> You are using pip version 9.0.1, however version 18.1 is available. As it would prefer a recent pip instead of the one set up by virtualenv , so let's upgrade it: (platformio-core) [tasmota_builder@jtest platformio-core]$ pip install --upgrade pip Collecting pip Downloading https://files.pythonhosted.org/packages/c2/d7/90f34cb0d83a6c5631cf71dfe64cc1054598c843a92b400e55675cc2ac37/pip-18.1-py2.py3-none-any.whl (1.3MB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1.3MB 793kB/s Installing collected packages: pip Found existing installation: pip 9.0.1 Uninstalling pip-9.0.1: Successfully uninstalled pip-9.0.1 Successfully installed pip-18.1 Fetch the Tasmota sources ~ If you want only to build, then the original repo will do, but if you want to contribute as well, then fork an own copy of the repo and clone out that one. (platformio-core) [tasmota_builder@jtest platformio-core]$ git clone https://github.com/arendst/Tasmota.git Cloning into 'Tasmota'... remote: Enumerating objects: 6, done. remote: Counting objects: 100% (6/6), done. remote: Compressing objects: 100% (5/5), done. remote: Total 16930 (delta 1), reused 3 (delta 1), pack-reused 16924 Receiving objects: 100% (16930/16930), 23.75 MiB | 12.94 MiB/s, done. Resolving deltas: 100% (11426/11426), done. After changing to the working copy, we are ready to go: (platformio-core) [tasmota_builder@jtest platformio-core]$ cd Tasmota/ (platformio-core) [tasmota_builder@jtest Tasmota]$ Configure the sources ~ Now you may want to configure the sources for your needs, as described at Upload Actually, the sources do build fine right out-of-the box, only it'll be a full build, including all the language localisation and all the build flavours as well, while you are usually interested only in one language and one build flavour only. In platformio.ini choose the environment (or flavour, if you like) you want to build. In tasmota/user_config_override.h fine tune the default values for the module, the wifi, the MQTT server, and so on. Refer to the Tasmota Wiki for details. Build the firmware ~ The build command itself is pio run , but as it emits quite a lot of messages (including errors if you're developing), so you may want to redirect a copy of the standard output and error to a file, so it'll be pio run 2>&1 | tee build.log . ( platformio - core ) [ tasmota_builder @ jtest Tasmota ] $ time pio run 2 >& 1 | tee build . log ************************************************************************************************************************************************************************ If you like PlatformIO , please : - follow us on Twitter to stay up - to - date on the latest project news > https : //twitter.com/PlatformIO_Org - star it on GitHub > https : //github.com/platformio/platformio - try PlatformIO IDE for IoT development > https : //platformio.org/platformio-ide - support us with PlatformIO Plus > https : //pioplus.com ************************************************************************************************************************************************************************ Processing tasmota ( framework : arduino ; platform : espressif8266 @1.8.0 ; board : esp01_1m ) ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ PlatformManager : Installing espressif8266 @ 1.8.0 Downloading ... Environment tasmota - TW [ SUCCESS ] Environment tasmota - UK [ SUCCESS ] ==================================================================== [ SUCCESS ] Took 797.56 seconds ==================================================================== That's all, really :D ! PlatformIO seems to handle the rebuilds and dependencies well, but if you want a clean build, the say pio run -t clean first, and then the pio run . Collect the results ~ The result will be here: ./.pioenvs/<build-flavour>/firmware.bin ( platformio-core ) [ tasmota_builder@jtest Tasmota ] $ find .pioenvs - name ' *. bin ' .pioenvs / tasmota-FR / firmware.bin .pioenvs / tasmota-GR / firmware.bin .pioenvs / tasmota-HE / firmware.bin .pioenvs / tasmota-HU / firmware.bin .pioenvs / tasmota-IT / firmware.bin .pioenvs / tasmota-NL / firmware.bin .pioenvs / tasmota-PL / firmware.bin .pioenvs / tasmota-PT / firmware.bin .pioenvs / tasmota-RU / firmware.bin .pioenvs / tasmota-SE / firmware.bin .pioenvs / tasmota-SK / firmware.bin .pioenvs / tasmota-TR / firmware.bin .pioenvs / tasmota-TW / firmware.bin .pioenvs / tasmota-UK / firmware.bin .pioenvs / tasmota / firmware.bin .pioenvs / tasmota-minimal / firmware.bin .pioenvs / tasmota-basic / firmware.bin .pioenvs / tasmota-knx / firmware.bin .pioenvs / tasmota-sensors / firmware.bin .pioenvs / tasmota-display / firmware.bin .pioenvs / tasmota-BG / firmware.bin .pioenvs / tasmota-BR / firmware.bin .pioenvs / tasmota-CN / firmware.bin .pioenvs / tasmota-CZ / firmware.bin .pioenvs / tasmota-DE / firmware.bin .pioenvs / tasmota-ES / firmware.bin About build times ~ The recent versions of PlatformIO-Core seem to parallelise quite well. When you've changed only a few files, not everything needs to be recompiled (though the image must still be re-packed), so that minute-like build time is the maximum, usually it'll be less. Prepare the local installer tool ~ You may rebuild the firmware on a remote machine, but you must have the installer tool on the local machine where the module is connected to. Fortunately, it's also python-based, so we can again employ virtualenv here. If you built the firmware also on your localhost, then there is no need for a separate environment, you may quite well install esptool into that one. Otherwise, create a virtual environment the usual way: [ tasmota_installer@lantash ~ ] $ virtualenv esptool New python executable in / home / tasmota_installer / esptool / bin / python2 .7 Also creating executable in / home / tasmota_installer / esptool / bin / python Installing setuptools , pip , wheel ... done . [ tasmota_installer@lantash ~ ] $ cd esptool / [ tasmota_installer@lantash ~/esptool ] $ . bin / activate ( esptool ) [ tasmota_installer@lantash ~/esptool ] $ pip install --upgrade pip Requirement already up - to - date : pip in . / lib / python2 .7 / site - packages ( 18.1 ) Now let's install esptool : (esptool) [tasmota_installer@lantash ~/esptool]$ pip install esptool Collecting esptool Downloading https://files.pythonhosted.org/packages/5c/85/5654e7b9019739d3d89af0adf528c9ae57a9a26682e3aa012e1e30f20674/esptool-2.6.tar.gz (80kB) 100% |################################| 81kB 222kB/s Collecting pyserial>=3.0 (from esptool) Downloading https://files.pythonhosted.org/packages/0d/e4/2a744dd9e3be04a0c0907414e2a01a7c88bb3915cbe3c8cc06e209f59c30/pyserial-3.4-py2.py3-none-any.whl (193kB) 100% |################################| 194kB 491kB/s Collecting pyaes (from esptool) Downloading https://files.pythonhosted.org/packages/44/66/2c17bae31c906613795711fc78045c285048168919ace2220daa372c7d72/pyaes-1.6.1.tar.gz Collecting ecdsa (from esptool) Downloading https://files.pythonhosted.org/packages/63/f4/73669d51825516ce8c43b816c0a6b64cd6eb71d08b99820c00792cb42222/ecdsa-0.13-py2.py3-none-any.whl (86kB) 100% |################################| 92kB 382kB/s Building wheels for collected packages: esptool, pyaes Running setup.py bdist_wheel for esptool ... done Stored in directory: /home/tasmota_installer/.cache/pip/wheels/cf/1f/62/7ad4e47843affd4f5b7032a39f1ef8a153c6d27533614d21aa Running setup.py bdist_wheel for pyaes ... done Stored in directory: /home/tasmota_installer/.cache/pip/wheels/bd/cf/7b/ced9e8f28c50ed666728e8ab178ffedeb9d06f6a10f85d6432 Successfully built esptool pyaes Installing collected packages: pyserial, pyaes, ecdsa, esptool Successfully installed ecdsa-0.13 esptool-2.6 pyaes-1.6.1 pyserial-3.4 If you've built the firmware on a remote machine, now it's time to download it into this installer environment (e.g. via scp or sftp ). IMPORTANT : For the subsequent steps your user must have the permission to write the serial port. Back up the current firmware (optional) ~ First of all, disconnect the bulb from the mains and wire up the serial connection and a button on GPIO0. If this GPIO0 is connected to GND when the module gets power, it starts in a firmware-update mode, and you can then read/write its flash storage. Switch off the power of the board, this will be the reference 'steady state' of the system. (esptool) [tasmota_installer@lantash ~/esptool]$ esptool.py read_flash 0x00000 0x100000 fcmila_bulb_orig.bin esptool.py v2.6 Found 1 serial ports Serial port /dev/cuaU0 Connecting...... Now, it'll wait for the module to appear connected, so press the button (GPIO0 to GND), keep it pressed switch on the power of the board now you may release the button ... Detecting chip type... ESP8266 Chip is ESP8266EX Features: WiFi MAC: bc:dd:c2:e0:2a:f2 Uploading stub... Running stub... Stub running... 1048576 (100 %) Read 1048576 bytes at 0x0 in 95.0 seconds (88.3 kbit/s)... Hard resetting via RTS pin... If all is well, the flash is being dumped, it may take a minute or so. If done, then power the module off , as this management mode is not restartable! If it's not well, then you may try some queries: (esptool) [tasmota_installer@lantash ~/esptool]$ esptool.py -p /dev/ttyU0 chip_id ... Chip ID: 0x00e02af2 ... (esptool) [tasmota_installer@lantash ~/esptool]$ esptool.py -p /dev/ttyU0 flash_id ... Manufacturer: c8 Device: 4014 Detected flash size: 1MB ... If they don't work, then check your cabling and your serial adapter. Until you can't get this step working, don't proceed to the next one, it won't work either. Erase the flash ~ (With the usual button-pressed-power-on rain dance, and don't forget to power the module off afterwards.) (esptool) [tasmota_installer@lantash ~/esptool]$ esptool.py erase_flash ... Erasing flash (this may take a while)... Chip erase completed successfully in 1.6s Install the firmware to your module ~ ( esptool ) [ tasmota_installer@lantash ~/esptool ] $ esptool . py write_flash --flash_size 1MB --flash_mode dout 0x00000 firmware.bin Configuring flash size ... Compressed 535424 bytes to 367679. .. Wrote 535424 bytes ( 367679 compressed ) at 0x00000000 in 33.8 seconds ( effective 126.6 kbit / s )... Hash of data verified . Leaving ... Power on for normal operation ~ No button-pressing, power on, and see what you achieved :). The module sends its logs on the serial line at 115200 baud 8N1, so to check the logs: (esptool) [tasmota_installer@lantash ~/esptool]$ cu -s 115200 -l /dev/ttyU0 | tee -a my_sonoff.log Connected <some initial binary data> 00:00:00 CFG: Use defaults 00:00:00 SM16716: ModuleSelected; clk_pin=4, dat_pin=14) 00:00:00 SRC: Restart 00:00:00 SM16716: Entry; function=FUNC_SET_DEVICE_POWER, index=00, payload=02 00:00:00 SM16716: Update; pwr=00, rgb=000000 00:00:00 Project sonoff Sonoff Version 6.4.1.9(sonoff)-2_4_2 00:00:00 SM16716: Entry; function=FUNC_INIT 00:00:00 SM16716: ModuleSelected; clk_pin=4, dat_pin=14) 00:00:00 WIF: Attempting connection... ... (Assuming that you're using FreeBSD. On Linux you set the speed via setserial or stty , and then do the dump with dd . Or just minicom , if you prefer.) Now you have a complete build path from source to device, and a log feedback as well, so you've got everything needed for being able to implement your ideas :D !","title":"Create your own Firmware Build without IDE"},{"location":"Create-your-own-Firmware-Build-without-IDE/#provision-a-linux-vm","text":"At least if you want to work in a cloud environment, but you may also choose to work on your physical machine as well. PlatformIO is based on python, so if we use python-virtualenv , then all the dependent packages will be confined to a separate folder, so it won't even taint the OS installation. As all of python , python-virtualenv and python-pip are available in most of the recent distros, you may pick your favourite one.","title":"Provision a Linux VM"},{"location":"Create-your-own-Firmware-Build-without-IDE/#install-python-and-tools","text":"Install python and python-virtualenv , and python-pip , because we don't want to mess up the python ecosystem of the distro. Update pip by pip install --upgrade pip , and this was the last step done as root, the rest goes as a plain user. I used CentOS here, so if you prefer Debian-based distros, just substitute apt-get install -y ... for yum install -y ... . [tasmota_builder@jtest ~]$ sudo yum install -y python python-virtualenv python-pip Loaded plugins: fastestmirror Loading mirror speeds from cached hostfile ... Complete! You may update pip in the host environment, but we'll do it in the virtualenv as well, so it's optional: [tasmota_builder@jtest ~]$ sudo pip install --upgrade pip Collecting pip ... Successfully installed pip-18.1","title":"Install python and tools"},{"location":"Create-your-own-Firmware-Build-without-IDE/#prepare-a-platformio-core-environment-contained-in-a-folder","text":"virtualenv creates a folder and prepares a whole self-contained python subsystem there. To activate it, so that all python-related things refer to this environment and not to the system global, you need to source the file bin/activate within it. NOTE : Not just execute in a subshell, but include it into the current one, so please note the . before bin/activate below: [ tasmota_builder@jtest ~ ] $ virtualenv platformio - core New python executable in / home / tasmota_builder / platformio - core / bin / python Installing setuptools , pip , wheel ... done . [ tasmota_builder@jtest ~ ] $ cd platformio - core [ tasmota_builder@jtest platformio-core ] $ . bin / activate ( platformio - core ) [ tasmota_builder@jtest platformio-core ] $ Now we are ready to install PlatformIO-Core into this small virtual environment: (platformio-core) [tasmota_builder@jtest platformio-core]$ pip install -U platformio Collecting platformio Downloading https://files.pythonhosted.org/packages/95/4a/3ccce45ba750dd9a8d48dcbe9b9080011ac2a5a248312b19552bbaec6b7d/platformio-3.6.3-py27-none-any.whl (160kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 163kB 4.5MB/s Collecting semantic-version<3,>=2.5.0 (from platformio) Downloading https://files.pythonhosted.org/packages/72/83/f76958017f3094b072d8e3a72d25c3ed65f754cc607fdb6a7b33d84ab1d5/semantic_version-2.6.0.tar.gz Collecting click<6,>=5 (from platformio) Downloading https://files.pythonhosted.org/packages/8f/98/14966b6d772fd5fba1eb3bb34a62a7f736d609572493397cdc5715c14514/click-5.1-py2.py3-none-any.whl (65kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 71kB 8.1MB/s Collecting colorama (from platformio) Downloading https://files.pythonhosted.org/packages/4f/a6/728666f39bfff1719fc94c481890b2106837da9318031f71a8424b662e12/colorama-0.4.1-py2.py3-none-any.whl Collecting requests<3,>=2.4.0 (from platformio) Downloading https://files.pythonhosted.org/packages/7d/e3/20f3d364d6c8e5d2353c72a67778eb189176f08e873c9900e10c0287b84b/requests-2.21.0-py2.py3-none-any.whl (57kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 61kB 7.9MB/s Collecting pyserial!=3.3,<4,>=3 (from platformio) Downloading https://files.pythonhosted.org/packages/0d/e4/2a744dd9e3be04a0c0907414e2a01a7c88bb3915cbe3c8cc06e209f59c30/pyserial-3.4-py2.py3-none-any.whl (193kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 194kB 4.7MB/s Collecting bottle<0.13 (from platformio) Downloading https://files.pythonhosted.org/packages/32/4e/ed046324d5ec980c252987c1dca191e001b9f06ceffaebf037eef469937c/bottle-0.12.16.tar.gz (72kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 81kB 8.8MB/s Collecting urllib3<1.25,>=1.21.1 (from requests<3,>=2.4.0->platformio) Downloading https://files.pythonhosted.org/packages/62/00/ee1d7de624db8ba7090d1226aebefab96a2c71cd5cfa7629d6ad3f61b79e/urllib3-1.24.1-py2.py3-none-any.whl (118kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 122kB 7.5MB/s Collecting chardet<3.1.0,>=3.0.2 (from requests<3,>=2.4.0->platformio) Downloading https://files.pythonhosted.org/packages/bc/a9/01ffebfb562e4274b6487b4bb1ddec7ca55ec7510b22e4c51f14098443b8/chardet-3.0.4-py2.py3-none-any.whl (133kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 143kB 6.8MB/s Collecting idna<2.9,>=2.5 (from requests<3,>=2.4.0->platformio) Downloading https://files.pythonhosted.org/packages/14/2c/cd551d81dbe15200be1cf41cd03869a46fe7226e7450af7a6545bfc474c9/idna-2.8-py2.py3-none-any.whl (58kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 61kB 7.8MB/s Collecting certifi>=2017.4.17 (from requests<3,>=2.4.0->platformio) Downloading https://files.pythonhosted.org/packages/9f/e0/accfc1b56b57e9750eba272e24c4dddeac86852c2bebd1236674d7887e8a/certifi-2018.11.29-py2.py3-none-any.whl (154kB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 163kB 5.9MB/s Building wheels for collected packages: semantic-version, bottle Running setup.py bdist_wheel for semantic-version ... done Stored in directory: /home/tasmota_builder/.cache/pip/wheels/60/bb/50/215d669d31f992767f5dd8d3c974e79261707ee7f898f0dc10 Running setup.py bdist_wheel for bottle ... done Stored in directory: /home/tasmota_builder/.cache/pip/wheels/0c/68/ac/1546dcb27101ca6c4e50c5b5da92dbd3307f07cda5d88e81c7 Successfully built semantic-version bottle Installing collected packages: semantic-version, click, colorama, urllib3, chardet, idna, certifi, requests, pyserial, bottle, platformio Successfully installed bottle-0.12.16 certifi-2018.11.29 chardet-3.0.4 click-5.1 colorama-0.4.1 idna-2.8 platformio-3.6.3 pyserial-3.4 requests-2.21.0 semantic-version> You are using pip version 9.0.1, however version 18.1 is available. As it would prefer a recent pip instead of the one set up by virtualenv , so let's upgrade it: (platformio-core) [tasmota_builder@jtest platformio-core]$ pip install --upgrade pip Collecting pip Downloading https://files.pythonhosted.org/packages/c2/d7/90f34cb0d83a6c5631cf71dfe64cc1054598c843a92b400e55675cc2ac37/pip-18.1-py2.py3-none-any.whl (1.3MB) 100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1.3MB 793kB/s Installing collected packages: pip Found existing installation: pip 9.0.1 Uninstalling pip-9.0.1: Successfully uninstalled pip-9.0.1 Successfully installed pip-18.1","title":"Prepare a PlatformIO-Core environment contained in a folder"},{"location":"Create-your-own-Firmware-Build-without-IDE/#fetch-the-tasmota-sources","text":"If you want only to build, then the original repo will do, but if you want to contribute as well, then fork an own copy of the repo and clone out that one. (platformio-core) [tasmota_builder@jtest platformio-core]$ git clone https://github.com/arendst/Tasmota.git Cloning into 'Tasmota'... remote: Enumerating objects: 6, done. remote: Counting objects: 100% (6/6), done. remote: Compressing objects: 100% (5/5), done. remote: Total 16930 (delta 1), reused 3 (delta 1), pack-reused 16924 Receiving objects: 100% (16930/16930), 23.75 MiB | 12.94 MiB/s, done. Resolving deltas: 100% (11426/11426), done. After changing to the working copy, we are ready to go: (platformio-core) [tasmota_builder@jtest platformio-core]$ cd Tasmota/ (platformio-core) [tasmota_builder@jtest Tasmota]$","title":"Fetch the Tasmota sources"},{"location":"Create-your-own-Firmware-Build-without-IDE/#configure-the-sources","text":"Now you may want to configure the sources for your needs, as described at Upload Actually, the sources do build fine right out-of-the box, only it'll be a full build, including all the language localisation and all the build flavours as well, while you are usually interested only in one language and one build flavour only. In platformio.ini choose the environment (or flavour, if you like) you want to build. In tasmota/user_config_override.h fine tune the default values for the module, the wifi, the MQTT server, and so on. Refer to the Tasmota Wiki for details.","title":"Configure the sources"},{"location":"Create-your-own-Firmware-Build-without-IDE/#build-the-firmware","text":"The build command itself is pio run , but as it emits quite a lot of messages (including errors if you're developing), so you may want to redirect a copy of the standard output and error to a file, so it'll be pio run 2>&1 | tee build.log . ( platformio - core ) [ tasmota_builder @ jtest Tasmota ] $ time pio run 2 >& 1 | tee build . log ************************************************************************************************************************************************************************ If you like PlatformIO , please : - follow us on Twitter to stay up - to - date on the latest project news > https : //twitter.com/PlatformIO_Org - star it on GitHub > https : //github.com/platformio/platformio - try PlatformIO IDE for IoT development > https : //platformio.org/platformio-ide - support us with PlatformIO Plus > https : //pioplus.com ************************************************************************************************************************************************************************ Processing tasmota ( framework : arduino ; platform : espressif8266 @1.8.0 ; board : esp01_1m ) ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ PlatformManager : Installing espressif8266 @ 1.8.0 Downloading ... Environment tasmota - TW [ SUCCESS ] Environment tasmota - UK [ SUCCESS ] ==================================================================== [ SUCCESS ] Took 797.56 seconds ==================================================================== That's all, really :D ! PlatformIO seems to handle the rebuilds and dependencies well, but if you want a clean build, the say pio run -t clean first, and then the pio run .","title":"Build the firmware"},{"location":"Create-your-own-Firmware-Build-without-IDE/#collect-the-results","text":"The result will be here: ./.pioenvs/<build-flavour>/firmware.bin ( platformio-core ) [ tasmota_builder@jtest Tasmota ] $ find .pioenvs - name ' *. bin ' .pioenvs / tasmota-FR / firmware.bin .pioenvs / tasmota-GR / firmware.bin .pioenvs / tasmota-HE / firmware.bin .pioenvs / tasmota-HU / firmware.bin .pioenvs / tasmota-IT / firmware.bin .pioenvs / tasmota-NL / firmware.bin .pioenvs / tasmota-PL / firmware.bin .pioenvs / tasmota-PT / firmware.bin .pioenvs / tasmota-RU / firmware.bin .pioenvs / tasmota-SE / firmware.bin .pioenvs / tasmota-SK / firmware.bin .pioenvs / tasmota-TR / firmware.bin .pioenvs / tasmota-TW / firmware.bin .pioenvs / tasmota-UK / firmware.bin .pioenvs / tasmota / firmware.bin .pioenvs / tasmota-minimal / firmware.bin .pioenvs / tasmota-basic / firmware.bin .pioenvs / tasmota-knx / firmware.bin .pioenvs / tasmota-sensors / firmware.bin .pioenvs / tasmota-display / firmware.bin .pioenvs / tasmota-BG / firmware.bin .pioenvs / tasmota-BR / firmware.bin .pioenvs / tasmota-CN / firmware.bin .pioenvs / tasmota-CZ / firmware.bin .pioenvs / tasmota-DE / firmware.bin .pioenvs / tasmota-ES / firmware.bin","title":"Collect the results"},{"location":"Create-your-own-Firmware-Build-without-IDE/#about-build-times","text":"The recent versions of PlatformIO-Core seem to parallelise quite well. When you've changed only a few files, not everything needs to be recompiled (though the image must still be re-packed), so that minute-like build time is the maximum, usually it'll be less.","title":"About build times"},{"location":"Create-your-own-Firmware-Build-without-IDE/#prepare-the-local-installer-tool","text":"You may rebuild the firmware on a remote machine, but you must have the installer tool on the local machine where the module is connected to. Fortunately, it's also python-based, so we can again employ virtualenv here. If you built the firmware also on your localhost, then there is no need for a separate environment, you may quite well install esptool into that one. Otherwise, create a virtual environment the usual way: [ tasmota_installer@lantash ~ ] $ virtualenv esptool New python executable in / home / tasmota_installer / esptool / bin / python2 .7 Also creating executable in / home / tasmota_installer / esptool / bin / python Installing setuptools , pip , wheel ... done . [ tasmota_installer@lantash ~ ] $ cd esptool / [ tasmota_installer@lantash ~/esptool ] $ . bin / activate ( esptool ) [ tasmota_installer@lantash ~/esptool ] $ pip install --upgrade pip Requirement already up - to - date : pip in . / lib / python2 .7 / site - packages ( 18.1 ) Now let's install esptool : (esptool) [tasmota_installer@lantash ~/esptool]$ pip install esptool Collecting esptool Downloading https://files.pythonhosted.org/packages/5c/85/5654e7b9019739d3d89af0adf528c9ae57a9a26682e3aa012e1e30f20674/esptool-2.6.tar.gz (80kB) 100% |################################| 81kB 222kB/s Collecting pyserial>=3.0 (from esptool) Downloading https://files.pythonhosted.org/packages/0d/e4/2a744dd9e3be04a0c0907414e2a01a7c88bb3915cbe3c8cc06e209f59c30/pyserial-3.4-py2.py3-none-any.whl (193kB) 100% |################################| 194kB 491kB/s Collecting pyaes (from esptool) Downloading https://files.pythonhosted.org/packages/44/66/2c17bae31c906613795711fc78045c285048168919ace2220daa372c7d72/pyaes-1.6.1.tar.gz Collecting ecdsa (from esptool) Downloading https://files.pythonhosted.org/packages/63/f4/73669d51825516ce8c43b816c0a6b64cd6eb71d08b99820c00792cb42222/ecdsa-0.13-py2.py3-none-any.whl (86kB) 100% |################################| 92kB 382kB/s Building wheels for collected packages: esptool, pyaes Running setup.py bdist_wheel for esptool ... done Stored in directory: /home/tasmota_installer/.cache/pip/wheels/cf/1f/62/7ad4e47843affd4f5b7032a39f1ef8a153c6d27533614d21aa Running setup.py bdist_wheel for pyaes ... done Stored in directory: /home/tasmota_installer/.cache/pip/wheels/bd/cf/7b/ced9e8f28c50ed666728e8ab178ffedeb9d06f6a10f85d6432 Successfully built esptool pyaes Installing collected packages: pyserial, pyaes, ecdsa, esptool Successfully installed ecdsa-0.13 esptool-2.6 pyaes-1.6.1 pyserial-3.4 If you've built the firmware on a remote machine, now it's time to download it into this installer environment (e.g. via scp or sftp ). IMPORTANT : For the subsequent steps your user must have the permission to write the serial port.","title":"Prepare the local installer tool"},{"location":"Create-your-own-Firmware-Build-without-IDE/#back-up-the-current-firmware-optional","text":"First of all, disconnect the bulb from the mains and wire up the serial connection and a button on GPIO0. If this GPIO0 is connected to GND when the module gets power, it starts in a firmware-update mode, and you can then read/write its flash storage. Switch off the power of the board, this will be the reference 'steady state' of the system. (esptool) [tasmota_installer@lantash ~/esptool]$ esptool.py read_flash 0x00000 0x100000 fcmila_bulb_orig.bin esptool.py v2.6 Found 1 serial ports Serial port /dev/cuaU0 Connecting...... Now, it'll wait for the module to appear connected, so press the button (GPIO0 to GND), keep it pressed switch on the power of the board now you may release the button ... Detecting chip type... ESP8266 Chip is ESP8266EX Features: WiFi MAC: bc:dd:c2:e0:2a:f2 Uploading stub... Running stub... Stub running... 1048576 (100 %) Read 1048576 bytes at 0x0 in 95.0 seconds (88.3 kbit/s)... Hard resetting via RTS pin... If all is well, the flash is being dumped, it may take a minute or so. If done, then power the module off , as this management mode is not restartable! If it's not well, then you may try some queries: (esptool) [tasmota_installer@lantash ~/esptool]$ esptool.py -p /dev/ttyU0 chip_id ... Chip ID: 0x00e02af2 ... (esptool) [tasmota_installer@lantash ~/esptool]$ esptool.py -p /dev/ttyU0 flash_id ... Manufacturer: c8 Device: 4014 Detected flash size: 1MB ... If they don't work, then check your cabling and your serial adapter. Until you can't get this step working, don't proceed to the next one, it won't work either.","title":"Back up the current firmware (optional)"},{"location":"Create-your-own-Firmware-Build-without-IDE/#erase-the-flash","text":"(With the usual button-pressed-power-on rain dance, and don't forget to power the module off afterwards.) (esptool) [tasmota_installer@lantash ~/esptool]$ esptool.py erase_flash ... Erasing flash (this may take a while)... Chip erase completed successfully in 1.6s","title":"Erase the flash"},{"location":"Create-your-own-Firmware-Build-without-IDE/#install-the-firmware-to-your-module","text":"( esptool ) [ tasmota_installer@lantash ~/esptool ] $ esptool . py write_flash --flash_size 1MB --flash_mode dout 0x00000 firmware.bin Configuring flash size ... Compressed 535424 bytes to 367679. .. Wrote 535424 bytes ( 367679 compressed ) at 0x00000000 in 33.8 seconds ( effective 126.6 kbit / s )... Hash of data verified . Leaving ...","title":"Install the firmware to your module"},{"location":"Create-your-own-Firmware-Build-without-IDE/#power-on-for-normal-operation","text":"No button-pressing, power on, and see what you achieved :). The module sends its logs on the serial line at 115200 baud 8N1, so to check the logs: (esptool) [tasmota_installer@lantash ~/esptool]$ cu -s 115200 -l /dev/ttyU0 | tee -a my_sonoff.log Connected <some initial binary data> 00:00:00 CFG: Use defaults 00:00:00 SM16716: ModuleSelected; clk_pin=4, dat_pin=14) 00:00:00 SRC: Restart 00:00:00 SM16716: Entry; function=FUNC_SET_DEVICE_POWER, index=00, payload=02 00:00:00 SM16716: Update; pwr=00, rgb=000000 00:00:00 Project sonoff Sonoff Version 6.4.1.9(sonoff)-2_4_2 00:00:00 SM16716: Entry; function=FUNC_INIT 00:00:00 SM16716: ModuleSelected; clk_pin=4, dat_pin=14) 00:00:00 WIF: Attempting connection... ... (Assuming that you're using FreeBSD. On Linux you set the speed via setserial or stty , and then do the dump with dd . Or just minicom , if you prefer.) Now you have a complete build path from source to device, and a log feedback as well, so you've got everything needed for being able to implement your ideas :D !","title":"Power on for normal operation"},{"location":"DHT11-Wiring---Sonoff-Basic/","text":"To wire a DHT11 up to a Sonoff Basic, I first soldered a pin header to the main pin header row. For the location see [[GPIO-Locations]]. I decided to use regular 2.54mm connectors (often referred to as Dupont connectors), so that I can switch sensors if I have to. In order to fit the dupont cables within the enclosure, I had to bend the 2.54mm pin headers by about 45\u00b0. As the DHT11 requires a pullup (depending on the cable length), and I didn't want to design a PCB just to connect 3 wires and a resistor, I came up with the solution described below. First, I slipped ferrules over the DHT11 pins and inserted the wires. This makes it a lot easier to hold the cables and the DHT11 pins in place. I left a bit more wire exposed so that I have a place to apply solder without burning the wire insulation. I applied heat to the ferrule, not the wire, and applied solder directly at the end of the ferrule. Solder will then flow into the ferrule. I also added a small solder blob (visible on the top ferrule) so that I can solder an 0805 resistor in place. Thanks to the ferrule, the wires won't become detached when heated again. Keep in mind that the ferrule has quite some heat capacity, so wait for the solder to cool down prior moving the wires or the sensor. I then did shrink the 2:1 green heatshrink tubes so that the contacts don't touch each other. Also, it is so very handy to have 4:1 shrinking tube. An 8mm 4:1 tube fits perfectly over the pins, and fully encloses the 3 wires. Get 4:1 heatshrink tube. It's so worth it. Here's how the finished project looks like:","title":"DHT11 Wiring   Sonoff Basic"},{"location":"DHT11/","text":"DHT11 is a basic, ultra low-cost digital temperature and humidity sensor. It is very inaccurate and surpassed by others (AM2301, BME280, ...) thus not recommended by us. Configuration ~ Wiring ~ DHT11 ESP266 - GND OUT GPIOx + 3.3V Tasmota Settings ~ In the Configuration -> Configure Module page assign: - GPIOx to DHT11 (1) After reboot of the device the temperature and humidity are displayed. Commands ~ TempOffset can be used for calibrating the measured temperature. This setting affects all temperature sensors on the device. Wemos DHT11 Shield ~ Note: this is ONLY for v1.0.0 of the DHT11 shield, since v2.0.0 uses I 2 C and pinned differently. From the Wemos DHT11 shield specs the DATA OUT pin is connected to D4 of the Wemos. Note: Having the shield compact on top of the processor increases the temperature. In normal Mode this can be up to 6\u00b0C. So you should add sleep mode. Adding normal \"Sleep 100\" and putting the sensor vertically reduces the temperature difference to 2\u00b0C Sonoff Basic specific ~ To wire a DHT11 up to a Sonoff Basic, I first soldered a pin header to the main pin header row. For the location see GPIO Locations . I decided to use regular 2.54mm connectors (often referred to as Dupont connectors), so that I can switch sensors if I have to. In order to fit the dupont cables within the enclosure, I had to bend the 2.54mm pin headers by about 45\u00b0. As the DHT11 requires a pullup (depending on the cable length), and I didn't want to design a PCB just to connect 3 wires and a resistor, I came up with the solution described below. First, I slipped ferrules over the DHT11 pins and inserted the wires. This makes it a lot easier to hold the cables and the DHT11 pins in place. I left a bit more wire exposed so that I have a place to apply solder without burning the wire insulation. I applied heat to the ferrule, not the wire, and applied solder directly at the end of the ferrule. Solder will then flow into the ferrule. I also added a small solder blob (visible on the top ferrule) so that I can solder an 0805 resistor in place. Thanks to the ferrule, the wires won't become detached when heated again. Keep in mind that the ferrule has quite some heat capacity, so wait for the solder to cool down prior moving the wires or the sensor. I then did shrink the 2:1 green heatshrink tubes so that the contacts don't touch each other. Also, it is so very handy to have 4:1 shrinking tube. An 8mm 4:1 tube fits perfectly over the pins, and fully encloses the 3 wires. Get 4:1 heatshrink tube. It's so worth it. Here's how the finished project looks like: OpenHab ~ sonoff.items: // DHT-6 Number DHT6_Temp \"Bathroom DHT-6 [%.1f \u00b0C]\" <temperature> (gTemperature,gTemperatureRoom) { mqtt=\"<[broker:tele/sonoff-dht-6/SENSOR:state:JSONPATH($.DHT11.Temperature)]\" } Number DHT6_Humidity \"Bathroom DHT-6 [%.1f %%]\" <humidity> (gHumidity) { mqtt=\"<[broker:tele/sonoff-dht-6/SENSOR:state:JSONPATH($.DHT11.Humidity)]\" } Switch DHT6_Reachable \"DHT-6 reachable\" <contact> (gReachable) { mqtt=\"<[broker:tele/sonoff-dht-6/LWT:state:MAP(reachable.map)]\" } Number DHT6_RSSI \"DHT-6 RSSI [%d %%]\" <qualityofservice> (gRSSI) { mqtt=\"<[broker:tele/sonoff-dht-6/STATE:state:JSONPATH($.Wifi.RSSI)]\" } sonoff.sitemap Frame { Text item=DHT6_Temp labelcolor=[DHT6_Reachable == \"ON\" = \"green\",DHT6_Reachable == \"OFF\" = \"red\"] { Text item=DHT6_Temp Text item=DHT6_Humidity Text item=DHT6_Reachable Text item=DHT6_RSSI } } Printable Housing ~ https://www.thingiverse.com/thing:2814909","title":"DHT11"},{"location":"DHT11/#configuration","text":"","title":"Configuration"},{"location":"DHT11/#wiring","text":"DHT11 ESP266 - GND OUT GPIOx + 3.3V","title":"Wiring"},{"location":"DHT11/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: - GPIOx to DHT11 (1) After reboot of the device the temperature and humidity are displayed.","title":"Tasmota Settings"},{"location":"DHT11/#commands","text":"TempOffset can be used for calibrating the measured temperature. This setting affects all temperature sensors on the device.","title":"Commands"},{"location":"DHT11/#wemos-dht11-shield","text":"Note: this is ONLY for v1.0.0 of the DHT11 shield, since v2.0.0 uses I 2 C and pinned differently. From the Wemos DHT11 shield specs the DATA OUT pin is connected to D4 of the Wemos. Note: Having the shield compact on top of the processor increases the temperature. In normal Mode this can be up to 6\u00b0C. So you should add sleep mode. Adding normal \"Sleep 100\" and putting the sensor vertically reduces the temperature difference to 2\u00b0C","title":"Wemos DHT11 Shield"},{"location":"DHT11/#sonoff-basic-specific","text":"To wire a DHT11 up to a Sonoff Basic, I first soldered a pin header to the main pin header row. For the location see GPIO Locations . I decided to use regular 2.54mm connectors (often referred to as Dupont connectors), so that I can switch sensors if I have to. In order to fit the dupont cables within the enclosure, I had to bend the 2.54mm pin headers by about 45\u00b0. As the DHT11 requires a pullup (depending on the cable length), and I didn't want to design a PCB just to connect 3 wires and a resistor, I came up with the solution described below. First, I slipped ferrules over the DHT11 pins and inserted the wires. This makes it a lot easier to hold the cables and the DHT11 pins in place. I left a bit more wire exposed so that I have a place to apply solder without burning the wire insulation. I applied heat to the ferrule, not the wire, and applied solder directly at the end of the ferrule. Solder will then flow into the ferrule. I also added a small solder blob (visible on the top ferrule) so that I can solder an 0805 resistor in place. Thanks to the ferrule, the wires won't become detached when heated again. Keep in mind that the ferrule has quite some heat capacity, so wait for the solder to cool down prior moving the wires or the sensor. I then did shrink the 2:1 green heatshrink tubes so that the contacts don't touch each other. Also, it is so very handy to have 4:1 shrinking tube. An 8mm 4:1 tube fits perfectly over the pins, and fully encloses the 3 wires. Get 4:1 heatshrink tube. It's so worth it. Here's how the finished project looks like:","title":"Sonoff Basic specific"},{"location":"DHT11/#openhab","text":"sonoff.items: // DHT-6 Number DHT6_Temp \"Bathroom DHT-6 [%.1f \u00b0C]\" <temperature> (gTemperature,gTemperatureRoom) { mqtt=\"<[broker:tele/sonoff-dht-6/SENSOR:state:JSONPATH($.DHT11.Temperature)]\" } Number DHT6_Humidity \"Bathroom DHT-6 [%.1f %%]\" <humidity> (gHumidity) { mqtt=\"<[broker:tele/sonoff-dht-6/SENSOR:state:JSONPATH($.DHT11.Humidity)]\" } Switch DHT6_Reachable \"DHT-6 reachable\" <contact> (gReachable) { mqtt=\"<[broker:tele/sonoff-dht-6/LWT:state:MAP(reachable.map)]\" } Number DHT6_RSSI \"DHT-6 RSSI [%d %%]\" <qualityofservice> (gRSSI) { mqtt=\"<[broker:tele/sonoff-dht-6/STATE:state:JSONPATH($.Wifi.RSSI)]\" } sonoff.sitemap Frame { Text item=DHT6_Temp labelcolor=[DHT6_Reachable == \"ON\" = \"green\",DHT6_Reachable == \"OFF\" = \"red\"] { Text item=DHT6_Temp Text item=DHT6_Humidity Text item=DHT6_Reachable Text item=DHT6_RSSI } }","title":"OpenHab"},{"location":"DHT11/#printable-housing","text":"https://www.thingiverse.com/thing:2814909","title":"Printable Housing"},{"location":"DS18x20/","text":"DS18x20 driver supports DS 18B20, DS18S20 and DS1822 1-Wire digital temperature sensors. Configuration ~ Wiring ~ DS18b20 ESP266 1 GND GND 2 Data GPIOx 3 VCC 3.3v You need to connect a 4.7K pullup resistor from data to 3.3V. Tasmota Settings ~ In the Configuration -> Configure Module page assign: - GPIOx to DS18x20 (4) After a reboot webUI will display temperature measured. Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2019-01-01T00:00:00\" , \"DS18B20\" :{ \"Temperature\" : 49.7 }, \"TempUnit\" : \"C\" } Commands ~ SetOption74 is used to enable/disable internal pullup for single DS18x20 sensor. TempOffset can be used for calibrating the measured temperature. This setting affects all temperature sensors on the device. Multiple Sensors ~ Tasmota supports multiple DS18b20 sensors connected to a single ESP8266 chip. Every sensors will get a unique ID used in webUI and MQTT telemetry. Sensor Versions ~ ESP01 Module ~ [!DANGER] BEWARE OF MANY VISUALLY SIMILAR BOARDS TO THIS RELAY BOARD but different schematics Some modules have culprits: * \"CH_PD\" is not set to HI (3.3V) as actually required. Usually this is done with a 10K resistor or directly to 3.3V, I have connected directly to the 3.3V * A resistor (R2 10k) which is connected between the terminal GPIO0 to ground. This ensures that the GPIO0 is always pulled to ground, which actually places the ESP-01 in program mode (flashing). To make the module working it is necessary to remove (solder out). Connect DS18B20 to the GPIO2 (see diagram below - soldering not necessary , it is possible to put the wires and the resistor directly in to the female part of the connector together with ESP 01S module pins) After flashing, set up Tasmota (see images below): * \"Generic module\" * GPIO0 as Relay1 (21) * GPIO2 as DS18x20(4) Retrieving the temperature via HTTP http://tasmota-ip/cm?user=<USER>&password=<PASS>&cmnd=status%2010 The temperature information will put published by MQTT to the tele/%topic%/SENSOR in the format of: \"Time\":\"2018-06-14T07:56:34\",\"DS18B20\":{\"Temperature\":21.9},\"TempUnit\":\"C\"}","title":"DS18x20"},{"location":"DS18x20/#configuration","text":"","title":"Configuration"},{"location":"DS18x20/#wiring","text":"DS18b20 ESP266 1 GND GND 2 Data GPIOx 3 VCC 3.3v You need to connect a 4.7K pullup resistor from data to 3.3V.","title":"Wiring"},{"location":"DS18x20/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: - GPIOx to DS18x20 (4) After a reboot webUI will display temperature measured. Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2019-01-01T00:00:00\" , \"DS18B20\" :{ \"Temperature\" : 49.7 }, \"TempUnit\" : \"C\" }","title":"Tasmota Settings"},{"location":"DS18x20/#commands","text":"SetOption74 is used to enable/disable internal pullup for single DS18x20 sensor. TempOffset can be used for calibrating the measured temperature. This setting affects all temperature sensors on the device.","title":"Commands"},{"location":"DS18x20/#multiple-sensors","text":"Tasmota supports multiple DS18b20 sensors connected to a single ESP8266 chip. Every sensors will get a unique ID used in webUI and MQTT telemetry.","title":"Multiple Sensors"},{"location":"DS18x20/#sensor-versions","text":"","title":"Sensor Versions"},{"location":"DS18x20/#esp01-module","text":"[!DANGER] BEWARE OF MANY VISUALLY SIMILAR BOARDS TO THIS RELAY BOARD but different schematics Some modules have culprits: * \"CH_PD\" is not set to HI (3.3V) as actually required. Usually this is done with a 10K resistor or directly to 3.3V, I have connected directly to the 3.3V * A resistor (R2 10k) which is connected between the terminal GPIO0 to ground. This ensures that the GPIO0 is always pulled to ground, which actually places the ESP-01 in program mode (flashing). To make the module working it is necessary to remove (solder out). Connect DS18B20 to the GPIO2 (see diagram below - soldering not necessary , it is possible to put the wires and the resistor directly in to the female part of the connector together with ESP 01S module pins) After flashing, set up Tasmota (see images below): * \"Generic module\" * GPIO0 as Relay1 (21) * GPIO2 as DS18x20(4) Retrieving the temperature via HTTP http://tasmota-ip/cm?user=<USER>&password=<PASS>&cmnd=status%2010 The temperature information will put published by MQTT to the tele/%topic%/SENSOR in the format of: \"Time\":\"2018-06-14T07:56:34\",\"DS18B20\":{\"Temperature\":21.9},\"TempUnit\":\"C\"}","title":"ESP01 Module"},{"location":"DS3231/","text":"!> This feature is not included in precompiled binaries. To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_DS3231 #define USE_DS3231 // DS3231 external RTC (+1k2 code) // #define USE_RTC_ADDR 0x68 // Default I2C address 0x68 #endif If you use a DS3231 with a different I 2 C address, uncomment and change to your address: #define USE_RTC_ADDR 0x68 Tasmota requires that its time be set in order to use timers. Usually, when the device boots, it gets the time and date from an an NTP (Network Time Protocol) server located somewhere on the Internet. When there is no Internet connection, Tasmota is not able to request the current date and time. The DS3231 is an external Real Time Clock (RTC) component used for keeping the time and date set in the device when it cannot establish an Internet connection. Configuration ~ Wiring ~ DS3231 ESP8266 GND GND VCC 3.3V SDA GPIOx SCL GPIOy Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to I2C SDA (6) GPIOy to I2C SCL (5) Wiring on Wemos D1 mini Tasmota Settings ~ Any time your device has an NTP connection, the DS3231 internal clock will be set automatically. The first time RTC is used, you must have an Internet connection . From that point forward, the time is stored in the RTC and the device time will be restored from the RTC when there is no Internet connection. (You can use your mobile phone hotspot for your device in a location where it can't get a Wi-Fi connection Check that the time is set correctly by inspecting the log in the Console. You should see messages that Tasmota read or wrote the time from and to the DS3231. Make sure that the time is set correctly even when you do not have Internet connection .","title":"DS3231"},{"location":"DS3231/#configuration","text":"","title":"Configuration"},{"location":"DS3231/#wiring","text":"DS3231 ESP8266 GND GND VCC 3.3V SDA GPIOx SCL GPIOy","title":"Wiring"},{"location":"DS3231/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to I2C SDA (6) GPIOy to I2C SCL (5) Wiring on Wemos D1 mini","title":"Tasmota Settings"},{"location":"DS3231/#tasmota-settings_1","text":"Any time your device has an NTP connection, the DS3231 internal clock will be set automatically. The first time RTC is used, you must have an Internet connection . From that point forward, the time is stored in the RTC and the device time will be restored from the RTC when there is no Internet connection. (You can use your mobile phone hotspot for your device in a location where it can't get a Wi-Fi connection Check that the time is set correctly by inspecting the log in the Console. You should see messages that Tasmota read or wrote the time from and to the DS3231. Make sure that the time is set correctly even when you do not have Internet connection .","title":"Tasmota Settings"},{"location":"DeepSleep/","text":"Deep sleep support for up to 1 day (i.e., 86,400 seconds) (e.g., if used with KNX) ( DeepSleepTime ). The ESP8266 has a limitation of a maximum of ~71 minutes deep sleep. To overcome the limitation, a short wake-up is performed - the device will wake up every hour for <0.3 seconds until the deep sleep time is reached. The remaining deep sleep time is decremented, and the device is then put back in deep sleep again. The remaining time is stored in RTC memory. As long as the device is powered (e.g., via the battery), this should work fine. Flash memory is not used because of how often this has to occur (every hour) and the time it takes for the flash to be ready takes much longer than the total time to write to the RTC. DeepSleepTime sets the time that the device remains in deep sleep before it returns to full operating mode before returning to deep sleep again. This cannot be changed! For example, if you set DeepSleepTime 3600 , the device will wake up every hour, exactly (e.g., 8:00am, 9:00am, ...). If you define DeepSleepTime 86400 (i.e., 60*60*24), it will wake-up exactly at 0:00 UTC time - not your local time. If you define DeepSleepTime 600 , it will wake-up every 10 minutes (e.g., 8:00, 8:10, 8:20, ...). To \"reset\" deep sleep, temporarily disconnect power and the RTC will be wiped on the next reboot. Alternatively, you can define a deep sleep input to temporarily disable deep sleep (described below). Please be aware that the minimum deep sleep time is 10 seconds. To wake the device, the RST pin must be connected to the D0/GPIO16 pin because the wake-up signal is sent through D0/GPIO16 to RST: It is recommended to leave GPIO16 configured as None (0) because GPIO16 cannot be used for anything else due to the hardwire to RST. Temporarily disable deep sleep mode ~ There are a couple of different methods to temporarily disable deep sleep mode as outlined below. Use a GPIO and connect it GND. This can be performed through a switch like in the schematic below. Flipping the switch ON will prevent Tasmota to enter DeepSleep again after next wake-up until the switch is flipped back OFF. You can define the DeepSleep (182) component as shown below: The following GPIOs CANNOT be used for that purpose : - GPIO16 (because it is connected to RST), - GPIO15 (because of an existing on-board pull-down resistor), - GPIO0 (because pulling it down at wake up will enter serial bootload mode). All others GPIO should be acceptables. An interresting use-case is to disable DeepSleep when an external power (USB, PSU, solar panel...) is applied to the device using a transistor like: If the device is not (easily) accessible, the below methods can be used disable the DeepSleep loop without physically accessing it. Send a retained DeepSleepTime 0 command to your device. As the message is retained in the MQTT broker, the device will receive it as soon as it connectes to the MQTT broker. If you are running hte moquitto broker, the following command line will do: mosquitto_pub -t \"cmnd/myDeviceTopic/DeepsleepTime\" -r -m \"0\" Or from another Tasmota device, you can use the console to send: publish2 cmnd/myDeviceTopic/DeepSleepTime 0 Don't forget to remove the retained flag so the broker can \"forget\" this message with mosquitto_pub -t \"cmnd/myDeviceTopic/DeepsleepTime\" -r -n or using a tool such as MQTT explorer. Once you have made your configuration change, you will need to re-enable the DeepSleep mode using the DeepSleepTime command. Configure a settable flag in your home automation hub (e.g., Node-Red, openHAB, Home Assistant). The flag should subscribe to the INFO1 boot time message on the device topic, e.g., tele/myDeviceTopic/INFO1 . The moment a message is received on this topic, the automation solution can publish a message to topic cmnd/myDeviceTopic/DeepSleepTime with a payload 0 . This will cause the device to disable deep sleep and allow maintenance such as firmware updates to be performed without having an unexpected deep sleep event. Send the DeepSleepTime 0 command only once . Once the device maintenance is completed, place the device back into deep sleep mode using the original configuration. Be sure to change myDeviceTopic to the device topic. If you're having issues after wakeup from sleep make sure bootloop detection is off SetOption36 0 #6890 Executing commands before entering DeepSleep ~ If you want to execute some commands or a special script BEFORE the device goes into deep sleep you can use FUNC_SAVE_BEFORE_RESTART as a predefined hook to implement your own procedure. This requires you to code your own function and self-compile custom firmware. To use rules, use the System#Save trigger. This will be executed just before the device goes into deep sleep. Overcome any Network issue ~ If all requirements (Wifi, time synchronization via NTP, MQTT broker connection, and the Teleperiod) are not met, the device will stay awake while trying to attain the remaining requirements. On battery powered devices this behavior is undesirable because it will quickly deplete the battery. To avoid this when these requirements cannot be met, put the device back into deep sleep for an hour. Do this through a rule that will be triggered 30 seconds after reboot and sends the device into deepsleep for an hour. Rule1 ON Dimmer#Boot DO RuleTimer1 30 ENDON ON Rules#Timer=1 DO DeepSleepTime 3600 ENDON Rule1 ON Deep Sleep Algorithm General Timing ~ Let's assume you have set DeepSleepTime 3600 (one hour) and TelePeriod 300 (five minutes). The device will first wake at 8:00 am. The device will boot and connect Wi-Fi. Next, the correct time must be sync'ed from one of the NTP servers. Now the device has all prerequisites for going into deep sleep. Deep sleep is then triggered at the TELEPERIOD event. In this example, it will occur after five minutes. Telemetry will be collected and sent (e.g., via MQTT). Now, deep sleep can happen. First, Offline is published to the LWT topic on MQTT. It then calculates the new sleeping time to wake-up at 9:00 am (3600 seconds after the last wake-up). At 9:00 am this same sequence of events happens again. If you want to minimize the time that the device is in operation, decrease TELEPERIOD down to 10 seconds. This period of time is counted after MQTT is connected. Also, in this case, the device will wake up at 9:00 am even if the uptime was much smaller. If the device missed a wake-up it will try a start at the next event - in this case 10:00 am. WEMOS D1 Deep Sleep Side-effects ~ Not all GPIO behave the same during deep sleep. Some GPIO go HIGH, some LOW, some FOLLOW the relay but work only on FET transistors. As soon as current flows they go LOW. I use one GPIO to trigger a BC337 transistor to switch OFF all connected devices during deep sleep. Findings: Pin GPIO Behavior D0 16 Excluded due to use as wake-up pin D1 5 KEEP STATE, go LOW if resistance to ground < infinite D2 4 KEEP STATE, go LOW if resistance to ground < infinite D3 0 HIGH D4 2 HIGH D5 14 HIGH, go LOW if resistance to ground < infinite D6 12 HIGH, go LOW if resistance to ground < infinite D7 13 HIGH, go LOW if resistance to ground < infinite D8 15 LOW Log Output Explanation ~ (logging level 4 ) When MQTT connects at 13:08:38 , this sets the system to READY. 13 : 08 : 43 MQT : tele /tasmota/ INFO3 = { \"RestartReason\" : \"Deep-Sleep Wake\" } 13 : 08 : 44 APP : Boot Count 3 13 : 08 : 44 CFG : Saved to flash at F4 , Count 96 , Bytes 3824 In the context of DeepSleep, maintaining a device boot count is not relevant. When deep sleep is enabled, boot count will not be incremented. This avoids excessive flash writes which will deteriorate the flash memory chip and eventually cause the device to fail. Boot count incrementing can be enabled using SetOption76 . In this example, TELEPERIOD is 10. Therefore when TELEPERIOD is reached, telemetry reporting occurs. 13 : 08 : 48 MQT : tele /tasmota/ STATE = { \"Time\" : \"2019-09-04T13:08:48\" , \"Epoch\" : 1567595328 , \"Uptime\" : \"0T00:00:14\" , \"UptimeSec\" : 14 , \"Heap\" : 24 , \"SleepMode\" : \"Dynamic\" , \"Sleep\" : 50 , \"LoadAvg\" : 20 , \"MqttCount\" : 1 , \"Wifi\" :{ \"AP\" : 1 , \"SSId\" : \"MyWLAN\" , \"BSSId\" : \"AA:FF:AA:AA:AA:AA\" , \"Channel\" : 11 , \"RSSI\" : 100 , \"LinkCount\" : 1 , \"Downtime\" : \"0T00:00:08\" , \"DeepSleep\" : 300 , \"Heap\" : 25160 }} 13 : 08 : 48 MQT : tele /tasmota/ SENSOR = { \"Time\" : \"2019-09-04T13:08:48\" , \"Epoch\" : 1567595328 , \"ANALOG\" :{ \"A0\" : 8 }} DATETIME is set. Status and telemetry sent. Now start shutdown procedure. First, send MQTT offline. 13:08:48 MQT: state/sonoff/LWT = Offline Deep sleep is 300 seconds. Therefore +-30 sec is allowed as the deviation between the proposed time between wake-up and real time between wake-up. Reporting in 0.1sec. In this case wake-up was one second late. 13:08:48 Timeslip 0.1 sec:? -300 < -10 < 300 If the error is in the range, this is tagged as a normal wake up where drift can we recalculated 13:08:48 Normal deepsleep? 1 Recalculate a new drift that is a multiplier for the next wake-up in 1/10000. In this case, the multiplier is 1.0257 13:08:48 % RTC new drift 10257 And for information: New target wake-up time 13:08:48 Next wakeup 2019-09-04T13:10:00 Based on run time and the error in the last loop, a new sleeping time will be calculated. This will be multiplied by the deepsleep_slip and, ideally, the device will wake up at the time above. 13:08:48 Sleeptime 285 sec, deepsleep_slip 10257 The effectiveness of the compensation can be seen here. Instead of typically 160-200 seconds, most times it is better than 10 seconds in a one hour deep sleep cycle.","title":"DeepSleep"},{"location":"DeepSleep/#temporarily-disable-deep-sleep-mode","text":"There are a couple of different methods to temporarily disable deep sleep mode as outlined below. Use a GPIO and connect it GND. This can be performed through a switch like in the schematic below. Flipping the switch ON will prevent Tasmota to enter DeepSleep again after next wake-up until the switch is flipped back OFF. You can define the DeepSleep (182) component as shown below: The following GPIOs CANNOT be used for that purpose : - GPIO16 (because it is connected to RST), - GPIO15 (because of an existing on-board pull-down resistor), - GPIO0 (because pulling it down at wake up will enter serial bootload mode). All others GPIO should be acceptables. An interresting use-case is to disable DeepSleep when an external power (USB, PSU, solar panel...) is applied to the device using a transistor like: If the device is not (easily) accessible, the below methods can be used disable the DeepSleep loop without physically accessing it. Send a retained DeepSleepTime 0 command to your device. As the message is retained in the MQTT broker, the device will receive it as soon as it connectes to the MQTT broker. If you are running hte moquitto broker, the following command line will do: mosquitto_pub -t \"cmnd/myDeviceTopic/DeepsleepTime\" -r -m \"0\" Or from another Tasmota device, you can use the console to send: publish2 cmnd/myDeviceTopic/DeepSleepTime 0 Don't forget to remove the retained flag so the broker can \"forget\" this message with mosquitto_pub -t \"cmnd/myDeviceTopic/DeepsleepTime\" -r -n or using a tool such as MQTT explorer. Once you have made your configuration change, you will need to re-enable the DeepSleep mode using the DeepSleepTime command. Configure a settable flag in your home automation hub (e.g., Node-Red, openHAB, Home Assistant). The flag should subscribe to the INFO1 boot time message on the device topic, e.g., tele/myDeviceTopic/INFO1 . The moment a message is received on this topic, the automation solution can publish a message to topic cmnd/myDeviceTopic/DeepSleepTime with a payload 0 . This will cause the device to disable deep sleep and allow maintenance such as firmware updates to be performed without having an unexpected deep sleep event. Send the DeepSleepTime 0 command only once . Once the device maintenance is completed, place the device back into deep sleep mode using the original configuration. Be sure to change myDeviceTopic to the device topic. If you're having issues after wakeup from sleep make sure bootloop detection is off SetOption36 0 #6890","title":"Temporarily disable deep sleep mode"},{"location":"DeepSleep/#executing-commands-before-entering-deepsleep","text":"If you want to execute some commands or a special script BEFORE the device goes into deep sleep you can use FUNC_SAVE_BEFORE_RESTART as a predefined hook to implement your own procedure. This requires you to code your own function and self-compile custom firmware. To use rules, use the System#Save trigger. This will be executed just before the device goes into deep sleep.","title":"Executing commands before entering DeepSleep"},{"location":"DeepSleep/#overcome-any-network-issue","text":"If all requirements (Wifi, time synchronization via NTP, MQTT broker connection, and the Teleperiod) are not met, the device will stay awake while trying to attain the remaining requirements. On battery powered devices this behavior is undesirable because it will quickly deplete the battery. To avoid this when these requirements cannot be met, put the device back into deep sleep for an hour. Do this through a rule that will be triggered 30 seconds after reboot and sends the device into deepsleep for an hour. Rule1 ON Dimmer#Boot DO RuleTimer1 30 ENDON ON Rules#Timer=1 DO DeepSleepTime 3600 ENDON Rule1 ON","title":"Overcome any Network issue"},{"location":"DeepSleep/#deep-sleep-algorithm-general-timing","text":"Let's assume you have set DeepSleepTime 3600 (one hour) and TelePeriod 300 (five minutes). The device will first wake at 8:00 am. The device will boot and connect Wi-Fi. Next, the correct time must be sync'ed from one of the NTP servers. Now the device has all prerequisites for going into deep sleep. Deep sleep is then triggered at the TELEPERIOD event. In this example, it will occur after five minutes. Telemetry will be collected and sent (e.g., via MQTT). Now, deep sleep can happen. First, Offline is published to the LWT topic on MQTT. It then calculates the new sleeping time to wake-up at 9:00 am (3600 seconds after the last wake-up). At 9:00 am this same sequence of events happens again. If you want to minimize the time that the device is in operation, decrease TELEPERIOD down to 10 seconds. This period of time is counted after MQTT is connected. Also, in this case, the device will wake up at 9:00 am even if the uptime was much smaller. If the device missed a wake-up it will try a start at the next event - in this case 10:00 am.","title":"Deep Sleep Algorithm General Timing"},{"location":"DeepSleep/#wemos-d1-deep-sleep-side-effects","text":"Not all GPIO behave the same during deep sleep. Some GPIO go HIGH, some LOW, some FOLLOW the relay but work only on FET transistors. As soon as current flows they go LOW. I use one GPIO to trigger a BC337 transistor to switch OFF all connected devices during deep sleep. Findings: Pin GPIO Behavior D0 16 Excluded due to use as wake-up pin D1 5 KEEP STATE, go LOW if resistance to ground < infinite D2 4 KEEP STATE, go LOW if resistance to ground < infinite D3 0 HIGH D4 2 HIGH D5 14 HIGH, go LOW if resistance to ground < infinite D6 12 HIGH, go LOW if resistance to ground < infinite D7 13 HIGH, go LOW if resistance to ground < infinite D8 15 LOW","title":"WEMOS D1 Deep Sleep Side-effects"},{"location":"DeepSleep/#log-output-explanation","text":"(logging level 4 ) When MQTT connects at 13:08:38 , this sets the system to READY. 13 : 08 : 43 MQT : tele /tasmota/ INFO3 = { \"RestartReason\" : \"Deep-Sleep Wake\" } 13 : 08 : 44 APP : Boot Count 3 13 : 08 : 44 CFG : Saved to flash at F4 , Count 96 , Bytes 3824 In the context of DeepSleep, maintaining a device boot count is not relevant. When deep sleep is enabled, boot count will not be incremented. This avoids excessive flash writes which will deteriorate the flash memory chip and eventually cause the device to fail. Boot count incrementing can be enabled using SetOption76 . In this example, TELEPERIOD is 10. Therefore when TELEPERIOD is reached, telemetry reporting occurs. 13 : 08 : 48 MQT : tele /tasmota/ STATE = { \"Time\" : \"2019-09-04T13:08:48\" , \"Epoch\" : 1567595328 , \"Uptime\" : \"0T00:00:14\" , \"UptimeSec\" : 14 , \"Heap\" : 24 , \"SleepMode\" : \"Dynamic\" , \"Sleep\" : 50 , \"LoadAvg\" : 20 , \"MqttCount\" : 1 , \"Wifi\" :{ \"AP\" : 1 , \"SSId\" : \"MyWLAN\" , \"BSSId\" : \"AA:FF:AA:AA:AA:AA\" , \"Channel\" : 11 , \"RSSI\" : 100 , \"LinkCount\" : 1 , \"Downtime\" : \"0T00:00:08\" , \"DeepSleep\" : 300 , \"Heap\" : 25160 }} 13 : 08 : 48 MQT : tele /tasmota/ SENSOR = { \"Time\" : \"2019-09-04T13:08:48\" , \"Epoch\" : 1567595328 , \"ANALOG\" :{ \"A0\" : 8 }} DATETIME is set. Status and telemetry sent. Now start shutdown procedure. First, send MQTT offline. 13:08:48 MQT: state/sonoff/LWT = Offline Deep sleep is 300 seconds. Therefore +-30 sec is allowed as the deviation between the proposed time between wake-up and real time between wake-up. Reporting in 0.1sec. In this case wake-up was one second late. 13:08:48 Timeslip 0.1 sec:? -300 < -10 < 300 If the error is in the range, this is tagged as a normal wake up where drift can we recalculated 13:08:48 Normal deepsleep? 1 Recalculate a new drift that is a multiplier for the next wake-up in 1/10000. In this case, the multiplier is 1.0257 13:08:48 % RTC new drift 10257 And for information: New target wake-up time 13:08:48 Next wakeup 2019-09-04T13:10:00 Based on run time and the error in the last loop, a new sleeping time will be calculated. This will be multiplied by the deepsleep_slip and, ideally, the device will wake up at the time above. 13:08:48 Sleeptime 285 sec, deepsleep_slip 10257 The effectiveness of the compensation can be seen here. Instead of typically 160-200 seconds, most times it is better than 10 seconds in a one hour deep sleep cycle.","title":"Log Output Explanation"},{"location":"Device-Groups/","text":"Device Groups ~ The device groups module provides a framework to allow multiple devices to be in a group with values such as power, light color/temperature/brightness, PWM values, sensor values, etc. shared with other devices in the group. For example, with multiple light modules in a device group, the light settings can be changed on one module and the settings will automatically be changed on the other light modules. Dimmer switch modules could be in a device group with light modules and the dimmer switch could control the power, brightness and colors of all the lights in the group. Multiple dimmer switches could be in a device group to form a 3-way/4-way dimmer switch. UDP multicasts, followed by UDP unicasts if necessary, are used to send updates to all devices so updates are fast. There is no need for an MQTT server but all the devices in a group must be on the same IP network. To include device groups support in the build, define USE_DEVICE_GROUPS in your user_config_override. This adds 3.5K to the code size. All devices in a group must be running firmware with device group support and have device groups enabled. To enable device groups, execute the command SetOption85 1. Device Groups Operation ~ The device group name is the MQTT group topic set with the GroupTopic command. All devices in the same IP network with the same group topic are in the same group. Some modules may define additional device groups. For example, if Remote Device Mode is enabled, the PWM Dimmer module defines three devices groups. The items that are sent to the group and the items that are received from the group are selected with the DevGroupShare command. By default all items are sent and received from the group. An example of when the DevGroupShare command would be used is when you have a group of lights that you control with a dimmer switch and home automation software. You want the dimmer switch to be able to control all items. The home automation software controls each light individually. When it controls the whole group, it actually sends command to each light in the group. If you use the home automation software to turn an individual light on or off or change it\u2019s brightness, color or scheme, you do not want the change to be replicated to the other lights. In this case, you would set the incoming and outgoing item masks to 0xffffffff (all items) on the dimmer switch (DevGroupShare 0xffffffff,0xffffffff) and set the incoming item mask to 0xffffffff and outgoing item mask to 0 on all the lights (DevGroupShare 0xffffffff,0). Commands ~ Command Parameters DevGroupShare <in>,<out> = set incoming and outgoing shared item mask (default = 0xffffffff,0xffffffff) 1 = Power, 2 = Light brightness, 4 = Light fade/speed, 8 = Light scheme, 16 = Light color, 32 = Dimmer settings (presets) GroupTopic<x> 1 = reset device group <x> MQTT group topic to firmware default (MQTT_GRPTOPIC) and restart <value> = set device group <x> MQTT group topic (32 chars max) and restart","title":"Device Groups"},{"location":"Device-Groups/#device-groups","text":"The device groups module provides a framework to allow multiple devices to be in a group with values such as power, light color/temperature/brightness, PWM values, sensor values, etc. shared with other devices in the group. For example, with multiple light modules in a device group, the light settings can be changed on one module and the settings will automatically be changed on the other light modules. Dimmer switch modules could be in a device group with light modules and the dimmer switch could control the power, brightness and colors of all the lights in the group. Multiple dimmer switches could be in a device group to form a 3-way/4-way dimmer switch. UDP multicasts, followed by UDP unicasts if necessary, are used to send updates to all devices so updates are fast. There is no need for an MQTT server but all the devices in a group must be on the same IP network. To include device groups support in the build, define USE_DEVICE_GROUPS in your user_config_override. This adds 3.5K to the code size. All devices in a group must be running firmware with device group support and have device groups enabled. To enable device groups, execute the command SetOption85 1.","title":"Device Groups"},{"location":"Device-Groups/#device-groups-operation","text":"The device group name is the MQTT group topic set with the GroupTopic command. All devices in the same IP network with the same group topic are in the same group. Some modules may define additional device groups. For example, if Remote Device Mode is enabled, the PWM Dimmer module defines three devices groups. The items that are sent to the group and the items that are received from the group are selected with the DevGroupShare command. By default all items are sent and received from the group. An example of when the DevGroupShare command would be used is when you have a group of lights that you control with a dimmer switch and home automation software. You want the dimmer switch to be able to control all items. The home automation software controls each light individually. When it controls the whole group, it actually sends command to each light in the group. If you use the home automation software to turn an individual light on or off or change it\u2019s brightness, color or scheme, you do not want the change to be replicated to the other lights. In this case, you would set the incoming and outgoing item masks to 0xffffffff (all items) on the dimmer switch (DevGroupShare 0xffffffff,0xffffffff) and set the incoming item mask to 0xffffffff and outgoing item mask to 0 on all the lights (DevGroupShare 0xffffffff,0).","title":"Device Groups Operation"},{"location":"Device-Groups/#commands","text":"Command Parameters DevGroupShare <in>,<out> = set incoming and outgoing shared item mask (default = 0xffffffff,0xffffffff) 1 = Power, 2 = Light brightness, 4 = Light fade/speed, 8 = Light scheme, 16 = Light color, 32 = Dimmer settings (presets) GroupTopic<x> 1 = reset device group <x> MQTT group topic to firmware default (MQTT_GRPTOPIC) and restart <value> = set device group <x> MQTT group topic (32 chars max) and restart","title":"Commands"},{"location":"Device-Recovery/","text":"Device Recovery ~ Configuration problems can cause boot loops, erratic behavior, devices which will not appear (i.e., no tasmota-xxxx AP) or connect to Wi-Fi, etc. In cases such as these when there is no proper operation a recovery process is required. By default, the firmware tries to preserve the existing configuration (to support automated updates via OTA upgrades). However, various things can happen that cause the existing configuration to become problematic, e.g., when upgrading from old releases without following the migration path . When code updates change the values or the way settings are used, those code changes don't directly write the settings on the running device when you load the new firmware. What happens is that when it boots up, the firmware looks to see if it has a valid configuration (if its an upgrade from an older Tasmota version) and if the CFG_HOLDER value is in the right place it assumes that the existing configuration is valid. If it doesn't find the right value it assumes that this is not a \"simple\" upgrade and takes the compiled-in configuration settings and writes them out to the configuration area. Recovery Techniques ~ Listed below are a few ways to reset the device to what is set in the firmware binary ( my_user_config.h and user_config_override.h ) aka firmware defaults, in order to recover a device: Hold the button ( Button1 ) down, if available, for 40 seconds. After that the device should reset and reboot. Fully cycle power after that is done to make sure everything is starting from scratch. Issue Reset 1 command via the console, MQTT or HTTP. After the device reboots fully cycle power. use Fast Power Cycle Device Recovery procedure Fast Power Cycle Device Recovery ~ Implemented for situations where a device cannot be reset to firmware defaults by other means (no serial access, no button). It resets ALL Tasmota settings (equal to Reset 1 ) after 4 power cycles. SetOption65 must be set to 0 (default) in order for this feature to be enabled. Tip If you have a weak power grid or frequent power brownouts its best to disable this feature with SetOption65 1 immediately or you'll end up with firmware default devices after a brownout event. Procedure Cut power from the device completely for 30 seconds Power the device on and off three times with intervals lower than 10 seconds and leave it on after fourth time Fast power cycle device recovery should activate and the device should be reset to firmware defaults If you flashed a precompiled binary you can reconfigure the device using the web UI after the reset. If your region experiences regular brownouts (rapid succession power outages), you should disable this feature to avoid unwanted device settings resets. Use SetOption65 1 to disable power cycle recovery. After Recovery... ~ Once recovered, the device should be observed that it operates without instabilities before attempting to configure the device in any way. If the device still does not, follow these steps if you are able to configure its Wi-Fi and connect: 1. Configure the device as Generic (18) 2. Perform an OTA upgrade specifically to tasmota-minimal.bin . Taking this intermediate step ensures that the firmware will be reloaded. Since Tasmota performs a version comparison before performing the OTA update, explicitly changing the firmware that is on the device will ensure that the firmware is indeed replaced in the next step. 3. Perform an OTA upgrade to the desired firmware variant. Once the device operates reliably, begin the configuration to set the GPIO configuration (via a Template or Module). Take any further configuration steps one at a time to ensure that after each setting is applied, the device continues to operate reliably. If the device exhibits defective behavior immediately after a particular individual setting is changed, then be aware that there may be a problem in the firmware. Please report this behavior via the Tasmota Discord Chat . If none of these methods result in reliable operation, the only remaining option is to connect the device to the serial programming interface, erase the flash memory and flash a different precompiled firmware binary.","title":"Device Recovery"},{"location":"Device-Recovery/#device-recovery","text":"Configuration problems can cause boot loops, erratic behavior, devices which will not appear (i.e., no tasmota-xxxx AP) or connect to Wi-Fi, etc. In cases such as these when there is no proper operation a recovery process is required. By default, the firmware tries to preserve the existing configuration (to support automated updates via OTA upgrades). However, various things can happen that cause the existing configuration to become problematic, e.g., when upgrading from old releases without following the migration path . When code updates change the values or the way settings are used, those code changes don't directly write the settings on the running device when you load the new firmware. What happens is that when it boots up, the firmware looks to see if it has a valid configuration (if its an upgrade from an older Tasmota version) and if the CFG_HOLDER value is in the right place it assumes that the existing configuration is valid. If it doesn't find the right value it assumes that this is not a \"simple\" upgrade and takes the compiled-in configuration settings and writes them out to the configuration area.","title":"Device Recovery"},{"location":"Device-Recovery/#recovery-techniques","text":"Listed below are a few ways to reset the device to what is set in the firmware binary ( my_user_config.h and user_config_override.h ) aka firmware defaults, in order to recover a device: Hold the button ( Button1 ) down, if available, for 40 seconds. After that the device should reset and reboot. Fully cycle power after that is done to make sure everything is starting from scratch. Issue Reset 1 command via the console, MQTT or HTTP. After the device reboots fully cycle power. use Fast Power Cycle Device Recovery procedure","title":"Recovery Techniques"},{"location":"Device-Recovery/#fast-power-cycle-device-recovery","text":"Implemented for situations where a device cannot be reset to firmware defaults by other means (no serial access, no button). It resets ALL Tasmota settings (equal to Reset 1 ) after 4 power cycles. SetOption65 must be set to 0 (default) in order for this feature to be enabled. Tip If you have a weak power grid or frequent power brownouts its best to disable this feature with SetOption65 1 immediately or you'll end up with firmware default devices after a brownout event.","title":"Fast Power Cycle Device Recovery"},{"location":"Device-Recovery/#after-recovery","text":"Once recovered, the device should be observed that it operates without instabilities before attempting to configure the device in any way. If the device still does not, follow these steps if you are able to configure its Wi-Fi and connect: 1. Configure the device as Generic (18) 2. Perform an OTA upgrade specifically to tasmota-minimal.bin . Taking this intermediate step ensures that the firmware will be reloaded. Since Tasmota performs a version comparison before performing the OTA update, explicitly changing the firmware that is on the device will ensure that the firmware is indeed replaced in the next step. 3. Perform an OTA upgrade to the desired firmware variant. Once the device operates reliably, begin the configuration to set the GPIO configuration (via a Template or Module). Take any further configuration steps one at a time to ensure that after each setting is applied, the device continues to operate reliably. If the device exhibits defective behavior immediately after a particular individual setting is changed, then be aware that there may be a problem in the firmware. Please report this behavior via the Tasmota Discord Chat . If none of these methods result in reliable operation, the only remaining option is to connect the device to the serial programming interface, erase the flash memory and flash a different precompiled firmware binary.","title":"After Recovery..."},{"location":"Displays/","text":"This feature is not included in precompiled binaries. To use it you must compile your build . Add the following to user_config_override.h : #define directive Description USE_DISPLAY Enable display support. Also requires at least one of the following compilation directives USE_DISPLAY_LCD Enable LCD display. Also requires USE_I2C USE_DISPLAY_SSD1306 Enable OLED SSD1306 display. Also requires USE_I2C USE_DISPLAY_MATRIX Enable MATRIX display USE_DISPLAY_ILI9341 Enable TFT display. Also requires USE_SPI USE_DISPLAY_EPAPER_29 Enable EPAPER_29 display. Also requires USE_SPI USE_DISPLAY_EPAPER_42 Enable EPAPER_42 display. Also requires USE_SPI USE_DISPLAY_SH1106 Enable OLED SH1106 display. Also requires USE_I2C USE_DISPLAY_ILI9488 Enable TFT ILI9488 display. Also requires USE_SPI USE_DISPLAY_SSD1351 Enable OLED SSD1351 display. Also requires USE_SPI USE_DISPLAY_RA8876 Enable TFT RA8876 display. Also requires USE_SPI USE_TOUCH_BUTTONS Enable virtual touch button support with touch displays SHOW_SPLASH Enable initialization splash message on the display USE_AWATCH Enables analog watch support USE_GRAPH Enable line charts. Also requires NUM_GRAPHS Display Commands ~ See commands page for full list of available Display Commands DisplayMode Parameters ~ The display driver is able to display predefined setups of text or user defined text. To display text using DisplayText set DisplayMode to 0 , or set DisplayMode to 1 for the HT16K33 dot-matrix display. Parameter LCD Display OLED Display TFT Display 0 DisplayText DisplayText DisplayText 1 Time/Date Time/Date Time/Date 2 Local sensors Local sensors Local sensors 3 MQTT and Time/Date Local sensors and Time/Date Local sensors and Time/Date 4 Local sensors MQTT and local sensors MQTT and local sensors 5 MQTT and Time/Date MQTT, local sensors and Time/Date MQTT, local sensors and Time/Date DisplayText Use ~ The DisplayText command is used to display text as well as graphics and graphs on LCD, OLED and e-Paper displays (EPD). The command argument is a string that is printed on the display at the current position. The string can be prefixed by embedded control commands enclosed in brackets [] . In order to use the DisplayText command the DisplayMode must be set to 0 (or optional 1 on LCD displays) or other modes must be disabled before compilation with #undef USE_DISPLAY_MODES1TO5 . DisplayText parameters ~ In the list below p stands for parameter and may be a number from 1 to n digits. On monochrome graphic displays things are drawn into a local frame buffer and sent to the display either via the d command or automatically at the end of the command. Positioning ~ lp = sets a character line to print at (on LCD display p = {0\u2026}, on TFT display p = {1\u2026}) cp = sets a character column to print at (on LCD display p = {0\u2026}, on TFT display p = {1\u2026}) xp = sets the x position for consecutive prints yp = sets the y position for consecutive prints Text is printed at the last provided position, either l or y for the vertical position, and either x or x for the horizontal position. Neither x nor y are advanced/updated after printing text. Line primitives ~ hp = draws a horizontal line with length p (x is advanced) vp = draws a vertical line with length p (y is advanced) Lp:p = draws a line top: p (x,y are advanced) kp = draws a circle with radius p Kp = draws a filled circle with radius p rp:p = draws a rectangle with p with and p height Rp:p = draws a filled rectangle with p with and p height up:p:p = draws a rounded rectangle with p with, p height and p radius ( not for ILI9341 ) Up:p:p = draws a filled rounded rectangle with p with, p height and p radius ( not for ILI9341 ) Miscellaneous ~ z = clear the display i = (re)init the display (in e-Paper mode with partial update) I = (re)init the display (in e-Paper mode with full update) d = update the display Dp = switch display auto updates on( p =1)/off( p =0), when off display must be updated with d o = switch display off O = switch display on ap = p (0..3) set rotation angle t = display Tasmota time in HH:MM tS = display Tasmota time in HH:MM:SS T = display Tasmota date in DD.MM.YY pp = pad text with spaces, positive values align left, negative values align right sp = set text scaling for classic GFX font (scaling factor 1...N) fp = set font (1=12, 2=24,(opt 3=8)) if font==0 the classic GFX font is used, if font==7 RA8876 internal font is used Cp = set foreground color (0,1) for black or white and RGB decimal code for color Bp = set background color (0,1) for black or white and RGB decimal code for color Cip = set foreground index color (0..18) for color displays (see index color table below) Bip = set background index color (0..18) for color displays (see index color table below) wp = draws an analog watch with radius p (#define USE_AWATCH) Pfilename: = display an rgb 16-bit color image when SD card file system is present Touch Buttons ~ ( #define USE_TOUCH_BUTTONS ) Draw up to 16 GFX buttons to switch real Tasmota devices such as relays. - Button number + 256 - a virtual touch toggle button is created (MQTT => TBT) - Button number + 512 - a virtual touch push button is created (MQTT => PBT) b#:xp:yp:xa:ys:oc:fc:tc:ts:text: Parameters are separated by colons. * b# where # = button number 0-15 * xp = x position * yp = y position * xa = x size * ys = y size * oc = outline index color * fc = fill index color * tc = text index color * ts = text size * text: = button text (must end with a colon :) (max 9 chars) Example: b0:260:260:100:50:2:11:4:2:Rel 1: Line chart ~ ( #define USE_GRAPH and #define NUM_GRAPHS 4 - maximum of 16) Up to 4 line charts may be defined. Example n = graph number (0..3) + x ticks (16*number of x ticks) + y ticks (1024*number of y ticks). Gn:xp:yp:xs:ys:t:fmax:fmin defines a line chart: Parameters are separated by colons. * n = number up to 4 charts (0..3) + optional ticks * xp = x position * yp = y position * xs = x size (if xs<0) graph is not reinitialized on second call (e.g., restart of scripter) * ys = y size * t = time in minutes for total chart * ymin = float chart minimum y * ymax = float chart maximum y * icol = line color index (only for color graphs) gn:v adds a value to the chart buffer: * n = number up to 4 charts (0..3) * v = float value to add Gdn:m sets graph n draw mode 0 = off, 1 = on. When on, redraw graph * Gsn:path: = save graph n to path (if optional SD card is present) * Grn:path: = restore graph n from path (if optional SD card is present) Color Indices ~ Selected with Ci and Bi in the ILI9488, SSD1351, and RA8876 color panels Index Color Index Color Index Color 0 BLACK 1 WHITE 2 RED 3 GREEN 4 BLUE 5 CYAN 6 MAGENTA 7 YELLOW 8 NAVY 9 DARKGREEN 10 DARKCYAN 11 MAROON 12 PURPLE 13 OLIVE 14 LIGHTGREY 15 DARKGREY 16 ORANGE 17 GREENYELLOW 18 PINK Notes on e-Paper Displays E-Paper displays have 2 operating modes: full update and partial update. While full update delivers a clean and sharp picture, it has the disadvantage of taking several seconds for the screen update and shows severe flickering during update. Partial update is quite fast (300 ms) with no flickering but there is the possibility that erased content is still slightly visible. It is therefore useful to perform a full update in regular intervals (e.g., each hour) to fully refresh the display. Compilation directives: #define USE_SPI , #define USE_DISPLAY , #define USE_DISPLAY_EPAPER29 , or #define USE_DISPLAY_EPAPER42 Remark : the 4.2 e-Paper display requires about 15k of RAM. Therefore it only works with Core 2.42 and above. OLED Lifetime The typical specifications for the lifetime of an OLED when permanently on is about 10000 hours (416 days). Dimming to 50% expands the lifetime to about 25000 hours. Burn-in The data sheets of the TFT and OLED displays mention burn-in effects when a static display is shown for extended periods of time. You may want to consider turning on the display on demand only. Fonts ~ The EPD font contains 95 characters starting from code 32, while the classic GFX font contains 256 characters ranging from 0 to 255. Custom characters above 127 can be displayed. To display these characters, you must specify an escape sequence (standard octal escapes do not work). The ~ character followed by a hex byte can define any character code. GFXFont: EPDFont: Hardware Connections ~ I 2 C displays are connected in the usual manner and defined via the GPIO component selection. The I 2 C address must be specified using DisplayAddress XX , e.g., 60 . The model must be spedified with DisplayModel , e.g., 2 for SSD1306. To permanently turn the display on set DisplayDimmer 100 . Display rotation can be permanently set using DisplayRotate X (x = 0..3 ). E-Paper displays are connected via software 3-wire SPI (CS, SCLK, MOSI) . The other three interface lines of the display (DC, Reset, busy) may be left unconnected. The jumper on the circuit board of the display must be set to 3-wire SPI. The ILI9488, ILI9341 and SSD1351 are connected via hardware 3-wire SPI (MOSI=GPIO13, SCLK=GPIO14, CS=GPIO15) . The ILI9488 must also be connected to the backlight pin (dimmer supported on SSD1351). Wiring The RA8876 is connected via standard hardware 4-wire SPI (MOSI=GPIO13, SCLK=GPIO14, CS=GPIO15, MISO=GPIO12) . No backlight pin is needed (dimmer supported). Examples ~ Print Text at size 1 on line 1, column 1: DisplayText [s1l1c1]Hello how are you? Draw a rectangle and draw text inside with size 2 and 7 chars padded with spaces: DisplayText [x85y95h130v30h-130v-30s2p7x90y100]37.25 C Refresh screen: DisplayText [z] Draw rectangle from x,y with width and height: DisplayText [x50y50r200:100] Display Local Sensors ~ (line breaks and indentation added to the rules for readability) Use Tasmota rules to display sensor values, time, and a separation line. Refresh the display every 60 minutes: rule1 on tele - SHT3X - 0x44 # Temperature do DisplayText [ f1p7x0y5 ] % value % C endon on tele - SHT3X - 0x44 # Humidity do DisplayText [ f1p10x70y5 ] % value % % [ x0y20h296x250y5t ] endon on tele - BMP280 # Pressure do DisplayText [ f1p10x140y5 ] % value % hPa endon on Time # Minute | 60 do DisplayText [ Tt ] endon Show 4 analog channels: rule1 on tele - ADS1115 # A0 do DisplayText [ s1p21c1l01 ] Analog1: % value % adc endon on tele - ADS1115 # A1 do DisplayText [ s1p21c1l3 ] Analog2: % value % adc endon on tele - ADS1115 # A2 do DisplayText [ s1p21c1l5 ] Analog3: % value % adc endon on tele - ADS1115 # A3 do DisplayText [ s1p21c1l7 ] Analog4: % value % adc endon Show BME280 + SGP30: rule1 on tele - BME280 # Temperature do DisplayText [ s1p21x0y0 ] Temp: % value % C endon on tele - BME280 # Humidity do DisplayText [ s1p21x0y10 ] Hum : % value % %% endon on tele - BME280 # Pressure do DisplayText [ s1p21x0y20 ] Prss: % value % hPa endon on tele - SGP30 # TVOC do DisplayText [ s1p21x0y30 ] TVOC: % value % ppb endon on tele - SGP30 # eCO2 do DisplayText [ s1p21x0y40 ] eCO2 : % value % ppm [ s1p0x0y50 ] Time: [ x35y50t ] endon Display Drivers ~ Waveshare has two kinds of display controllers: with partial update and without partial update. The 2.9 inch driver is for partial update and should also support other Waveshare partial update models with modified WIDTH and HEIGHT parameters. The 4.2 inch driver is a hack which makes the full update display behave like a partial update and should probably work with other full update displays. The drivers are subclasses of the Adafruit GFX library. The class hierarchy is LOWLEVEL :: Paint :: Renderer :: GFX , where: GFX : unmodified Adafruit library Renderer : the interface for Tasmota Paint : the modified pixel driver for e-paper - there are several virtual functions that can be subclassed down to LOWLEVEL . The display dispatcher only does the class initialization call. All other calls go to the Renderer class. In black and white displays, a local RAM buffer must be allocated before calling the driver. This must be set to zero on character or TFT color displays. Remark : To use the 400x300 e-Paper display, the Arduino library 2.4 or later must be used because it leaves much more RAM available than prior versions. This display requires 15k of RAM! The EPD fonts use about 9k space, which can be selected at compile time using #ifdef directives. SSD1306 - 1.15k EPD42 - 2.57k EPD29 - 2.1k Display and Render class - ~12k","title":"Displays"},{"location":"Displays/#display-commands","text":"See commands page for full list of available Display Commands","title":"Display Commands"},{"location":"Displays/#displaymode-parameters","text":"The display driver is able to display predefined setups of text or user defined text. To display text using DisplayText set DisplayMode to 0 , or set DisplayMode to 1 for the HT16K33 dot-matrix display. Parameter LCD Display OLED Display TFT Display 0 DisplayText DisplayText DisplayText 1 Time/Date Time/Date Time/Date 2 Local sensors Local sensors Local sensors 3 MQTT and Time/Date Local sensors and Time/Date Local sensors and Time/Date 4 Local sensors MQTT and local sensors MQTT and local sensors 5 MQTT and Time/Date MQTT, local sensors and Time/Date MQTT, local sensors and Time/Date","title":"DisplayMode Parameters"},{"location":"Displays/#displaytext-use","text":"The DisplayText command is used to display text as well as graphics and graphs on LCD, OLED and e-Paper displays (EPD). The command argument is a string that is printed on the display at the current position. The string can be prefixed by embedded control commands enclosed in brackets [] . In order to use the DisplayText command the DisplayMode must be set to 0 (or optional 1 on LCD displays) or other modes must be disabled before compilation with #undef USE_DISPLAY_MODES1TO5 .","title":"DisplayText Use"},{"location":"Displays/#displaytext-parameters","text":"In the list below p stands for parameter and may be a number from 1 to n digits. On monochrome graphic displays things are drawn into a local frame buffer and sent to the display either via the d command or automatically at the end of the command.","title":"DisplayText parameters"},{"location":"Displays/#positioning","text":"lp = sets a character line to print at (on LCD display p = {0\u2026}, on TFT display p = {1\u2026}) cp = sets a character column to print at (on LCD display p = {0\u2026}, on TFT display p = {1\u2026}) xp = sets the x position for consecutive prints yp = sets the y position for consecutive prints Text is printed at the last provided position, either l or y for the vertical position, and either x or x for the horizontal position. Neither x nor y are advanced/updated after printing text.","title":"Positioning"},{"location":"Displays/#line-primitives","text":"hp = draws a horizontal line with length p (x is advanced) vp = draws a vertical line with length p (y is advanced) Lp:p = draws a line top: p (x,y are advanced) kp = draws a circle with radius p Kp = draws a filled circle with radius p rp:p = draws a rectangle with p with and p height Rp:p = draws a filled rectangle with p with and p height up:p:p = draws a rounded rectangle with p with, p height and p radius ( not for ILI9341 ) Up:p:p = draws a filled rounded rectangle with p with, p height and p radius ( not for ILI9341 )","title":"Line primitives"},{"location":"Displays/#miscellaneous","text":"z = clear the display i = (re)init the display (in e-Paper mode with partial update) I = (re)init the display (in e-Paper mode with full update) d = update the display Dp = switch display auto updates on( p =1)/off( p =0), when off display must be updated with d o = switch display off O = switch display on ap = p (0..3) set rotation angle t = display Tasmota time in HH:MM tS = display Tasmota time in HH:MM:SS T = display Tasmota date in DD.MM.YY pp = pad text with spaces, positive values align left, negative values align right sp = set text scaling for classic GFX font (scaling factor 1...N) fp = set font (1=12, 2=24,(opt 3=8)) if font==0 the classic GFX font is used, if font==7 RA8876 internal font is used Cp = set foreground color (0,1) for black or white and RGB decimal code for color Bp = set background color (0,1) for black or white and RGB decimal code for color Cip = set foreground index color (0..18) for color displays (see index color table below) Bip = set background index color (0..18) for color displays (see index color table below) wp = draws an analog watch with radius p (#define USE_AWATCH) Pfilename: = display an rgb 16-bit color image when SD card file system is present","title":"Miscellaneous"},{"location":"Displays/#touch-buttons","text":"( #define USE_TOUCH_BUTTONS ) Draw up to 16 GFX buttons to switch real Tasmota devices such as relays. - Button number + 256 - a virtual touch toggle button is created (MQTT => TBT) - Button number + 512 - a virtual touch push button is created (MQTT => PBT) b#:xp:yp:xa:ys:oc:fc:tc:ts:text: Parameters are separated by colons. * b# where # = button number 0-15 * xp = x position * yp = y position * xa = x size * ys = y size * oc = outline index color * fc = fill index color * tc = text index color * ts = text size * text: = button text (must end with a colon :) (max 9 chars) Example: b0:260:260:100:50:2:11:4:2:Rel 1:","title":"Touch Buttons"},{"location":"Displays/#line-chart","text":"( #define USE_GRAPH and #define NUM_GRAPHS 4 - maximum of 16) Up to 4 line charts may be defined. Example n = graph number (0..3) + x ticks (16*number of x ticks) + y ticks (1024*number of y ticks). Gn:xp:yp:xs:ys:t:fmax:fmin defines a line chart: Parameters are separated by colons. * n = number up to 4 charts (0..3) + optional ticks * xp = x position * yp = y position * xs = x size (if xs<0) graph is not reinitialized on second call (e.g., restart of scripter) * ys = y size * t = time in minutes for total chart * ymin = float chart minimum y * ymax = float chart maximum y * icol = line color index (only for color graphs) gn:v adds a value to the chart buffer: * n = number up to 4 charts (0..3) * v = float value to add Gdn:m sets graph n draw mode 0 = off, 1 = on. When on, redraw graph * Gsn:path: = save graph n to path (if optional SD card is present) * Grn:path: = restore graph n from path (if optional SD card is present)","title":"Line chart"},{"location":"Displays/#color-indices","text":"Selected with Ci and Bi in the ILI9488, SSD1351, and RA8876 color panels Index Color Index Color Index Color 0 BLACK 1 WHITE 2 RED 3 GREEN 4 BLUE 5 CYAN 6 MAGENTA 7 YELLOW 8 NAVY 9 DARKGREEN 10 DARKCYAN 11 MAROON 12 PURPLE 13 OLIVE 14 LIGHTGREY 15 DARKGREY 16 ORANGE 17 GREENYELLOW 18 PINK","title":"Color Indices"},{"location":"Displays/#fonts","text":"The EPD font contains 95 characters starting from code 32, while the classic GFX font contains 256 characters ranging from 0 to 255. Custom characters above 127 can be displayed. To display these characters, you must specify an escape sequence (standard octal escapes do not work). The ~ character followed by a hex byte can define any character code. GFXFont: EPDFont:","title":"Fonts"},{"location":"Displays/#hardware-connections","text":"I 2 C displays are connected in the usual manner and defined via the GPIO component selection. The I 2 C address must be specified using DisplayAddress XX , e.g., 60 . The model must be spedified with DisplayModel , e.g., 2 for SSD1306. To permanently turn the display on set DisplayDimmer 100 . Display rotation can be permanently set using DisplayRotate X (x = 0..3 ). E-Paper displays are connected via software 3-wire SPI (CS, SCLK, MOSI) . The other three interface lines of the display (DC, Reset, busy) may be left unconnected. The jumper on the circuit board of the display must be set to 3-wire SPI. The ILI9488, ILI9341 and SSD1351 are connected via hardware 3-wire SPI (MOSI=GPIO13, SCLK=GPIO14, CS=GPIO15) . The ILI9488 must also be connected to the backlight pin (dimmer supported on SSD1351). Wiring The RA8876 is connected via standard hardware 4-wire SPI (MOSI=GPIO13, SCLK=GPIO14, CS=GPIO15, MISO=GPIO12) . No backlight pin is needed (dimmer supported).","title":"Hardware Connections"},{"location":"Displays/#examples","text":"Print Text at size 1 on line 1, column 1: DisplayText [s1l1c1]Hello how are you? Draw a rectangle and draw text inside with size 2 and 7 chars padded with spaces: DisplayText [x85y95h130v30h-130v-30s2p7x90y100]37.25 C Refresh screen: DisplayText [z] Draw rectangle from x,y with width and height: DisplayText [x50y50r200:100]","title":"Examples"},{"location":"Displays/#display-local-sensors","text":"(line breaks and indentation added to the rules for readability) Use Tasmota rules to display sensor values, time, and a separation line. Refresh the display every 60 minutes: rule1 on tele - SHT3X - 0x44 # Temperature do DisplayText [ f1p7x0y5 ] % value % C endon on tele - SHT3X - 0x44 # Humidity do DisplayText [ f1p10x70y5 ] % value % % [ x0y20h296x250y5t ] endon on tele - BMP280 # Pressure do DisplayText [ f1p10x140y5 ] % value % hPa endon on Time # Minute | 60 do DisplayText [ Tt ] endon Show 4 analog channels: rule1 on tele - ADS1115 # A0 do DisplayText [ s1p21c1l01 ] Analog1: % value % adc endon on tele - ADS1115 # A1 do DisplayText [ s1p21c1l3 ] Analog2: % value % adc endon on tele - ADS1115 # A2 do DisplayText [ s1p21c1l5 ] Analog3: % value % adc endon on tele - ADS1115 # A3 do DisplayText [ s1p21c1l7 ] Analog4: % value % adc endon Show BME280 + SGP30: rule1 on tele - BME280 # Temperature do DisplayText [ s1p21x0y0 ] Temp: % value % C endon on tele - BME280 # Humidity do DisplayText [ s1p21x0y10 ] Hum : % value % %% endon on tele - BME280 # Pressure do DisplayText [ s1p21x0y20 ] Prss: % value % hPa endon on tele - SGP30 # TVOC do DisplayText [ s1p21x0y30 ] TVOC: % value % ppb endon on tele - SGP30 # eCO2 do DisplayText [ s1p21x0y40 ] eCO2 : % value % ppm [ s1p0x0y50 ] Time: [ x35y50t ] endon","title":"Display Local Sensors"},{"location":"Displays/#display-drivers","text":"Waveshare has two kinds of display controllers: with partial update and without partial update. The 2.9 inch driver is for partial update and should also support other Waveshare partial update models with modified WIDTH and HEIGHT parameters. The 4.2 inch driver is a hack which makes the full update display behave like a partial update and should probably work with other full update displays. The drivers are subclasses of the Adafruit GFX library. The class hierarchy is LOWLEVEL :: Paint :: Renderer :: GFX , where: GFX : unmodified Adafruit library Renderer : the interface for Tasmota Paint : the modified pixel driver for e-paper - there are several virtual functions that can be subclassed down to LOWLEVEL . The display dispatcher only does the class initialization call. All other calls go to the Renderer class. In black and white displays, a local RAM buffer must be allocated before calling the driver. This must be set to zero on character or TFT color displays. Remark : To use the 400x300 e-Paper display, the Arduino library 2.4 or later must be used because it leaves much more RAM available than prior versions. This display requires 15k of RAM! The EPD fonts use about 9k space, which can be selected at compile time using #ifdef directives. SSD1306 - 1.15k EPD42 - 2.57k EPD29 - 2.1k Display and Render class - ~12k","title":"Display Drivers"},{"location":"Domoticz/","text":"Tasmota supports Domoticz MQTT 'out of the box' for both relays and sensors. Find below the procedure to configure Domoticz and Tasmota. Prerequisites The following servers should be made available: You have installed/access to a MQTT broker server and made contact with your Tasmota device You have installed Domoticz MQTT and Virtual Sensor ~ If not already done configure Domoticz MQTT and Virtual Sensor hardware. On the hardware page add Type MQTT Client Gateway with LAN interface Give it a name Configure the interface with access to your MQTT server ( Remote Address , Port , Username and Password ) Set the Public Topic to flat (which seems to relate to out in the select field) On the hardware page add Type Dummy (used for virtual switches) Give it a name Virtual Switch ~ Make a new virtual switch and remeber its Idx number. Make a new virtual switch to be used with Sonoff by clicking Create Virtual Sensors Give it a name Select Sensor Type Switch On the Devices page find the new switch by it's name Remember it's Idx number Tasmota Configuration ~ Tasmota provides different ways to configure Domoticz parameters. Choose the method you prefer: [The sections below don't look like they are needed any longer. The in topic and out topic entry areas don't appear to be in the Domoticz configure section - at least they are not there in mine and mine is working 17/03/2018] Use the webinterface and select Configuration - Configure Domoticz : Set In topic to domoticz/in as hardcoded in Domoticz Set Out topic to domoticz/out as hardcoded in Domoticz Configure Idx 1 to the value read in step 2.i Use MQTT and execute commands (if necessary, replace tasmota with unique topic you configured in Initital Configuration, see point 5 there ): cmnd/tasmota/DomoticzInTopic with payload domoticz/in as hardcoded in Domoticz cmnd/tasmota/DomoticzOutTopic with payload domoticz/out as hardcoded in Domoticz cmnd/tasmota/DomoticzIdx1 with payload value read in step 2.i Use the serial interface and execute commands: DomoticzInTopic with domoticz/in as hardcoded in Domoticz DomoticzOutTopic with domoticz/out as hardcoded in Domoticz DomoticzIdx1 with the value read in step 2.i Usage That's it! You can now control your device from the Domoticz user interface. On the Switches page scroll down and find your Switch as configured in step 1 Toggle the light bulb; Tasmota should respond Automatic Disovery ~ Tasmota supports automatic discovery by Domoticz through the Domoticz MQTT Discovery plugin . Prerequisites The following services should be made available: You have installed/access to a MQTT broker server and made contact with your sonoff You have installed Domoticz You have installed the Domoticz MQTT Discovery plugin MQTT Discovery Plugin ~ Configure Domoticz MQTT Discovery plugin. On the hardware page add Type MQTT Discovery Give it a name, e.g. Tasmota Configure the interface with access to your MQTT server ( MQTT Server Address , Port , Username and Password ) Set the Discovery topic to homeassistant unless it has been changed in a custom Tasmota build Set the Ignored device topic to /tasmota/ to avoid unconfigured Tasmota devices from being discoved Tasmota Configuration ~ Precompiled Binary Each Tasmota device must have it's own topic, the easiest way is to set topic to tasmota_%06X (%06X will be replaced by MAC address). See here for how to set the topic. Use MQTT or Serial or Web console and execute commands (replace <tasmota_xxx> with the device's unique topic) cmnd/<tasmota_xxxx>/SetOption19 with payload 1 to enable MQTT discovery Custom Binary The above settings can be defined in user_config_override.h (TBD) Usage That's it! You will now find your Sonoff in the Domoticz user interface. On the Switches page scroll down and find your Switch as configured in step 1 Toggle the light bulb; Sonoff should respond ...including sensors ~","title":"Domoticz"},{"location":"Domoticz/#mqtt-and-virtual-sensor","text":"If not already done configure Domoticz MQTT and Virtual Sensor hardware. On the hardware page add Type MQTT Client Gateway with LAN interface Give it a name Configure the interface with access to your MQTT server ( Remote Address , Port , Username and Password ) Set the Public Topic to flat (which seems to relate to out in the select field) On the hardware page add Type Dummy (used for virtual switches) Give it a name","title":"MQTT and Virtual Sensor"},{"location":"Domoticz/#virtual-switch","text":"Make a new virtual switch and remeber its Idx number. Make a new virtual switch to be used with Sonoff by clicking Create Virtual Sensors Give it a name Select Sensor Type Switch On the Devices page find the new switch by it's name Remember it's Idx number","title":"Virtual Switch"},{"location":"Domoticz/#tasmota-configuration","text":"Tasmota provides different ways to configure Domoticz parameters. Choose the method you prefer: [The sections below don't look like they are needed any longer. The in topic and out topic entry areas don't appear to be in the Domoticz configure section - at least they are not there in mine and mine is working 17/03/2018] Use the webinterface and select Configuration - Configure Domoticz : Set In topic to domoticz/in as hardcoded in Domoticz Set Out topic to domoticz/out as hardcoded in Domoticz Configure Idx 1 to the value read in step 2.i Use MQTT and execute commands (if necessary, replace tasmota with unique topic you configured in Initital Configuration, see point 5 there ): cmnd/tasmota/DomoticzInTopic with payload domoticz/in as hardcoded in Domoticz cmnd/tasmota/DomoticzOutTopic with payload domoticz/out as hardcoded in Domoticz cmnd/tasmota/DomoticzIdx1 with payload value read in step 2.i Use the serial interface and execute commands: DomoticzInTopic with domoticz/in as hardcoded in Domoticz DomoticzOutTopic with domoticz/out as hardcoded in Domoticz DomoticzIdx1 with the value read in step 2.i","title":"Tasmota Configuration"},{"location":"Domoticz/#automatic-disovery","text":"Tasmota supports automatic discovery by Domoticz through the Domoticz MQTT Discovery plugin .","title":"Automatic Disovery"},{"location":"Domoticz/#mqtt-discovery-plugin","text":"Configure Domoticz MQTT Discovery plugin. On the hardware page add Type MQTT Discovery Give it a name, e.g. Tasmota Configure the interface with access to your MQTT server ( MQTT Server Address , Port , Username and Password ) Set the Discovery topic to homeassistant unless it has been changed in a custom Tasmota build Set the Ignored device topic to /tasmota/ to avoid unconfigured Tasmota devices from being discoved","title":"MQTT Discovery Plugin"},{"location":"Domoticz/#tasmota-configuration_1","text":"","title":"Tasmota Configuration"},{"location":"Domoticz/#including-sensors","text":"","title":"...including sensors"},{"location":"Dynamic-Sleep/","text":"Dynamic Sleep (CPU Main loop target / CPU Power Management) ~ SetOption60 may be used to configure your device to use Normal Sleep or Dynamic Sleep. Dynamic Sleep is enabled by default from Tasmota version 6.3.0.15 but may be reconfigured by setting the value of SetOption60 accordingly. Command Description SetOption60 0 Dynamic Sleep is ENABLED (Default since 6.3.0.15) SetOption60 1 Normal Sleep is ENABLED The term CPU is used loosely here for the sake of making it easier to understand - When the term CPU is used it is actually referring to the ESP8266 SoC Micro Controller. With the introduction of many new drivers, sensors and other functions as part of the Tasmota firmware, it has become more important to pay specific attention to the amount of microcontroller clock cycles shared with the underlying SDK/Arduino ESP8266 Core. The main application loop of the Tasmota firmware needs to visit each of the driver callbacks within the main loop to make sure all the required drivers and sensors receive the necessary processing time whilst ensuring that the main loop does not overwhelm the need for processing time by the SDK / Arduino ESP8266 core. The highest priority drivers/sensors need to be called once per 50ms to operate as designed but most of the normal run of the mill drivers and sensors do not necessarily require this amount of intense polling. The 50-millisecond mark would normally be considered to be an absolute minimum duty cycle for the main processing loop on ESP8266 boards whilst most Sonoff device derivatives will function perfectly well way above this default setting. To make this manageable from device to device a new setting has been introduced enabling the setting of the main loop target to a specific value in milliseconds. For default operation, this will be set to 50 milliseconds as there are generally no drivers or sensors that need to be polled at a rate higher than this. To allow for power usage flexibility this value may also be increased to a value of up to 250 milliseconds which is very useful to reduce power and processing demand on non-time critical devices such as switches (which is what most of Tasmota is used for.) The purpose of this setting is to allow you as a user to set the speed at which driver and sensors will be serviced and as a result also the amount of time given to the SDK / Arduino ESP8266 core to handle its background tasks (which are not under direct control of the Tasmota firmware.) Example Use Case ~ Let's assume the default value of 50 for sleep and that a simple device such as a Sonoff Basic R1 or R2 is being used. In this case, the main firmware loop will iterate through all the drivers and sensors once per 50 milliseconds. Current tests suggest that a simple device such as a Sonoff Basic requires only about 9.5 milliseconds to complete one iteration of servicing all the drivers and sensors enabled in the standard tasmota.bin firmware. The time management functionality offered by dynamic sleep will compute this time requirement automatically and allow the SDK / Arduino ESP8266 Core to service background tasks such as maintaining WiFi connectivity for the remainder of the time not spent in the main firmware loop - i.e. in the case of sleep 50 this would mean 50 milliseconds - ~9.5 milliseconds = ~40.5 milliseconds spent outside of the main firmware loop servicing SDK / ESP8266 Core functions which automatically consume fewer clock cycles when there is nothing intense for the SDK / ESP8266 Core to maintain or perform. Normal Sleep was previously the only option for Tasmota powered devices wishing to take advantage of power saving but it does have the disadvantage that the sleep would be a constant setting insofar that the entire firmware codebase would run at a pre-determined speed causing some drivers to run slower than expected and decreasing the speed at which services such as the WebUI is rendered (This varies between the various underlying cores depending on which version is used.) Using Dynamic Sleep (SetOption60 = 0) instead of Normal Sleep (SetOption60 = 1) has the advantage that CPU time will be given to any particular driver or process (let's say the WebUI) on demand as and when needed whilst spending most of its time waiting for the next main loop iteration to occur. During this time of waiting the ESP8266's power demand can go from 80mA all the way down to 20mA which yields great benefits for power saving vs. firmware responsiveness compared to the traditional sleep setting. Normally the target main loop setting would be 50 milliseconds. The firmware will service all the driver and sensor callbacks up to a maximum of 20 times per second. In most cases, this is unnecessary as most normal sensors like temperature sensors only need polling once per second. So, whether you poll the temperature sensor 20 times per second (sleep 50) or 5 times per second (sleep 200) it has no impact on the functionality. Allowing the main loop to iterate 20 times per second vs. 5 times per second is obviously more time consuming and processor consuming leaving less time to idle (i.e., save power). For example, if you were using an MCP230xx with interrupts, and you need a high interrupt response then sleep 50 or lower would make sense since that specific driver can poll once per 50 milliseconds to check for interrupts. Most other sensor polling can be done in intervals longer than 50 milliseconds so you achieve more idle time, and therefore also more sleep time so it saves power. Monitoring Performance ~ Given all the above it is an obvious conclusion that in order to manage something you would need to be able to measure it. For this reason two new variables have been added to the telemetry data namely LoopSet and LoadAvg and are represented in the telemetry JSON as follows: MQT : tele /sound1/ STATE = { \"Time\" : \"2018-11-26T17:41:27\" , \"Uptime\" : \"0T05:05:17\" , \"Vcc\" : 3.504 , \"SleepMode\" : \"Dynamic\" , \"Sleep\" : 50 , \"LoadAvg\" : 19 , \"POWER\" : \"OFF\" , \"Wifi\" :{ \"AP\" : 1 , \"SSId\" : \"Wireless\" , \"BSSId\" : \"DE:AD:00:00:BE:EF\" , \"Channel\" : 3 , \"RSSI\" : 100 }} The two values indicated for LoopSet and LoadAvg have the following relation: Variable Value Description SleepMode Normal Normal Sleep mode is enabled (SetOption60 = 1) SleepMode Dynamic Dynamic Sleep mode is enabled (SetOption60 = 0) Sleep 50 Current setting for sleep LoadAvg 19 Reported % time of Sleep spent doing Tasmota main loop processing In this example, 19% of 50 milliseconds would be 9.5 milliseconds (19/100*50), so we can see that there is sufficient headroom for the SDK / ESP8266 Arduino Core to do its background work. On some devices which have many sensors connected you may observe the LoadAvg value exceeding 100 - This means that you have not set the value of sleep high enough to accommodate all the sensors and drivers which need to be serviced. In the latter case, you have two options - either increase the value of sleep to a higher one to maintain a load average well below 100 or use multiple devices to spread the load across separate Tasmota powered devices/boards. For the most part, all Sonoff based products should perform well balanced with the default setting of 50 for sleep. How to use Dynamic Sleep ~ From serial console, or webui console enter command SetOption60 0 and Sleep xx Where xx is the number of milliseconds you wish to target your main processing loop at ranging from 0 through to 250. Should you set a sleep value that is too low you will observe output on telemetry for the value of LoadAvg to be in excess of 100 - This is not ideal and should be avoided as it starves the Arduino Core / SDK of the needed processing time to take care of background tasks such as WiFi management. For optimal operation of the Tasmota firmware, it is recommended to keep your device running at a LoadAvg value of 75 or lower. If your device does not have any time critical drivers/sensors connected you are encouraged to increase the sleep value to a higher value to gain from the power saving benefits thereof.","title":"Dynamic Sleep"},{"location":"Dynamic-Sleep/#dynamic-sleep-cpu-main-loop-target-cpu-power-management","text":"SetOption60 may be used to configure your device to use Normal Sleep or Dynamic Sleep. Dynamic Sleep is enabled by default from Tasmota version 6.3.0.15 but may be reconfigured by setting the value of SetOption60 accordingly. Command Description SetOption60 0 Dynamic Sleep is ENABLED (Default since 6.3.0.15) SetOption60 1 Normal Sleep is ENABLED The term CPU is used loosely here for the sake of making it easier to understand - When the term CPU is used it is actually referring to the ESP8266 SoC Micro Controller. With the introduction of many new drivers, sensors and other functions as part of the Tasmota firmware, it has become more important to pay specific attention to the amount of microcontroller clock cycles shared with the underlying SDK/Arduino ESP8266 Core. The main application loop of the Tasmota firmware needs to visit each of the driver callbacks within the main loop to make sure all the required drivers and sensors receive the necessary processing time whilst ensuring that the main loop does not overwhelm the need for processing time by the SDK / Arduino ESP8266 core. The highest priority drivers/sensors need to be called once per 50ms to operate as designed but most of the normal run of the mill drivers and sensors do not necessarily require this amount of intense polling. The 50-millisecond mark would normally be considered to be an absolute minimum duty cycle for the main processing loop on ESP8266 boards whilst most Sonoff device derivatives will function perfectly well way above this default setting. To make this manageable from device to device a new setting has been introduced enabling the setting of the main loop target to a specific value in milliseconds. For default operation, this will be set to 50 milliseconds as there are generally no drivers or sensors that need to be polled at a rate higher than this. To allow for power usage flexibility this value may also be increased to a value of up to 250 milliseconds which is very useful to reduce power and processing demand on non-time critical devices such as switches (which is what most of Tasmota is used for.) The purpose of this setting is to allow you as a user to set the speed at which driver and sensors will be serviced and as a result also the amount of time given to the SDK / Arduino ESP8266 core to handle its background tasks (which are not under direct control of the Tasmota firmware.)","title":"Dynamic Sleep (CPU Main loop target / CPU Power Management)"},{"location":"Dynamic-Sleep/#example-use-case","text":"Let's assume the default value of 50 for sleep and that a simple device such as a Sonoff Basic R1 or R2 is being used. In this case, the main firmware loop will iterate through all the drivers and sensors once per 50 milliseconds. Current tests suggest that a simple device such as a Sonoff Basic requires only about 9.5 milliseconds to complete one iteration of servicing all the drivers and sensors enabled in the standard tasmota.bin firmware. The time management functionality offered by dynamic sleep will compute this time requirement automatically and allow the SDK / Arduino ESP8266 Core to service background tasks such as maintaining WiFi connectivity for the remainder of the time not spent in the main firmware loop - i.e. in the case of sleep 50 this would mean 50 milliseconds - ~9.5 milliseconds = ~40.5 milliseconds spent outside of the main firmware loop servicing SDK / ESP8266 Core functions which automatically consume fewer clock cycles when there is nothing intense for the SDK / ESP8266 Core to maintain or perform. Normal Sleep was previously the only option for Tasmota powered devices wishing to take advantage of power saving but it does have the disadvantage that the sleep would be a constant setting insofar that the entire firmware codebase would run at a pre-determined speed causing some drivers to run slower than expected and decreasing the speed at which services such as the WebUI is rendered (This varies between the various underlying cores depending on which version is used.) Using Dynamic Sleep (SetOption60 = 0) instead of Normal Sleep (SetOption60 = 1) has the advantage that CPU time will be given to any particular driver or process (let's say the WebUI) on demand as and when needed whilst spending most of its time waiting for the next main loop iteration to occur. During this time of waiting the ESP8266's power demand can go from 80mA all the way down to 20mA which yields great benefits for power saving vs. firmware responsiveness compared to the traditional sleep setting. Normally the target main loop setting would be 50 milliseconds. The firmware will service all the driver and sensor callbacks up to a maximum of 20 times per second. In most cases, this is unnecessary as most normal sensors like temperature sensors only need polling once per second. So, whether you poll the temperature sensor 20 times per second (sleep 50) or 5 times per second (sleep 200) it has no impact on the functionality. Allowing the main loop to iterate 20 times per second vs. 5 times per second is obviously more time consuming and processor consuming leaving less time to idle (i.e., save power). For example, if you were using an MCP230xx with interrupts, and you need a high interrupt response then sleep 50 or lower would make sense since that specific driver can poll once per 50 milliseconds to check for interrupts. Most other sensor polling can be done in intervals longer than 50 milliseconds so you achieve more idle time, and therefore also more sleep time so it saves power.","title":"Example Use Case"},{"location":"Dynamic-Sleep/#monitoring-performance","text":"Given all the above it is an obvious conclusion that in order to manage something you would need to be able to measure it. For this reason two new variables have been added to the telemetry data namely LoopSet and LoadAvg and are represented in the telemetry JSON as follows: MQT : tele /sound1/ STATE = { \"Time\" : \"2018-11-26T17:41:27\" , \"Uptime\" : \"0T05:05:17\" , \"Vcc\" : 3.504 , \"SleepMode\" : \"Dynamic\" , \"Sleep\" : 50 , \"LoadAvg\" : 19 , \"POWER\" : \"OFF\" , \"Wifi\" :{ \"AP\" : 1 , \"SSId\" : \"Wireless\" , \"BSSId\" : \"DE:AD:00:00:BE:EF\" , \"Channel\" : 3 , \"RSSI\" : 100 }} The two values indicated for LoopSet and LoadAvg have the following relation: Variable Value Description SleepMode Normal Normal Sleep mode is enabled (SetOption60 = 1) SleepMode Dynamic Dynamic Sleep mode is enabled (SetOption60 = 0) Sleep 50 Current setting for sleep LoadAvg 19 Reported % time of Sleep spent doing Tasmota main loop processing In this example, 19% of 50 milliseconds would be 9.5 milliseconds (19/100*50), so we can see that there is sufficient headroom for the SDK / ESP8266 Arduino Core to do its background work. On some devices which have many sensors connected you may observe the LoadAvg value exceeding 100 - This means that you have not set the value of sleep high enough to accommodate all the sensors and drivers which need to be serviced. In the latter case, you have two options - either increase the value of sleep to a higher one to maintain a load average well below 100 or use multiple devices to spread the load across separate Tasmota powered devices/boards. For the most part, all Sonoff based products should perform well balanced with the default setting of 50 for sleep.","title":"Monitoring Performance"},{"location":"Dynamic-Sleep/#how-to-use-dynamic-sleep","text":"From serial console, or webui console enter command SetOption60 0 and Sleep xx Where xx is the number of milliseconds you wish to target your main processing loop at ranging from 0 through to 250. Should you set a sleep value that is too low you will observe output on telemetry for the value of LoadAvg to be in excess of 100 - This is not ideal and should be avoided as it starves the Arduino Core / SDK of the needed processing time to take care of background tasks such as WiFi management. For optimal operation of the Tasmota firmware, it is recommended to keep your device running at a LoadAvg value of 75 or lower. If your device does not have any time critical drivers/sensors connected you are encouraged to increase the sleep value to a higher value to gain from the power saving benefits thereof.","title":"How to use Dynamic Sleep"},{"location":"Energy-Saving/","text":"Using the Sleep command you can instruct Tasmota to sleep for the set milliseconds in its main cycle. While sleeping your device will consume less power. Dynamic Sleep is enabled by default with a value of 50. To continue using Normal Sleep you may disable it by using the command: SetOption60 1 Setting Sleep to lowest value 1 reduces power consumption already about ~30% in idle mode (relay off) and button presses are still noticed without any delay. Setting this around 50 ms reduces power consumption from ~1.1 W to ~0.6 W on an idling (relay off) device and button presses are still noticed correctly. With this setting you have to concentrate very hard to click the button so fast that it is not recognized by the device. If your device needs to do something continuously, this will be affected. E.g., device LED will flicker and Sonoff POW will not be able to correctly total the energy consumption. Spot readings of power, voltage, etc. will however remain correct. From the release notes: Expect overall button/key/switch misses and wrong values on Sonoff Pow Also, if using KNX IP Protocol , Sleep needs to be 0 in order to avoid losing any telegram. Notes: - Starting with Tasmota 6.1.1.12 Sleep \u2260 0 has no impact on real time related commands like Delay , PulseTime , TelePeriod and Blinktime . - As the WiFi Modem on an ESP8266 is the major consumer - using Sleep with WiFi AP mode enabled is more or less without effect. Device power consumption and measurement ~ Most low-price plug-in home energy meters like Sonoff devices are very imprecise for power consumption < 10 W and become more and more imprecise for power consumption (< 1.5 W). Furthermore, the results of such meters are very strongly dependant on the load type (capacitive/inductive) and are absolutely imprecise for non-ohmic load types having switch-mode power supplies. In addition, using Sleep - which periodically cycles the power of the device between 20% and 100% - on such meters makes their readings more or less useless. Example of power consumption ~ Absolute AC line measurement using calibrated meter ~ The following measurement was done directly on 230 V/AC line using a Sonoff Dual R2 and two different Sonoff S20 connected on different MID calibrated meter (Eastron SMD630 MID/saia-burgess ALE3). Device power consumption using Sleep Device Sleep 0 Sleep 1 Sleep 50 Sleep 200 Sonoff Dual R2 1.24 W 0.84 W 0.76 W 0.68 W Sonoff S20 1.11 W 0.77 W 0.59 W 0.51 W All measurements were done with - WiFi STA mode, enabled and connected (70%) - MQTT enabled and connected - Syslog enabled and connected - TelePeriod 60 for debugging - Relays off - Measurement period of 24-56 hours to reduce measurement discrepancies The first impression is that a higher sleep value reduces the consumption, but only slightly. The second result is that using Sleep <value> ( value \u2260 0, e. g., 1) is good enough to reduce the power consumption anywhere between 1/3 and up to 45% (value=200). Quantity measurement of ESP-12 module/ESP8266 3.3V line ~ To find out why Sleep reduces the power consumption and how its value should be set, the current of the 3.3V DC ESP8266 of an ESP-12 module was measured using an oscilloscope and (for easy reading the oscilloscope diagram) a 1 \u03a9 shunt which results in a 1:1 interpretation between voltage and current. This measurement simplified the measure of a time based power consumption; no integration must be done. On the other side note that the quantity measurement does not respect the effectiveness of the complete device circuit. Sleep 0 Using Sleep 0 there are no delay() calls in Tasmota main loop and therefore the power consumption is continuous at current ~80 mA: Sleep 1 Due to the fact that the Tasmota main loop now calls delay() (even with 1ms) it seems it results in periodically (100ms) enabling the WiFi Modem Sleep mode within the WiFi Manager library. It results in periodically lowering the current to 15-20 mA for ~90ms of each loop: Sleep 100 By increasing the sleep value, there are more and more ~90ms periods with additional lowering of the current to 8-10 mA - I really don't know where this comes from: Sleep 250 As already noticed with Sleep 100 the number periods having 8-10 mA instead of 15-20 mA increase again: The quantity measurement confirms the suspicion that a Sleep value \u2260 0 results in reducing the power consumption about 1/3.","title":"Energy Saving"},{"location":"Energy-Saving/#device-power-consumption-and-measurement","text":"Most low-price plug-in home energy meters like Sonoff devices are very imprecise for power consumption < 10 W and become more and more imprecise for power consumption (< 1.5 W). Furthermore, the results of such meters are very strongly dependant on the load type (capacitive/inductive) and are absolutely imprecise for non-ohmic load types having switch-mode power supplies. In addition, using Sleep - which periodically cycles the power of the device between 20% and 100% - on such meters makes their readings more or less useless.","title":"Device power consumption and measurement"},{"location":"Energy-Saving/#example-of-power-consumption","text":"","title":"Example of power consumption"},{"location":"Energy-Saving/#absolute-ac-line-measurement-using-calibrated-meter","text":"The following measurement was done directly on 230 V/AC line using a Sonoff Dual R2 and two different Sonoff S20 connected on different MID calibrated meter (Eastron SMD630 MID/saia-burgess ALE3).","title":"Absolute AC line measurement using calibrated meter"},{"location":"Energy-Saving/#quantity-measurement-of-esp-12-moduleesp8266-33v-line","text":"To find out why Sleep reduces the power consumption and how its value should be set, the current of the 3.3V DC ESP8266 of an ESP-12 module was measured using an oscilloscope and (for easy reading the oscilloscope diagram) a 1 \u03a9 shunt which results in a 1:1 interpretation between voltage and current. This measurement simplified the measure of a time based power consumption; no integration must be done. On the other side note that the quantity measurement does not respect the effectiveness of the complete device circuit.","title":"Quantity measurement of ESP-12 module/ESP8266 3.3V line"},{"location":"Esptool/","text":"How to setup and configure Esptool for Tasmota upload. The information below is for the Python version of esptool - If you want to use the Windows/Linux/OSX(MAC) executable version of esptool (as would be included in Arduino ESP8266 cores) then please go to the esptool executable (non-python) section at the bottom. Download Esptool ~ If you do not have an installed copy of Python 2.x or 3.x download and install it from https://www.python.org/. Download Esptool Source code from https://github.com/espressif/esptool/releases to a known folder. Install Esptool ~ Go to the known folder and install Esptool with command python setup.py install . Packages for Esptool are maintained for Debian and Ubuntu and can be installed with sudo apt install esptool . Download Tasmota ~ Download the latest Tasmota release firmware file tasmota.bin to a known folder. A second source is thehackbox This source can be used for OTA too. Upload Tasmota ~ Put device in firmware upload mode ~ When performing a firmware upload do not connect the device to AC but use the power supply provided by your (FTDI type) serial interface. Put the device in firmware upload mode by grounding pin GPIO00 while applying power. Grounding pin GPIO00 can often be achieved by pressing button 1 on the Sonoff device or using a wire between GPIO00 and Gnd if the button is not available. Deviations may apply. Connect the serial interface of your PC to the device while GPIO00 to Gnd. Esptool uses the serial interface to communicate with your device. On Windows these interfaces are named COM1, COM2 etc. On Linux these interfaces are called /dev/ttyUSB0, /dev/ttyUSB1 etc. Before using Esptool make sure you know to which serial interface name your device is connected to. In the following commands I use COM5 as an example. Optional: Backup firmware ~ Ensure the device is in firmware upload mode. Backup the current firmware with the following command: esptool.py --port COM5 read_flash 0x00000 0x100000 image1M.bin NOTE: When the command completes the device is out of firmware upload mode! Erase firmware ~ Ensure the device is in firmware upload mode. Erase the complete flash memory holding the firmware with the following command: esptool.py --port COM5 erase_flash NOTE1: When the command completes the device is out of firmware upload mode! NOTE2: It only takes a few seconds to erase 1M of flash. Upload firmware ~ Ensure the device is in firmware upload mode. Load the downloaded Tasmota firmware file tasmota.bin with the following command: esptool.py --port COM5 write_flash -fs 1MB -fm dout 0x0 tasmota.bin NOTE1: When the command completes the device is out of firmware upload mode! NOTE2: For a proper device initialization after first firmware upload power down and power up the device. ESPTOOL Executable (Windows & Linux) ~ The executable version of esptool is maintained by Ivan Grokhotkov and releases are kept at https://github.com/igrr/esptool-ck/releases Download and Install ~ For the purpose of simplicity only the Windows version will be explained here, but the command and parameters are the same for Windows, Linux and MAC/OSX. Download the latest release from https://github.com/igrr/esptool-ck/releases and extract the compressed file to a known location. Download Tasmota ~ Download the latest Tasmota release firmware file tasmota.bin to a known folder (The same folder as where you have the esptool executable will work well for this process to be simpler) If you want features from the current development codebase which has not been included in the last release please download this tasmota.bin to a known folder (The same folder as where you have the esptool executable will work well for this process to be simpler) The information posted further up in this Wiki for placing the device into bootload / firmware upgrade mode may be followed as this process does not change irrespective whether you use the Python or executable version of esptool. Once the device is in firmware upload mode the following commands are recommended for completion of the firmware flashing. Erase the flash completely with the following command (substituting the COM port for the one which was used on your computer) esptool -cp COM3 -cb 115200 -ce -v Once the erase is complete, reset your device back into programming mode and then upload the firmware using the following command esptool -cp COM3 -cb 115200 -bm dout -cf tasmota.bin -v","title":"Esptool"},{"location":"Esptool/#download-esptool","text":"If you do not have an installed copy of Python 2.x or 3.x download and install it from https://www.python.org/. Download Esptool Source code from https://github.com/espressif/esptool/releases to a known folder.","title":"Download Esptool"},{"location":"Esptool/#install-esptool","text":"Go to the known folder and install Esptool with command python setup.py install . Packages for Esptool are maintained for Debian and Ubuntu and can be installed with sudo apt install esptool .","title":"Install Esptool"},{"location":"Esptool/#download-tasmota","text":"Download the latest Tasmota release firmware file tasmota.bin to a known folder. A second source is thehackbox This source can be used for OTA too.","title":"Download Tasmota"},{"location":"Esptool/#upload-tasmota","text":"","title":"Upload Tasmota"},{"location":"Esptool/#put-device-in-firmware-upload-mode","text":"When performing a firmware upload do not connect the device to AC but use the power supply provided by your (FTDI type) serial interface. Put the device in firmware upload mode by grounding pin GPIO00 while applying power. Grounding pin GPIO00 can often be achieved by pressing button 1 on the Sonoff device or using a wire between GPIO00 and Gnd if the button is not available. Deviations may apply. Connect the serial interface of your PC to the device while GPIO00 to Gnd. Esptool uses the serial interface to communicate with your device. On Windows these interfaces are named COM1, COM2 etc. On Linux these interfaces are called /dev/ttyUSB0, /dev/ttyUSB1 etc. Before using Esptool make sure you know to which serial interface name your device is connected to. In the following commands I use COM5 as an example.","title":"Put device in firmware upload mode"},{"location":"Esptool/#optional-backup-firmware","text":"Ensure the device is in firmware upload mode. Backup the current firmware with the following command: esptool.py --port COM5 read_flash 0x00000 0x100000 image1M.bin NOTE: When the command completes the device is out of firmware upload mode!","title":"Optional: Backup firmware"},{"location":"Esptool/#erase-firmware","text":"Ensure the device is in firmware upload mode. Erase the complete flash memory holding the firmware with the following command: esptool.py --port COM5 erase_flash NOTE1: When the command completes the device is out of firmware upload mode! NOTE2: It only takes a few seconds to erase 1M of flash.","title":"Erase firmware"},{"location":"Esptool/#upload-firmware","text":"Ensure the device is in firmware upload mode. Load the downloaded Tasmota firmware file tasmota.bin with the following command: esptool.py --port COM5 write_flash -fs 1MB -fm dout 0x0 tasmota.bin NOTE1: When the command completes the device is out of firmware upload mode! NOTE2: For a proper device initialization after first firmware upload power down and power up the device.","title":"Upload firmware"},{"location":"Esptool/#esptool-executable-windows-linux","text":"The executable version of esptool is maintained by Ivan Grokhotkov and releases are kept at https://github.com/igrr/esptool-ck/releases","title":"ESPTOOL Executable (Windows &amp; Linux)"},{"location":"Esptool/#download-and-install","text":"For the purpose of simplicity only the Windows version will be explained here, but the command and parameters are the same for Windows, Linux and MAC/OSX. Download the latest release from https://github.com/igrr/esptool-ck/releases and extract the compressed file to a known location.","title":"Download and Install"},{"location":"Esptool/#download-tasmota_1","text":"Download the latest Tasmota release firmware file tasmota.bin to a known folder (The same folder as where you have the esptool executable will work well for this process to be simpler) If you want features from the current development codebase which has not been included in the last release please download this tasmota.bin to a known folder (The same folder as where you have the esptool executable will work well for this process to be simpler) The information posted further up in this Wiki for placing the device into bootload / firmware upgrade mode may be followed as this process does not change irrespective whether you use the Python or executable version of esptool. Once the device is in firmware upload mode the following commands are recommended for completion of the firmware flashing. Erase the flash completely with the following command (substituting the COM port for the one which was used on your computer) esptool -cp COM3 -cb 115200 -ce -v Once the erase is complete, reset your device back into programming mode and then upload the firmware using the following command esptool -cp COM3 -cb 115200 -bm dout -cf tasmota.bin -v","title":"Download Tasmota"},{"location":"Expanding-4CH/","text":"Opening my Sonoff 4CH (https://www.itead.cc/sonoff-4ch.html) I realized that on PCB there is a predisposition for 2.5 mm jack (also confirmed by schematic on Itead wiki: https://www.itead.cc/wiki/File:Sonoff_4CH.SCHMATIC.pdf). I ordered on Aliexpress some 2.5 mm jacks and when I received it after some work... The schematic reports that 2.5 mm jack is configured as following (jack on right side, ESP8285 on the left side: 3.3V and GND are very welcome for sensors expansions but GPIO7 and GPIO8 are not usable because they are used internally by ESP8285 for flash memory connection (sigh!) R35 and R36 resistors are not soldered on Sonoff 4CH PCB and it is possible to use their pads to \"manually route\" the jack contact on another ESP8285 pin (!). I selected R35 pad because my \"waterproof\" DS18B20 sensors provide signal line on TEM1 jack contact. For ESP8285 pin I prefer IO2 that is already available on header programming pins... Then the route to do is: TEM1 -> R35 pad -> GPIO2: DS18B20 sensors need a 4.7Kohm pullup resistor between DATA pin and 3.3V and this is also useful to pullup GPIO2 in order to avoid ESP8285 reset. Final result in these photos: Tasmota is also configured with DS18x20 on GPIO2 and it works ! * Note * : source file sonoff/sonoff_template.h provides the configuration on Sonoff 4CH and it is also possible to use GPIO16 (as in the screenshot above) but be aware that no interrupts can be used on GPIO16 and you could have problems with some sensors.","title":"Expanding 4CH"},{"location":"Expanding-Tasmota/","text":"You can wire peripherals (sensors, displays, switches, LED lights, ...) to available pins of the ESP8266 chip that controls these devices. To make a link between the different naming schemes the Pin Definition overview in the ESP8266 wiki is quite helpful. Examples ~ Connect switch If you take a Sonoff Basic and connect a switch between pin4 (GND) and pin5 (GPIO14) of the 5 pin programming header you now have a second switch connected to the device. You can set this through the module config page as option Switch1 (9) or from the command line with gpio14 9 . See Buttons and Switches for more information. Connect jack Instead of connecting a switch, you could connect a 4-pin 2.5mm jack, with the pins wired: Jack Pin ESP8266 tip 5 GPIO14 R1 no connection R2 1 GND R3 4 3.3V You can then plug a sensor into the jack like you would to a Sonoff TH and define what sensor you have connected to GPIO14. Restrictions ~ [!DANGER] If you can avoid it, don't use GPIOs: 0, 1, 2, 6-11, 15 and 16 . That leaves 4, 5, 12, 13, 14 as GPIOs without any constraints. 3 being RX is also good to avoid (PWM is not working on this GPIO). Others can be used but you have to mind the constraints outlined in this document . Voltage and Current ~ [!DANGER] The ESP8266 is a 3.3V microcontroller, so its I/O operates at 3.3V as well. The pins are not 5V tolerant, applying more than 3.6V on any pin will release the magic smoke (fry the chip). The maximum current that can be drawn from a single GPIO pin is 12mA. Power Supply ~ [!DANGER] The power supplied to the device is one of the most important elements** for stable device operation. Many devices on the market have barely adequate power supplies for normal operation. ** Connected peripherals may strain the ability of the power supply on the device to deliver appropriate power to all the components, both on-board as well as externally connected. Voltage regulation issues typically result in fatal exception fault code 1 . You must ensure that the device receives sufficient power (current and appropriate voltage level). Take into account the current that each wired component (f.e. sensor) will draw from the device itself. Electrical Considerations ~ When you switch a GPIO pin to an input and hang a long wire off of it, that wire can pick up stray signals and cause the voltage on the GPIO pin to vary. This can cause the system to think the switch has changed. To fix this, there are several things you can do. add a pull-up resistor add a bypass capacitor shielding on the wire use twisted pair wiring A pull-up resistor is a resistor connected between the GPIO pin and 3.3v. The exact value of this is not critical, 4.7k is a common value to use, as is 10k. This ensures that when the switch it open, the GPIO pin will go high. A bypass capacitor is a small (pF range) capacitor that is connected between the GPIO and ground. This provides a path for any radio signals that are picked up by the wire to go to ground and not confuse the system. Shielding or using twisted pair wiring are other ways to reduce the effect of radio signals on the system. Example for 10K Resistor (issue #2708 ) The ESP8266 Hardware ~ Complete document available from https://tttapa.github.io/ESP8266/Chap04%20-%20Microcontroller.html Digital I/O ~ Just like a normal Arduino, the ESP8266 has digital input/output pins (I/O or GPIO, General Purpose Input/Output pins). As the name implies, they can be used as digital inputs to read a digital voltage, or as digital outputs to output either 0V (sink current) or 3.3V (source current). Usable pins ~ The ESP8266 and ESP8255 have 17 GPIO pins (0-16) but several are reserved or have constraints . Do not use any of the reserved pins. If you do, you might crash your program. On the ESP8266, six pins (GPIO 6 - 11) are used to interface the flash memory (the small 8-legged chip usually right next to the ESP8266). The ESP8255 has its flash memory integrated into the chip which frees up GPIO 9 and 10. GPIO 1 and 3 are used as TX and RX of the hardware Serial port (UART), so in most cases, you can\u2019t use them as normal I/O while sending/receiving serial data. Boot modes ~ Some I/O pins have a special function during boot: They select 1 of 3 boot modes: GPIO15 GPIO0 GPIO2 Mode 0V 0V 3.3V Uart Bootloader 0V 3.3V 3.3V Boot sketch (SPI flash) 3.3V x x SDIO mode (not used for Arduino) Note: you don\u2019t have to add an external pull-up resistor to GPIO2, the internal one is enabled at boot. We have to be sure that these conditions are met by adding external resistors, or the board manufacturer of your board has added them for you. This has some implications, however: GPIO15 is always pulled low, so you can\u2019t use the internal pull-up resistor. You have to keep this in mind when using GPIO15 as an input to read a switch or connect it to a device with an open-collector (or open-drain) output, like I\u00b2C. GPIO0 is pulled high during normal operation, so you can\u2019t use it as a Hi-Z input. GPIO2 can\u2019t be low at boot, so you can\u2019t connect a switch to it. Internal pull-up/-down resistors GPIO 0-15 all have a built-in pull-up resistor, just like in an Arduino. GPIO16 has a built-in pull-down resistor. PWM ~ Unlike most Atmel chips (Arduino), the ESP8266 doesn\u2019t support hardware PWM, however, software PWM is supported on all digital pins. The default PWM range is 10-bits @ 1kHz, but this can be changed (up to >14-bit@1kHz). Check Restrictions . Analog input ~ The ESP8266 has a single analog input, with an input range of 0 - 1.0V. If you supply 3.3V, for example, you will damage the chip. Some boards like the NodeMCU have an on-board resistive voltage divider, to get an easier 0 - 3.3V range. You could also just use a trimpot as a voltage divider. The ADC (analog to digital converter) has a resolution of 10 bits. Communication ~ Serial ~ The ESP8266 has two hardware UARTS (Serial ports): UART0 on pins 1 and 3 (TX0 and RX0 resp.), and UART1 on pins 2 and 8 (TX1 and RX1 resp.), however, GPIO8 is used to connect the flash chip. This means that UART1 can only transmit data. UART0 also has hardware flow control on pins 15 and 13 (RTS0 and CTS0 resp.). These two pins can also be used as alternative TX0 and RX0 pins. I\u00b2C ~ ESP8266 doesn\u2019t have a hardware TWI (Two Wire Interface) but it is implemented in software. This means that you can use pretty much any two digital pins. By default, the I\u00b2C library uses pin 4 as SDA and pin 5 as SCL. (The data sheet specifies GPIO2 as SDA and GPIO14 as SCL.) The maximum speed is approximately 450kHz. SPI ~ The ESP8266 has one SPI connection available to the user, referred to as HSPI. It uses GPIO14 as CLK, 12 as MISO, 13 as MOSI and 15 as Slave Select (SS). It can be used in both Slave and Master mode (in software). GPIO overview ~ NodeMCU Labelled Pin GPIO# Function State Restrictions D3 0 Boot mode select 3.3V No Hi-Z D10 1 TX0 - Not usable during Serial transmission D4 2 Boot mode select TX1 3.3V (boot only) Don\u2019t connect to ground at boot time Sends debug data at boot time D9 3 RX0 - Not usable during Serial transmission D2 4 SDA (I\u00b2C) - - D1 5 SCL (I\u00b2C) - - x 6 - 8 Flash connection x Not usable, and not broken out x 9, 10 Flash connection * Only available on the ESP8285 x 11 Flash connection x Not usable, and not broken out D6 12 MISO (SPI) - - D7 13 MOSI (SPI) - - D5 14 SCK (SPI) - - D8 15 SS (SPI) 0V Pull-up resistor not usable (extern pull down resistor) D0 16 Wake up from sleep - No pull-up resistor, but pull-down instead Should be connected to RST to wake up","title":"Expanding Tasmota"},{"location":"Expanding-Tasmota/#examples","text":"","title":"Examples"},{"location":"Expanding-Tasmota/#restrictions","text":"[!DANGER] If you can avoid it, don't use GPIOs: 0, 1, 2, 6-11, 15 and 16 . That leaves 4, 5, 12, 13, 14 as GPIOs without any constraints. 3 being RX is also good to avoid (PWM is not working on this GPIO). Others can be used but you have to mind the constraints outlined in this document .","title":"Restrictions"},{"location":"Expanding-Tasmota/#voltage-and-current","text":"[!DANGER] The ESP8266 is a 3.3V microcontroller, so its I/O operates at 3.3V as well. The pins are not 5V tolerant, applying more than 3.6V on any pin will release the magic smoke (fry the chip). The maximum current that can be drawn from a single GPIO pin is 12mA.","title":"Voltage and Current"},{"location":"Expanding-Tasmota/#power-supply","text":"[!DANGER] The power supplied to the device is one of the most important elements** for stable device operation. Many devices on the market have barely adequate power supplies for normal operation. ** Connected peripherals may strain the ability of the power supply on the device to deliver appropriate power to all the components, both on-board as well as externally connected. Voltage regulation issues typically result in fatal exception fault code 1 . You must ensure that the device receives sufficient power (current and appropriate voltage level). Take into account the current that each wired component (f.e. sensor) will draw from the device itself.","title":"Power Supply"},{"location":"Expanding-Tasmota/#electrical-considerations","text":"When you switch a GPIO pin to an input and hang a long wire off of it, that wire can pick up stray signals and cause the voltage on the GPIO pin to vary. This can cause the system to think the switch has changed. To fix this, there are several things you can do. add a pull-up resistor add a bypass capacitor shielding on the wire use twisted pair wiring A pull-up resistor is a resistor connected between the GPIO pin and 3.3v. The exact value of this is not critical, 4.7k is a common value to use, as is 10k. This ensures that when the switch it open, the GPIO pin will go high. A bypass capacitor is a small (pF range) capacitor that is connected between the GPIO and ground. This provides a path for any radio signals that are picked up by the wire to go to ground and not confuse the system. Shielding or using twisted pair wiring are other ways to reduce the effect of radio signals on the system. Example for 10K Resistor (issue #2708 )","title":"Electrical Considerations"},{"location":"Expanding-Tasmota/#the-esp8266-hardware","text":"Complete document available from https://tttapa.github.io/ESP8266/Chap04%20-%20Microcontroller.html","title":"The ESP8266 Hardware"},{"location":"Expanding-Tasmota/#digital-io","text":"Just like a normal Arduino, the ESP8266 has digital input/output pins (I/O or GPIO, General Purpose Input/Output pins). As the name implies, they can be used as digital inputs to read a digital voltage, or as digital outputs to output either 0V (sink current) or 3.3V (source current).","title":"Digital I/O"},{"location":"Expanding-Tasmota/#usable-pins","text":"The ESP8266 and ESP8255 have 17 GPIO pins (0-16) but several are reserved or have constraints . Do not use any of the reserved pins. If you do, you might crash your program. On the ESP8266, six pins (GPIO 6 - 11) are used to interface the flash memory (the small 8-legged chip usually right next to the ESP8266). The ESP8255 has its flash memory integrated into the chip which frees up GPIO 9 and 10. GPIO 1 and 3 are used as TX and RX of the hardware Serial port (UART), so in most cases, you can\u2019t use them as normal I/O while sending/receiving serial data.","title":"Usable pins"},{"location":"Expanding-Tasmota/#boot-modes","text":"Some I/O pins have a special function during boot: They select 1 of 3 boot modes: GPIO15 GPIO0 GPIO2 Mode 0V 0V 3.3V Uart Bootloader 0V 3.3V 3.3V Boot sketch (SPI flash) 3.3V x x SDIO mode (not used for Arduino) Note: you don\u2019t have to add an external pull-up resistor to GPIO2, the internal one is enabled at boot. We have to be sure that these conditions are met by adding external resistors, or the board manufacturer of your board has added them for you. This has some implications, however: GPIO15 is always pulled low, so you can\u2019t use the internal pull-up resistor. You have to keep this in mind when using GPIO15 as an input to read a switch or connect it to a device with an open-collector (or open-drain) output, like I\u00b2C. GPIO0 is pulled high during normal operation, so you can\u2019t use it as a Hi-Z input. GPIO2 can\u2019t be low at boot, so you can\u2019t connect a switch to it. Internal pull-up/-down resistors GPIO 0-15 all have a built-in pull-up resistor, just like in an Arduino. GPIO16 has a built-in pull-down resistor.","title":"Boot modes"},{"location":"Expanding-Tasmota/#pwm","text":"Unlike most Atmel chips (Arduino), the ESP8266 doesn\u2019t support hardware PWM, however, software PWM is supported on all digital pins. The default PWM range is 10-bits @ 1kHz, but this can be changed (up to >14-bit@1kHz). Check Restrictions .","title":"PWM"},{"location":"Expanding-Tasmota/#analog-input","text":"The ESP8266 has a single analog input, with an input range of 0 - 1.0V. If you supply 3.3V, for example, you will damage the chip. Some boards like the NodeMCU have an on-board resistive voltage divider, to get an easier 0 - 3.3V range. You could also just use a trimpot as a voltage divider. The ADC (analog to digital converter) has a resolution of 10 bits.","title":"Analog input"},{"location":"Expanding-Tasmota/#communication","text":"","title":"Communication"},{"location":"Expanding-Tasmota/#serial","text":"The ESP8266 has two hardware UARTS (Serial ports): UART0 on pins 1 and 3 (TX0 and RX0 resp.), and UART1 on pins 2 and 8 (TX1 and RX1 resp.), however, GPIO8 is used to connect the flash chip. This means that UART1 can only transmit data. UART0 also has hardware flow control on pins 15 and 13 (RTS0 and CTS0 resp.). These two pins can also be used as alternative TX0 and RX0 pins.","title":"Serial"},{"location":"Expanding-Tasmota/#i2c","text":"ESP8266 doesn\u2019t have a hardware TWI (Two Wire Interface) but it is implemented in software. This means that you can use pretty much any two digital pins. By default, the I\u00b2C library uses pin 4 as SDA and pin 5 as SCL. (The data sheet specifies GPIO2 as SDA and GPIO14 as SCL.) The maximum speed is approximately 450kHz.","title":"I\u00b2C"},{"location":"Expanding-Tasmota/#spi","text":"The ESP8266 has one SPI connection available to the user, referred to as HSPI. It uses GPIO14 as CLK, 12 as MISO, 13 as MOSI and 15 as Slave Select (SS). It can be used in both Slave and Master mode (in software).","title":"SPI"},{"location":"Expanding-Tasmota/#gpio-overview","text":"NodeMCU Labelled Pin GPIO# Function State Restrictions D3 0 Boot mode select 3.3V No Hi-Z D10 1 TX0 - Not usable during Serial transmission D4 2 Boot mode select TX1 3.3V (boot only) Don\u2019t connect to ground at boot time Sends debug data at boot time D9 3 RX0 - Not usable during Serial transmission D2 4 SDA (I\u00b2C) - - D1 5 SCL (I\u00b2C) - - x 6 - 8 Flash connection x Not usable, and not broken out x 9, 10 Flash connection * Only available on the ESP8285 x 11 Flash connection x Not usable, and not broken out D6 12 MISO (SPI) - - D7 13 MOSI (SPI) - - D5 14 SCK (SPI) - - D8 15 SS (SPI) 0V Pull-up resistor not usable (extern pull down resistor) D0 16 Wake up from sleep - No pull-up resistor, but pull-down instead Should be connected to RST to wake up","title":"GPIO overview"},{"location":"FAQ/","text":"Installation ~ Cannot enter flash mode ~ Be sure to press the button correctly, you must \"feel\" a click. If your on-device button doesn't allow you to enter flash mode or there is no GPIO0 broken out to the PCB, you can always bridge GND to GPIO0 pin directly on the chip. Search on the Internet for your chip's pinouts and use the tutorial . Be sure to keep GPIO0 grounded long enough (3-5 seconds) before disconnecting to ensure the chip has booted completely into programming mode. On devices that do not provide a GPIO0 connected button, it may be easier to leave the wired bridge in place throughout the entire flashing process (erase & upload). Doing so will not create any problems for flashing the device. After the firmware is uploaded successfully, remove the bridge. This allows the device to boot normally. Flashing issues ~ Double check if you wired the device the serial-to-USB adapter correctly. Almost every device needs RX and TX pins switched to TX and RX. See Hardware Preparation for more. Another common problem are the jumper cables used. Try another cable if you keep getting connection errors or check the cables for connectivity. Most of them are made cheaply and it happens quite often that those cables do not offer a good connection because of bad crimping or broken copper lines in them. Be sure to use a USB Data Cable and not a cheap loading cable for mobile phones for connecting the serial-to-USB adapter to your computer. If you are unsure, just try another USB cable. Data USB cables are often thicker than the normal loading cables (and more expensive). Another problem can be the difficulties in getting the ESP chip into programming mode when it boots. If the flash still fails or the progress interrupts, it could be that your computer or serial-to-USB adapter doesn't provide enough power to the device. Try another computer or use an external power supply (3.3V one). Use the correct serial-to-USB adapter driver. Check the model of your adapter chip and get the correct driver. If the flash completes successfully, but you get a hash mismatch (esptool.py error message A fatal error occurred: MD5 of file does not match data in flash! ) ensure that your 3.3v current is sufficient. Workarounds include using a dedicated bread board power supply or using the 3.3v output of an additional microcontroller. If using an additional power supply to power the device, be sure to use a common ground for the power supply, the device to be flashed and the serial-to-USB adapter. If esptool.py stops at \"Uploading stub...\", use --no-stub If the flash fails or the device does not operate as expected, try using the default ESP82xx boot ROM baud rate - 74880 . This is the baud rate the ESP82xx is set to by default when it boots into programming mode. It can be specified as a command line option in esptool.py ( -b ) and esptool.exe ( -cb ). You may also want to select a serial monitor/terminal capable of setting this \"unusual\" baud rate. In Termite, type this value ( 74880 ) in the baud rate selection text box when configuring the port. Having the option to specify this unusual baud rate will allow you to view the ESP8266 boot ROM log while the device is booting. Device is hot to the touch ~ Remember - NEVER EVER FLASH WITH 5V! ? Better unpower your device and check if the wiring is correct and the voltage is on your FTDI is set to 3.3V. If you've connected VCC to the wrong pin it might cause your device to overheat and destroy it. There was white smoke and the device does not work anymore! ~ Yes, you've released the fabled \"white smoke\", the mysterious substance all electronic devices work on. In the immortal words of Doctor Bones: It's dead Jim! Sonoff 4CH V2 / Sonoff Dual V2 will not flash ~ Testing with two different (fairly new) FTDI boards and two Sonoff 4CH v2.0 and the Sonoff Dual v2.0 boards I found that I was getting errors uploading sketches i.e. \"warning: espcomm_sync failed\" basically a lack of communication between the two devices. I found that the problem in both Sonoff's was that instead of the FTDI Sonoff cross-over TX->RX and RX->TX I had to do TX->TX RX->RX this then allowed me to upload the sketch. Flashing fails on MacOS High Sierra ~ Related to issue #957 . Solution: 1. Install the VCP drivers for Mac from the FTDI website 2. After install, reboot (it does not work if you do not reboot). 3. After reboot, plug the FTDI USB/serial converter. Accept the security alert from MacOS. 4. Restart the flash process. It works! Wi-Fi ~ Cannot connect to Wi-Fi ~ If your device does not connect to your Wi-Fi and you've made sure the Wi-Fi credentials are correct, it is caused by using special chars or white spaces in your SSID or Password of your Wi-Fi. Remove them and try again. Other reason can be using an SSID longer than the allowed 32 characters. With some Wi-Fi routers (i.e. Linksys with DD-WRT), you may have conflicts with the 5GHz radio. Don't choose \"Mixed\" option. Select \"AC/N-Mixed\" instead. Moreover, you probably should disconnect 5GHz radio during the configuration process. DD-WRT also has Wi-Fi Multi-Media (WMM) enabled by default. Disabling WMM can resolve connectivity issues. I entered the wrong Wi-Fi information ~ If you have a device with a button and the button is configured as a component in the Tasmota settings (e.g., GPIO0 - Button1), you can try pressing the button to force the device into Wi-Fi configuration mode with 4 short presses of the button. If that didn't work reset your device using Fast power cycle device recovery If you are unsure what SSID you have entered, you can try to find that with special Wi-Fi sniffing tools. For example Nirsoft WifiChannelMonitor can show your mistakenly configured SSID name. Linux system example: apt install aircrack-ng wireshark airmon-ng check kill airmon-ng start (e.g. wlp58s0 or wlan0) wireshark Select your Wi-Fi device from the list. Plug in the mis-configured device and immediately watch SSIDs. You should see your mis-configured SSID fairly soon. If these methods don't work, it may still be possible to save the device without opening it to perform a serial flash. Since Tasmota uses GET request for forms, the password may be in your browser history. Search in your browser history for 192.168.4.1 (or whatever address you used for configuring it) There should be an entry similar to this: http://192.168.4.1/wi?s1=<mySSID>&p1=<myPassword>-********&s2=&p2=********&h=hostName&save= s1 is your first AP SSID p1 is the first AP password s2 and p2 are the same parameters but for the second AP h is the hostname given to the device by the Tasmota configuration After getting the incorrectly entered configuration from this URL, configure an access point with these settings as described above Access your device and set the correct Wi-Fi credentials If you flashed a light bulb or any device without a built-in button and entered wrong Wi-Fi password you now have a device that won't connect to your Wi-Fi and you have no button to force it into Wi-Fi configuration mode. This tip takes advantage of a security risk present in Arduino Cores prior to 2.6.0. It will not work with Tasmota binaries compiled with 2.6.0 or later. To solve this you can try creating a new Wi-Fi AP with the same SSID and no (none) authentication. Use an old router, a mobile phone or, if you're desperate, change the settings on your main router (but remember to turn authentication back on when you're done). Depending on the router/phone it will ignore the wrong Wi-Fi password since authentication is set to none and let your Tasmota flashed device connect to it. Now simply connect to the same AP and open the web UI, triple check your ssid and password, enter some simple info for SSID2 which you can create as a hotspot on your phone and save. Device disconnects from Wi-Fi often ~ First thing to try when having Wi-Fi issues: Erase all flash using esptool.py or esptool.exe and flash via serial (as explained here ) using the latest precompiled binaries . This approach has solved most of the reported issues. Sometimes this is due to a bad flash, a bad OTA or invalid data that remains in the flash where the SDK memory is. If you still have issues, you should look into your Wi-Fi network: Check the Wi-Fi channel availability and noise with an Android app like Wi-Fi Analyzer. Disable Auto Channel in your Wi-Fi router and select any Wi-Fi channel that is not very congested in your area. Disable Wi-Fi Repeaters and Mesh Networks. Check Wi-Fi signal in your device. The same Mesh may be stable in one area and lead to unwanted Tasmota reconnects in other areas, presumably when the signals of access points overlap with similar strength. If disabling Mesh Networks is not an option, then keeping the network busy, e.g. by issuing a Ping from another host every 20 seconds has helped to avoid the reconnects. Wi-Fi Stops Working ~ There have been many reports of Wi-Fi no longer working after it was working for a while. Every time this has been reported, it's ended up being a hardware or signal interference problem. On the hardware side, we've seen reports of bad solder joints on the board that when touched up seem to solve the problem (capacitors being loose can cause this) or low quality/weak power supplies or voltage regulators that cannot cope with the power requirements of Tasmota or have degraded over time. We've also seen reports then when a specific LED light bulb was hooked up near one, the signal quality dropped to unusable. All you can really do is check the solder joints, move the device closer to your Access Point. If all else fails, replace the device. Weaker Wi-Fi signal after upgrade ~ On an ESP82xx, Wi-Fi calibration is sensitive to the power supplied. If this changes substantially (e.g., you add a sensor, configure a new Tasmota feature, upgrade the firmware or Arduino Core, etc.), the device's Wi-Fi calibration may not be set properly any longer. The Wi-Fi signal strength (RSSI) can drop significantly and impact Wi-Fi performance. In such a case, the Wi-Fi calibration needs to be deleted to force the device to re-calibrate Wi-Fi after it restarts. 1. Save the device configuration 2. Run Reset 5 in the Console. This command deletes Wi-Fi calibration data, erases all flash memory, and resets parameters to firmware defaults but keeps your Wi-Fi network credentials 3. The device will restart 4. Cycle the power on the device. Wi-Fi calibration will not be done unless the device performs a cold boot from power up. 5. Restore your device configuration from the step 1 backup MQTT ~ Cannot connect to my MQTT broker ~ Make sure you've configured MQTT correctly. If that didn't solve the issue check your MQTT broker logs. Most likely problem is your broker doesn't allow logins for your Tasmota configure user and password or your ACL settings do not include your device. In some very specific cases the MQTT broker code clashes with the Arduino Core and doesn't allow a connection. In that case create a different user for your device, try another core binary or a different MQTT broker. Frequent MQTT reconnects ~ Most MQTT reconnect messages are linked with Wi-Fi instability first. Resolve any Wi-Fi issue first! If the console shows repeated messages like: 02 : 32 : 54 MQTT : tele /MYSONOFF/ LWT = Online ( retained ) 02 : 32 : 54 MQTT : cmnd /MYSONOFF/ POWER = 02 : 32 : 55 MQTT : Attempting connection ... 02 : 32 : 56 mDNS : Query done with 0 mqtt services found 02 : 32 : 56 MQTT : Connected or your mosquitto broker log shows messages like this - 1496455347 : New client connected from IP_addr_1 as SONOFF ( c1 , k15 , u 'SONOFF_USER' ). 1496455349 : New connection from IP_addr_1 on port 1883 . 1496455349 : Client SONOFF already connected , closing old connection . 1496455349 : Client SONOFF disconnected . 1496455349 : New client connected from IP_addr_2 as SONOFF ( c1 , k15 , u 'SONOFF_USER' ). 1496455350 : New connection from IP_addr_2 on port 1883 . 1496455350 : Client SONOFF already connected , closing old connection . 1496455350 : Client SONOFF disconnected . You have more than one device connected with the same %topic% defined. Its important that each device has a unique %topic% instead of the default sonoff . If that is not the issue, erase all flash using esptool.py or esptool.exe and flash again by wire (as explained here ) using the latest precompiled bins with core v2.6 . Device ~ Relay clicks and LED flashes at 1 second intervals ~ This indicates that your device did not get flashed properly. In this case it will toggle all it's pins at 1 sec intervals. A flash erase and a new flash is required. Status LED blinking ~ Your device status LED blinks repeatedly when Wi-Fi and/or MQTT is not connected. If you're not using MQTT and did not configure it the status LED will still keep blinking. You can disable status LED blinking using: Backlog LedPower 0; SetOption31 1 My device randomly switches on and off. Do I have ghosts in my house? ~ Most of the issues with random, or \"ghost\", switching are related to MQTT retain settings. In short, your MQTT broker is retaining a message with the POWER status of the device which gets applied on reboots. Solution here In some cases, adding a switch to a device causes ghost switching. In this case, you may need to add a low pass filter to dampen any spikes on the input. In the case of the Sonoff T1, a modification to change the filter capacitor on the PCB may be required. This short 10 minute video by TheHookUp nicely explains what it is and how to prevent it. Other cause can be of electrical nature. If you have connected an external switch using long wires they can pick up stray signals and cause the voltage on the GPIO to vary. Solution here Device resets to defaults every minute or so ~ Your device may be in a boot loop - a restart caused by any exception or watchdog timer within less than BOOT_LOOP_TIME ( default 10 seconds ). The number of boot loops allowed before beginning to reset settings is determined by SetOption36 . When Tasmota reaches this situation, it will begin restoring default settings as follows: - 1 st restart: disable ESP8285 generic GPIOs interfering with flash SPI - 2 nd restart: disable rules causing boot loop - 3 rd restart: disable all rules - 4 th restart: reset user defined GPIOs to disable any attached peripherals - 5 th restart: reset module to Sonoff Basic (1) Cannot find my device in Modules ~ If you flashed a device which is not listed in the Modules list, use Templates to configure your device. Try looking for it first in the Templates Repository . Device keeps restarting after changing config over MQTT ~ If you changed configurations over MQTT, the command can fail due to a bug and the command is repeatedly sent, causing the device to restart. The restart is normal if you change something at the device configuration. You need to clear the retain messages of your HA/Broker/MQTT Server. Read also: - #2140 - #2658 (comment) - #2716 Can you add this unsupported sensor to Tasmota ~ Short answer: NO! Long answer: There is not enough time in our coders lives to take requests, if you can code a driver for that sensor and submit a PR it will be considered, otherwise you can only wait for someone else to do it. Tasmota is sending a lengthy status update every 5 seconds. What's going on? ~ Turn off TasmoAdmin ! It is polling your device with STATUS 0 command with a HTTP request every 5 seconds which causes the status updates and unnecessary stress load on the device. In some cases it might even interfere with normal device operation. Web Interface Asks for Password ~ You modified the Web Admin password ( Configure Other ) and now you cannot access the web interface. You have set up a password for the web interface. You can login with the username admin and the password you entered. However, if you don't remember that password there are a few options you can try to gain access to the web interface again. Reset the password using the WebPassword command. If you have serial connection to the device: Execute WebPassword 0 using a serial terminal interface. If you have configured MQTT: Send 0 to cmnd/<device-topic>/WebPassword . You can send it from any MQTT client . You can also use another Tasmota device using the Publish command - Execute Publish cmnd/<device-topic>/WebPassword 0 from that device's Console. If the options above are not available: Since Tasmota uses GET request for forms, the password may be in your browser history. Look there for entries with the name you configured for the device. For example, in the following link: http://<device-ip>/co?t1={\"NAME\":\"Generic\"'\"GPIO\":[23'22'24'17'134'132'0'0'131'52'21'0'0]'\"FLAG\":0'\"BASE\":67}&p1=SecretPassword&b1=on&a1=Sonoff&a2=Sonoff2&a3=Sonoff3&a4=Sonoff4&b2=0&save= the p1 parameter contains the password for the web interface ( SecretPassword in this case). Note: special characters may appear as the characters' corresponding ASCII hexadecimal codes (e.g., \"{\" = '\\%7B', etc.) If you had set up WifiConfig 7 as your Wi-Fi fallback method (by previously executing WiFiConfig in the Console), you can reset the device by booting it into Wi-Fi Manager mode. If the SSID configured in the device is not available (e.g., turn off the router), the device will fallback to that restricted Wi-Fi Manager Mode. If your device has a physical push-button, reset the firmware to the default settings as detailed here . If nothing helps, then you have to flash the firmware again using the serial interface. Be sure to erase the flash memory before uploading the binary. Power monitoring shows wrong values ~ If the values shown in the Web UI don't seem right and you're using a Supported Module you need to calibrate the power monitoring sensor . In case you're using a template you created yourself or found in our Templates Repository try the calibration method first. If the values are still wrong or unrealistic the power monitoring sensors' GPIOs are not configured correctly and you will need to find the correct GPIO assignments before proceeding. Sensors do not show values ~ Make sure your sensor is properly wired and the GPIOs assigned. Your vanilla tasmota.bin doesn't have complete sensor support. Make sure you've installed tasmota-sensors.bin that support the largest number of sensors. Some sensors require enabling in the code and compiling your own binary. See Builds for a comprehensive list of supported components. Timers trigger at the wrong time ~ Tasmota devices must have a their time of day set properly in order for any timers to work properly. Check the log in the web UI Console to see if the device's time is set correctly. There are two elements to setting the time: 1. obtaining the UTC time, and, 2. local Daylight Saving Time policies. There are three methods available to set the device time: 1. NTP , 2. An RTC peripheral , or 3. the Time command. The typical method Tasmota uses to set its time is to obtain the time from an Internet NTP server. It can also query an NTP server on its local network (e.g., a network router with an NTP service, a Raspberry Pi running the NTP daemon, the Chrony add-on in Home Assistant, etc.). Check the information about your router's features. If the router provides an NTP server, be sure to configure it properly. If the Tasmota device receives its IP address via DHCP from the router, Tasmota will request its time sync from the router's time server. This is managed by the Arduino core, not Tasmota ( #5283 ). Therefore, if the NTP server on the router is not configured, or configured improperly, the time on the Tasmota device could be wrong. If the router does not have a time server, this is not the problem. If you cannot configure your router's time server to the correct time (e.g., a router provided by your ISP with no access to administration functions), you will need to set a static IP address on the Tasmota device. If the device does not request its address from a DHCP server (i.e., uses a static IP address), the time sync request is forced to NTPSERVER1 . If can't connect, it tries NTPSERVER2 . And finally NTPSERVER3 . Ensure that these parameters are set appropriately and that the device can reach at least one of these time servers. You may want to consider setting up an NTP server locally. As long as the computer is able to set its time at some point from an Internet time server, this computer can serve as an NTP server for your Tasmota device(s). This can be the same computer that hosts your MQTT broker or home automation hub. You must also set the TimeZone and Daylight Saving Time policies ( TimeDST / TimeSTD ). If you have timers that use the sunset or sunrise times, you must set your latitude and longitude in order for these times to be calculated correctly for your location. Auto-discovery in Home Assistant does not work ~ The tasmota-lite.bin firmware binary (which comes packaged with Tuya-Convert) does not support auto-discovery. Please upgrade to tasmota.bin or a similar firmware variant that supports this feature. Make sure its enabled in Tasmota it with SetOption19 1 and you configured the Home Assistant MQTT integration with Discovery enabled. Why is my changed configuration not loaded? ~ If you have flashed a precompiled binary, be aware that all the configuration made after the flash (Wi-Fi, MQTT, topics, names, rules, etc) will be lost in a factory firmware reset. In short : The CFG_HOLDER is the place where the config is stored on your device. The device checks if a config is saved in this CFG_HOLDER (value from the my_user_config.h) and always loads this if exists. => won't load new applied configs in your my_user_config.h To get the new config on your device, you need to change the CFG_HOLDER. BUT: You should always try to stay on the default CFG_HOLDER, to reach this, you need to flash two times change your config in the my_user_config.h or better user_config_override.h change the CFG_HOLDER number. +1 or -1 is enough (e.g. 0x20161208) flash change the CFG_HOLDER back to default ( 0x20161209 ) flash again After this, your new config is saved in the default CFG_HOLDER on your device. This is necessary to avoid losing your config if you update to a new firmware by using the pre-build images or if you forget to change the CFG_HOLDER to your custom one if you build the firmware yourself. How CFG_HOLDER works : The config of your Tasmota is stored in an area of the flash memory (flash config area or FCA ). Using a new device (where Tasmota firmware runs the first time) the FCA does not contain a Tasmota configuration so on the very first start of Tasmota it uses your settings from my_user_config.h or user_config_override.h and copy this into the FCA. To prevent that the following Tasmota starts will overwrite your FCA settings again (e.g. because you has changed some things using commands) the FCA will be marked by a header value to indicate not copy the values from my_user_config.h / user_config_override.h again. This header becomes the value from CFG_HOLDER. On every start the device compares the header of FCA with the CFG_HOLDER from your source code and only if this header value is not identical, Tasmotat will copy the data from my_user_config.h/user_config_override.h to flash settings area - this is normally only the case on a fresh device or if you has changed the CFG_HOLDER value. Summary : To force Tasmota to overwrite current (valid or invalid) settings in FCA with your settings from my_user_config.h / user_config_override.h you can - change CFG_HOLDER value once, compile, reflash device (as described above). To avoid overwriting settings by new versions don't forget either - repeat the step above using original CFG_HOLDER value - or never forget to change CFG_HOLDER value for even all upcoming version to your value - or use the command Reset 1 or Reset 2 after changes in your my_user_config.h / user_config_override.h without the need to double reflash your device and/or double change your CFG_HOLDER value: - change values in my_user_config.h / user_config_override.h - leave CFG_HOLDER as is - start your device and issue command Reset 1 or Reset 2 How do I invert the output of the green LED on the Sonoff Basic so the LED is on when the relay is off? ~ LedState default value is 1 (on) - Show power state on LED. The LED can be disabled completely with LedState 0 (off). However, there is no option to invert the output of the green LED on the Sonoff Basic. What is an Arduino Core ~ Arduino Core (open source) are the core libraries for ESP8266/ESP8285 chips to make them Arduino Framework Compatible. This Core is programmed on top of the Espressif SDK (closed source). You can see the Arduino Core Version and the Espressif SDK Version on the Tasmota WebUI under the Information Menu entry. Example: Core-/SDK-Version: 2_3_0 /1.5.3(aec24ac9) 2.6.1 ( recommended version ): All Tasmota features work mqtt reconnect and lagging fixed fixed Esp8266 IP Address not reachable umm_malloc error fixed Extend PWM resolution for low brightness lights ( Details ) Modem Sleep doesn't work but Tasmota has a CPU dynamic sleep to save energy, so it is not a big issue for this core Alexa works Web UI is fast Serial Software exceptions of 2.3.0 are solved Krack Vulnerability is solved Security fix Beacon Frame Crash More RAM is available Firmware is a little bigger in size compared to 2.4.2 Most Wi-Fi Repeaters don't produces conflicts or disconnections Mesh Networks are supported Most Routers of brands Ubiquity and Fritzbox don't produces conflicts or disconnections 2.3.0 ( this core has many security issues, not supported beginning with 6.7.0.x ) Not all Tasmota features work Modem Sleep works to save energy (see Energy Saving ) Web UI is slower Low RAM Available - Not many features can be enabled at once (sensors, etc.) Has the Krack Vulnerability Software Serial can produce a restart exception (not enough RAM) if several features are enabled. (So, in this case only hardware serial will work - TX and RX pins) Most Wi-Fi Repeaters produces conflicts and disconnections Mesh Networks are not supported Some Routers of brands (Ubiquiti and Fritzbox) produce conflicts and disconnections If the Wi-Fi router has auto channel, channel switching is reliably managed by this core 2.4.2 ( avoid this core version, has security issues too, not supported beginning with 6.7.0.x ): All Tasmota features work Modem Sleep doesn't work but Tasmota has a CPU dynamic sleep to save energy, so it is not a big issue for this core Web UI is faster Serial Software exceptions of 2.3.0 are solved Krack Vulnerability is solved More RAM is available Firmware is a little bigger in flash size Most Wi-Fi Repeaters produce conflicts and disconnections Mesh Networks are not supported Some Routers of brands (Ubiquiti and Fritzbox) produce conflicts and disconnections If the Wi-Fi router has auto channel, channel switching is not reliably managed by this core. Use Fixed Channels in the router instead 2.5.2 Not supported beginning with 6.6.0.18 I Cannot Find An Answer Here! ~ Check the Troubleshooting section or join Discord , Telegram , or the Community Forum for assistance from other Tasmota users.","title":"FAQ"},{"location":"FAQ/#installation","text":"","title":"Installation"},{"location":"FAQ/#cannot-enter-flash-mode","text":"Be sure to press the button correctly, you must \"feel\" a click. If your on-device button doesn't allow you to enter flash mode or there is no GPIO0 broken out to the PCB, you can always bridge GND to GPIO0 pin directly on the chip. Search on the Internet for your chip's pinouts and use the tutorial . Be sure to keep GPIO0 grounded long enough (3-5 seconds) before disconnecting to ensure the chip has booted completely into programming mode. On devices that do not provide a GPIO0 connected button, it may be easier to leave the wired bridge in place throughout the entire flashing process (erase & upload). Doing so will not create any problems for flashing the device. After the firmware is uploaded successfully, remove the bridge. This allows the device to boot normally.","title":"Cannot enter flash mode"},{"location":"FAQ/#flashing-issues","text":"Double check if you wired the device the serial-to-USB adapter correctly. Almost every device needs RX and TX pins switched to TX and RX. See Hardware Preparation for more. Another common problem are the jumper cables used. Try another cable if you keep getting connection errors or check the cables for connectivity. Most of them are made cheaply and it happens quite often that those cables do not offer a good connection because of bad crimping or broken copper lines in them. Be sure to use a USB Data Cable and not a cheap loading cable for mobile phones for connecting the serial-to-USB adapter to your computer. If you are unsure, just try another USB cable. Data USB cables are often thicker than the normal loading cables (and more expensive). Another problem can be the difficulties in getting the ESP chip into programming mode when it boots. If the flash still fails or the progress interrupts, it could be that your computer or serial-to-USB adapter doesn't provide enough power to the device. Try another computer or use an external power supply (3.3V one). Use the correct serial-to-USB adapter driver. Check the model of your adapter chip and get the correct driver. If the flash completes successfully, but you get a hash mismatch (esptool.py error message A fatal error occurred: MD5 of file does not match data in flash! ) ensure that your 3.3v current is sufficient. Workarounds include using a dedicated bread board power supply or using the 3.3v output of an additional microcontroller. If using an additional power supply to power the device, be sure to use a common ground for the power supply, the device to be flashed and the serial-to-USB adapter. If esptool.py stops at \"Uploading stub...\", use --no-stub If the flash fails or the device does not operate as expected, try using the default ESP82xx boot ROM baud rate - 74880 . This is the baud rate the ESP82xx is set to by default when it boots into programming mode. It can be specified as a command line option in esptool.py ( -b ) and esptool.exe ( -cb ). You may also want to select a serial monitor/terminal capable of setting this \"unusual\" baud rate. In Termite, type this value ( 74880 ) in the baud rate selection text box when configuring the port. Having the option to specify this unusual baud rate will allow you to view the ESP8266 boot ROM log while the device is booting.","title":"Flashing issues"},{"location":"FAQ/#device-is-hot-to-the-touch","text":"Remember - NEVER EVER FLASH WITH 5V! ? Better unpower your device and check if the wiring is correct and the voltage is on your FTDI is set to 3.3V. If you've connected VCC to the wrong pin it might cause your device to overheat and destroy it.","title":"Device is hot to the touch"},{"location":"FAQ/#there-was-white-smoke-and-the-device-does-not-work-anymore","text":"Yes, you've released the fabled \"white smoke\", the mysterious substance all electronic devices work on. In the immortal words of Doctor Bones: It's dead Jim!","title":"There was white smoke and the device does not work anymore!"},{"location":"FAQ/#sonoff-4ch-v2-sonoff-dual-v2-will-not-flash","text":"Testing with two different (fairly new) FTDI boards and two Sonoff 4CH v2.0 and the Sonoff Dual v2.0 boards I found that I was getting errors uploading sketches i.e. \"warning: espcomm_sync failed\" basically a lack of communication between the two devices. I found that the problem in both Sonoff's was that instead of the FTDI Sonoff cross-over TX->RX and RX->TX I had to do TX->TX RX->RX this then allowed me to upload the sketch.","title":"Sonoff 4CH V2 / Sonoff Dual V2 will not flash"},{"location":"FAQ/#flashing-fails-on-macos-high-sierra","text":"Related to issue #957 . Solution: 1. Install the VCP drivers for Mac from the FTDI website 2. After install, reboot (it does not work if you do not reboot). 3. After reboot, plug the FTDI USB/serial converter. Accept the security alert from MacOS. 4. Restart the flash process. It works!","title":"Flashing fails on MacOS High Sierra"},{"location":"FAQ/#wi-fi","text":"","title":"Wi-Fi"},{"location":"FAQ/#cannot-connect-to-wi-fi","text":"If your device does not connect to your Wi-Fi and you've made sure the Wi-Fi credentials are correct, it is caused by using special chars or white spaces in your SSID or Password of your Wi-Fi. Remove them and try again. Other reason can be using an SSID longer than the allowed 32 characters. With some Wi-Fi routers (i.e. Linksys with DD-WRT), you may have conflicts with the 5GHz radio. Don't choose \"Mixed\" option. Select \"AC/N-Mixed\" instead. Moreover, you probably should disconnect 5GHz radio during the configuration process. DD-WRT also has Wi-Fi Multi-Media (WMM) enabled by default. Disabling WMM can resolve connectivity issues.","title":"Cannot connect to Wi-Fi"},{"location":"FAQ/#i-entered-the-wrong-wi-fi-information","text":"If you have a device with a button and the button is configured as a component in the Tasmota settings (e.g., GPIO0 - Button1), you can try pressing the button to force the device into Wi-Fi configuration mode with 4 short presses of the button. If that didn't work reset your device using Fast power cycle device recovery If you are unsure what SSID you have entered, you can try to find that with special Wi-Fi sniffing tools. For example Nirsoft WifiChannelMonitor can show your mistakenly configured SSID name. Linux system example: apt install aircrack-ng wireshark airmon-ng check kill airmon-ng start (e.g. wlp58s0 or wlan0) wireshark Select your Wi-Fi device from the list. Plug in the mis-configured device and immediately watch SSIDs. You should see your mis-configured SSID fairly soon. If these methods don't work, it may still be possible to save the device without opening it to perform a serial flash. Since Tasmota uses GET request for forms, the password may be in your browser history. Search in your browser history for 192.168.4.1 (or whatever address you used for configuring it) There should be an entry similar to this: http://192.168.4.1/wi?s1=<mySSID>&p1=<myPassword>-********&s2=&p2=********&h=hostName&save= s1 is your first AP SSID p1 is the first AP password s2 and p2 are the same parameters but for the second AP h is the hostname given to the device by the Tasmota configuration After getting the incorrectly entered configuration from this URL, configure an access point with these settings as described above Access your device and set the correct Wi-Fi credentials If you flashed a light bulb or any device without a built-in button and entered wrong Wi-Fi password you now have a device that won't connect to your Wi-Fi and you have no button to force it into Wi-Fi configuration mode. This tip takes advantage of a security risk present in Arduino Cores prior to 2.6.0. It will not work with Tasmota binaries compiled with 2.6.0 or later. To solve this you can try creating a new Wi-Fi AP with the same SSID and no (none) authentication. Use an old router, a mobile phone or, if you're desperate, change the settings on your main router (but remember to turn authentication back on when you're done). Depending on the router/phone it will ignore the wrong Wi-Fi password since authentication is set to none and let your Tasmota flashed device connect to it. Now simply connect to the same AP and open the web UI, triple check your ssid and password, enter some simple info for SSID2 which you can create as a hotspot on your phone and save.","title":"I entered the wrong Wi-Fi information"},{"location":"FAQ/#device-disconnects-from-wi-fi-often","text":"First thing to try when having Wi-Fi issues: Erase all flash using esptool.py or esptool.exe and flash via serial (as explained here ) using the latest precompiled binaries . This approach has solved most of the reported issues. Sometimes this is due to a bad flash, a bad OTA or invalid data that remains in the flash where the SDK memory is. If you still have issues, you should look into your Wi-Fi network: Check the Wi-Fi channel availability and noise with an Android app like Wi-Fi Analyzer. Disable Auto Channel in your Wi-Fi router and select any Wi-Fi channel that is not very congested in your area. Disable Wi-Fi Repeaters and Mesh Networks. Check Wi-Fi signal in your device. The same Mesh may be stable in one area and lead to unwanted Tasmota reconnects in other areas, presumably when the signals of access points overlap with similar strength. If disabling Mesh Networks is not an option, then keeping the network busy, e.g. by issuing a Ping from another host every 20 seconds has helped to avoid the reconnects.","title":"Device disconnects from Wi-Fi often"},{"location":"FAQ/#wi-fi-stops-working","text":"There have been many reports of Wi-Fi no longer working after it was working for a while. Every time this has been reported, it's ended up being a hardware or signal interference problem. On the hardware side, we've seen reports of bad solder joints on the board that when touched up seem to solve the problem (capacitors being loose can cause this) or low quality/weak power supplies or voltage regulators that cannot cope with the power requirements of Tasmota or have degraded over time. We've also seen reports then when a specific LED light bulb was hooked up near one, the signal quality dropped to unusable. All you can really do is check the solder joints, move the device closer to your Access Point. If all else fails, replace the device.","title":"Wi-Fi Stops Working"},{"location":"FAQ/#weaker-wi-fi-signal-after-upgrade","text":"On an ESP82xx, Wi-Fi calibration is sensitive to the power supplied. If this changes substantially (e.g., you add a sensor, configure a new Tasmota feature, upgrade the firmware or Arduino Core, etc.), the device's Wi-Fi calibration may not be set properly any longer. The Wi-Fi signal strength (RSSI) can drop significantly and impact Wi-Fi performance. In such a case, the Wi-Fi calibration needs to be deleted to force the device to re-calibrate Wi-Fi after it restarts. 1. Save the device configuration 2. Run Reset 5 in the Console. This command deletes Wi-Fi calibration data, erases all flash memory, and resets parameters to firmware defaults but keeps your Wi-Fi network credentials 3. The device will restart 4. Cycle the power on the device. Wi-Fi calibration will not be done unless the device performs a cold boot from power up. 5. Restore your device configuration from the step 1 backup","title":"Weaker Wi-Fi signal after upgrade"},{"location":"FAQ/#mqtt","text":"","title":"MQTT"},{"location":"FAQ/#cannot-connect-to-my-mqtt-broker","text":"Make sure you've configured MQTT correctly. If that didn't solve the issue check your MQTT broker logs. Most likely problem is your broker doesn't allow logins for your Tasmota configure user and password or your ACL settings do not include your device. In some very specific cases the MQTT broker code clashes with the Arduino Core and doesn't allow a connection. In that case create a different user for your device, try another core binary or a different MQTT broker.","title":"Cannot connect to my MQTT broker"},{"location":"FAQ/#frequent-mqtt-reconnects","text":"Most MQTT reconnect messages are linked with Wi-Fi instability first. Resolve any Wi-Fi issue first! If the console shows repeated messages like: 02 : 32 : 54 MQTT : tele /MYSONOFF/ LWT = Online ( retained ) 02 : 32 : 54 MQTT : cmnd /MYSONOFF/ POWER = 02 : 32 : 55 MQTT : Attempting connection ... 02 : 32 : 56 mDNS : Query done with 0 mqtt services found 02 : 32 : 56 MQTT : Connected or your mosquitto broker log shows messages like this - 1496455347 : New client connected from IP_addr_1 as SONOFF ( c1 , k15 , u 'SONOFF_USER' ). 1496455349 : New connection from IP_addr_1 on port 1883 . 1496455349 : Client SONOFF already connected , closing old connection . 1496455349 : Client SONOFF disconnected . 1496455349 : New client connected from IP_addr_2 as SONOFF ( c1 , k15 , u 'SONOFF_USER' ). 1496455350 : New connection from IP_addr_2 on port 1883 . 1496455350 : Client SONOFF already connected , closing old connection . 1496455350 : Client SONOFF disconnected . You have more than one device connected with the same %topic% defined. Its important that each device has a unique %topic% instead of the default sonoff . If that is not the issue, erase all flash using esptool.py or esptool.exe and flash again by wire (as explained here ) using the latest precompiled bins with core v2.6 .","title":"Frequent MQTT reconnects"},{"location":"FAQ/#device","text":"","title":"Device"},{"location":"FAQ/#relay-clicks-and-led-flashes-at-1-second-intervals","text":"This indicates that your device did not get flashed properly. In this case it will toggle all it's pins at 1 sec intervals. A flash erase and a new flash is required.","title":"Relay clicks and LED flashes at 1 second intervals"},{"location":"FAQ/#status-led-blinking","text":"Your device status LED blinks repeatedly when Wi-Fi and/or MQTT is not connected. If you're not using MQTT and did not configure it the status LED will still keep blinking. You can disable status LED blinking using: Backlog LedPower 0; SetOption31 1","title":"Status LED blinking"},{"location":"FAQ/#my-device-randomly-switches-on-and-off-do-i-have-ghosts-in-my-house","text":"Most of the issues with random, or \"ghost\", switching are related to MQTT retain settings. In short, your MQTT broker is retaining a message with the POWER status of the device which gets applied on reboots. Solution here In some cases, adding a switch to a device causes ghost switching. In this case, you may need to add a low pass filter to dampen any spikes on the input. In the case of the Sonoff T1, a modification to change the filter capacitor on the PCB may be required. This short 10 minute video by TheHookUp nicely explains what it is and how to prevent it. Other cause can be of electrical nature. If you have connected an external switch using long wires they can pick up stray signals and cause the voltage on the GPIO to vary. Solution here","title":"My device randomly switches on and off. Do I have ghosts in my house?"},{"location":"FAQ/#device-resets-to-defaults-every-minute-or-so","text":"Your device may be in a boot loop - a restart caused by any exception or watchdog timer within less than BOOT_LOOP_TIME ( default 10 seconds ). The number of boot loops allowed before beginning to reset settings is determined by SetOption36 . When Tasmota reaches this situation, it will begin restoring default settings as follows: - 1 st restart: disable ESP8285 generic GPIOs interfering with flash SPI - 2 nd restart: disable rules causing boot loop - 3 rd restart: disable all rules - 4 th restart: reset user defined GPIOs to disable any attached peripherals - 5 th restart: reset module to Sonoff Basic (1)","title":"Device resets to defaults every minute or so"},{"location":"FAQ/#cannot-find-my-device-in-modules","text":"If you flashed a device which is not listed in the Modules list, use Templates to configure your device. Try looking for it first in the Templates Repository .","title":"Cannot find my device in Modules"},{"location":"FAQ/#device-keeps-restarting-after-changing-config-over-mqtt","text":"If you changed configurations over MQTT, the command can fail due to a bug and the command is repeatedly sent, causing the device to restart. The restart is normal if you change something at the device configuration. You need to clear the retain messages of your HA/Broker/MQTT Server. Read also: - #2140 - #2658 (comment) - #2716","title":"Device keeps restarting after changing config over MQTT"},{"location":"FAQ/#can-you-add-this-unsupported-sensor-to-tasmota","text":"Short answer: NO! Long answer: There is not enough time in our coders lives to take requests, if you can code a driver for that sensor and submit a PR it will be considered, otherwise you can only wait for someone else to do it.","title":"Can you add this unsupported sensor to Tasmota"},{"location":"FAQ/#tasmota-is-sending-a-lengthy-status-update-every-5-seconds-whats-going-on","text":"Turn off TasmoAdmin ! It is polling your device with STATUS 0 command with a HTTP request every 5 seconds which causes the status updates and unnecessary stress load on the device. In some cases it might even interfere with normal device operation.","title":"Tasmota is sending a lengthy status update every 5 seconds. What's going on?"},{"location":"FAQ/#web-interface-asks-for-password","text":"You modified the Web Admin password ( Configure Other ) and now you cannot access the web interface. You have set up a password for the web interface. You can login with the username admin and the password you entered. However, if you don't remember that password there are a few options you can try to gain access to the web interface again. Reset the password using the WebPassword command. If you have serial connection to the device: Execute WebPassword 0 using a serial terminal interface. If you have configured MQTT: Send 0 to cmnd/<device-topic>/WebPassword . You can send it from any MQTT client . You can also use another Tasmota device using the Publish command - Execute Publish cmnd/<device-topic>/WebPassword 0 from that device's Console. If the options above are not available: Since Tasmota uses GET request for forms, the password may be in your browser history. Look there for entries with the name you configured for the device. For example, in the following link: http://<device-ip>/co?t1={\"NAME\":\"Generic\"'\"GPIO\":[23'22'24'17'134'132'0'0'131'52'21'0'0]'\"FLAG\":0'\"BASE\":67}&p1=SecretPassword&b1=on&a1=Sonoff&a2=Sonoff2&a3=Sonoff3&a4=Sonoff4&b2=0&save= the p1 parameter contains the password for the web interface ( SecretPassword in this case). Note: special characters may appear as the characters' corresponding ASCII hexadecimal codes (e.g., \"{\" = '\\%7B', etc.) If you had set up WifiConfig 7 as your Wi-Fi fallback method (by previously executing WiFiConfig in the Console), you can reset the device by booting it into Wi-Fi Manager mode. If the SSID configured in the device is not available (e.g., turn off the router), the device will fallback to that restricted Wi-Fi Manager Mode. If your device has a physical push-button, reset the firmware to the default settings as detailed here . If nothing helps, then you have to flash the firmware again using the serial interface. Be sure to erase the flash memory before uploading the binary.","title":"Web Interface Asks for Password"},{"location":"FAQ/#power-monitoring-shows-wrong-values","text":"If the values shown in the Web UI don't seem right and you're using a Supported Module you need to calibrate the power monitoring sensor . In case you're using a template you created yourself or found in our Templates Repository try the calibration method first. If the values are still wrong or unrealistic the power monitoring sensors' GPIOs are not configured correctly and you will need to find the correct GPIO assignments before proceeding.","title":"Power monitoring shows wrong values"},{"location":"FAQ/#sensors-do-not-show-values","text":"Make sure your sensor is properly wired and the GPIOs assigned. Your vanilla tasmota.bin doesn't have complete sensor support. Make sure you've installed tasmota-sensors.bin that support the largest number of sensors. Some sensors require enabling in the code and compiling your own binary. See Builds for a comprehensive list of supported components.","title":"Sensors do not show values"},{"location":"FAQ/#timers-trigger-at-the-wrong-time","text":"Tasmota devices must have a their time of day set properly in order for any timers to work properly. Check the log in the web UI Console to see if the device's time is set correctly. There are two elements to setting the time: 1. obtaining the UTC time, and, 2. local Daylight Saving Time policies. There are three methods available to set the device time: 1. NTP , 2. An RTC peripheral , or 3. the Time command. The typical method Tasmota uses to set its time is to obtain the time from an Internet NTP server. It can also query an NTP server on its local network (e.g., a network router with an NTP service, a Raspberry Pi running the NTP daemon, the Chrony add-on in Home Assistant, etc.). Check the information about your router's features. If the router provides an NTP server, be sure to configure it properly. If the Tasmota device receives its IP address via DHCP from the router, Tasmota will request its time sync from the router's time server. This is managed by the Arduino core, not Tasmota ( #5283 ). Therefore, if the NTP server on the router is not configured, or configured improperly, the time on the Tasmota device could be wrong. If the router does not have a time server, this is not the problem. If you cannot configure your router's time server to the correct time (e.g., a router provided by your ISP with no access to administration functions), you will need to set a static IP address on the Tasmota device. If the device does not request its address from a DHCP server (i.e., uses a static IP address), the time sync request is forced to NTPSERVER1 . If can't connect, it tries NTPSERVER2 . And finally NTPSERVER3 . Ensure that these parameters are set appropriately and that the device can reach at least one of these time servers. You may want to consider setting up an NTP server locally. As long as the computer is able to set its time at some point from an Internet time server, this computer can serve as an NTP server for your Tasmota device(s). This can be the same computer that hosts your MQTT broker or home automation hub. You must also set the TimeZone and Daylight Saving Time policies ( TimeDST / TimeSTD ). If you have timers that use the sunset or sunrise times, you must set your latitude and longitude in order for these times to be calculated correctly for your location.","title":"Timers trigger at the wrong time"},{"location":"FAQ/#auto-discovery-in-home-assistant-does-not-work","text":"The tasmota-lite.bin firmware binary (which comes packaged with Tuya-Convert) does not support auto-discovery. Please upgrade to tasmota.bin or a similar firmware variant that supports this feature. Make sure its enabled in Tasmota it with SetOption19 1 and you configured the Home Assistant MQTT integration with Discovery enabled.","title":"Auto-discovery in Home Assistant does not work"},{"location":"FAQ/#why-is-my-changed-configuration-not-loaded","text":"If you have flashed a precompiled binary, be aware that all the configuration made after the flash (Wi-Fi, MQTT, topics, names, rules, etc) will be lost in a factory firmware reset. In short : The CFG_HOLDER is the place where the config is stored on your device. The device checks if a config is saved in this CFG_HOLDER (value from the my_user_config.h) and always loads this if exists. => won't load new applied configs in your my_user_config.h To get the new config on your device, you need to change the CFG_HOLDER. BUT: You should always try to stay on the default CFG_HOLDER, to reach this, you need to flash two times change your config in the my_user_config.h or better user_config_override.h change the CFG_HOLDER number. +1 or -1 is enough (e.g. 0x20161208) flash change the CFG_HOLDER back to default ( 0x20161209 ) flash again After this, your new config is saved in the default CFG_HOLDER on your device. This is necessary to avoid losing your config if you update to a new firmware by using the pre-build images or if you forget to change the CFG_HOLDER to your custom one if you build the firmware yourself. How CFG_HOLDER works : The config of your Tasmota is stored in an area of the flash memory (flash config area or FCA ). Using a new device (where Tasmota firmware runs the first time) the FCA does not contain a Tasmota configuration so on the very first start of Tasmota it uses your settings from my_user_config.h or user_config_override.h and copy this into the FCA. To prevent that the following Tasmota starts will overwrite your FCA settings again (e.g. because you has changed some things using commands) the FCA will be marked by a header value to indicate not copy the values from my_user_config.h / user_config_override.h again. This header becomes the value from CFG_HOLDER. On every start the device compares the header of FCA with the CFG_HOLDER from your source code and only if this header value is not identical, Tasmotat will copy the data from my_user_config.h/user_config_override.h to flash settings area - this is normally only the case on a fresh device or if you has changed the CFG_HOLDER value. Summary : To force Tasmota to overwrite current (valid or invalid) settings in FCA with your settings from my_user_config.h / user_config_override.h you can - change CFG_HOLDER value once, compile, reflash device (as described above). To avoid overwriting settings by new versions don't forget either - repeat the step above using original CFG_HOLDER value - or never forget to change CFG_HOLDER value for even all upcoming version to your value - or use the command Reset 1 or Reset 2 after changes in your my_user_config.h / user_config_override.h without the need to double reflash your device and/or double change your CFG_HOLDER value: - change values in my_user_config.h / user_config_override.h - leave CFG_HOLDER as is - start your device and issue command Reset 1 or Reset 2","title":"Why is my changed configuration not loaded?"},{"location":"FAQ/#how-do-i-invert-the-output-of-the-green-led-on-the-sonoff-basic-so-the-led-is-on-when-the-relay-is-off","text":"LedState default value is 1 (on) - Show power state on LED. The LED can be disabled completely with LedState 0 (off). However, there is no option to invert the output of the green LED on the Sonoff Basic.","title":"How do I invert the output of the green LED on the Sonoff Basic so the LED is on when the relay is off?"},{"location":"FAQ/#what-is-an-arduino-core","text":"Arduino Core (open source) are the core libraries for ESP8266/ESP8285 chips to make them Arduino Framework Compatible. This Core is programmed on top of the Espressif SDK (closed source). You can see the Arduino Core Version and the Espressif SDK Version on the Tasmota WebUI under the Information Menu entry. Example: Core-/SDK-Version: 2_3_0 /1.5.3(aec24ac9) 2.6.1 ( recommended version ): All Tasmota features work mqtt reconnect and lagging fixed fixed Esp8266 IP Address not reachable umm_malloc error fixed Extend PWM resolution for low brightness lights ( Details ) Modem Sleep doesn't work but Tasmota has a CPU dynamic sleep to save energy, so it is not a big issue for this core Alexa works Web UI is fast Serial Software exceptions of 2.3.0 are solved Krack Vulnerability is solved Security fix Beacon Frame Crash More RAM is available Firmware is a little bigger in size compared to 2.4.2 Most Wi-Fi Repeaters don't produces conflicts or disconnections Mesh Networks are supported Most Routers of brands Ubiquity and Fritzbox don't produces conflicts or disconnections 2.3.0 ( this core has many security issues, not supported beginning with 6.7.0.x ) Not all Tasmota features work Modem Sleep works to save energy (see Energy Saving ) Web UI is slower Low RAM Available - Not many features can be enabled at once (sensors, etc.) Has the Krack Vulnerability Software Serial can produce a restart exception (not enough RAM) if several features are enabled. (So, in this case only hardware serial will work - TX and RX pins) Most Wi-Fi Repeaters produces conflicts and disconnections Mesh Networks are not supported Some Routers of brands (Ubiquiti and Fritzbox) produce conflicts and disconnections If the Wi-Fi router has auto channel, channel switching is reliably managed by this core 2.4.2 ( avoid this core version, has security issues too, not supported beginning with 6.7.0.x ): All Tasmota features work Modem Sleep doesn't work but Tasmota has a CPU dynamic sleep to save energy, so it is not a big issue for this core Web UI is faster Serial Software exceptions of 2.3.0 are solved Krack Vulnerability is solved More RAM is available Firmware is a little bigger in flash size Most Wi-Fi Repeaters produce conflicts and disconnections Mesh Networks are not supported Some Routers of brands (Ubiquiti and Fritzbox) produce conflicts and disconnections If the Wi-Fi router has auto channel, channel switching is not reliably managed by this core. Use Fixed Channels in the router instead 2.5.2 Not supported beginning with 6.6.0.18","title":"What is an Arduino Core"},{"location":"FAQ/#i-cannot-find-an-answer-here","text":"Check the Troubleshooting section or join Discord , Telegram , or the Community Forum for assistance from other Tasmota users.","title":"I Cannot Find An Answer Here!"},{"location":"Fast-power-cycle-device-recovery/","text":"Introduced in v6.7.1 Fast power cycle device recovery is implemented for situations where a device cannot be reset to firmware defaults (no serial access, no button). It resets all Tasmota settings (equal to Reset 1 ) after 4 power cycles. SetOption65 must be set to 0 (default) in order for this feature to be enabled. To use: ~ Cut power from the device completely for 30 seconds Power the device on and off three times with intervals lower than 10 seconds and leave it on after fourth time Fast power cycle device recovery should activate and the device should be reset to firmware defaults If you flashed a precompiled binary you can reconfigure the device using the web UI.","title":"Fast power cycle device recovery"},{"location":"Fast-power-cycle-device-recovery/#to-use","text":"Cut power from the device completely for 30 seconds Power the device on and off three times with intervals lower than 10 seconds and leave it on after fourth time Fast power cycle device recovery should activate and the device should be reset to firmware defaults If you flashed a precompiled binary you can reconfigure the device using the web UI.","title":"To use:"},{"location":"Flash-Sonoff-using-Raspberry-Pi/","text":"If you don't have a USB-to-TTL serial adapter available, but you have a Raspberry Pi, you can use this procedure for flashing your device. Tutorial (a little outdated) Summarizing the process and needed connections based on the above blog, please refer there for a more detailed explanation Preparation of the Raspberry Pi ~ Install esptool (pip needed) sudo pip install esptool Prepare serial connection. Note: Use the correct serial connection as per your version of the Raspberry Pi. Device Serial Connection RaspberryPi 1/2/3 (BT disabled or miniuart) /dev/ttyAMA0 RaspberryPi 3 /dev/ttyS0 sudo systemctl stop serial-getty@ttyS0.service sudo systemctl disable serial-getty@ttyS0.service sudo cp /boot/cmdline.txt /boot/cmdline.bak (This backups the file ;)) sudo nano /boot/cmdline.txt -> delete \"console=serial0,115200\" option I don\u2019t know if this is necessary, but I did it as it was mentioned here: https://spellfoundry.com/2016/05/29/configuring-gpio-serial-port-raspbian-jessie-including-pi-3/ sudo nano /boot/config.txt -> add the line (at the bottom): enable_uart=1 Please note following overlays setting port to /dev/ttyAMA0 pi3-miniuart-bt pi3-disable-bt Reboot your Pi Connections ~ Connect GND, RX->TX and TX->RX as shown below. If you power the device with the 3.3V power from the RPi it will cause it to reboot when connecting. You can still enter flash mode if you power up the RPi with the 3.3v connected and pressing the connecting GPIO0 to ground (e.g., pressing the button on the Sonoff Basic) simultaneously. It's recommended to use either an external power supply for this or use the 5V GPIO and a 3.3V Voltage Regulator. ( issue #4807 ) Do not connect 3.3V yet! https://www.sigmdel.ca/michel/ha/sonoff/flashing_sonoff_en.html (For RaspberryPi 3 (40 GPIO pins) GND is the last pin on the left, the 39th pin.) This is how it looks in real-life \ud83d\ude06 Flashing the firmware ~ Erase flash memory: Connect 3.3V while button pressed for about 10 seconds to enter flash-mode. Then release and run: ```bash # if using Raspberry Pi 1/2 use # esptool.py --port /dev/ttyAMA0 erase_flash # if using Raspberry Pi 3 use esptool.py --port /dev/ttyS0 erase_flash ``` You should see output like this: bash \u279c ~ esptool.py --port /dev/ttyAMA0 erase_flash esptool.py v2.5.1 Serial port /dev/ttyAMA0 Connecting.... Detecting chip type... ESP8266 Chip is ESP8285 Features: WiFi, Embedded Flash MAC: dc:4f:22:ab:5e:dc Uploading stub... Running stub... Stub running... Erasing flash (this may take a while)... Chip erase completed successfully in 3.3s Hard resetting via RTS pin... \u279c ~ Flash .bin, which you can download from the release-section : Again connect 3.3V while pressing button for 10 seconds. Then release and run: ```bash # if using Raspberry Pi 1/2 use # esptool.py --port /dev/ttyAMA0 write_flash -fm dout 0x0 /path/to/downloaded/tasmota.bin # if using Raspberry Pi 3 use esptool.py --port /dev/ttyS0 write_flash -fm dout 0x0 /path/to/downloaded/tasmota.bin ``` You should see output like this: ```bash \u279c ~ esptool.py --port /dev/ttyAMA0 write_flash -fm dout 0x0 tasmota.bin esptool.py v2.5.1 Serial port /dev/ttyAMA0 Connecting..... Detecting chip type... ESP8266 Chip is ESP8285 Features: WiFi, Embedded Flash MAC: dc:4f:22 5e:dc Uploading stub... Running stub... Stub running... Configuring flash size... Auto-detected Flash size: 1MB Compressed 456000 bytes to 312426... Wrote 456000 bytes (312426 compressed) at 0x00000000 in 29.2 seconds (effective 124.8 kbit/s)... Hash of data verified. Leaving... Hard resetting via RTS pin... \u279c ~ ``` Setup Wi-Fi: Connect with an external device to the sonoff-xxxx Wi-Fi AP and configure over the browser. Alternative: Reboot your device after flashing (toggle power wire) and connect to the serial console via miniterm: ```bash # if using Raspberry Pi 1/2 use # miniterm.py /dev/ttyAMA0 115200 -e # if using Raspberry Pi 3 use miniterm.py /dev/ttyS0 115200 -e ``` You will see some output, after pressing enter. Now just type in, your SSID, press enter and then type the password\u2026 Backlog ssid yourSSID; password yourPassword That\u2019s it ~ Sources: Flashing commands https://spellfoundry.com/2016/05/29/configuring-gpio-serial-port-raspbian-jessie-including-pi-3/","title":"Flash Sonoff using Raspberry Pi"},{"location":"Flash-Sonoff-using-Raspberry-Pi/#preparation-of-the-raspberry-pi","text":"Install esptool (pip needed) sudo pip install esptool Prepare serial connection. Note: Use the correct serial connection as per your version of the Raspberry Pi. Device Serial Connection RaspberryPi 1/2/3 (BT disabled or miniuart) /dev/ttyAMA0 RaspberryPi 3 /dev/ttyS0 sudo systemctl stop serial-getty@ttyS0.service sudo systemctl disable serial-getty@ttyS0.service sudo cp /boot/cmdline.txt /boot/cmdline.bak (This backups the file ;)) sudo nano /boot/cmdline.txt -> delete \"console=serial0,115200\" option I don\u2019t know if this is necessary, but I did it as it was mentioned here: https://spellfoundry.com/2016/05/29/configuring-gpio-serial-port-raspbian-jessie-including-pi-3/ sudo nano /boot/config.txt -> add the line (at the bottom): enable_uart=1 Please note following overlays setting port to /dev/ttyAMA0 pi3-miniuart-bt pi3-disable-bt Reboot your Pi","title":"Preparation of the Raspberry Pi"},{"location":"Flash-Sonoff-using-Raspberry-Pi/#connections","text":"Connect GND, RX->TX and TX->RX as shown below. If you power the device with the 3.3V power from the RPi it will cause it to reboot when connecting. You can still enter flash mode if you power up the RPi with the 3.3v connected and pressing the connecting GPIO0 to ground (e.g., pressing the button on the Sonoff Basic) simultaneously. It's recommended to use either an external power supply for this or use the 5V GPIO and a 3.3V Voltage Regulator. ( issue #4807 ) Do not connect 3.3V yet! https://www.sigmdel.ca/michel/ha/sonoff/flashing_sonoff_en.html (For RaspberryPi 3 (40 GPIO pins) GND is the last pin on the left, the 39th pin.) This is how it looks in real-life \ud83d\ude06","title":"Connections"},{"location":"Flash-Sonoff-using-Raspberry-Pi/#flashing-the-firmware","text":"Erase flash memory: Connect 3.3V while button pressed for about 10 seconds to enter flash-mode. Then release and run: ```bash # if using Raspberry Pi 1/2 use # esptool.py --port /dev/ttyAMA0 erase_flash # if using Raspberry Pi 3 use esptool.py --port /dev/ttyS0 erase_flash ``` You should see output like this: bash \u279c ~ esptool.py --port /dev/ttyAMA0 erase_flash esptool.py v2.5.1 Serial port /dev/ttyAMA0 Connecting.... Detecting chip type... ESP8266 Chip is ESP8285 Features: WiFi, Embedded Flash MAC: dc:4f:22:ab:5e:dc Uploading stub... Running stub... Stub running... Erasing flash (this may take a while)... Chip erase completed successfully in 3.3s Hard resetting via RTS pin... \u279c ~ Flash .bin, which you can download from the release-section : Again connect 3.3V while pressing button for 10 seconds. Then release and run: ```bash # if using Raspberry Pi 1/2 use # esptool.py --port /dev/ttyAMA0 write_flash -fm dout 0x0 /path/to/downloaded/tasmota.bin # if using Raspberry Pi 3 use esptool.py --port /dev/ttyS0 write_flash -fm dout 0x0 /path/to/downloaded/tasmota.bin ``` You should see output like this: ```bash \u279c ~ esptool.py --port /dev/ttyAMA0 write_flash -fm dout 0x0 tasmota.bin esptool.py v2.5.1 Serial port /dev/ttyAMA0 Connecting..... Detecting chip type... ESP8266 Chip is ESP8285 Features: WiFi, Embedded Flash MAC: dc:4f:22 5e:dc Uploading stub... Running stub... Stub running... Configuring flash size... Auto-detected Flash size: 1MB Compressed 456000 bytes to 312426... Wrote 456000 bytes (312426 compressed) at 0x00000000 in 29.2 seconds (effective 124.8 kbit/s)... Hash of data verified. Leaving... Hard resetting via RTS pin... \u279c ~ ``` Setup Wi-Fi: Connect with an external device to the sonoff-xxxx Wi-Fi AP and configure over the browser. Alternative: Reboot your device after flashing (toggle power wire) and connect to the serial console via miniterm: ```bash # if using Raspberry Pi 1/2 use # miniterm.py /dev/ttyAMA0 115200 -e # if using Raspberry Pi 3 use miniterm.py /dev/ttyS0 115200 -e ``` You will see some output, after pressing enter. Now just type in, your SSID, press enter and then type the password\u2026 Backlog ssid yourSSID; password yourPassword","title":"Flashing the firmware"},{"location":"Flash-Sonoff-using-Raspberry-Pi/#thats-it","text":"Sources: Flashing commands https://spellfoundry.com/2016/05/29/configuring-gpio-serial-port-raspbian-jessie-including-pi-3/","title":"That\u2019s it"},{"location":"Flashingx/","text":"If you have read through the Prerequisites you should have selected a pre-compiled Tasmota firmware binary or chosen to compile your own Tasmota firmware binary . Once you have followed Hardware preparation , your device should be in Flash Mode and ready for a Tasmota firmware binary file to be flashed. For that you need a flashing tool . Optionally, you may want to back up the device manufacturer's firmware on the 1 in a million chance you don't like Tasmota. Tasmotizer! ~ Tasmotizer! is specifically designed for use with Tasmota with an easy to use GUI and esptool.py under the hood. Download the latest release for your platform. If using Windows just double click the downloaded file and it'll start, no installation required. For python follow the installation instructions . You can also watch our Video tutorial for Tasmotizer . Thx Jon! Note If you get an anti-virus infection warning don't fret, it is a known false positive . If you're still apprehensive you can always run the Python version. It is time to Tasmotize! Connect your device to the serial-to-USB adapter or plug in NodeMCU/D1 mini. Check whether the correct serial port (COM or tty port) is selected. Tasmotizer! will try its best to select the right one for you. Choose Tasmota firmware binary: BIN file - browse to the Tasmota firmware binary you downloaded or compiled. Release - select from a list of available release binaries Development - select from a list of latest development binaries optional Backup the original device firmware Erase flash [!DANGER] Leave Erase before flashing checked if it is the first time flashing Tasmota on the device or you're experiencing issues with the existing flash and need to do a full erase. If you're upgrading an already flashed Tasmota and wish to keep your settings, uncheck Erase before flashing . Click Tasmotize and wait until done. If the flash was successful it will display: Unplug your serial programming adapter or device and plug it back in or connect to another power source. Your device is now ready for Initial configuration . [!TIP] You can use Send Config Tasmotizer! button for the initial configuration of your device. esptool.py ~ Esptool is the official Espressif tool for flashing ESP8266 chips. It requires Python, if you do not have an installed copy of Python 2.x or 3.x download and install it from https://www.python.org. Download the esptool Source code to a folder of your choice. Go to the folder and install Esptool with command python setup.py install Upload Tasmota Make sure you followed the steps to put your device in flash mode. Place your chosen firmware binary file in the same folder as esptool.py. Esptool uses the serial interface to communicate with your device. On Windows these interfaces are named COM1, COM2, etc. and on Linux they are named /dev/ttyUSB0, /dev/ttyUSB1, etc. Before using esptool, make sure you know which serial port your programming adapter is connected to. The following use COM5 as an example. Change COM5 with your serial port designation. Ensure the device is in flash mode before each step. Backup Firmware (optional step) Backup the current firmware with the following command: esptool.py --port COM5 read_flash 0x00000 0x100000 fwbackup.bin When the command completes the device is not in flash mode anymore. Repeat the process of putting your device in programming mode. Erase Flash Memory Erase the complete flash memory holding the firmware with the following command: esptool.py --port COM5 erase_flash It only takes a few seconds to erase 1M of flash. When the command completes the device is not in flash mode anymore. Repeat the process of putting your device in programming mode. Upload Firmware Load the chosen Tasmota firmware file with the following command (e.g., tasmota.bin in this example): esptool.py --port COM5 write_flash -fs 1MB -fm dout 0x0 tasmota.bin Unplug your serial programming adapter or your device and plug it back in or connect to another power source. Your device is now ready for Initial configuration . [!TIP] For proper device initialization after the firmware upload completes, power down and power up the device. Esptool Executable ~ The executable version of esptool is maintained by Ivan Grokhotkov and releases are kept at https://github.com/igrr/esptool-ck/releases . Supports Linux, Linux ARM, Windows 32-bit and Mac First Step For the purpose of simplicity only the Windows version will be explained here, but the commands and parameters are the same for Windows, Linux and Mac. Download the latest release of Esptool-CK and extract the compressed file to a folder of your choice. Place your chosen firmware binary file (e.g., tasmota.bin in the example below) in the same folder as Esptool-CK to simplify the process. The following commands use COM5 as an example. Change COM5 with your port designation. Ensure the device is in flash mode before each step. Erase Flash Memory esptool -cp COM5 -ce -v Upload firmware Once the erase is complete, put device back into programming mode and upload the firmware esptool -cp COM5 -bm dout -cf tasmota.bin -v Unplug your serial programming adapter or your device and plug it back in or connect to another power source. Your device is now ready for Initial configuration . For proper device initialization after the firmware upload completes, power down and power up the device. Compiling from Source ~ Tutorials for setting up development environments if you want to modify the code or default settings and compile your own binaries . - PlatformIO - setup and configure PlatformIO for compilation and upload - PlatformIO CLI - use the PlatformIO command line interface on Linux for compilation and upload - PlatformIO-Core - automate firmware builds using PlatformIO-Core and flash with esptool - Visual Studio Code - setup and configure Visual Studio Code with PlatformIO for Tasmota - Atom - beginner guide building Tasmota firmware using Atom with PlatformIO plugin - Arduino IDE - setup and configure Arduino IDE for Tasmota compilation and upload - Docker Tasmota - compile from a Docker container using PlatformIO In PlatformIO, be sure that you always have the latest build of the ESP Core. Delete the following in your .platformio folder ( %USERPROFILE%\\.platformio in Windows): - Everything in .platformio/platforms - All folders that begin with framework... in .platformio/packages Read more in Compile Your Own Tasmota . Online Compilers Can only create a firmware binary. Use one of the tools to flash it to your device. - Gitpod - compile your own binary in the cloud using Gitpod . - TasmoCompiler - simple web GUI to compile Tasmota with your own settings OTA Flashing Tools ~ Tasmota is NOT a developer of these tools. For help and troubleshooting you will need to get support from those projects . - EspBuddy - OTA or serial flash (using intermediate firmware for 1M devices), backup settings and past firmwares, auto-build using custom flags, flash in batch, handle Sonoff DIY devices... - Tuya Convert - easy OTA flash for devices with Tuya chips, no disassembly required - Sonoff DIY - OTA flash for select Sonoff devices (some disassembly required) - Node-RED OTA server and firmware manager - Node-RED flow for managing OTA updates - OTA over SCP - setup and configure \"OTA over SCP\" upload for PlatformIO - Python HTTP OTA server - setting up a small Python server to serve OTA upgrade binaries - SonOTA - OTA flash eWeLink based devices (mostly outdated) Need More Help? ~ If you have encountered problems during flash see the FAQ . Ask for help in Discord or Community Forum","title":"Flashingx"},{"location":"Flashingx/#tasmotizer","text":"Tasmotizer! is specifically designed for use with Tasmota with an easy to use GUI and esptool.py under the hood. Download the latest release for your platform. If using Windows just double click the downloaded file and it'll start, no installation required. For python follow the installation instructions . You can also watch our Video tutorial for Tasmotizer . Thx Jon! Note If you get an anti-virus infection warning don't fret, it is a known false positive . If you're still apprehensive you can always run the Python version. It is time to Tasmotize! Connect your device to the serial-to-USB adapter or plug in NodeMCU/D1 mini. Check whether the correct serial port (COM or tty port) is selected. Tasmotizer! will try its best to select the right one for you. Choose Tasmota firmware binary: BIN file - browse to the Tasmota firmware binary you downloaded or compiled. Release - select from a list of available release binaries Development - select from a list of latest development binaries optional Backup the original device firmware Erase flash [!DANGER] Leave Erase before flashing checked if it is the first time flashing Tasmota on the device or you're experiencing issues with the existing flash and need to do a full erase. If you're upgrading an already flashed Tasmota and wish to keep your settings, uncheck Erase before flashing . Click Tasmotize and wait until done. If the flash was successful it will display: Unplug your serial programming adapter or device and plug it back in or connect to another power source. Your device is now ready for Initial configuration . [!TIP] You can use Send Config Tasmotizer! button for the initial configuration of your device.","title":"Tasmotizer!"},{"location":"Flashingx/#esptoolpy","text":"Esptool is the official Espressif tool for flashing ESP8266 chips. It requires Python, if you do not have an installed copy of Python 2.x or 3.x download and install it from https://www.python.org. Download the esptool Source code to a folder of your choice. Go to the folder and install Esptool with command python setup.py install","title":"esptool.py"},{"location":"Flashingx/#esptool-executable","text":"The executable version of esptool is maintained by Ivan Grokhotkov and releases are kept at https://github.com/igrr/esptool-ck/releases . Supports Linux, Linux ARM, Windows 32-bit and Mac","title":"Esptool Executable"},{"location":"Flashingx/#compiling-from-source","text":"Tutorials for setting up development environments if you want to modify the code or default settings and compile your own binaries . - PlatformIO - setup and configure PlatformIO for compilation and upload - PlatformIO CLI - use the PlatformIO command line interface on Linux for compilation and upload - PlatformIO-Core - automate firmware builds using PlatformIO-Core and flash with esptool - Visual Studio Code - setup and configure Visual Studio Code with PlatformIO for Tasmota - Atom - beginner guide building Tasmota firmware using Atom with PlatformIO plugin - Arduino IDE - setup and configure Arduino IDE for Tasmota compilation and upload - Docker Tasmota - compile from a Docker container using PlatformIO In PlatformIO, be sure that you always have the latest build of the ESP Core. Delete the following in your .platformio folder ( %USERPROFILE%\\.platformio in Windows): - Everything in .platformio/platforms - All folders that begin with framework... in .platformio/packages Read more in Compile Your Own Tasmota .","title":"Compiling from Source"},{"location":"Flashingx/#ota-flashing-tools","text":"Tasmota is NOT a developer of these tools. For help and troubleshooting you will need to get support from those projects . - EspBuddy - OTA or serial flash (using intermediate firmware for 1M devices), backup settings and past firmwares, auto-build using custom flags, flash in batch, handle Sonoff DIY devices... - Tuya Convert - easy OTA flash for devices with Tuya chips, no disassembly required - Sonoff DIY - OTA flash for select Sonoff devices (some disassembly required) - Node-RED OTA server and firmware manager - Node-RED flow for managing OTA updates - OTA over SCP - setup and configure \"OTA over SCP\" upload for PlatformIO - Python HTTP OTA server - setting up a small Python server to serve OTA upgrade binaries - SonOTA - OTA flash eWeLink based devices (mostly outdated)","title":"OTA Flashing Tools"},{"location":"Flashingx/#need-more-help","text":"If you have encountered problems during flash see the FAQ . Ask for help in Discord or Community Forum","title":"Need More Help?"},{"location":"For-Developers/","text":"Information for tool developers: ~ JSON Status Responses Sensor API Maintained Tasmota forks with additional features: ~ Time Proportioned Output Fork PID Control Fork","title":"For Developers"},{"location":"For-Developers/#information-for-tool-developers","text":"JSON Status Responses Sensor API","title":"Information for tool developers:"},{"location":"For-Developers/#maintained-tasmota-forks-with-additional-features","text":"Time Proportioned Output Fork PID Control Fork","title":"Maintained Tasmota forks with additional features:"},{"location":"GPIO-Locations/","text":"ESP8266 ~ TYWE3S ~ Digoo DG-SP202 / OxaOxe NX-SP202 ~ (Found out by tracing the PCB copper tracks of the unknown ESP module. Not verified, except GPIO0, RX, TX, Vcc and GND which have successfully been used for flashing.) Sonoff TH ~ Sonoff Basic ~","title":"GPIO Locations"},{"location":"GPIO-Locations/#esp8266","text":"","title":"ESP8266"},{"location":"GPIO-Locations/#tywe3s","text":"","title":"TYWE3S"},{"location":"GPIO-Locations/#digoo-dg-sp202-oxaoxe-nx-sp202","text":"(Found out by tracing the PCB copper tracks of the unknown ESP module. Not verified, except GPIO0, RX, TX, Vcc and GND which have successfully been used for flashing.)","title":"Digoo DG-SP202 / OxaOxe NX-SP202"},{"location":"GPIO-Locations/#sonoff-th","text":"","title":"Sonoff TH"},{"location":"GPIO-Locations/#sonoff-basic","text":"","title":"Sonoff Basic"},{"location":"GPS-NTP-server/","text":"GPS-based NTP-server (Serial) ~ The foremost reason for the inclusion of this driver was to have a network unrelated time source, but besides this location data is provided too. !> Only u-blox-devices are supported The UBX binary protocol was chosen, because it is very memory efficient and all the needed data can be read without further parsing. The genereric NMEA-standard is NOT supported! The driver is tested on a NEO-6m and a Beitian-220. Series 7 should work too. These modules are quite cheap, starting at about 3.50\u20ac for the NEO-6m. Features: ~ simplified NTP-Server sets system time automatically and Settings.latitude and Settings.longitude via command get position and time data can log postion data with timestamp to flash with a small memory footprint of only 12 Bytes per record (!!EXPERIMENTAL!!) constructs a GPX-file for download of this data Web-UI and console command interface Connecting the GPS-device to a Wemos D1 mini ~ Wemos D1 Mini GPS VCC +3.3V Vin GND GND TX Rx RX Tx Tasmota Settings ~ In the Configuration -> Configure Module page, select the following for Wemos D1 mini: 1. Module Type: 18 Generic 2. TX GPIO1 Serial Out: GPX_TX 3. RX GPIO3 Serial In: GPX_RX No further installation steps needed. To get more debug information compile it with option \"DEBUG_TASMOTA_SENSOR\". The driver expects the device to be configured for 9600 baud, which is the default for most of these sensors. If necessary the configuration can be changed with the freely available \"u-center\"-software, which is windows-only but is reported to run quite well with WINE and can be confirmed to work with CrossOver on macOs Catalina. NTP-Server ~ Simply start the server with 'sensor60 9'. Flash-Log ~ This is highly experimental feature, which uses the OTA-partition to log position data. !! \u26a0\ufe0f FOR OBVIOUS REASONS THIS WILL SHORTEN THE LIFE OF THE FLASH MEMORY AND SHOULD BE USED WISELY \u26a0\ufe0f !! After the first recording, a download-link will appear in the web interface. By clicking on it, a GPX-file will be created on-the fly for download. All recorded data is lost after each OTA-update. Commands: ~ sensor60 0 write to all available sectors, then restart and overwrite the older ones sensor60 1 write to all available sectors, then restart and overwrite the older ones sensor60 2 filter out horizontal drift noise sensor60 3 turn off noise filter sensor60 4 start recording, new data will be appended sensor60 5 start new recording, old data will lost sensor60 6 stop recording, download link will be visible in Web-UI sensor60 7 send mqtt on new postion + TELE -> consider to set TELE to a very high value sensor60 8 only TELE message sensor60 9 start NTP-Server sensor60 10 deactivate NTP-Server sensor60 11 force update of Tasmota-system-UTC with every new GPS-time-message sensor60 12 do NOT update of Tasmota-system-UTC with every new GPS-time-message sensor60 13 set latitude and longitude in settings sensor60 14 open virtual serial port over TCP, usable for u-center: tcp://ip-address:port (default port: 1234) !! \u26a0\ufe0f misconfiguration via u-center can virtually brick the device \u26a0\ufe0f !! sensor60 15 pause virtual serial port over TCP (connection stays active in the background)","title":"GPS NTP server"},{"location":"GPS-NTP-server/#gps-based-ntp-server-serial","text":"The foremost reason for the inclusion of this driver was to have a network unrelated time source, but besides this location data is provided too. !> Only u-blox-devices are supported The UBX binary protocol was chosen, because it is very memory efficient and all the needed data can be read without further parsing. The genereric NMEA-standard is NOT supported! The driver is tested on a NEO-6m and a Beitian-220. Series 7 should work too. These modules are quite cheap, starting at about 3.50\u20ac for the NEO-6m.","title":"GPS-based NTP-server (Serial)"},{"location":"GPS-NTP-server/#features","text":"simplified NTP-Server sets system time automatically and Settings.latitude and Settings.longitude via command get position and time data can log postion data with timestamp to flash with a small memory footprint of only 12 Bytes per record (!!EXPERIMENTAL!!) constructs a GPX-file for download of this data Web-UI and console command interface","title":"Features:"},{"location":"GPS-NTP-server/#connecting-the-gps-device-to-a-wemos-d1-mini","text":"Wemos D1 Mini GPS VCC +3.3V Vin GND GND TX Rx RX Tx","title":"Connecting the GPS-device to a Wemos D1 mini"},{"location":"GPS-NTP-server/#tasmota-settings","text":"In the Configuration -> Configure Module page, select the following for Wemos D1 mini: 1. Module Type: 18 Generic 2. TX GPIO1 Serial Out: GPX_TX 3. RX GPIO3 Serial In: GPX_RX No further installation steps needed. To get more debug information compile it with option \"DEBUG_TASMOTA_SENSOR\". The driver expects the device to be configured for 9600 baud, which is the default for most of these sensors. If necessary the configuration can be changed with the freely available \"u-center\"-software, which is windows-only but is reported to run quite well with WINE and can be confirmed to work with CrossOver on macOs Catalina.","title":"Tasmota Settings"},{"location":"GPS-NTP-server/#ntp-server","text":"Simply start the server with 'sensor60 9'.","title":"NTP-Server"},{"location":"GPS-NTP-server/#flash-log","text":"This is highly experimental feature, which uses the OTA-partition to log position data. !! \u26a0\ufe0f FOR OBVIOUS REASONS THIS WILL SHORTEN THE LIFE OF THE FLASH MEMORY AND SHOULD BE USED WISELY \u26a0\ufe0f !! After the first recording, a download-link will appear in the web interface. By clicking on it, a GPX-file will be created on-the fly for download. All recorded data is lost after each OTA-update.","title":"Flash-Log"},{"location":"GPS-NTP-server/#commands","text":"sensor60 0 write to all available sectors, then restart and overwrite the older ones sensor60 1 write to all available sectors, then restart and overwrite the older ones sensor60 2 filter out horizontal drift noise sensor60 3 turn off noise filter sensor60 4 start recording, new data will be appended sensor60 5 start new recording, old data will lost sensor60 6 stop recording, download link will be visible in Web-UI sensor60 7 send mqtt on new postion + TELE -> consider to set TELE to a very high value sensor60 8 only TELE message sensor60 9 start NTP-Server sensor60 10 deactivate NTP-Server sensor60 11 force update of Tasmota-system-UTC with every new GPS-time-message sensor60 12 do NOT update of Tasmota-system-UTC with every new GPS-time-message sensor60 13 set latitude and longitude in settings sensor60 14 open virtual serial port over TCP, usable for u-center: tcp://ip-address:port (default port: 1234) !! \u26a0\ufe0f misconfiguration via u-center can virtually brick the device \u26a0\ufe0f !! sensor60 15 pause virtual serial port over TCP (connection stays active in the background)","title":"Commands:"},{"location":"Getting-Started/","text":"Prerequisites ~ Needed Hardware ~ ESP8266 or ESP8285 Device Any variation of the ESP8266 chip can be flashed with Tasmota. Serial-to-USB Adapter The power supplied to the device is one of the most important elements for both flashing the device and for stable operation. You must ensure that the device receives sufficient power (current AND appropriate voltage level) to properly flash the firmware on the device. CH340G is a reliable and very cheap adapter (example 1 , 2 ). FTDI FT232 - these adapters have a lot of fakes in the market so buy only from reliable sources ( example ). Buy only the variant with a separate 3.3V regulator on PCB! CP2102 or PL2303 - works with certain devices, but using an external 3.3V supply might be necessary. Not recommended for beginners! RaspberryPi - only for advanced users. External 3.3V supply necessary. NodeMCU and D1 mini (Pro/Lite) boards have a micro USB upload port and don't require an adapter. [!NOTE] Don't forget to install drivers for your serial-to-USB adapter. [!DANGER] Some adapters can be switched between 3.3V and 5V for the data pins, but still provide 5V on the power pin which will fry your device. You MUST make sure both the data and VCC pins are set for 3.3V. Soldering Tools To solder you'll of course need a soldering iron, soldering tin and some flux. If you're new to soldering check out some soldering tutorial videos while you're at it. If you're intimidated by soldering you could get away with holding the headers with jumper wires in the pin holes during flashing but it is not a fool proof process and flashing might fail. Jumper wires You could use any kind of wire but jumper wires (also called DuPont wires) are more practical than soldering and desoldering. Pin Headers Pin headers come in male or female version. Choose according to your jumper wire connectors. Computer with Linux, Windows or MacOS You need a computer with a USB port to upload the firmware to your device and configure it. Smartphone Tasmota installed from a precompiled binary needs to be configured to work with your Wi-Fi network before you can access the Tasmota web UI. This is usually done by connecting to a Tasmota Wi-Fi Access Point with your smartphone (or tablet or computer with Wi-Fi). Needed Software ~ Tasmota Firmware Binary Download a Tasmota firmware binary file (.bin). If you're not sure which binary is the right one for you just start with tasmota.bin or consult the builds table to see which features you need. Official release binaries can be downloaded from GitHub releases or from our OTA server . Latest development branch binaries are available only from our OTA server . The latest merged development code is compiled hourly. Flashing Tool Tasmotizer - NEW flashing and firmware download tool just for Tasmota. (Windows, Linux or Mac) Tasmota PyFlasher - flashing tool intended for Tasmota. (Windows or Mac) NodeMCU PyFlasher - easy to use GUI flasher based on esptool.py. (Windows or Mac) Esptool.py - the official flashing tool from Espressif. (Requires Python) Esptool executable - Esptool in executable form, no Python required. (Windows, Linux or Mac) Serial Terminal A program that connects to your Tasmota device directly over the serial connection you used to flash it. This is an optional way to configure your device using Commands and Backlog . Termite - simple terminal for windows Termie - open source clone of Termite Putty - popular client available on every platform Minicom - one of many Linux terminals [!TIP] Enable local echo so that you can see what is typed and transmitted to the device. Enable Append CR+LF since every request needs to end with <CR><LF> . MQTT Knowledge ~ Tasmota is designed to be controlled and communicate via MQTT . To use it to its fullest potential you need an MQTT broker . Read our article on MQTT to learn why it is essential in Tasmota. Compiling Tools (Optional) ~ If you want to modify the code or default settings and compile your own Tasmota firmware . Hardware Preparation ~ We need to connect to the serial programming interface of the ESP8266 chip. This is done by connecting our serial-to-USB converter TX and RX pins to the ESP8266 RX and TX pins and powering the chip with the 3.3V and GND pins. In most cases those pins are available on the PCB in the form of pin holes or solder pads but pin headers or jumper wires need to be soldered or otherwise applied. In some cases you will need to solder wires directly on the chip's pins which requires some experience and good soldering equipment. BEWARE! DO NOT CONNECT DEVICES TO MAINS POWER WHILE THE COVER IS OPEN AND CIRCUIT BOARD IS EXPOSED!!! NEVER TRY TO FLASH WHILE YOUR DEVICE IS CONNECTED TO MAINS POWER!!! YOU CAN BE ELECTROCUTED IF YOU DON'T KNOW WHAT YOU ARE DOING! If you are not careful, your own health will be in danger. Shorting your serial interface with mains AC power will fry your device and serial adapter and will also harm or destroy your computer. It is important to always have all mains power cables disconnected from the device while being connected via serial or even while the case of the device is opened. Serial Connection ~ Each device has its pins labelled differently. If the labelling isn't visible on the PCB please refer to the devices flashing guide or search the Internet for correct pin locations. Device specific instructions and restrictions are documented in the Tasmota Device Templates Repository When you have identified pins on your device, connect wires according to the table: Serial adapter ESP8266 device 3V3 3V3 or VCC TX RX RX TX GND GND Note that TX from your adapter goes to RX on the ESP8266 device and RX from adapter goes to TX on the device! Serial Connection using NODEMCU ESP8266 You can use the USB-to-serial adaptor of a NODEMCU (and probably other ESP8266 boards with a serial chip). You do not need to overwrite the existing firmware of your NODEMCU so it can be done using one already pre-installed with Tasmota - when you unplug and reset the NODEMCU it will revert to its previous state. Simply connect the EN pin to ground to prevent the ESP8266 chip on your NODEMCU from starting. Then connect as a normal USB-to-serial except connect TX to TX and RX to RX, ie no crossover required. NODEMCU ESP8266 device 3V3 3V3 or VCC RX RX TX TX GND GND Programming Mode ~ ESP8266 needs to be put into programming mode or flash mode before the firmware can be uploaded. This is done by pulling the GPIO0 pin to GND while the chip is booting. On most devices the installed control button is connected to GPIO0 and GND, making entering Programming Mode very easy. On others you will need to bridge the pins on the PCB or directly on the chip with a jumper wire. Device specific instructions are documented in Tasmota Device Templates Repository . To put the ESP8266 into Programming Mode: Disconnect serial-to-USB adapter and power Bridge GPIO0 and GND (by pressing the on-board button or connection with a wire) Connect the serial-to-USB adapter to your computer After a few seconds disconnect GPIO0 from GND (release button or remove the wire connection). On devices that do not provide the GPIO0 connected button, it may be easier to leave the wired bridge in place throughout the entire flashing process (erase & upload). Doing so will not create any problems. After the firmware is uploaded successfully, remove the bridge. This allows the device to boot normally. You can test whether your device is in Programming Mode by attempting to read information from the ESP82xx chip. This requires esptool.py . Instructions on installing and using esptool are provided below . For example ( COM5 will be your COM port): esptool.py -p COM5 read_mac (It should read the MAC address. It may fail afterwards during Uploading and running a \"stub\". This is normal.) esptool.py -p COM5 flash_id If everything went well, you are now in Programming Mode and ready to continue with flashing . If the flashing process is unable to start, disconnect the device and retry the steps. Common Mistakes ~ Wire connections and solder joints - Double check all connections and also check for solder overflow. Use a USB data cable - Some USB cables are for charging only and do not connect the data lines needed to load the firmware onto the device. Insufficient power delivered over the serial-to-USB adapter. This leads to flashing failures or corrupted flash altogether. Supply more power with a separate 3.3V power supply or get an adapter with a better power supply. Be sure all DC voltages use the same GND reference. Recheck your serial-to-USB adapter so to ensure that it supplies 3.3V voltage and NOT 5V . 5V will damage the ESP chip! Releasing GPIO0 button/wire before booting is finished - It is safe to leave GPIO0 connected to GND during the entire programming process (erase & upload). Just be sure to remove the GPIO0 to GND bridge before booting the device for regular operation. Make sure that the RX pin is connected to the TX pin between the serial adapter and your ESP device, and vice versa. Erase the flash memory first and cycle power afterwards before uploading the Tasmota firmware binary. Not erasing can leave behind remnants of the previous flash contents which can interfere with the new firmware operation. Flashing ~ If you have followed [Hardware preparation (#Hardware-Preparation), your device should be in Flash Mode and ready for a Tasmota firmware binary file to be flashed. For that you need a flashing tool . Tip You may want to back up the device manufacturer's firmware on the one in a million chance you don't like Tasmota. Tasmotizer! ~ Tasmotizer! is specifically designed for use with Tasmota with an easy to use GUI and esptool.py under the hood. Download the latest release for your platform. In Windows just double click the downloaded file and it'll start, no installation required. For python follow the installation instructions . Video tutorial by SuperHouseTV Note If you get an anti-virus infection warning don't fret, it is a known false positive . If you're still apprehensive you can always run the Python version. It is time to Tasmotize! Connect your device to the serial-to-USB adapter or plug in NodeMCU/D1 mini. Check whether the correct serial port (COM or tty port) is selected. Tasmotizer! will try its best to select the right one for you. Choose Tasmota firmware binary: BIN file - browse to the Tasmota firmware binary you downloaded or compiled. Release - select from a list of available release binaries Development - select from a list of latest development binaries optional Backup the original device firmware Erase flash Danger Leave Erase before flashing checked if it is the first time flashing Tasmota on the device or you're experiencing issues with the existing flash and need to do a full erase. If you're upgrading an already flashed Tasmota and wish to keep your settings, uncheck Erase before flashing . Click Tasmotize and wait until done. If the flash was successful it will display: Unplug your serial programming adapter or device and plug it back in or connect to another power source. You can use Send Config Tasmotizer! button for the initial configuration of your device instead of webUI. esptool.py ~ Esptool is the official Espressif tool for flashing ESP8266 chips. It requires Python, if you do not have an installed copy of Python 2.x or 3.x download and install it from https://www.python.org. Download the esptool Source code to a folder of your choice. Go to the folder and install Esptool with command python setup.py install Upload Tasmota Make sure you followed the steps to put your device in flash mode. Place your chosen firmware binary file in the same folder as esptool.py. Esptool uses the serial interface to communicate with your device. On Windows these interfaces are named COM1, COM2, etc. and on Linux they are named /dev/ttyUSB0, /dev/ttyUSB1, etc. Before using esptool, make sure you know which serial port your programming adapter is connected to. The following use COM5 as an example. Change COM5 with your serial port designation. Ensure the device is in flash mode before each step. Backup Firmware (optional step) Backup the current firmware with the following command: esptool.py --port COM5 read_flash 0x00000 0x100000 fwbackup.bin When the command completes the device is not in flash mode anymore. Repeat the process of putting your device in programming mode. Erase Flash Memory Erase the complete flash memory holding the firmware with the following command: esptool.py --port COM5 erase_flash It only takes a few seconds to erase 1M of flash. When the command completes the device is not in flash mode anymore. Repeat the process of putting your device in programming mode. Upload Firmware Load the chosen Tasmota firmware file with the following command (e.g., tasmota.bin in this example): esptool.py --port COM5 write_flash -fs 1MB -fm dout 0x0 tasmota.bin Unplug your serial programming adapter or your device and plug it back in or connect to another power source. Your device is now ready for Initial configuration . For proper device initialization after the firmware upload completes, power down and power up the device. Esptool Executable ~ The executable version of esptool is maintained by Ivan Grokhotkov and releases are kept at https://github.com/igrr/esptool-ck/releases . Supports Linux, Linux ARM, Windows 32-bit and Mac First Step For the purpose of simplicity only the Windows version will be explained here, but the commands and parameters are the same for Windows, Linux and Mac. Download the latest release of Esptool-CK and extract the compressed file to a folder of your choice. Place your chosen firmware binary file (e.g., tasmota.bin in the example below) in the same folder as Esptool-CK to simplify the process. The following commands use COM5 as an example. Change COM5 with your port designation. Ensure the device is in flash mode before each step. Erase Flash Memory esptool -cp COM5 -ce -v Upload firmware Once the erase is complete, put device back into programming mode and upload the firmware esptool -cp COM5 -bm dout -cf tasmota.bin -v Unplug your serial programming adapter or your device and plug it back in or connect to another power source. Your device is now ready for Initial configuration . For proper device initialization after the firmware upload completes, power down and power up the device. OTA Conversion Tasmota is NOT a developer of these tools. For help and troubleshooting you will need to get support from those projects . Tuya-Convert - easy OTA flash for devices with Tuya chips, no disassembly required Sonoff DIY - OTA flash for select Sonoff devices (some disassembly required) You've successfully flashed your device with a downloaded binary of Tasmota but now you need to connect the tasmotised device to your Wi-Fi network. Initial Configuration ~ Using Web UI ~ Configure Wi-Fi Tasmota provides a wireless access point for easy Wi-Fi configuration. If you flashed using Tuya Convert this is the only option to set up your device. Connect your device to a power source and grab your smartphone (or tablet or laptop or any other web and Wi-Fi capable device). Search for a Wi-Fi AP named tasmota-xxxx (where xxxx is a number) and connect to it. In this example the Wi-Fi AP is named tasmota-7718 . When it connects to the network, you may get a warning that there is no Internet connection and be prompted to connect to a different network. Do not allow the mobile device to select a different network . Warning Wi-Fi manager server is active for only 3 minutes. If you miss the window you might have to disconnect your device from power and reconnect. After you have connected to the Tasmota Wi-Fi AP, open http://192.168.4.1 in a web browser on the smartphone (or whatever device you used). Depending on the phone, it will take you to the Tasmota configuration page automatically, or you will get a prompt to sign in to Wi-Fi network or authorize . Tapping on the AP name should also open the configuration page. At this page you can have Tasmota scan for available Wi-Fi networks. Select the right network from the list or enter the following: AP1 SSid - your Wi-Fi network name SSID's are case sensitive AP1 Password - password for your Wi-Fi AP Wi-Fi password has to be under 32 characters and without special characters (e.g. asterisks) or white spaces Recommended: AP2 SSid - alternative Wi-Fi network SSID AP2 Password - password for your alternative Wi-Fi AP Click the checkbox to see the password you enter to ensure that it is correct and that your mobile device has not inadvertently capitalized the first letter if it is supposed to be lower case nor autocorrected what you entered. ~~Double~~ Triple check the Wi-Fi credentials and click on Save to apply the settings. The device will restart and connect to your home network. The tasmota-xxxx network will not longer be present. Therefore your smartphone will automatically be disconnected and should connect back to its data network. Tip If you're not using a second Wi-Fi network you can enter an SSID without a password you can connect to as a backup in case something went wrong with your Wi-Fi credentials. Configure MQTT Look in your router for a newly connected device with the same name as the Wi-Fi access point. (In this example * tasmota-7718* .) If you don't have access to your router you can find your newly flashed device with an IP scanner: Fing - for Android or iOS Angry IP Scanner - open source for Linux, Windows and Mac. Requires Java. Super Scan - Windows only too (free) Tasmota Device Locator - Browser-based Open the IP address with your web browser and you have full access to Tasmota. Now is the time to set up MQTT and the last remaining, but equally important, step: Configure Template or Module Configure your device using Templates in Configuration - Configure Template or Modules in Configuration - Configure Module . Your device running Tasmota is now ready to be controlled . Using Serial Terminal ~ If you flashed the device using serial-to-USB adapter (or it is a NodeMCU/D1 mini) you can take advantage of the existing connection and configure your device over the serial connection using Commands . First you will need a Serial Terminal program. In this example Termite on Windows is used. Download Termite and extract the .exe file, no installation necessary. Connect your serial-to-USB adapter or NodeMCU/D1 mini to the computer. Open Termite and set it to the proper COM port ( Termite selects the first available port by default ). Set Baud rate to 115200 and Forward to none. Connect your device to the serial-to-USB adapter. You should see the initial boot output in Termite. If your screen is empty type status in the bottom command bar and hit enter. If you get a return message from your device similar to the one displayed under purple status you're all set. To configure Tasmota you need to issue commands, some commands will reboot your device and to avoid that we will use the Backlog command feature. Configure your Wi-Fi network and a secondary Wi-Fi network Backlog ssid1 <yourssid>; password1 <your_password>; ssid2 <your_ssid2>; password2 <your_password> Device will restart and connect to your network. It will display your devices newly assigned IP. Direct your web browser to that IP address to access the Web UI for further configuration and contol. Configure MQTT broker address, MQTT credentials, unique device topic and OTA url to the latest official release Backlog mqtthost <yourhost>; mqttuser <user>; mqttpassword <password>; topic <unique_topic>; otaurl http://thehackbox.org/tasmota/release/tasmota.bin Tip Keep your personal configuration in a text file and simply copy and paste the backlog commands to a newly flashed device. Commands and Backlog are powerful and in time you can learn to configure almost everything (NTP servers, longitude and latitude, custom device options, etc) with a few copy and paste moves. Your device is connected to your network and to the MQTT broker. One last thing to do is configure your device using Templates in Configuration - Configure Template or Modules in Configuration - Configure Module . Check out all the supported devices in Tasmota Device Templates Repository","title":"Getting Started"},{"location":"Getting-Started/#prerequisites","text":"","title":"Prerequisites"},{"location":"Getting-Started/#needed-hardware","text":"","title":"Needed Hardware"},{"location":"Getting-Started/#needed-software","text":"","title":"Needed Software"},{"location":"Getting-Started/#mqtt-knowledge","text":"Tasmota is designed to be controlled and communicate via MQTT . To use it to its fullest potential you need an MQTT broker . Read our article on MQTT to learn why it is essential in Tasmota.","title":"MQTT Knowledge"},{"location":"Getting-Started/#compiling-tools-optional","text":"If you want to modify the code or default settings and compile your own Tasmota firmware .","title":"Compiling Tools (Optional)"},{"location":"Getting-Started/#hardware-preparation","text":"We need to connect to the serial programming interface of the ESP8266 chip. This is done by connecting our serial-to-USB converter TX and RX pins to the ESP8266 RX and TX pins and powering the chip with the 3.3V and GND pins. In most cases those pins are available on the PCB in the form of pin holes or solder pads but pin headers or jumper wires need to be soldered or otherwise applied. In some cases you will need to solder wires directly on the chip's pins which requires some experience and good soldering equipment. BEWARE! DO NOT CONNECT DEVICES TO MAINS POWER WHILE THE COVER IS OPEN AND CIRCUIT BOARD IS EXPOSED!!! NEVER TRY TO FLASH WHILE YOUR DEVICE IS CONNECTED TO MAINS POWER!!! YOU CAN BE ELECTROCUTED IF YOU DON'T KNOW WHAT YOU ARE DOING! If you are not careful, your own health will be in danger. Shorting your serial interface with mains AC power will fry your device and serial adapter and will also harm or destroy your computer. It is important to always have all mains power cables disconnected from the device while being connected via serial or even while the case of the device is opened.","title":"Hardware Preparation"},{"location":"Getting-Started/#serial-connection","text":"Each device has its pins labelled differently. If the labelling isn't visible on the PCB please refer to the devices flashing guide or search the Internet for correct pin locations. Device specific instructions and restrictions are documented in the Tasmota Device Templates Repository When you have identified pins on your device, connect wires according to the table: Serial adapter ESP8266 device 3V3 3V3 or VCC TX RX RX TX GND GND Note that TX from your adapter goes to RX on the ESP8266 device and RX from adapter goes to TX on the device!","title":"Serial Connection"},{"location":"Getting-Started/#programming-mode","text":"ESP8266 needs to be put into programming mode or flash mode before the firmware can be uploaded. This is done by pulling the GPIO0 pin to GND while the chip is booting. On most devices the installed control button is connected to GPIO0 and GND, making entering Programming Mode very easy. On others you will need to bridge the pins on the PCB or directly on the chip with a jumper wire. Device specific instructions are documented in Tasmota Device Templates Repository . To put the ESP8266 into Programming Mode: Disconnect serial-to-USB adapter and power Bridge GPIO0 and GND (by pressing the on-board button or connection with a wire) Connect the serial-to-USB adapter to your computer After a few seconds disconnect GPIO0 from GND (release button or remove the wire connection). On devices that do not provide the GPIO0 connected button, it may be easier to leave the wired bridge in place throughout the entire flashing process (erase & upload). Doing so will not create any problems. After the firmware is uploaded successfully, remove the bridge. This allows the device to boot normally. You can test whether your device is in Programming Mode by attempting to read information from the ESP82xx chip. This requires esptool.py . Instructions on installing and using esptool are provided below . For example ( COM5 will be your COM port): esptool.py -p COM5 read_mac (It should read the MAC address. It may fail afterwards during Uploading and running a \"stub\". This is normal.) esptool.py -p COM5 flash_id If everything went well, you are now in Programming Mode and ready to continue with flashing . If the flashing process is unable to start, disconnect the device and retry the steps.","title":"Programming Mode"},{"location":"Getting-Started/#common-mistakes","text":"Wire connections and solder joints - Double check all connections and also check for solder overflow. Use a USB data cable - Some USB cables are for charging only and do not connect the data lines needed to load the firmware onto the device. Insufficient power delivered over the serial-to-USB adapter. This leads to flashing failures or corrupted flash altogether. Supply more power with a separate 3.3V power supply or get an adapter with a better power supply. Be sure all DC voltages use the same GND reference. Recheck your serial-to-USB adapter so to ensure that it supplies 3.3V voltage and NOT 5V . 5V will damage the ESP chip! Releasing GPIO0 button/wire before booting is finished - It is safe to leave GPIO0 connected to GND during the entire programming process (erase & upload). Just be sure to remove the GPIO0 to GND bridge before booting the device for regular operation. Make sure that the RX pin is connected to the TX pin between the serial adapter and your ESP device, and vice versa. Erase the flash memory first and cycle power afterwards before uploading the Tasmota firmware binary. Not erasing can leave behind remnants of the previous flash contents which can interfere with the new firmware operation.","title":"Common Mistakes"},{"location":"Getting-Started/#flashing","text":"If you have followed [Hardware preparation (#Hardware-Preparation), your device should be in Flash Mode and ready for a Tasmota firmware binary file to be flashed. For that you need a flashing tool . Tip You may want to back up the device manufacturer's firmware on the one in a million chance you don't like Tasmota.","title":"Flashing"},{"location":"Getting-Started/#tasmotizer","text":"Tasmotizer! is specifically designed for use with Tasmota with an easy to use GUI and esptool.py under the hood. Download the latest release for your platform. In Windows just double click the downloaded file and it'll start, no installation required. For python follow the installation instructions . Video tutorial by SuperHouseTV Note If you get an anti-virus infection warning don't fret, it is a known false positive . If you're still apprehensive you can always run the Python version. It is time to Tasmotize! Connect your device to the serial-to-USB adapter or plug in NodeMCU/D1 mini. Check whether the correct serial port (COM or tty port) is selected. Tasmotizer! will try its best to select the right one for you. Choose Tasmota firmware binary: BIN file - browse to the Tasmota firmware binary you downloaded or compiled. Release - select from a list of available release binaries Development - select from a list of latest development binaries optional Backup the original device firmware Erase flash Danger Leave Erase before flashing checked if it is the first time flashing Tasmota on the device or you're experiencing issues with the existing flash and need to do a full erase. If you're upgrading an already flashed Tasmota and wish to keep your settings, uncheck Erase before flashing . Click Tasmotize and wait until done. If the flash was successful it will display: Unplug your serial programming adapter or device and plug it back in or connect to another power source. You can use Send Config Tasmotizer! button for the initial configuration of your device instead of webUI.","title":"Tasmotizer!"},{"location":"Getting-Started/#esptoolpy","text":"Esptool is the official Espressif tool for flashing ESP8266 chips. It requires Python, if you do not have an installed copy of Python 2.x or 3.x download and install it from https://www.python.org. Download the esptool Source code to a folder of your choice. Go to the folder and install Esptool with command python setup.py install","title":"esptool.py"},{"location":"Getting-Started/#esptool-executable","text":"The executable version of esptool is maintained by Ivan Grokhotkov and releases are kept at https://github.com/igrr/esptool-ck/releases . Supports Linux, Linux ARM, Windows 32-bit and Mac","title":"Esptool Executable"},{"location":"Getting-Started/#initial-configuration","text":"","title":"Initial Configuration"},{"location":"Getting-Started/#using-web-ui","text":"","title":"Using Web UI"},{"location":"Getting-Started/#using-serial-terminal","text":"If you flashed the device using serial-to-USB adapter (or it is a NodeMCU/D1 mini) you can take advantage of the existing connection and configure your device over the serial connection using Commands . First you will need a Serial Terminal program. In this example Termite on Windows is used. Download Termite and extract the .exe file, no installation necessary. Connect your serial-to-USB adapter or NodeMCU/D1 mini to the computer. Open Termite and set it to the proper COM port ( Termite selects the first available port by default ). Set Baud rate to 115200 and Forward to none. Connect your device to the serial-to-USB adapter. You should see the initial boot output in Termite. If your screen is empty type status in the bottom command bar and hit enter. If you get a return message from your device similar to the one displayed under purple status you're all set. To configure Tasmota you need to issue commands, some commands will reboot your device and to avoid that we will use the Backlog command feature. Configure your Wi-Fi network and a secondary Wi-Fi network Backlog ssid1 <yourssid>; password1 <your_password>; ssid2 <your_ssid2>; password2 <your_password> Device will restart and connect to your network. It will display your devices newly assigned IP. Direct your web browser to that IP address to access the Web UI for further configuration and contol. Configure MQTT broker address, MQTT credentials, unique device topic and OTA url to the latest official release Backlog mqtthost <yourhost>; mqttuser <user>; mqttpassword <password>; topic <unique_topic>; otaurl http://thehackbox.org/tasmota/release/tasmota.bin Tip Keep your personal configuration in a text file and simply copy and paste the backlog commands to a newly flashed device. Commands and Backlog are powerful and in time you can learn to configure almost everything (NTP servers, longitude and latitude, custom device options, etc) with a few copy and paste moves. Your device is connected to your network and to the MQTT broker. One last thing to do is configure your device using Templates in Configuration - Configure Template or Modules in Configuration - Configure Module . Check out all the supported devices in Tasmota Device Templates Repository","title":"Using Serial Terminal"},{"location":"Gitpod/","text":"Even though Tasmota offers several pre-compiled firmware variants, sometimes the ready-to-flash binaries aren't enough. If you need to enable or disable some features, or simply change some parameters, then you need to compile a firmware binary yourself. If you are not experienced enough or don't want to install an IDE (Integrated Development Environment) like PlatformIO or Arduino-IDE on your computer, compiling your own firmware is a breeze using Gitpod . Gitpod is a web browser based online IDE. All you need to use it is to link your GitHub account (or make a new one here ). Gitpod will take care of all the necessary software package dependencies for you. After you successfully sign in, you can start your personal project. The fastest way to load Tasmota into Gitpod is with one of the following links: - Development Branch: https://gitpod.io#https://github.com/arendst/Tasmota/tree/development - Master Release: https://gitpod.io#https://github.com/arendst/Tasmota/tree/master - TasmoCompiler : https://gitpod.io/#https://github.com/benzino77/tasmocompiler Browser Extension Gitpod has a browser extension (Chrome and Firefox) which is handy to directly load a GitHub project into your personal Gitpod work-space. More information on the Gitpod browser extension . Using Gitpod ~ After Gitpod loads the project, you will be greeted by the main window. Gitpod will then automatically compile tasmota.bin . Wait for the compilation to complete. The display consists of three panels: 1. Explorer 2. Editor 3. Terminal Customize Firmware Features and Settings ~ ATTENTION: The proper method of customizing firmware compilation options is to use the user_config_override.h file. Most customizations should not require changes to the my_user_config.h file. To modify the stock configuration: 1. Select the /tasmota folder in the Explorer (1) pane 2. Create a new file called user_config_override.h 3. In the Editor (2) pane, add, change, or remove anything you need in your configuration file to define your own settings. Refer to the user_config_override_sample.h file as well as my_user_config.h for #define options ( sample ). You can find a list of Tasmota features and settings listed here . Define the features you require in your configuration file. 4. Click 'File' on the menu bar and 'Save' your edits. Prepare the IDE for Compilation ~ Open the platformio.ini file located in the /tasmota root directory (scroll to the bottom of the file Explorer (1) pane). In this file, removing a leading semicolon ; enables a statement. In the Editor (2) pane: If you are using your own user_config_override.h , you must tell the compiler to use it. Rename platformio_override_sample.ini to platformio_override.ini . This enables -DUSE_CONFIG_OVERRIDE . By default, the 2.6.1 Core will be compiled. If you wish to use a different Core, find the [core_active] section in the file and enable the platform and build_flags lines for the desired Core. Then click 'File' on the menu bar and 'Save' your edits. Compile Your Firmware ~ This action is done in the Terminal pane (3) with very simple commands. The simplest one is platformio run -e tasmota . With this command, Gitpod will compile the Tasmota firmware with the features you selected. If you need a different variant, you can specify this option on the command line: platformio run -e <variant-name> Examples: - platformio run -e tasmota-sensors - platformio run -e tasmota-DE Compilation normally takes only a couple of minutes. The time if takes is directly related to the configurations you selected; the more features selected means more time is needed to compile. When done, you will find a firmware file named firmware.bin in the /Tasmota/.pioenvs/<variant-name>/ folder in the Explorer (1) pane. Download firmware.bin to your computer by right-clicking on the file and selecting 'Download'. You are now ready to flash your device. Watch a livestream video by digiblurDIY of compiling Tasmota using Gitpod. Flash Your Device ~ OTA Flash If you already have Tasmota flashed on your device, you can use the File Upload OTA method to load the new firmware binary file. 1. Download tasmota-minimal.bin 2. Make a backup of the device configuration using the web UI Configuration menu option. 3. Upload tasmota-minimal.bin to your device using the web UI Firmware Upgrade selection. Choose Upgrade by file upload . 3. After tasmota-minimal.bin is successfully loaded, select Firmware Upgrade once again and upload the firmware file compiled using Gitpod. Serial Flash Follow the same procedure for flashing as you would any new device.","title":"Gitpod"},{"location":"Gitpod/#using-gitpod","text":"After Gitpod loads the project, you will be greeted by the main window. Gitpod will then automatically compile tasmota.bin . Wait for the compilation to complete. The display consists of three panels: 1. Explorer 2. Editor 3. Terminal","title":"Using Gitpod"},{"location":"Gitpod/#customize-firmware-features-and-settings","text":"ATTENTION: The proper method of customizing firmware compilation options is to use the user_config_override.h file. Most customizations should not require changes to the my_user_config.h file. To modify the stock configuration: 1. Select the /tasmota folder in the Explorer (1) pane 2. Create a new file called user_config_override.h 3. In the Editor (2) pane, add, change, or remove anything you need in your configuration file to define your own settings. Refer to the user_config_override_sample.h file as well as my_user_config.h for #define options ( sample ). You can find a list of Tasmota features and settings listed here . Define the features you require in your configuration file. 4. Click 'File' on the menu bar and 'Save' your edits.","title":"Customize Firmware Features and Settings"},{"location":"Gitpod/#prepare-the-ide-for-compilation","text":"Open the platformio.ini file located in the /tasmota root directory (scroll to the bottom of the file Explorer (1) pane). In this file, removing a leading semicolon ; enables a statement. In the Editor (2) pane: If you are using your own user_config_override.h , you must tell the compiler to use it. Rename platformio_override_sample.ini to platformio_override.ini . This enables -DUSE_CONFIG_OVERRIDE . By default, the 2.6.1 Core will be compiled. If you wish to use a different Core, find the [core_active] section in the file and enable the platform and build_flags lines for the desired Core. Then click 'File' on the menu bar and 'Save' your edits.","title":"Prepare the IDE for Compilation"},{"location":"Gitpod/#compile-your-firmware","text":"This action is done in the Terminal pane (3) with very simple commands. The simplest one is platformio run -e tasmota . With this command, Gitpod will compile the Tasmota firmware with the features you selected. If you need a different variant, you can specify this option on the command line: platformio run -e <variant-name> Examples: - platformio run -e tasmota-sensors - platformio run -e tasmota-DE Compilation normally takes only a couple of minutes. The time if takes is directly related to the configurations you selected; the more features selected means more time is needed to compile. When done, you will find a firmware file named firmware.bin in the /Tasmota/.pioenvs/<variant-name>/ folder in the Explorer (1) pane. Download firmware.bin to your computer by right-clicking on the file and selecting 'Download'. You are now ready to flash your device. Watch a livestream video by digiblurDIY of compiling Tasmota using Gitpod.","title":"Compile Your Firmware"},{"location":"Gitpod/#flash-your-device","text":"","title":"Flash Your Device"},{"location":"HC-SR04/","text":"!> This feature is included only in tasmota-sensors.bin HC-SR04 (HC-SR04P and JSN-SR04T) is an ultrasonic ranging sensor. Provides 2cm to 400cm of non-contact measurement functionality with a ranging accuracy that can reach up to 3mm. Each HC-SR04 module includes an ultrasonic transmitter, a receiver and a control circuit. See HC-SR04 Ultrasonic Sensor for more information. Buy example: - AliExpress - Sparkfun Configuration ~ Wiring ~ HC-SR04 ESP8266 Vcc 5V GND GND Trig GPIOx Echo use voltage divider! GPIOy The HC-SR04 operates at 5V and therefore the echo signal will be 5V as well. Connecting the echo pin via a voltage divider (see schematic) will divide the 5V to 3.3V, which is the operating voltage of an ESP8266. There is a variant of the HC-SR04, called HC-SR04P. It mainly operates at 3.3V and then it doesn't need the voltage divider but you will notice a range drop of about 1 meter. Tasmota Settings ~ In the Configuration -> Configure Module page assign: 1. GPIOx to SR04 Tri (69) 2. GPIOy to SR04 Ech (70) Tasmota Main ~ After a reboot webUI displays the HC-SR04 distance. Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2019-01-01T22:42:35\" , \"SR04\" :{ \"Distance\" : 16.754 }}","title":"HC SR04"},{"location":"HC-SR04/#configuration","text":"","title":"Configuration"},{"location":"HC-SR04/#wiring","text":"HC-SR04 ESP8266 Vcc 5V GND GND Trig GPIOx Echo use voltage divider! GPIOy The HC-SR04 operates at 5V and therefore the echo signal will be 5V as well. Connecting the echo pin via a voltage divider (see schematic) will divide the 5V to 3.3V, which is the operating voltage of an ESP8266. There is a variant of the HC-SR04, called HC-SR04P. It mainly operates at 3.3V and then it doesn't need the voltage divider but you will notice a range drop of about 1 meter.","title":"Wiring"},{"location":"HC-SR04/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: 1. GPIOx to SR04 Tri (69) 2. GPIOy to SR04 Ech (70)","title":"Tasmota Settings"},{"location":"HC-SR04/#tasmota-main","text":"After a reboot webUI displays the HC-SR04 distance. Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2019-01-01T22:42:35\" , \"SR04\" :{ \"Distance\" : 16.754 }}","title":"Tasmota Main"},{"location":"HM-10/","text":"This feature is included only in tasmota-sensors.bin Otherwise you must compile your build . Add the following to user_config_override.h : #ifndef USE_HM10 #define USE_HM10 // Add support BLE sensor bridge (+5k1 code) #endif #ifndef USE_IBEACON #define USE_IBEACON // Add support for bluetooth LE passive scan of ibeacon devices #endif HM-10 is a Bluetooth BLE V4.0 module based on TI CC254x chip. Originally manufactured by Jinan Huamao but there are many clones in the market ( MLT-BT05, CC41-A , JDY-08 , AT-09, ...) While they look similar and utilize the same CC254x Bluetooth chip, the firmware on them is different. In order to get any type of module to work work Tasmota it is mandatory to flash the original firmware on it . Use the newest V707 firmware but at least V609 is required to work with the Tasmota driver. Tip It is possible to do this without soldering by directly sticking male jumper wire connectors through the plastic foil on some boards or using some removable adhesives (bluetack). Configuration ~ Check whether your module is communicating properly over its TX/RX pins and that it has the required firmware (preferably HMSoft V707 ). Only when you're sure everything is ok proceed with the configuration. Wiring ~ HM-10 ESP8266 GND GND VCC 3.3V TX GPIOx RX GPIOy Tasmota Settings for BLE sensors ~ In the Configuration -> Configure Module page assign: 1. GPIOx to HM10 TX (195) 2. GPIOy to HM10 RX (194) If you have the proper firmware webUI should show (in this case V707 is the fflashed firmware version): If you have supported Bluetooth devices in range, they will soon be discovered and start to populate the webUI with data as it is transmitted: [!WARNING] Most of the self-flashed modules will still have their factory default settings with baud rate of 9600 but Tasmota requires 115200. To fix try commands from Tasmota console: HM10Baud 9600 then HM10AT RENEW and reboot Tasmota. If that doesn't solve it you will have to connect to the HM-10 with serial-to-USB adapter and set the baudrate in a terminal using commands AT+RENEW then AT+BAUD? . If the output is 4 baudrate is properly set to 115200, if not use AT+BAUD4 For a complete overview of supported devices, commands and features read the Bluetooth article Tasmota Settings for iBeacon ~ In the Configuration -> Configure Module page assign: 1. GPIOx to iBeacon TX (168) 2. GPIOy to iBeacon RX (169) When first connected HM-10 is in peripheral mode. You have to change it to central mode using commands Sensor52 1 and Sensor52 2 . If you have supported iBeacon Bluetooth devices in range, they will be discovered and will start to populate the webUI with data: For a complete overview of supported devices, commands and features read the Bluetooth article Breakout Boards ~","title":"HM 10"},{"location":"HM-10/#configuration","text":"Check whether your module is communicating properly over its TX/RX pins and that it has the required firmware (preferably HMSoft V707 ). Only when you're sure everything is ok proceed with the configuration.","title":"Configuration"},{"location":"HM-10/#wiring","text":"HM-10 ESP8266 GND GND VCC 3.3V TX GPIOx RX GPIOy","title":"Wiring"},{"location":"HM-10/#tasmota-settings-for-ble-sensors","text":"In the Configuration -> Configure Module page assign: 1. GPIOx to HM10 TX (195) 2. GPIOy to HM10 RX (194) If you have the proper firmware webUI should show (in this case V707 is the fflashed firmware version): If you have supported Bluetooth devices in range, they will soon be discovered and start to populate the webUI with data as it is transmitted: [!WARNING] Most of the self-flashed modules will still have their factory default settings with baud rate of 9600 but Tasmota requires 115200. To fix try commands from Tasmota console: HM10Baud 9600 then HM10AT RENEW and reboot Tasmota. If that doesn't solve it you will have to connect to the HM-10 with serial-to-USB adapter and set the baudrate in a terminal using commands AT+RENEW then AT+BAUD? . If the output is 4 baudrate is properly set to 115200, if not use AT+BAUD4 For a complete overview of supported devices, commands and features read the Bluetooth article","title":"Tasmota Settings for BLE sensors"},{"location":"HM-10/#tasmota-settings-for-ibeacon","text":"In the Configuration -> Configure Module page assign: 1. GPIOx to iBeacon TX (168) 2. GPIOy to iBeacon RX (169) When first connected HM-10 is in peripheral mode. You have to change it to central mode using commands Sensor52 1 and Sensor52 2 . If you have supported iBeacon Bluetooth devices in range, they will be discovered and will start to populate the webUI with data: For a complete overview of supported devices, commands and features read the Bluetooth article","title":"Tasmota Settings for iBeacon"},{"location":"HM-10/#breakout-boards","text":"","title":"Breakout Boards"},{"location":"HM-17/","text":"This feature is included only in tasmota-sensors.bin Otherwise you must compile your build . Add the following to user_config_override.h : #ifndef USE_IBEACON #define USE_IBEACON // Add support for bluetooth LE passive scan of ibeacon devices #endif HM-17 and HM-16 are a Bluetooth BLE V4.1 module based on TI CC2640R2f chip. Manufactured by Jinan Huamao Configuration ~ Check whether your module is communicating properly over its TX/RX pins and that it has the required firmware (firmware V120 or V110). Only when you're sure everything is ok proceed with the configuration. Wiring ~ HM-16/17 ESP8266 GND GND VCC 3.3V TX GPIOx RX GPIOy Tasmota Settings for iBeacon ~ In the Configuration -> Configure Module page assign: 1. GPIOx to iBeacon TX (168) 2. GPIOy to iBeacon RX (169) When first connected HM-16/17 is in peripheral mode. You have to change it to central mode using commands Sensor52 1 and Sensor52 2 . If you have supported iBeacon Bluetooth devices in range, they will be discovered and will start to populate the webUI with data: For a complete overview of supported devices, commands and features read the Bluetooth article Breakout Boards ~","title":"HM 17"},{"location":"HM-17/#configuration","text":"Check whether your module is communicating properly over its TX/RX pins and that it has the required firmware (firmware V120 or V110). Only when you're sure everything is ok proceed with the configuration.","title":"Configuration"},{"location":"HM-17/#wiring","text":"HM-16/17 ESP8266 GND GND VCC 3.3V TX GPIOx RX GPIOy","title":"Wiring"},{"location":"HM-17/#tasmota-settings-for-ibeacon","text":"In the Configuration -> Configure Module page assign: 1. GPIOx to iBeacon TX (168) 2. GPIOy to iBeacon RX (169) When first connected HM-16/17 is in peripheral mode. You have to change it to central mode using commands Sensor52 1 and Sensor52 2 . If you have supported iBeacon Bluetooth devices in range, they will be discovered and will start to populate the webUI with data: For a complete overview of supported devices, commands and features read the Bluetooth article","title":"Tasmota Settings for iBeacon"},{"location":"HM-17/#breakout-boards","text":"","title":"Breakout Boards"},{"location":"Hardware-Preparation/","text":"You've followed Prerequisites and got everything you need. Now you have to prepare your device for flashing. We need to connect to the serial programming interface of the ESP8266 chip. This is done by connecting our serial-to-USB converter TX and RX pins to the ESP8266 RX and TX pins and powering the chip with the 3.3V and GND pins. In most cases those pins are available on the PCB in the form of pin holes or solder pads but pin headers or jumper wires need to be soldered or otherwise applied. In some cases you will need to solder wires directly on the chip's pins which requires some experience and good soldering equipment. [!WARNING|style:flat|label:DANGER] DO NOT CONNECT DEVICES TO MAINS POWER WHILE THE COVER IS OPEN AND CIRCUIT BOARD IS EXPOSED!!! NEVER TRY TO FLASH WHILE YOUR DEVICE IS CONNECTED TO MAINS POWER!!! YOU CAN BE ELECTROCUTED IF YOU DON'T KNOW WHAT YOU ARE DOING! If you are not careful, your own health will be in danger. Shorting your serial interface with mains AC power will fry your device and serial adapter and will also harm or destroy your computer. It is important to always have all mains power cables disconnected from the device while being connected via serial or even while the case of the device is opened. Serial Connection ~ Each device has its pins labelled differently. If the labelling isn't visible on the PCB please refer to the devices flashing guide or search the Internet for correct pin locations. Device specific instructions and restrictions are documented in the Tasmota Device Templates Repository When you have identified pins on your device, connect wires according to the table: Serial adapter ESP8266 device 3V3 3V3 or VCC TX RX RX TX GND GND Note that TX from your adapter goes to RX on the ESP8266 device and RX from adapter goes to TX on the device! Serial Connection using NODEMCU ESP8266 ~ You can use the USB-to-serial adaptor of a NODEMCU (and probably other ESP8266 boards with a serial chip). You do not need to overwrite the existing firmware of your NODEMCU so it can be done using one already pre-installed with Tasmota - when you unplug and reset the NODEMCU it will revert to its previous state. Simply connect the EN pin to ground to prevent the ESP8266 chip on your NODEMCU from starting. Then connect as a normal USB-to-serial except connect TX to TX and RX to RX, ie no crossover required. NODEMCU ESP8266 device 3V3 3V3 or VCC RX RX TX TX GND GND Programming Mode ~ ESP8266 needs to be put into Programming Mode before the firmware can be uploaded. This is done by pulling the GPIO0 pin to GND while the chip is booting. On most devices the installed control button is connected to GPIO0 and GND, making entering Programming Mode very easy. On others you will need to bridge the pins on the PCB or directly on the chip with a jumper wire. Device specific instructions are documented in Tasmota Device Templates Repository . To put the ESP8266 into Programming Mode: Disconnect serial-to-USB adapter and power Bridge GPIO0 and GND (by pressing the on-board button or connection with a wire) Connect the serial-to-USB adapter to your computer After a few seconds disconnect GPIO0 from GND (release button or remove the wire connection). On devices that do not provide the GPIO0 connected button, it may be easier to leave the wired bridge in place throughout the entire flashing process (erase & upload). Doing so will not create any problems. After the firmware is uploaded successfully, remove the bridge. This allows the device to boot normally. You can test whether your device is in Programming Mode by attempting to read information from the ESP82xx chip. This requires esptool.py . Instructions on installing and using esptool are provided in the Flashing article . For example ( COM5 will be your COM port): - esptool.py -p COM5 read_mac (It should read the MAC address. It may fail afterwards during Uploading and running a \"stub\". This is normal.) - esptool.py -p COM5 flash_id If everything went well, you are now in Programming Mode and ready to continue with flashing . If the flashing process is unable to start, disconnect the device and retry the steps. Common Mistakes ~ Wire connections and solder joints - Double check all connections and also check for solder overflow. Use a USB data cable - Some USB cables are for charging only and do not connect the data lines needed to load the firmware onto the device. Insufficient power delivered over the serial-to-USB adapter. This leads to flashing failures or corrupted flash altogether. Supply more power with a separate 3.3V power supply or get an adapter with a better power supply. Be sure all DC voltages use the same GND reference. Recheck your serial-to-USB adapter so to ensure that it supplies 3.3V voltage and NOT 5V . 5V will damage the ESP chip! Releasing GPIO0 button/wire before booting is finished - It is safe to leave GPIO0 connected to GND during the entire programming process (erase & upload). Just be sure to remove the GPIO0 to GND bridge before booting the device for regular operation. Make sure that the RX pin is connected to the TX pin between the serial adapter and your ESP device, and vice versa. Erase the flash memory first and cycle power afterwards before uploading the Tasmota firmware binary. Not erasing can leave behind remnants of the previous flash contents which can interfere with the new firmware operation.","title":"Hardware Preparation"},{"location":"Hardware-Preparation/#serial-connection","text":"Each device has its pins labelled differently. If the labelling isn't visible on the PCB please refer to the devices flashing guide or search the Internet for correct pin locations. Device specific instructions and restrictions are documented in the Tasmota Device Templates Repository When you have identified pins on your device, connect wires according to the table: Serial adapter ESP8266 device 3V3 3V3 or VCC TX RX RX TX GND GND Note that TX from your adapter goes to RX on the ESP8266 device and RX from adapter goes to TX on the device!","title":"Serial Connection"},{"location":"Hardware-Preparation/#serial-connection-using-nodemcu-esp8266","text":"You can use the USB-to-serial adaptor of a NODEMCU (and probably other ESP8266 boards with a serial chip). You do not need to overwrite the existing firmware of your NODEMCU so it can be done using one already pre-installed with Tasmota - when you unplug and reset the NODEMCU it will revert to its previous state. Simply connect the EN pin to ground to prevent the ESP8266 chip on your NODEMCU from starting. Then connect as a normal USB-to-serial except connect TX to TX and RX to RX, ie no crossover required. NODEMCU ESP8266 device 3V3 3V3 or VCC RX RX TX TX GND GND","title":"Serial Connection using NODEMCU ESP8266"},{"location":"Hardware-Preparation/#programming-mode","text":"ESP8266 needs to be put into Programming Mode before the firmware can be uploaded. This is done by pulling the GPIO0 pin to GND while the chip is booting. On most devices the installed control button is connected to GPIO0 and GND, making entering Programming Mode very easy. On others you will need to bridge the pins on the PCB or directly on the chip with a jumper wire. Device specific instructions are documented in Tasmota Device Templates Repository . To put the ESP8266 into Programming Mode: Disconnect serial-to-USB adapter and power Bridge GPIO0 and GND (by pressing the on-board button or connection with a wire) Connect the serial-to-USB adapter to your computer After a few seconds disconnect GPIO0 from GND (release button or remove the wire connection). On devices that do not provide the GPIO0 connected button, it may be easier to leave the wired bridge in place throughout the entire flashing process (erase & upload). Doing so will not create any problems. After the firmware is uploaded successfully, remove the bridge. This allows the device to boot normally. You can test whether your device is in Programming Mode by attempting to read information from the ESP82xx chip. This requires esptool.py . Instructions on installing and using esptool are provided in the Flashing article . For example ( COM5 will be your COM port): - esptool.py -p COM5 read_mac (It should read the MAC address. It may fail afterwards during Uploading and running a \"stub\". This is normal.) - esptool.py -p COM5 flash_id If everything went well, you are now in Programming Mode and ready to continue with flashing . If the flashing process is unable to start, disconnect the device and retry the steps.","title":"Programming Mode"},{"location":"Hardware-Preparation/#common-mistakes","text":"Wire connections and solder joints - Double check all connections and also check for solder overflow. Use a USB data cable - Some USB cables are for charging only and do not connect the data lines needed to load the firmware onto the device. Insufficient power delivered over the serial-to-USB adapter. This leads to flashing failures or corrupted flash altogether. Supply more power with a separate 3.3V power supply or get an adapter with a better power supply. Be sure all DC voltages use the same GND reference. Recheck your serial-to-USB adapter so to ensure that it supplies 3.3V voltage and NOT 5V . 5V will damage the ESP chip! Releasing GPIO0 button/wire before booting is finished - It is safe to leave GPIO0 connected to GND during the entire programming process (erase & upload). Just be sure to remove the GPIO0 to GND bridge before booting the device for regular operation. Make sure that the RX pin is connected to the TX pin between the serial adapter and your ESP device, and vice versa. Erase the flash memory first and cycle power afterwards before uploading the Tasmota firmware binary. Not erasing can leave behind remnants of the previous flash contents which can interfere with the new firmware operation.","title":"Common Mistakes"},{"location":"Home-Assistant/","text":"Home Assistant ~ Home Assistant (Hass) is an open source home automation solution that puts local control and privacy first. Tasmota communicates with Home Assistant using MQTT. Before going any further, make sure MQTT is properly set up in Home Assistant and in Tasmota . First, test if the two can communicate. In Home Assistant web UI go to Developer Tools - MQTT . Subscribe to tele/topic%/STATE and click START LISTENING . You should see a JSON response from your device. To test control of a relay or light, as Publish a packet topic enter cmnd/%topic%/POWER with payload toggle . When you click PUBLISH your device should switch state and a JSON response will be visible in Listen to a topic window. Adding Devices ~ Home Assistant has two avenues of adding Tasmota devices: 1. Using MQTT discovery 2. Adding by editing configuration.yaml [!NOTE] After every change to the configuration file you'll need to restart Home Assistant to make it aware of the changes. If you don't want to use MQTT discovery, skip to Manual Config Automatic Discovery ~ Home Assistant has a feature called MQTT discovery . With MQTT discovery no user interaction or configuration file editing is needed to add new devices in Home Assistant. Automatic discovery is currently supported for Relays Announced to Home Assistant as MQTT Switch . To make a relay discovered as \"light\" in Home Assistant use command SetOption30 1 Alternatively you can configure it manually using Light Switch integration. Lights Announced to Home Assistant as MQTT Light . Dimmers Announced to Home Assistant as MQTT Light with a single channel used for dimming. Buttons Announced to Home Assistant as Automation Trigger . To have buttons discovered ButtonTopic must be set to 1 or to a custom name and it will automatically start to listen and publish using /stat/%topic%/BUTTON<x> topic. When using ButtonTopic 1 the only possible trigger will be HOLD (SetOption1 or SetOption11 must be enabled). When using ButtonTopic with a custom name all the possible combination enabled by SetOption1, SetOption11 and Setoption13 will be possible. SwitchMode default for buttons and switches is Switchmode 0 (TOGGLE). To change the behavior, SwitchMode must be changed (the Button must be configured as Switch to have effect). For example setting up a switch to SwitchMode 1 (follow) will create a switch with ON and OFF payloads. [!WARNING] When a Button is set to a different topic than 0 is not possible to use Button#State as a trigger for rules. Switches Announced to Home Assistant as MQTT Binary Sensor and/or as a Automation Trigger . To have switches discovered SwitchTopic must be set to a custom name and it will automatically start to listen and publish using /stat/%topic%/SWITCH<x> topic. Depending by the SwitchMode used, a switch can be a Trigger ( TOGGLE or HOLD ), a Binary Sensor ( ON / OFF ) or both at the same time. Example: When using with SwitchMode 0 Tasmota will create just one Trigger for TOGGLE . When using with SwitchMode 1 Tasmota will create a Binary Sensor with ON and OFF Payloads. When using with Switchmode 5 Tasmota will create a Binary Sensor with ON and OFF Payloads and a Trigger for TOGGLE All switchmodes are supported with the exception of SwitchMode11 and SwitchMode12 able to generate just a TOGGLE trigger. [!WARNING] When a Switch is set to a different topic than 0 is not possible to use Switch#State as a trigger for rules. Types of devices not listed above (fans, covers, etc) require manual configuration Enabling ~ For a Tasmota device to be automatically discovered by Home Assistant you need to enable MQTT discovery with command: SetOption19 1 [!NOTE] Discovery is not built in to tasmota lite. Use the full version for discovery. After the automatic discovery feature is enabled a retained MQTT message starting with topic \"homeassistant/\" is sent to the broker. That message contains your device configuration which will be picked up and used by Home Assistant to automatically add your device. Enabling discovery will automatically change some SetOptions to suit the new configuration: SetOption4 to 0 Return MQTT response always as RESULT and not as %COMMAND% topic SetOption17 to 1 Show Color as a comma-separated decimal string instead of hexadecimal SetOption59 to 1 Send tele/%topic%/STATE in addition to stat/%topic%/RESULT for commands State , Power and any command causing a light to be turned on. [!NOTE] For every change you made on your device configuration you will need a reboot or use SetOption19 1 again to see the changes under Home Assistant. Warning Please be advised that not all sensors can be correctly rendered under Home Assistant. In those cases a fallback function will be used to create a generic sensor. Disabling ~ To disable MQTT discovery and remove the retained message, execute SetOption19 0 . The \"homeassistant/\" topic is removed from Home Assistant and MQTT broker. Finalizing Setup ~ All automatically discovered entities will show up under: Configuration -> Integrations -> Configured -> MQTT The entities are grouped by hardware, example for a Sonoff Basic: By clicking on one of the entities, and then on the cog wheel, name in Home Assistant and entity_id can be customized: For every device discovered with SetOption19 an informative sensor will be created automatically: Home Assistant (Hass) is an open-source home automation platform running on Python 3. configuration.yaml editing ~ The advantage of manually configuring a device is that you maintain control of all aspects of the configuration. Home Assistant configuration is done by editing the configuration.yaml file. [!DANGER] All the configurations are just examples. You need to be familiar with Home Assistant's configuration structure and procedures. Straight copy paste of the given examples into configuration.yaml will not work for you. If you are using a localized (non-english) version be sure to check the correct spelling and cases for values: * 'payload_available' * 'payload_not_available' * 'payload_on' * 'payload_off' Tip If you want the power states to be persistent in Tasmota and Home Assistant set PowerRetain 1 instead of using retain: true in Home Assistant Switches ~ Add in Home Assistant using the MQTT Switch integration. Required Commands SetOption59 1 - enables sending of tele/%topic%/STATE on POWER and light related commands Single Switch switch : - platform : mqtt name : \"Tasmota Switch\" state_topic : \"stat/tasmota/RESULT\" value_template : \"{{ value_json.POWER }}\" command_topic : \"cmnd/tasmota/POWER\" payload_on : \"ON\" payload_off : \"OFF\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" qos : 1 retain : false Multiple Switches When a device has more than one relay you need to create a new switch for each relay. For each relay use corresponding POWER\\<x> (POWER1, POWER2, etc) or if SetOption26 is enabled) switch : - platform : mqtt name : \"Tasmota Switch 1\" state_topic : \"stat/tasmota/RESULT\" value_template : \"{{ value_json.POWER1 }}\" command_topic : \"cmnd/tasmota/POWER1\" payload_on : \"ON\" payload_off : \"OFF\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" qos : 1 retain : false - platform : mqtt name : \"Tasmota Switch 2\" state_topic : \"stat/tasmota/RESULT\" value_template : \"{{ value_json.POWER2 }}\" command_topic : \"cmnd/tasmota/POWER2\" payload_on : \"ON\" payload_off : \"OFF\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" qos : 1 retain : false - platform : mqtt name : \"Tasmota Switch 3\" state_topic : \"stat/tasmota/RESULT\" value_template : \"{{ value_json.POWER3 }}\" command_topic : \"cmnd/tasmota/POWER3\" payload_on : \"ON\" payload_off : \"OFF\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" qos : 1 retain : false Dimmer Used for dimmers and dimmable lights (single channel lights). light : - platform : mqtt name : \"Dimmer\" command_topic : \"cmnd/tasmota/POWER\" state_topic : \"tele/tasmota/STATE\" state_value_template : \"{{value_json.POWER}}\" availability_topic : \"tele/tasmota/LWT\" brightness_command_topic : \"cmnd/tasmota/Dimmer\" brightness_state_topic : \"tele/tasmota/STATE\" brightness_scale : 100 on_command_type : \"brightness\" brightness_value_template : \"{{value_json.Dimmer}}\" payload_on : \"ON\" payload_off : \"OFF\" payload_available : \"Online\" payload_not_available : \"Offline\" qos : 1 retain : false Tip If you are using your device to control a light, you may want to use MQTT Light integration instead. Simply replace switch: with light: in the configuration keeping everything else the same. Lights ~ Add in Home Assistant using the MQTT Light integration. Required Commands SetOption17 1 - enables decimal colors\\ SetOption59 1 - enables sending of tele/%topic%/STATE on POWER and light related commands Optional Commands Fade on - makes transitions smoother Speed 5 - sets transition speed Dimming Used for dimmers and dimmable lights (single channel lights). light : - platform : mqtt name : \"Dimmer\" command_topic : \"cmnd/tasmota/POWER\" state_topic : \"tele/tasmota/STATE\" state_value_template : \"{{value_json.POWER}}\" availability_topic : \"tele/tasmota/LWT\" brightness_command_topic : \"cmnd/tasmota/Dimmer\" brightness_state_topic : \"tele/tasmota/STATE\" brightness_scale : 100 on_command_type : \"brightness\" brightness_value_template : \"{{value_json.Dimmer}}\" payload_on : \"ON\" payload_off : \"OFF\" payload_available : \"Online\" payload_not_available : \"Offline\" qos : 1 retain : false RGB Light light : - platform : mqtt name : \"RGB Light\" command_topic : \"cmnd/tasmota/POWER\" state_topic : \"tele/tasmota/STATE\" state_value_template : \"{{value_json.POWER}}\" availability_topic : \"tele/tasmota/LWT\" brightness_command_topic : \"cmnd/tasmota/Dimmer\" brightness_state_topic : \"tele/tasmota/STATE\" brightness_scale : 100 on_command_type : \"brightness\" brightness_value_template : \"{{value_json.Dimmer}}\" rgb_command_topic : \"cmnd/tasmota/Color2\" rgb_state_topic : \"tele/tasmota/STATE\" rgb_value_template : \"{{value_json.Color.split(',')[0:3]|join(',')}}\" effect_command_topic : \"cmnd/tasmota/Scheme\" effect_state_topic : \"tele/tasmota/STATE\" effect_value_template : \"{{value_json.Scheme}}\" effect_list : - 0 - 1 - 2 - 3 - 4 payload_on : \"ON\" payload_off : \"OFF\" payload_available : \"Online\" payload_not_available : \"Offline\" qos : 1 retain : false RGB+W Light light : - platform : mqtt name : \"RGB+W Light\" command_topic : \"cmnd/tasmota/POWER\" state_topic : \"tele/tasmota/STATE\" state_value_template : \"{{value_json.POWER}}\" availability_topic : \"tele/tasmota/LWT\" brightness_command_topic : \"cmnd/tasmota/Dimmer\" brightness_state_topic : \"tele/tasmota/STATE\" brightness_scale : 100 on_command_type : \"brightness\" brightness_value_template : \"{{value_json.Dimmer}}\" white_value_state_topic : \"tele/tasmota/STATE\" white_value_command_topic : \"cmnd/tasmota/White\" white_value_scale : 100 white_value_template : \"{{ value_json.Channel[3] }}\" rgb_command_topic : \"cmnd/tasmota/Color2\" rgb_state_topic : \"tele/tasmota/STATE\" rgb_value_template : \"{{value_json.Color.split(',')[0:3]|join(',')}}\" effect_command_topic : \"cmnd/tasmota/Scheme\" effect_state_topic : \"tele/tasmota/STATE\" effect_value_template : \"{{value_json.Scheme}}\" effect_list : - 0 - 1 - 2 - 3 - 4 payload_on : \"ON\" payload_off : \"OFF\" payload_available : \"Online\" payload_not_available : \"Offline\" qos : 1 retain : false RGB+CCT Light Also known as RGBWW or 5 channel lights light : - platform : mqtt name : \"RGBCCT Light\" command_topic : \"cmnd/tasmota/POWER\" state_topic : \"tele/tasmota/STATE\" state_value_template : \"{{value_json.POWER}}\" availability_topic : \"tele/tasmota/LWT\" brightness_command_topic : \"cmnd/tasmota/Dimmer\" brightness_state_topic : \"tele/tasmota/STATE\" brightness_scale : 100 on_command_type : \"brightness\" brightness_value_template : \"{{value_json.Dimmer}}\" color_temp_command_topic : \"cmnd/tasmota/CT\" color_temp_state_topic : \"tele/tasmota/STATE\" color_temp_value_template : \"{{value_json.CT}}\" rgb_command_topic : \"cmnd/tasmota/Color2\" rgb_state_topic : \"tele/tasmota/STATE\" rgb_value_template : \"{{value_json.Color.split(',')[0:3]|join(',')}}\" effect_command_topic : \"cmnd/tasmota/Scheme\" effect_state_topic : \"tele/tasmota/STATE\" effect_value_template : \"{{value_json.Scheme}}\" effect_list : - 0 - 1 - 2 - 3 - 4 payload_on : \"ON\" payload_off : \"OFF\" payload_available : \"Online\" payload_not_available : \"Offline\" qos : 1 retain : false Addressable LED Applies only to WS281x lights. light : - platform : mqtt name : \"Addressable LED\" command_topic : \"cmnd/tasmota/POWER\" state_topic : \"stat/tasmota/STATE\" state_value_template : \"{{value_json.POWER}}\" availability_topic : \"tele/tasmota/LWT\" brightness_command_topic : \"cmnd/tasmota/Dimmer\" brightness_state_topic : \"stat/tasmota/STATE\" brightness_scale : 100 on_command_type : \"brightness\" brightness_value_template : \"{{value_json.Dimmer}}\" rgb_command_topic : \"cmnd/tasmota/Color2\" rgb_state_topic : \"tele/tasmota/STATE\" rgb_value_template : \"{{value_json.Color.split(',')[0:3]|join(',')}}\" effect_command_topic : \"cmnd/tasmota/Scheme\" effect_state_topic : \"stat/tasmota/STATE\" effect_value_template : \"{{value_json.Scheme}}\" effect_list : - 0 - 1 - 2 - 3 - 4 - 5 - 6 - 7 - 8 - 9 - 10 - 11 - 12 payload_on : \"ON\" payload_off : \"OFF\" payload_available : \"Online\" payload_not_available : \"Offline\" qos : 1 retain : false No SetOption17 RGB If you don't want to use SetOption17 1 you can change yaml rgb_value_template: \"{{value_json.Color.split(',')[0:3]|join(',')}}\" to rgb_value_template : \"{% if value_json.Color is defined %}{{ (value_json.Color[0:2]|int(base=16),value_json.Color[2:4]|int(base=16),value_json.Color[4:6]|int(base=16)) | join(',')}}{% endif %}\" Sensors ~ Add in Home Assistant using the MQTT Sensor integration. A sensor will send its data in set intervals defined by TelePeriod (default every 5 minutes). Temperature Check your sensor name in Tasmota and change accordingly. This example uses the DHT22 sensor. sensor : - platform : mqtt name : \"Tasmota Temperature\" state_topic : \"tele/tasmota/SENSOR\" value_template : \"{{ value_json['DHT22'].Temperature }}\" unit_of_measurement : \"\u00b0C\" # \"F\" if using Fahrenheit availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" device_class : temperature Humidity Check your sensor name in Tasmota and change accordingly. This example uses the DHT22 sensor. sensor : - platform : mqtt name : \"Tasmota Humidity\" state_topic : \"tele/tasmota/SENSOR\" value_template : \"{{ value_json['DHT22'].Humidity }}\" unit_of_measurement : \"%\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" device_class : humidity Pressure Check your sensor name in Tasmota and change accordingly. This example uses the BMP280 sensor. sensor : - platform : mqtt name : \"Tasmota Pressure\" state_topic : \"tele/tasmota/SENSOR\" value_template : \"{{ value_json.BMP280.Pressure }}\" unit_of_measurement : \"hPa\" device_class : pressure Change unit_of_measurement to \"mmHg\" if SetOption24 1 Power Monitoring ~ Add in Home Assistant using the MQTT Sensor integration. Power monitoring sensors will send their data in set intervals defined by TelePeriod (default every 5 minutes). To get all the data in Home Assistant requires multiple sensors which you can later group to your liking in Lovelace UI Power Monitoring sensor : - platform : mqtt name : \"Energy Today\" state_topic : \"tele/tasmota/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Today\"] }}' unit_of_measurement : \"kWh\" - platform : mqtt name : \"Power\" state_topic : \"tele/tasmota/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Power\"] }}' unit_of_measurement : \"W\" - platform : mqtt name : \"Voltage\" state_topic : \"tele/tasmota/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Voltage\"] }}' unit_of_measurement : \"V\" - platform : mqtt name : \"Current\" state_topic : \"tele/tasmota/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Current\"] }}' unit_of_measurement : \"A\" Tip For additional sensors use \"Total\";\"Yesterday\";\"Period\",\"ApparentPower\",\"ReactivePower\";\"Factor\" in value_template string Video tutorial on a power monitoring plug setup by Digiblur Binary Sensors ~ Add in Home Assistant using the MQTT Binary Sensor integration. PIR Sensor Used for a configured PIR Sensor and requires this rule: Required Commands Rule1 on Switch1#State=1 do Publish stat/hall/MOTION ON endon on Switch1#State=1 do Publish stat/hall/MOTION OFF endon Rule1 1 binary_sensor : - platform : mqtt name : \"Tasmota Motion Sensor\" state_topic : \"stat/tasmota/MOTION\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" device_class : motion qos : 1 Door Sensor Requires a reed switch configured in Tasmota. Required Commands Rule1 on Switch1#State=1 do Publish stat/hall/MOTION ON endon on Switch1#State=1 do Publish stat/hall/MOTION OFF endon Rule1 1 binary_sensor : - platform : mqtt name : \"Tasmota Motion Sensor\" state_topic : \"stat/tasmota/MOTION\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" device_class : door # also: window, garage_door or opening qos : 1 RF Bridge An RF door sensor configured with an RF receiver in Tasmota. binary_sensor : - platform : mqtt name : \"RF bridge rfkey\" payload_on : \"1\" payload_off : \"0\" device_class : opening state_topic : \"tele/tasmota/RESULT\" value_template : '{{ value_json.RfReceived.RfKey }}' Fans ~ Add in Home Assistant using the MQTT Fan integration. Fan Derived from #2839 by @kbickar and @finity69x2 # Example configuration.yaml entry fan : - platform : mqtt name : \"Tasmota Fan\" command_topic : \"cmnd/tasmota/FanSpeed\" speed_command_topic : \"cmnd/tasmota/FanSpeed\" state_topic : \"stat/tasmota/RESULT\" speed_state_topic : \"stat/tasmota/RESULT\" state_value_template : > {% if value_json.FanSpeed is defined %} {% if value_json.FanSpeed == 0 -%}0{%- elif value_json.FanSpeed > 0 -%}4{%- endif %} {% else %} {% if states.fan.tasmota.state == 'off' -%}0{%- elif states.fan.tasmota.state == 'on' -%}4{%- endif %} {% endif %} speed_value_template : \"{{ value_json.FanSpeed }}\" availability_topic : tele/tasmota/LWT payload_off : \"0\" payload_on : \"4\" payload_low_speed : \"1\" payload_medium_speed : \"2\" payload_high_speed : \"3\" payload_available : Online payload_not_available : Offline speeds : - off - low - medium - high Device Specific ~ iFan02 Combination of configs found in issue #2839 and Home Assistant forum thread Sonoff IFan02 (Tasmota) MQTT Fan . fan : - platform : mqtt name : \"Pat Ceiling Fan\" state_topic : \"stat/ifan02/RESULT\" speed_state_topic : \"stat/ifan02/RESULT\" state_value_template : > {% if value_json.FanSpeed is defined %} {% if value_json.FanSpeed == 0 -%}0{%- elif value_json.FanSpeed > 0 -%}2{%- endif %} {% else %} {% if states.fan.pat_ceiling_fan.state == 'off' -%}0{%- elif states.fan.pat_ceiling_fan.state == 'on' -%}2{%- endif %} {% endif %} speed_value_template : \"{{ value_json.FanSpeed }}\" availability_topic : tele/ifan02/LWT payload_available : Online payload_not_available : Offline speed_command_topic : \"cmnd/ifan02/FanSpeed\" payload_low_speed : \"1\" payload_medium_speed : \"2\" payload_high_speed : \"3\" command_topic : \"cmnd/ifan02/FanSpeed\" payload_off : \"0\" payload_on : \"2\" qos : 1 retain : false speeds : - low - medium - high light : - platform : mqtt name : \"Pat Ceiling Light\" state_topic : \"tele/ifan02/STATE\" value_template : \"{{ value_json.POWER }}\" command_topic : \"cmnd/ifan02/POWER\" availability_topic : \"tele/ifan02/LWT\" qos : 1 payload_on : \"ON\" payload_off : \"OFF\" payload_available : \"Online\" payload_not_available : \"Offline\" retain : false Sonoff S31 Configure the device as Sonoff S31, and run:\\ SetOption4 1 SetOption59 1 switch : - platform : mqtt name : \"s31 power\" state_topic : \"tele/s31/STATE\" value_template : \"{{ value_json.POWER }}\" command_topic : \"cmnd/s31/POWER\" availability_topic : \"tele/s31/LWT\" qos : 1 payload_on : \"ON\" payload_off : \"OFF\" payload_available : \"Online\" payload_not_available : \"Offline\" retain : false sensor : - platform : mqtt name : \"s31 Voltage\" state_topic : \"tele/s31/SENSOR\" value_template : \"{{ value_json['ENERGY'].Voltage }}\" unit_of_measurement : \"V\" availability_topic : \"tele/s31/LWT\" qos : 1 payload_available : \"Online\" payload_not_available : \"Offline\" - platform : mqtt name : \"s31 Current\" state_topic : \"tele/s31/SENSOR\" value_template : \"{{ value_json['ENERGY'].Current | round(2) }}\" unit_of_measurement : \"A\" availability_topic : \"tele/s31/LWT\" qos : 1 payload_available : \"Online\" payload_not_available : \"Offline\" - platform : mqtt name : \"s31 Power\" state_topic : \"tele/s31/SENSOR\" value_template : \"{{ value_json['ENERGY'].Power }}\" unit_of_measurement : \"W\" availability_topic : \"tele/s31/LWT\" qos : 1 payload_available : \"Online\" payload_not_available : \"Offline\" device_class : power - platform : mqtt name : \"s31 Power Factor\" state_topic : \"tele/s31/SENSOR\" value_template : \"{{ value_json['ENERGY'].Factor }}\" availability_topic : \"tele/s31/LWT\" qos : 1 payload_available : \"Online\" payload_not_available : \"Offline\" - platform : mqtt name : \"s31 Energy Today\" state_topic : \"tele/s31/SENSOR\" value_template : \"{{ value_json['ENERGY'].Today }}\" unit_of_measurement : \"kWh\" availability_topic : \"tele/s31/LWT\" qos : 1 payload_available : \"Online\" payload_not_available : \"Offline\" - platform : mqtt name : \"s31 Energy Yesterday\" state_topic : \"tele/s31/SENSOR\" value_template : \"{{ value_json['ENERGY'].Yesterday }}\" unit_of_measurement : \"kWh\" availability_topic : \"tele/s31/LWT\" qos : 1 payload_available : \"Online\" payload_not_available : \"Offline\" - platform : mqtt name : \"s31 Energy Total\" state_topic : \"tele/s31/SENSOR\" value_template : \"{{ value_json['ENERGY'].Total }}\" unit_of_measurement : \"kWh\" availability_topic : \"tele/s31/LWT\" qos : 1 payload_available : \"Online\" payload_not_available : \"Offline\" Zigbee Devices ~ Dimmable Light This configuration is for a dimmable light reporting on 0xE1F9 using endpoint 1, cluster 8 for brightness. ZbRead part in the template is needed to always update the brightness values. # Example configuration.yaml entry light : - platform : mqtt schema : template name : \"Fire Light\" command_topic : \"cmnd/zigbee-gateway/Backlog\" state_topic : \"tele/zigbee-gateway/SENSOR\" command_on_template : > {%- if brightness is defined -%} ZbSend { \"device\":\"0xE1F9\", \"send\":{\"Dimmer\":{{ brightness }} } }; ZbSend { \"device\":\"0xE1F9\", \"send\":{\"Power\":true} }; delay 20; ZbRead { \"device\":\"0xE1F9\", \"endpoint\":1, \"cluster\":8, \"read\":0 } {%- else -%} ZbSend { \"device\":\"0xE1F9\", \"send\":{\"Power\":true} }; delay 20; ZbRead { \"device\":\"0xE1F9\", \"endpoint\":1, \"cluster\":8, \"read\":0 } {%- endif -%} command_off_template : 'ZbSend { \"device\":\"0xE1F9\", \"send\":{\"Power\":false} }; delay 20; ZbRead { \"device\":\"0xE1F9\", \"endpoint\":1, \"cluster\":8, \"read\":0 }' state_template : > {% if value_json.ZbReceived is defined and value_json.ZbReceived['0xE1F9'] is defined and value_json.ZbReceived['0xE1F9'].Power is defined %} {% if value_json.ZbReceived['0xE1F9'].Power == true %} on {% else %} off {% endif %} {% else %} {{ states('light.fire_light') }} {% endif %} brightness_template : > {%- if value_json.ZbReceived is defined and value_json.ZbReceived['0xE1F9'] is defined and value_json.ZbReceived['0xE1F9'].Dimmer is defined -%} {{ value_json['ZbReceived']['0xE1F9'].Dimmer | int }} {%- else -%} {{ state_attr('light.fire_light', 'brightness') | int }} {%- endif -%} Water Leak Sensor This specific configuration is for Xiaomi Aqara Water Leak sensor reporting on 0x099F . # Example configuration.yaml entry binary_sensor : - platform : mqtt name : \"Water Leak\" state_topic : \"tele/zigbee-gateway/SENSOR\" value_template : > {%- if value_json.ZbReceived is defined and value_json.ZbReceived['0x099F'] is defined -%} {%- if value_json.ZbReceived['0x099F']['0500!00'] == '010000FF0000' -%} ON {% else %} OFF {% endif %} {% else %} {{ states('binary_sensor.water_leak') }} {% endif %} availability_topic : \"tele/zigbee-gateway/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" qos : 1 device_class : moisture Enable join switch - platform : mqtt name : Zigbee2Tasmota enable join state_topic : \"tele/zigbee/RESULT\" command_topic : \"cmnd/zigbee/ZbPermitJoin\" payload_on : \"1\" payload_off : \"0\" state_on : \"Enable Pairing mode for 60 seconds\" state_off : \"off\" optimistic : false qos : 1 retain : false value_template : '{{value_json.ZbState.Message }}' icon : mdi:zigbee Useful Automations ~ Sync Power State When MQTT broker or Home Assistant is restarted, or there is a WiFi outage, Tasmota device state may not be synced with Home Assistant. Use this automation to get all your (auto discovered) devices in sync, including power state, immediately after Home Assistant is started. For autodiscovered devices: automation : - alias : \"Sync Tasmota states on start-up - autodiscovery\" initial_state : true trigger : platform : homeassistant event : start action : - service : mqtt.publish data : topic : \"tasmotas/cmnd/state\" payload : \"\" For manually configured devices: automation : - alias : \"Sync Tasmota states on start-up - manual configuration\" initial_state : true trigger : platform : homeassistant event : start action : - service : mqtt.publish data : topic : \"cmnd/tasmotas/state\" payload : \"\" Report Firmware Version - Autodiscovery automation : - id : 'tasmota_firmware_installed' alias : \"Tasmota Firmware Installed\" initial_state : true trigger : - event : start platform : homeassistant action : - data : payload : '2' topic : tasmotas/cmnd/status service : mqtt.publish initial_state : 'true' Then you can make a sensor that detects the latest version of Tasmota and alerts you if there is an update. Autodiscovery only. configuration.yaml # Getting Firmware from JSON for Tasmota sensor : - platform : rest resource : https://api.github.com/repos/arendst/Tasmota/releases/latest name : Sonoff Firmware Version Available username : !secret githubuser password : !secret githubpass authentication : basic value_template : '{{ value_json.tag_name }}' headers : Accept : application/vnd.github.v3+json Content-Type : application/json User-Agent : Home Assistant REST sensor - platform : mqtt name : \"Coffee Maker Firmware\" state_topic : \"coffee/stat/STATUS2\" value_template : 'v{{ value_json.StatusFWR.Version }}' - platform : mqtt name : \"Garage Door Firmware\" state_topic : \"garage/stat/STATUS2\" value_template : 'v{{ value_json.StatusFWR.Version }}' binary_sensor : - platform : template sensors : sonoff_update_available : value_template : >- {{ (states.sensor.tasmota_firmware_version_available.state > states.sensor.coffee_maker_firmware.state) or (states.sensor.tasmota_firmware_version_available.state > states.sensor.garage_door_firmware.state) }} Note the above is for 2 switches. customize.yaml binary_sensor.tasmota_update_available : friendly_name : Update Available Tasmota device_class : problem Then it will show as an alert icon that you can show in Lovelace. Report Firmware Version - Manual Add a sensor like below for each Tasmota device whose firmware version you want to track. # Example configuration.yaml entry sensor : - platform : mqtt name : \"Tasmota\" state_topic : \"stat/tasmota/STATUS2\" value_template : \"{{value_json['StatusFWR'].Version }}\" availability_topic : \"tele/tasmota/LWT\" payload_available : \"Online\" payload_not_available : \"Offline\" qos : 0 Automation to have each device report firmware version on Home Assistant reboot. You can manually trigger this automation from Home Assistant UI. automation : - alias : \"Tasmota Firmware Version Check\" trigger : platform : homeassistant event : start action : - service : mqtt.publish data : topic : \"cmnd/tasmotas/STATUS\" payload : \"2\" New device IP Address Here is some code that will display the IP address of yout newly flashed device. The script: script : get_tasmota_ip : alias : Get Tasmota New IP (tasmota) sequence : - data : topic : cmnd/tasmota/ipaddress service : mqtt.publish The sensor: sensor : - platform : mqtt name : \"Tasmota IP\" state_topic : 'stat/tasmota/RESULT' value_template : \"{{ value_json.IPAddress1.split(' ')[1].replace('(','').replace(')','') }}\" Restart HA and plug in your newly flashed device. Click EXECUTE (in the new group) and the \"Tasmota IP\" sensor will display the IP address. After finding out the new IP don't forget to change the topic of the new device to a unique one. Tip If you want all your devices to switch to autodiscovery method go through Developer tools - MQTT by publishing to grouptopic cmnd/tasmotas/SetOption19 with payload 1","title":"Home Assistant"},{"location":"Home-Assistant/#home-assistant","text":"Home Assistant (Hass) is an open source home automation solution that puts local control and privacy first. Tasmota communicates with Home Assistant using MQTT. Before going any further, make sure MQTT is properly set up in Home Assistant and in Tasmota . First, test if the two can communicate. In Home Assistant web UI go to Developer Tools - MQTT . Subscribe to tele/topic%/STATE and click START LISTENING . You should see a JSON response from your device. To test control of a relay or light, as Publish a packet topic enter cmnd/%topic%/POWER with payload toggle . When you click PUBLISH your device should switch state and a JSON response will be visible in Listen to a topic window.","title":"Home Assistant"},{"location":"Home-Assistant/#adding-devices","text":"Home Assistant has two avenues of adding Tasmota devices: 1. Using MQTT discovery 2. Adding by editing configuration.yaml [!NOTE] After every change to the configuration file you'll need to restart Home Assistant to make it aware of the changes. If you don't want to use MQTT discovery, skip to Manual Config","title":"Adding Devices"},{"location":"Home-Assistant/#automatic-discovery","text":"Home Assistant has a feature called MQTT discovery . With MQTT discovery no user interaction or configuration file editing is needed to add new devices in Home Assistant. Automatic discovery is currently supported for","title":"Automatic Discovery"},{"location":"Home-Assistant/#enabling","text":"For a Tasmota device to be automatically discovered by Home Assistant you need to enable MQTT discovery with command: SetOption19 1 [!NOTE] Discovery is not built in to tasmota lite. Use the full version for discovery. After the automatic discovery feature is enabled a retained MQTT message starting with topic \"homeassistant/\" is sent to the broker. That message contains your device configuration which will be picked up and used by Home Assistant to automatically add your device. Enabling discovery will automatically change some SetOptions to suit the new configuration: SetOption4 to 0 Return MQTT response always as RESULT and not as %COMMAND% topic SetOption17 to 1 Show Color as a comma-separated decimal string instead of hexadecimal SetOption59 to 1 Send tele/%topic%/STATE in addition to stat/%topic%/RESULT for commands State , Power and any command causing a light to be turned on. [!NOTE] For every change you made on your device configuration you will need a reboot or use SetOption19 1 again to see the changes under Home Assistant. Warning Please be advised that not all sensors can be correctly rendered under Home Assistant. In those cases a fallback function will be used to create a generic sensor.","title":"Enabling"},{"location":"Home-Assistant/#disabling","text":"To disable MQTT discovery and remove the retained message, execute SetOption19 0 . The \"homeassistant/\" topic is removed from Home Assistant and MQTT broker.","title":"Disabling"},{"location":"Home-Assistant/#finalizing-setup","text":"All automatically discovered entities will show up under: Configuration -> Integrations -> Configured -> MQTT The entities are grouped by hardware, example for a Sonoff Basic: By clicking on one of the entities, and then on the cog wheel, name in Home Assistant and entity_id can be customized: For every device discovered with SetOption19 an informative sensor will be created automatically: Home Assistant (Hass) is an open-source home automation platform running on Python 3.","title":"Finalizing Setup"},{"location":"Home-Assistant/#configurationyaml-editing","text":"The advantage of manually configuring a device is that you maintain control of all aspects of the configuration. Home Assistant configuration is done by editing the configuration.yaml file. [!DANGER] All the configurations are just examples. You need to be familiar with Home Assistant's configuration structure and procedures. Straight copy paste of the given examples into configuration.yaml will not work for you. If you are using a localized (non-english) version be sure to check the correct spelling and cases for values: * 'payload_available' * 'payload_not_available' * 'payload_on' * 'payload_off' Tip If you want the power states to be persistent in Tasmota and Home Assistant set PowerRetain 1 instead of using retain: true in Home Assistant","title":"configuration.yaml editing"},{"location":"Home-Assistant/#switches","text":"Add in Home Assistant using the MQTT Switch integration. Required Commands SetOption59 1 - enables sending of tele/%topic%/STATE on POWER and light related commands","title":"Switches"},{"location":"Home-Assistant/#lights","text":"Add in Home Assistant using the MQTT Light integration. Required Commands SetOption17 1 - enables decimal colors\\ SetOption59 1 - enables sending of tele/%topic%/STATE on POWER and light related commands Optional Commands Fade on - makes transitions smoother Speed 5 - sets transition speed","title":"Lights"},{"location":"Home-Assistant/#sensors","text":"Add in Home Assistant using the MQTT Sensor integration. A sensor will send its data in set intervals defined by TelePeriod (default every 5 minutes).","title":"Sensors"},{"location":"Home-Assistant/#power-monitoring","text":"Add in Home Assistant using the MQTT Sensor integration. Power monitoring sensors will send their data in set intervals defined by TelePeriod (default every 5 minutes). To get all the data in Home Assistant requires multiple sensors which you can later group to your liking in Lovelace UI","title":"Power Monitoring"},{"location":"Home-Assistant/#binary-sensors","text":"Add in Home Assistant using the MQTT Binary Sensor integration.","title":"Binary Sensors"},{"location":"Home-Assistant/#fans","text":"Add in Home Assistant using the MQTT Fan integration.","title":"Fans"},{"location":"Home-Assistant/#device-specific","text":"","title":"Device Specific"},{"location":"Home-Assistant/#zigbee-devices","text":"","title":"Zigbee Devices"},{"location":"Home-Assistant/#useful-automations","text":"","title":"Useful Automations"},{"location":"Home/","text":"Latest release: 8.2 Elliot What's New? ~ Tasmota v8.2 2020-03-21 Tasmota v8.2 Elliot is released. Breaking changes ~ Most of the sensor support is moved to tasmota-sensors.bin. If your sensor didn't come with the device, it is most likely not supported in the default tasmota.bin firmware build anymore. Consult Builds table for complete information. Enabling SetOption19 will no longer switch %prefix% and %topic% and will keep the default topic structure Zigbee command prefixes have changed from Zigbee* to Zb* Some of notable new features: - Support for gzipped binaries - Added group control of devices using UDP - Added support for Mijia BLE sensors using HM10 or NRF24L01 peripherals - Added native support for Martin Jerry type PWM dimmer switches - Plenty of new switchmodes . See changelog for a complete list of new features, changes and fixes. Tasmota v8.1 2019-12-25 Merry Christmas and Happy New Year from the Tasmota Development Team. Tasmota v8.1 Doris is released. See changelog for all changes . This release supports downgrade only to version 7.2.0.x . There are major changes in configuration code and layout which will completely break any downgrade to versions prior to v7.2. Tasmota v7.2 2019-12-21 Tasmota v7.2 Constance is released. See changelog for all changes . Breaking change: tasmota-basic.bin is renamed to tasmota-lite.bin . Update your OtaUrl accordingly. This will be the only release that supports fallback from future release 8.0 and development versions 7.2.0.x which will be released shortly. Tasmota v8.0 will have major changes in configuration code and layout which will completely break any downgrade to versions below v7.2. 5 MILLION 2019-12-11 Tasmota has hit 5 MILLION DOWNLOADS from GitHub!!! We would like to thank everyone for making this project better with each new release. Onwards to 10 million and beyond! Tasmotizer! 2019-12-04 Remember that official Tasmota firmware flashing tool from a month ago? Pfft, old news! We present to you the even more official, completely home made and GMO free: TASMOTIZER! It downloads the latest release/development firmware for you, backs up the original firmware with one-click and can even (if you wish so) send your default settings to the device after it's flashed. But most of all it has a dark theme, so it must be good! Tasmota v7.1.1 2019-11-29 Tasmota v7.1.1 Betty is released. Read Moving to v7 on all the breaking changes and how to deal with them. This release is chock full of changes and improvements! * Everything is Tasmota now, Sonoff-Tasmota is no more. * WebUI went to the dark side but managed to pick up colorpicker powers on the way. * Default and only supported Arduino cores are >2.6. * Expanded TuyaMCU support with new commands. * Better I2C device address management. * Zigbee devices support. and more... Oh, there's also this swanky new Tasmota documentation site on http://tasmota.com. Community ~ See Discord , Telegram or Community Forum for feedback, questions and troubleshooting. Contributing ~ You too can contribute to the Tasmota project.","title":"Home"},{"location":"Home/#whats-new","text":"","title":"What's New?"},{"location":"Home/#breaking-changes","text":"","title":"Breaking changes"},{"location":"Home/#community","text":"See Discord , Telegram or Community Forum for feedback, questions and troubleshooting.","title":"Community"},{"location":"Home/#contributing","text":"You too can contribute to the Tasmota project.","title":"Contributing"},{"location":"HomeSeer/","text":"For those knowing more about HomeSeer please update this page. About HomeSeer HS3 is the industry standard for flexible, powerful, home automation software. A wide selection of software drivers (plug-ins) is available for use with scores of home automation technologies and products. The following forum link provides a guide to upload Tasmota to an S20 using SonOTA and integrate it with HomeSeer HS3 using the mcsMQTT plugin. Here is a guide for integrating HomeSeer HS3 with the Sonoff 4CH Pro and Tasmota firmware as a Garage Door controller using the mcsMQTT plugin. Requirements for HomeSeer HS3 and Tasmota devices: * HomeSeer HS3 * MQTT server * A MQTT plugin for HS3 Currently there are two plugins, both free: \"MQTT\" and \"mcsMQTT\". The former is more intuitive but hasn't been updated for a while, the latter is newer and constantly updated. If you use \"MQTT\" plugin you need to synch the virtual device to reflect the status of the physical button, this can be done with a plugin: * EasyTrigger plugin - costs 25$ (used to synchronise the status of the virtual device in HomeSeer when the Sonoff Tasmota module is operated from the physical button) If you use \"mcsMQTT\", starting from ver 3.0.3+ it allows to create a device that both report and control the status of the Sonoff. More info here: https://forums.homeseer.com/showthread.php?t=192675 Tasmota Plug-in If your interested in a FREE specific plug-in for Sonoff + Tasmota, then Instructions are HERE and you can install it from the Homeseer Plug-ins Manager, in Primary Technology as TasMQTT. This plug-in takes care of two-way updates so wall switches update Homseer devices and homeseer changes update Sonoff devices. The plug-in also takes care of monitoring sonoff availability and optionally flags homeseer devices as offline so events can take that into consideration before making changes. When devices come back online Homeseer is updated with the current status of the devices. The plug-in also supports Tasmota Sensors such as the Sonoff TH1 etc. The plug-in has so far been tested extensively with the entire Sonoff Portfolio and as new devices become available we'll test those too. This plug-in has been in beta for 6 months and has now reached production. Beta's will continue to be released to support any new Tasmota enabled devices.","title":"HomeSeer"},{"location":"Homebridge/","text":"Homebridge is a NodeJS server which emulates the iOS HomeKit API to enable support for non-native devices (like Sonoff and Magichome devices). Tasmota compatible plugins have been developed by macwyznawca and arachnetech as well as others to add support for these devices in Apple's Home app and through iCloud for automation (iPad, HomePod/Apple TV 4 or newer required). Note these plugins are not necessarily specific to Sonoff devices. The homebridge-mqttthing package has support for many types of devices and is quite flexible with different options especially for RGB/RGBW LED strips. As of 1.0.11 homebridge-mqttthing supports the following Homekit device types: * Light bulb * Switch * Outlet * Motion Sensor * Occupancy Sensor * Light Sensor * Contact Sensor * Doorbell * Security System * Smoke Sensor * Temperature Sensor * Humidity Sensor * Stateless Programmable Switch * Garage Door * Garage Door Opener Check out macwyznawca's packages for supported functions, each in a separate package. To use Homebridge with Tasmota you need to have an existing MQTT broker set up ( see wiki article ) and each of your Sonoff devices should have a unique topic set. Example screenshot from Apple Home.app","title":"Homebridge"},{"location":"Honeywell-HIH/","text":"This feature is included only in tasmota-sensors.bin Otherwise you must compile your build . Add the following to user_config_override.h : #ifndef USE_HIH6 #define USE_HIH6 // Enable Honeywell HIH (I2C address 0x27) (+0k6) #endif Honeywell HumidIcon\u2122 Digital Humidity and Temperature Sensors HIH Series Configuration ~ Wiring ~ Get the 4 pin SIP version if possible, as this will be easier to solder than the 8 pin SMD version. Looking at the side of the sensor with a filter: * Pin 1 VDD 1. connect via 0.22 uF to ground 1. connect to 3v3 on the ESP * Pin 2 GND 1. connect to GND on the ESP * Pin 3 SCL 1. connect via 2k2 resistor to 3v3 1. connect to TX on the ESP * Pin 4 SDA 1. connect via 2k2 resistor to 3v3 1. connect to RX on the ESP Remember to peel off the white sticker over the filter before use. I have tested several of these without the 0.22 uF capacitor and without the pull-up resistors, and I haven't seen any difference in the readings. The cap is probably more important that the resistors, since the internal pull-ups in the ESP8266 will work. That said, if I was installing these in a hard-to-service location, I would follow the wiring diagram exactly. I have noticed that temperature readings tend to be a degree or so high if the sensor is wired directly to the ESP: Soldering a 1-2\" piece of wire between the ESP and the HIH7121 fixes this issue: Tasmota Settings ~ In the Configuration -> Configure Module page assign: 1. GPIO RX to I2C SDA (6) 2. GPIO TX to I2C SCL (5) After a reboot the driver will detect the HIHxxxx automatically and display sensor data. <--- if you have an LCD display also configured, run I2CDriver3 0 More documentation on this is in the I2CDEVICES.md file. Why the Honeywell HIH series sensors? ~ The go-to humidity sensor for the DIY Arduino/ESP8266 community is the DHT22. Unfortunately, this sensor has a tendency to collect condensation and give false readings (usually 99.9% RH) in wet environments like a bathroom or outside. Not being able to use a humidity sensor in a wet area (IMHO) defeats the point of a humidity sensor, so I set about looking for alternatives. After looking at several options, I found the Honeywell HIHxxxx sensors. Different models of the HIH line have different features and work over different ranges of humidity, but most of them use the same I2C protocol, which is now supported in Tasmota. Check the datasheets to compare sensors. One of the most critical features to look for is a hydrophobic filter which allows humid air through, but blocks water droplets from entering the sensor. This is listed on the datasheets as \"with filter,condensation resistant\". Also keep in mind the humidity range you'll be measuring. For my purposes (bathroom humidity sensor), there was a clear choice in the HIH7121-021 ( datasheet , non-affiliate direct link to product on Mouser , which works over a range of 0-100% RH, supports I2C, is accurate to within 3%, and has a hydrophobic filter. The article focuses on that sensor, but I suspect much of the information will be applicable to other HIHxxxx sensors. by @thepotoo","title":"Honeywell HIH"},{"location":"Honeywell-HIH/#configuration","text":"","title":"Configuration"},{"location":"Honeywell-HIH/#wiring","text":"Get the 4 pin SIP version if possible, as this will be easier to solder than the 8 pin SMD version. Looking at the side of the sensor with a filter: * Pin 1 VDD 1. connect via 0.22 uF to ground 1. connect to 3v3 on the ESP * Pin 2 GND 1. connect to GND on the ESP * Pin 3 SCL 1. connect via 2k2 resistor to 3v3 1. connect to TX on the ESP * Pin 4 SDA 1. connect via 2k2 resistor to 3v3 1. connect to RX on the ESP Remember to peel off the white sticker over the filter before use. I have tested several of these without the 0.22 uF capacitor and without the pull-up resistors, and I haven't seen any difference in the readings. The cap is probably more important that the resistors, since the internal pull-ups in the ESP8266 will work. That said, if I was installing these in a hard-to-service location, I would follow the wiring diagram exactly. I have noticed that temperature readings tend to be a degree or so high if the sensor is wired directly to the ESP: Soldering a 1-2\" piece of wire between the ESP and the HIH7121 fixes this issue:","title":"Wiring"},{"location":"Honeywell-HIH/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: 1. GPIO RX to I2C SDA (6) 2. GPIO TX to I2C SCL (5) After a reboot the driver will detect the HIHxxxx automatically and display sensor data. <--- if you have an LCD display also configured, run I2CDriver3 0 More documentation on this is in the I2CDEVICES.md file.","title":"Tasmota Settings"},{"location":"Honeywell-HIH/#why-the-honeywell-hih-series-sensors","text":"The go-to humidity sensor for the DIY Arduino/ESP8266 community is the DHT22. Unfortunately, this sensor has a tendency to collect condensation and give false readings (usually 99.9% RH) in wet environments like a bathroom or outside. Not being able to use a humidity sensor in a wet area (IMHO) defeats the point of a humidity sensor, so I set about looking for alternatives. After looking at several options, I found the Honeywell HIHxxxx sensors. Different models of the HIH line have different features and work over different ranges of humidity, but most of them use the same I2C protocol, which is now supported in Tasmota. Check the datasheets to compare sensors. One of the most critical features to look for is a hydrophobic filter which allows humid air through, but blocks water droplets from entering the sensor. This is listed on the datasheets as \"with filter,condensation resistant\". Also keep in mind the humidity range you'll be measuring. For my purposes (bathroom humidity sensor), there was a clear choice in the HIH7121-021 ( datasheet , non-affiliate direct link to product on Mouser , which works over a range of 0-100% RH, supports I2C, is accurate to within 3%, and has a hydrophobic filter. The article focuses on that sensor, but I suspect much of the information will be applicable to other HIHxxxx sensors. by @thepotoo","title":"Why the Honeywell HIH series sensors?"},{"location":"How-to-Expand-Sonoff-Basic-to-4MB-Flash/","text":"Heya, In this memo I'll describe how to expand the flash of a sonoff basic from 1MB to 4MB. The advantage for this change is, to avoid to double flash with the minimal and then with the normal firmware and to use more features like Webserver and SSL encryption. It was hard to find those information, I'll give credits to some users from the german CreationX Forum. Because to unsolder the flash isn't that easy as just solder in pins, this is only for advanced users . Don't forget, it's at your own risk and the device could be damaged permanently. The Hardware ~ Soldering iron Tin Tweezers The Flash ~ The origin flash block is a XTX PN25F08B 1725XDG. We exchange it with a WINBOND W25Q32FVSIG 1416. You can find the WINBOND Flash on eBay ( another ebay ) or AliExpress Those China flash memory ICs are cheap productions, means the chance to solder in a new defect not working flash block is high! Be ready to re-do the operation if the upload fails. If you want to test the flash block, build yourself a test module, something like this for easy soldering in a flash and test it before soldering it in another sonoff basics board. The Operation ~ You will notice that the LED is in the way. Get a pen and mark on of its Pin with the board, so you can solder it in back later in the correct Position. Its a Red-Green LED, if you solder it in the wrong way, it will light up in red. After the LED is out of the way, you give some tin on the pins from the flash block and connect all 4 pins in a row together with tin. This way it will be easier to desolder it, because you need to melt all pins at the same time. Now get a thin object between the flash and the board, try to gently lift the flash up and at the same time melt both rows of the flash pins tin rotatory. If you got enough space between the board and the flash change to the tweezers and finally take the flash block off. Now refresh the contacts on the board for the new flash block with a lil bit of fresh tin. Don't forget to give a lil bit tin to the new pins of the flash block, too! Now put it on the contacts on the board and try to lock it with the tweezers. Next take the solder iron and head just one pin and try to arrange the flashblock in the center now. Finally, heat and solder the other pins to the board. You can also use a hot air rework station, this would be much safer, but also more expensive ( Amazon ). Be sure to protect the rest of the board if using the heat gun! Good job, you are done :) Flashing ~ The next step is to tell Atom (i did not do it with Arduino IDE, sry) to use the whole new 4MB Flash. Note: You can only use 3MB, because 1MB is needed for SPIFFS. To do this, you need to edit the platformio.ini file. Search for your prefered language Block and copy the whole Block. Rename it to e.g. Sonoff-DE-4M Now change the following line build_flags = -Wl,-Tesp8266.flash.1m0.ld -DMY_LANGUAGE=de-DE to build_flags = -Wl,-Tesp8266.flash.4m1m.ld -DMY_LANGUAGE=de-DE Now scroll back to the top and enter a new default environment with the name of your newly created block env_default = sonoff-DE-4M You are done with the preparations, connect the Sonoff with the 4MB Flash in flash mode (hold button while powering it up), click clean, click build, click upload. Result ~ On the Information Page on the tasmota web interface you can now see the 4MB flash :)","title":"How to Expand Sonoff Basic to 4MB Flash"},{"location":"How-to-Expand-Sonoff-Basic-to-4MB-Flash/#the-hardware","text":"Soldering iron Tin Tweezers","title":"The Hardware"},{"location":"How-to-Expand-Sonoff-Basic-to-4MB-Flash/#the-flash","text":"The origin flash block is a XTX PN25F08B 1725XDG. We exchange it with a WINBOND W25Q32FVSIG 1416. You can find the WINBOND Flash on eBay ( another ebay ) or AliExpress Those China flash memory ICs are cheap productions, means the chance to solder in a new defect not working flash block is high! Be ready to re-do the operation if the upload fails. If you want to test the flash block, build yourself a test module, something like this for easy soldering in a flash and test it before soldering it in another sonoff basics board.","title":"The Flash"},{"location":"How-to-Expand-Sonoff-Basic-to-4MB-Flash/#the-operation","text":"You will notice that the LED is in the way. Get a pen and mark on of its Pin with the board, so you can solder it in back later in the correct Position. Its a Red-Green LED, if you solder it in the wrong way, it will light up in red. After the LED is out of the way, you give some tin on the pins from the flash block and connect all 4 pins in a row together with tin. This way it will be easier to desolder it, because you need to melt all pins at the same time. Now get a thin object between the flash and the board, try to gently lift the flash up and at the same time melt both rows of the flash pins tin rotatory. If you got enough space between the board and the flash change to the tweezers and finally take the flash block off. Now refresh the contacts on the board for the new flash block with a lil bit of fresh tin. Don't forget to give a lil bit tin to the new pins of the flash block, too! Now put it on the contacts on the board and try to lock it with the tweezers. Next take the solder iron and head just one pin and try to arrange the flashblock in the center now. Finally, heat and solder the other pins to the board. You can also use a hot air rework station, this would be much safer, but also more expensive ( Amazon ). Be sure to protect the rest of the board if using the heat gun! Good job, you are done :)","title":"The Operation"},{"location":"How-to-Expand-Sonoff-Basic-to-4MB-Flash/#flashing","text":"The next step is to tell Atom (i did not do it with Arduino IDE, sry) to use the whole new 4MB Flash. Note: You can only use 3MB, because 1MB is needed for SPIFFS. To do this, you need to edit the platformio.ini file. Search for your prefered language Block and copy the whole Block. Rename it to e.g. Sonoff-DE-4M Now change the following line build_flags = -Wl,-Tesp8266.flash.1m0.ld -DMY_LANGUAGE=de-DE to build_flags = -Wl,-Tesp8266.flash.4m1m.ld -DMY_LANGUAGE=de-DE Now scroll back to the top and enter a new default environment with the name of your newly created block env_default = sonoff-DE-4M You are done with the preparations, connect the Sonoff with the 4MB Flash in flash mode (hold button while powering it up), click clean, click build, click upload.","title":"Flashing"},{"location":"How-to-Expand-Sonoff-Basic-to-4MB-Flash/#result","text":"On the Information Page on the tasmota web interface you can now see the 4MB flash :)","title":"Result"},{"location":"How-to-Flash-the-RF-Bridge/","text":"Someone asked me on here a more detailed explanation of how to do this, so I thought I would post (as best as I can recall) how to do it with a Windows PC. The Sonoff RF Bridge firmware is uploaded Like any other ESP device. Please refer to the flashing instructions. Ensure the switch on your RF Bridge is switched of the OFF position (change it back to ON position AFTER flashing your Bridge). Connect up your USB serial adapter to the correct pins on the bridge. Hold DOWN the pairing button while connecting the USB serial adapter to your computer (the bridge should now go into the correct mode where you can flash it). (Pin out etc on the below image) At the top right of the Arduio IDE software, click on the right arrow (UPLOAD) to upload the firmware. This should take about 2-3 minutes as it compiles the firmware then uploads it. When compete, disconnect the cables etc, switch the switch back to the ON position (away from the 5 pin header) and it should now be working as you expect. Credits @erew123 #1841","title":"How to Flash the RF Bridge"},{"location":"I2CDevices/","text":"remoteMarkdownUrl","title":"I2C Devices"},{"location":"IP-Symcon/","text":"For users knowing more about integrating Tasmota with IP-Symcon please update this page. The Tasmota IP-Symcon interface can be found at https://github.com/Schnittcher/IPS-Tasmota There are currently two modules for IP Symcon Conditions ~ Mosquitto Broker MQTT Client - currently a modified version of IPS_MQTT by thomasf68 IP-Symcon version 4.1 or higher IPS-TasmotaConfigurator ~ With the configurator it is possible to generate automatically the IP Symcon instances for the Tasmota devices. IPS-Tasmota ~ With this Module it is possible to map devices that contain standard functions of the Tasmota firmware. For example: Sonoff Switch, Sonoff POW, Sonoff 4CH, Sonoff TH IPS-TasmotaLED ~ With the IPS-TasmotaLED module it is possible to map the LED modules that run with the Tasmota firmware. For example: WS2812, AiLight, Sonoff Led, B1, BN-SZ01, H801 and MagicHome Installation ~ Github Repositorys in IP Symcon via Core Instances -> Modules -> Add IPS-KS-MQTT Client: ~ https://github.com/Schnittcher/IPS-KS-MQTT.git IPS-Tasmota: ~ https://github.com/Schnittcher/IPS-Tasmota.git","title":"IP Symcon"},{"location":"IP-Symcon/#conditions","text":"Mosquitto Broker MQTT Client - currently a modified version of IPS_MQTT by thomasf68 IP-Symcon version 4.1 or higher","title":"Conditions"},{"location":"IP-Symcon/#ips-tasmotaconfigurator","text":"With the configurator it is possible to generate automatically the IP Symcon instances for the Tasmota devices.","title":"IPS-TasmotaConfigurator"},{"location":"IP-Symcon/#ips-tasmota","text":"With this Module it is possible to map devices that contain standard functions of the Tasmota firmware. For example: Sonoff Switch, Sonoff POW, Sonoff 4CH, Sonoff TH","title":"IPS-Tasmota"},{"location":"IP-Symcon/#ips-tasmotaled","text":"With the IPS-TasmotaLED module it is possible to map the LED modules that run with the Tasmota firmware. For example: WS2812, AiLight, Sonoff Led, B1, BN-SZ01, H801 and MagicHome","title":"IPS-TasmotaLED"},{"location":"IP-Symcon/#installation","text":"Github Repositorys in IP Symcon via Core Instances -> Modules -> Add","title":"Installation"},{"location":"IP-Symcon/#ips-ks-mqtt-client","text":"https://github.com/Schnittcher/IPS-KS-MQTT.git","title":"IPS-KS-MQTT Client:"},{"location":"IP-Symcon/#ips-tasmota_1","text":"https://github.com/Schnittcher/IPS-Tasmota.git","title":"IPS-Tasmota:"},{"location":"IR-Remote/","text":"IR Remote driver enables sending IR codes through an IR transmitter and receiving them through an IR receiver via IRremoteESP8266 library . Most builds support only most common IR protocols, but tasmota-ir.bin supports almost all protocols available in the IRremoteESP8266 library. IR Transmitter ~ Common transmitter modules in the market have a weak IR LED, thus effective transmit distance is really short. If you need range it is best to build your own . For the LED we recommend TSAL6400 for best performance. YT-IRTM transmitter/receiver board is serial only and does not work with this driver (its also limited to only NEC IR protocol). Wiring ~ IR w/ 2N222 ESP266 data GPIOx + 3.3v/5v - GND Tasmota ~ In the Configuration -> Configure Module page assign: - GPIOx to IRsend (8) See IR commands for use. IR Receiver ~ IR Receiver is used to capture IR codes. Those codes can be sent using IRSend or used as a rule trigger. Example uses the widely available KY-022 breakout board. Wiring ~ KY-022 ESP266 S GPIOx + 5v - GND Tasmota ~ In the Configuration -> Configure Module page assign: - GPIOx to IRrecv (51) On a captured code IR receiver sends a tele/%topic%/RESULT JSON reponse: { \"Time\" : \"2019-01-01T00:00:00\" , \"IrReceived\" : { \"Protocol\" : \"NEC\" , \"Bits\" : 32 , \"Data\" : \"0x00FF00FF\" } } Further Reading ~ This covers only the basic IR protocols. Read Complete IR Remote Protocols for more advanced applications. IR Send RAW configuration and use User maintained codes database for IR Linux Infrared Remote Control (LIRC) for more information. Related Projects ~ IR Blaster with Tasmota Sonoff Basic IR \"hat\" Example circuit with transmitter and receiver:","title":"IR Remote"},{"location":"IR-Remote/#ir-transmitter","text":"Common transmitter modules in the market have a weak IR LED, thus effective transmit distance is really short. If you need range it is best to build your own . For the LED we recommend TSAL6400 for best performance. YT-IRTM transmitter/receiver board is serial only and does not work with this driver (its also limited to only NEC IR protocol).","title":"IR Transmitter"},{"location":"IR-Remote/#wiring","text":"IR w/ 2N222 ESP266 data GPIOx + 3.3v/5v - GND","title":"Wiring"},{"location":"IR-Remote/#tasmota","text":"In the Configuration -> Configure Module page assign: - GPIOx to IRsend (8) See IR commands for use.","title":"Tasmota"},{"location":"IR-Remote/#ir-receiver","text":"IR Receiver is used to capture IR codes. Those codes can be sent using IRSend or used as a rule trigger. Example uses the widely available KY-022 breakout board.","title":"IR Receiver"},{"location":"IR-Remote/#wiring_1","text":"KY-022 ESP266 S GPIOx + 5v - GND","title":"Wiring"},{"location":"IR-Remote/#tasmota_1","text":"In the Configuration -> Configure Module page assign: - GPIOx to IRrecv (51) On a captured code IR receiver sends a tele/%topic%/RESULT JSON reponse: { \"Time\" : \"2019-01-01T00:00:00\" , \"IrReceived\" : { \"Protocol\" : \"NEC\" , \"Bits\" : 32 , \"Data\" : \"0x00FF00FF\" } }","title":"Tasmota"},{"location":"IR-Remote/#further-reading","text":"This covers only the basic IR protocols. Read Complete IR Remote Protocols for more advanced applications. IR Send RAW configuration and use User maintained codes database for IR Linux Infrared Remote Control (LIRC) for more information.","title":"Further Reading"},{"location":"IR-Remote/#related-projects","text":"IR Blaster with Tasmota Sonoff Basic IR \"hat\" Example circuit with transmitter and receiver:","title":"Related Projects"},{"location":"IRSend-RAW-Encoding/","text":"There are two command syntax forms for sending a remote control code in RAW format with IRsend : IRSend<x> <frequency>,<rawdata1>,<rawdata2>,..,<rawdataN> e.g., IRsend 0,926,844,958,832,1798,868,902,848,900,870,900,852,908,918,958,794,934,874,928,1738,934,856,1764 IRSend<x> raw,<frequency>[,<header_mark>,<header_space>,<bit_mark>],<zero_space>[, [<one_multiple>] | <one_space>],<bit_stream> Where Parameter Description <frequency> carrier frequency (default 0 = 38kHz) <header_mark> ** header mark duration (\u00b5s) (optional for some protocols) <header_space> ** header space duration (\u00b5s) (optional for some protocols) <bit_mark> bit mark duration (\u00b5s) (optional for some protocols) <zero_space> zero space duration (\u00b5s) <one_multiple> used to specify the one space duration if the one space duration is an integral multiple of the zero space duration. This parameter may be omitted if the multiple is 2. Use of this parameter is mutually exclusive with the <one_space> parameter <one_space> one space duration (\u00b5s). Use this parameter if the one space duration is not an integral multiple of <zero_space> Use of this parameter is mutually exclusive with the <one_multiple> parameter <bit_stream> bit stream data (stream of ones and zeroes) ** If header_mark and header_space are specified, the gap will be computed as (header_mark + header_space) * 3 with a high limit of 65ms (65,000\u00b5s) to avoid 16 bits overflow. If header_mark and header_space are not specified, the gap will be 40ms (40,000\u00b5s). This command syntax version makes use of the output of the raw IR decoder from ToniA/Raw-IR-decoder-for-Arduino Examples for bitstream command syntax ~ rawirdecode output: ~ Number of symbols: 75 Symbols: Hh010101101000111011001110000000001100110000000001100000000000000010001100 Bytes: 00: 0101|0110 | 6A | 01101010 01: 1000|1110 | 71 | 01110001 02: 1100|1110 | 73 | 01110011 03: 0000|0000 | 00 | 00000000 04: 1100|1100 | 33 | 00110011 05: 0000|0001 | 80 | 10000000 06: 1000|0000 | 01 | 00000001 07: 0000|0000 | 00 | 00000000 08: 1000|1100 | 31 | 00110001 6A,71,73,00,33,80,01,00,31 Timings (in us): PAUSE SPACE: 0 HEADER MARK: 8620 HEADER SPACE: 4260 BIT MARK: 544 ZERO SPACE: 411 ONE SPACE: 1496 Decoding known protocols... Unknown protocol Bytecount: 9 Corresponding command: IRSend<x> raw,0,8620,4260,544,411,1496,010101101000111011001110000000001100110000000001100000000000000010001100 Gree air conditioner Power On ~ {8956, 4560, 546, 1710, 588, 616, 584, 618, 584, 1712, 586, 1712, 588, 614, 586, 614, 586, 618, 586, 1706, 590, 616 , 586, 1708, 590, 616, 588, 610, 590, 612, 590, 612, 590, 618, 584, 618, 584, 616, 586, 614, 588, 612, 590, 612, 590, 1712, 586 , 616, 588, 612, 590, 614, 588, 614, 586, 618, 586, 616, 586, 1710, 588, 614, 586, 1708, 590, 610, 592, 612, 590, 1708, 588, 614 , 588, 20084, 548, 612, 590, 614, 588, 614, 588, 616, 586, 654, 546, 616, 586, 616, 586, 614, 588, 612, 588, 610, 592, 612, 590 , 612, 590, 614, 586, 1712, 586, 616, 586, 612, 588, 614, 588, 614, 586, 616, 586, 612, 590, 614, 588, 610, 590, 616, 586, 614 , 588, 612, 590, 612, 590, 614, 588, 614, 588, 614, 588, 1708, 590, 612, 590, 1708, 590} Arrange the data into pairs: MARK SPACE BIT 8956 4560 (header) 546 1710 1 588 616 0 584 618 0 584 1712 1 586 1712 1 588 614 0 586 614 0 ... 590 612 0 590 614 0 588 614 0 588 614 0 588 1708 1 590 612 0 590 1708 1 590 (ignore) The header is always the first pair, the zeroes have the shortest space duration and the ones have the longest space duration. header mark is 8956 header space is 4560 bit mark, get the average, say 590 zero space, say 615 one space, say 1710 Corresponding command: IRSend<x> raw,0,8956,4560,590,615,1710,1001100 ... 0000101 Understanding IR encoding ~ Below are several topics that may help you decoding and understanding what your IR remotes are sending (ex: HVAC) or convert from popular IR formats like PRONTO or Broadlink. First, have a look at the excellent article from Elektor IR Remote Control Codes Decoding IR codes by hand ~ From discussion with @johan1111 on Discord. Let's suppose you have an unsupported HVAL and record the following raw IR codes using Tasmota: [3094,3062,3092,4442,576,1652,578,528,576,1650,580,528,576,528,576,1650,...] IR messages typically start with a long Mark (IR on), followed by a long Space (IR off). Here we see a double sequence of Mark (3094 \u00b5s) - Space (3062 \u00b5s) - Mark (3092 \u00b5s) - Space (4442 \u00b5s). The actual bitstream is 576,1652,578,528,576,1650,580,528,576,528,576,1650,... . You need to take timing by pairs, again the first value is Mark (IR on), the second Space (IR off). The Mark is typically of constant time, and the space will vary from short (~528 \u00b5s) for bit 0 to long (~1650 \u00b5s) for bit 1 . So the first bits of the bitstream are: 101001... Pioneer IR enconding ~ Pioneer IR encoding is very similar to NEC encoding for the bitstream. When capturing IR codes, they will easily be recognized as NEC codes. But they have subtle differences. First, the Frequency if 40KHz for Pioneer vs 38KHz for NEC. The number of IR pulses are the same, so all Pioneer timings are 5% shorter than Nec equivalent. Most Pioneer will tolerate the difference, but some won't. If you have a Pioneer device, prefer the Pioneer encoding. Second, Pioneer introduced 64 bits messages vs 32 bits for NEC. Most simple Pioneer commands still use 32 bits, but newer require 64 bits. 64 bits messages are actually sent as 2x 32 bits messages with a very short pause in between. Example, Pioneer Vol+ is 32 bits message and must be sent twice. You can either send the same message 0xA55A50AF twice with IRSend2 or send a 64 bits message with twice the same 32 payload: 0xA55A50AFA55A50AF . IRSend2 {\"Protocol\":\"PIONEER\",\"Bits\":32,\"Data\":\"0xA55A50AF\"} or IRSend {\"Protocol\":\"PIONEER\",\"Bits\":64,\"Data\":\"0xA55A50AFA55A50AF\"} Example 2: Pioneer Stereo: IRSend {\"Protocol\":\"PIONEER\",\"Bits\":64,\"Data\":\"0xA55AF906A55A03FC\"} How to convert Pioneer codes to Tasmota ~ Pioneer kindly publishes all IR Codes online on its website. Let's take a Pioneer Receiver like VSX-820. Choose the right Excel file and navigate in the corresponding tab. Pioneer codes are in short format. For example \"TV / SAT\" code is A59B+A5CD . You now need to convert these short codes into 64 bits IRRemote8266 codes. Steps: 1. Take the first byte: 0xA5 or 0b10100101 . Pioneer codes are LSB, but we need MSB. So read backwards all bits to 0b10100101 and back to hex A5 . Your first byte is A5 . Note: You can see here that 0xA5 is a palindrome. 2. Invert all bits of previous byte: 0b01011010 . Your second byte is 5A . 3. Take the second byte 0x9B or 0b10011011 . Read backwards all bits giving 0b11011001. Your third byte is D9 . 4. Invert all bits from previous byte: 0b00100110 . Your fourth byte is 26 . Do the same with the second sequence A5CD , you should find the following sequence: A55AB3CD . The final sequence is: IRSend {\"Protocol\":\"PIONEER\",\"Bits\":64,\"Data\":\"0xA55AD926A55AB3CD\"} Converting Pronto IR codes to Tasmota ~ Pronto is a very common and early format to describe raw IR codes. It is fully described in this excellent series of articles The Pronto's IR Code Format Pronto is commonly represented as a series of 4-digits HEX numbers in unsigned 16-bits format. Example, from Foxtel Vol+: Vol + 0000 0073 0000 0012 000F 000A 0006 000A 0006 0016 0006 000A 0006 0010 0006 0016 0006 0016 0006 000A 0006 000A 0006 000A 0006 0016 0006 0010 0006 0016 0006 000A 0006 0010 0006 000A 0006 000A 0006 0CA0 To convert from Pronto to IRSend by hand it requires extra work. Ignore first 0000 0073 is the IR frequency, compute as \"Frequency = 1000000/(N * .241246)\". So for 0x73 (115), this gives 36KHz. First value for IRSend is 36 . 0000 is the length of the One Time Burst. There is no one time burst 0012 - Decimal 18 is the length of the repeat burst. There are 18 bits (Burst pairs) in this code. Next pulses are measured in pulses of the IR clock, so it depends on the frequency. With 36KHz, each pulse is (1000/36) 27.7 microseconds So you need to multiply by 27.7 for Tasmota to get actual \u00b5s 000F 000A - becomes 415,277 0006 000A - becomes 166,277 And so on... In the end, it will look like: IRSend 36,415,277,166,277,... Converting Broadlink IR codes to Tasmota ~ Broadlink is another popular device to send and receive IR/RF codes. Unfortunately, it does not run ESP8266, so it cannot be Tasmotized. Broadlink codes come either in Base64 format or in Hex format. Below will use Hex format which is easier to work by hand. Example: \"Code\": \"2600700000015692171117111612171116121612161117111735173517361636161117351735173517111636161216121611171116121612163616111735173517351735173517351700053D0001554916000C4E0001554916000C4E0001564817000C4D0001564917000C4C0001564917000D050000000000000000\", \"Base64\": \"JgBwAAABVpIXERcRFhIXERYSFhIWERcRFzUXNRc2FjYWERc1FzUXNRcRFjYWEhYSFhEXERYSFhIWNhYRFzUXNRc1FzUXNRc1FwAFPQABVUkWAAxOAAFVSRYADE4AAVZIFwAMTQABVkkXAAxMAAFWSRcADQUAAAAAAAAAAA== The Broadling protocol is described here: Broadlink RM2 network protocol Here is a copy of the part specifically describing Offset Contents 0x00 0x26 = IR, 0xb2 for RF 433Mhz, 0xd7 for RF 315Mhz 0x01 repeat count, (0 = no repeat, 1 send twice, .....) 0x02-0x03 Length of the following data in little endian 0x04 .... Pulse lengths in 2^-15 s units (\u00b5s * 269 / 8192 works very well) .... 0x0d 0x05 at the end for IR only Each value is represented by one byte. If the length exceeds one byte then it is stored big endian with a leading 0. Example: The header for an Optoma projector is 8920 4450 8920 * 269 / 8192 = 0x124 4450 * 269 / 8192 = 0x92 ... which would be encoded as 0x00 0x1 0x24 0x92 in broalink format. You have all the needed information to convert from Broadlink to Tasmota...","title":"IRSend RAW Encoding"},{"location":"IRSend-RAW-Encoding/#examples-for-bitstream-command-syntax","text":"","title":"Examples for bitstream command syntax"},{"location":"IRSend-RAW-Encoding/#rawirdecode-output","text":"Number of symbols: 75 Symbols: Hh010101101000111011001110000000001100110000000001100000000000000010001100 Bytes: 00: 0101|0110 | 6A | 01101010 01: 1000|1110 | 71 | 01110001 02: 1100|1110 | 73 | 01110011 03: 0000|0000 | 00 | 00000000 04: 1100|1100 | 33 | 00110011 05: 0000|0001 | 80 | 10000000 06: 1000|0000 | 01 | 00000001 07: 0000|0000 | 00 | 00000000 08: 1000|1100 | 31 | 00110001 6A,71,73,00,33,80,01,00,31 Timings (in us): PAUSE SPACE: 0 HEADER MARK: 8620 HEADER SPACE: 4260 BIT MARK: 544 ZERO SPACE: 411 ONE SPACE: 1496 Decoding known protocols... Unknown protocol Bytecount: 9 Corresponding command: IRSend<x> raw,0,8620,4260,544,411,1496,010101101000111011001110000000001100110000000001100000000000000010001100","title":"rawirdecode output:"},{"location":"IRSend-RAW-Encoding/#gree-air-conditioner-power-on","text":"{8956, 4560, 546, 1710, 588, 616, 584, 618, 584, 1712, 586, 1712, 588, 614, 586, 614, 586, 618, 586, 1706, 590, 616 , 586, 1708, 590, 616, 588, 610, 590, 612, 590, 612, 590, 618, 584, 618, 584, 616, 586, 614, 588, 612, 590, 612, 590, 1712, 586 , 616, 588, 612, 590, 614, 588, 614, 586, 618, 586, 616, 586, 1710, 588, 614, 586, 1708, 590, 610, 592, 612, 590, 1708, 588, 614 , 588, 20084, 548, 612, 590, 614, 588, 614, 588, 616, 586, 654, 546, 616, 586, 616, 586, 614, 588, 612, 588, 610, 592, 612, 590 , 612, 590, 614, 586, 1712, 586, 616, 586, 612, 588, 614, 588, 614, 586, 616, 586, 612, 590, 614, 588, 610, 590, 616, 586, 614 , 588, 612, 590, 612, 590, 614, 588, 614, 588, 614, 588, 1708, 590, 612, 590, 1708, 590} Arrange the data into pairs: MARK SPACE BIT 8956 4560 (header) 546 1710 1 588 616 0 584 618 0 584 1712 1 586 1712 1 588 614 0 586 614 0 ... 590 612 0 590 614 0 588 614 0 588 614 0 588 1708 1 590 612 0 590 1708 1 590 (ignore) The header is always the first pair, the zeroes have the shortest space duration and the ones have the longest space duration. header mark is 8956 header space is 4560 bit mark, get the average, say 590 zero space, say 615 one space, say 1710 Corresponding command: IRSend<x> raw,0,8956,4560,590,615,1710,1001100 ... 0000101","title":"Gree air conditioner Power On"},{"location":"IRSend-RAW-Encoding/#understanding-ir-encoding","text":"Below are several topics that may help you decoding and understanding what your IR remotes are sending (ex: HVAC) or convert from popular IR formats like PRONTO or Broadlink. First, have a look at the excellent article from Elektor IR Remote Control Codes","title":"Understanding IR encoding"},{"location":"IRSend-RAW-Encoding/#decoding-ir-codes-by-hand","text":"From discussion with @johan1111 on Discord. Let's suppose you have an unsupported HVAL and record the following raw IR codes using Tasmota: [3094,3062,3092,4442,576,1652,578,528,576,1650,580,528,576,528,576,1650,...] IR messages typically start with a long Mark (IR on), followed by a long Space (IR off). Here we see a double sequence of Mark (3094 \u00b5s) - Space (3062 \u00b5s) - Mark (3092 \u00b5s) - Space (4442 \u00b5s). The actual bitstream is 576,1652,578,528,576,1650,580,528,576,528,576,1650,... . You need to take timing by pairs, again the first value is Mark (IR on), the second Space (IR off). The Mark is typically of constant time, and the space will vary from short (~528 \u00b5s) for bit 0 to long (~1650 \u00b5s) for bit 1 . So the first bits of the bitstream are: 101001...","title":"Decoding IR codes by hand"},{"location":"IRSend-RAW-Encoding/#pioneer-ir-enconding","text":"Pioneer IR encoding is very similar to NEC encoding for the bitstream. When capturing IR codes, they will easily be recognized as NEC codes. But they have subtle differences. First, the Frequency if 40KHz for Pioneer vs 38KHz for NEC. The number of IR pulses are the same, so all Pioneer timings are 5% shorter than Nec equivalent. Most Pioneer will tolerate the difference, but some won't. If you have a Pioneer device, prefer the Pioneer encoding. Second, Pioneer introduced 64 bits messages vs 32 bits for NEC. Most simple Pioneer commands still use 32 bits, but newer require 64 bits. 64 bits messages are actually sent as 2x 32 bits messages with a very short pause in between. Example, Pioneer Vol+ is 32 bits message and must be sent twice. You can either send the same message 0xA55A50AF twice with IRSend2 or send a 64 bits message with twice the same 32 payload: 0xA55A50AFA55A50AF . IRSend2 {\"Protocol\":\"PIONEER\",\"Bits\":32,\"Data\":\"0xA55A50AF\"} or IRSend {\"Protocol\":\"PIONEER\",\"Bits\":64,\"Data\":\"0xA55A50AFA55A50AF\"} Example 2: Pioneer Stereo: IRSend {\"Protocol\":\"PIONEER\",\"Bits\":64,\"Data\":\"0xA55AF906A55A03FC\"}","title":"Pioneer IR enconding"},{"location":"IRSend-RAW-Encoding/#how-to-convert-pioneer-codes-to-tasmota","text":"Pioneer kindly publishes all IR Codes online on its website. Let's take a Pioneer Receiver like VSX-820. Choose the right Excel file and navigate in the corresponding tab. Pioneer codes are in short format. For example \"TV / SAT\" code is A59B+A5CD . You now need to convert these short codes into 64 bits IRRemote8266 codes. Steps: 1. Take the first byte: 0xA5 or 0b10100101 . Pioneer codes are LSB, but we need MSB. So read backwards all bits to 0b10100101 and back to hex A5 . Your first byte is A5 . Note: You can see here that 0xA5 is a palindrome. 2. Invert all bits of previous byte: 0b01011010 . Your second byte is 5A . 3. Take the second byte 0x9B or 0b10011011 . Read backwards all bits giving 0b11011001. Your third byte is D9 . 4. Invert all bits from previous byte: 0b00100110 . Your fourth byte is 26 . Do the same with the second sequence A5CD , you should find the following sequence: A55AB3CD . The final sequence is: IRSend {\"Protocol\":\"PIONEER\",\"Bits\":64,\"Data\":\"0xA55AD926A55AB3CD\"}","title":"How to convert Pioneer codes to Tasmota"},{"location":"IRSend-RAW-Encoding/#converting-pronto-ir-codes-to-tasmota","text":"Pronto is a very common and early format to describe raw IR codes. It is fully described in this excellent series of articles The Pronto's IR Code Format Pronto is commonly represented as a series of 4-digits HEX numbers in unsigned 16-bits format. Example, from Foxtel Vol+: Vol + 0000 0073 0000 0012 000F 000A 0006 000A 0006 0016 0006 000A 0006 0010 0006 0016 0006 0016 0006 000A 0006 000A 0006 000A 0006 0016 0006 0010 0006 0016 0006 000A 0006 0010 0006 000A 0006 000A 0006 0CA0 To convert from Pronto to IRSend by hand it requires extra work. Ignore first 0000 0073 is the IR frequency, compute as \"Frequency = 1000000/(N * .241246)\". So for 0x73 (115), this gives 36KHz. First value for IRSend is 36 . 0000 is the length of the One Time Burst. There is no one time burst 0012 - Decimal 18 is the length of the repeat burst. There are 18 bits (Burst pairs) in this code. Next pulses are measured in pulses of the IR clock, so it depends on the frequency. With 36KHz, each pulse is (1000/36) 27.7 microseconds So you need to multiply by 27.7 for Tasmota to get actual \u00b5s 000F 000A - becomes 415,277 0006 000A - becomes 166,277 And so on... In the end, it will look like: IRSend 36,415,277,166,277,...","title":"Converting Pronto IR codes to Tasmota"},{"location":"IRSend-RAW-Encoding/#converting-broadlink-ir-codes-to-tasmota","text":"Broadlink is another popular device to send and receive IR/RF codes. Unfortunately, it does not run ESP8266, so it cannot be Tasmotized. Broadlink codes come either in Base64 format or in Hex format. Below will use Hex format which is easier to work by hand. Example: \"Code\": \"2600700000015692171117111612171116121612161117111735173517361636161117351735173517111636161216121611171116121612163616111735173517351735173517351700053D0001554916000C4E0001554916000C4E0001564817000C4D0001564917000C4C0001564917000D050000000000000000\", \"Base64\": \"JgBwAAABVpIXERcRFhIXERYSFhIWERcRFzUXNRc2FjYWERc1FzUXNRcRFjYWEhYSFhEXERYSFhIWNhYRFzUXNRc1FzUXNRc1FwAFPQABVUkWAAxOAAFVSRYADE4AAVZIFwAMTQABVkkXAAxMAAFWSRcADQUAAAAAAAAAAA== The Broadling protocol is described here: Broadlink RM2 network protocol Here is a copy of the part specifically describing Offset Contents 0x00 0x26 = IR, 0xb2 for RF 433Mhz, 0xd7 for RF 315Mhz 0x01 repeat count, (0 = no repeat, 1 send twice, .....) 0x02-0x03 Length of the following data in little endian 0x04 .... Pulse lengths in 2^-15 s units (\u00b5s * 269 / 8192 works very well) .... 0x0d 0x05 at the end for IR only Each value is represented by one byte. If the length exceeds one byte then it is stored big endian with a leading 0. Example: The header for an Optoma projector is 8920 4450 8920 * 269 / 8192 = 0x124 4450 * 269 / 8192 = 0x92 ... which would be encoded as 0x00 0x1 0x24 0x92 in broalink format. You have all the needed information to convert from Broadlink to Tasmota...","title":"Converting Broadlink IR codes to Tasmota"},{"location":"Initial-Configuration/","text":"You've successfully flashed your device with a downloaded binary of Tasmota but now you need to connect the tasmotised device to your Wi-Fi network. Using Web UI ~ Configure Wi-Fi ~ Tasmota provides a wireless access point for easy Wi-Fi configuration. !> If you flashed using Tuya Convert this is the only option to set up your device. Connect your device to a power source and grab your smartphone (or tablet or laptop or any other web and Wi-Fi capable device). Search for a Wi-Fi AP named tasmota-xxxx (where xxxx is a number) and connect to it. In this example the Wi-Fi AP is named tasmota-7718 . When it connects to the network, you may get a warning that there is no Internet connection and be prompted to connect to a different network. Do not allow the mobile device to select a different network . ?> Wi-Fi manager server is active for only 3 minutes. If you miss the window you might have to disconnect your device from power and reconnect. After you have connected to the Tasmota Wi-Fi AP, open http://192.168.4.1 in a web browser on the smartphone (or whatever device you used). Depending on the phone, it will take you to the Tasmota configuration page automatically, or you will get a prompt to sign in to Wi-Fi network or authorize . Tapping on the AP name should also open the configuration page. At this page you can have Tasmota scan for available Wi-Fi networks. Select the right network from the list or enter the following: AP1 SSid - your Wi-Fi network name SSID's are case sensitive AP1 Password - password for your Wi-Fi AP Wi-Fi password has to be under 32 characters and without special characters (e.g. asterisks) or white spaces Recommended: AP2 SSid - alternative Wi-Fi network SSID AP2 Password - password for your alternative Wi-Fi AP Click the checkbox to see the password you enter to ensure that it is correct and that your mobile device has not inadvertently capitalized the first letter if it is supposed to be lower case nor autocorrected what you entered. ~~Double~~ Triple check the Wi-Fi credentials and click on Save to apply the settings. The device will restart and connect to your home network. The tasmota-xxxx network will not longer be present. Therefore your smartphone will automatically be disconnected and should connect back to its data network. [!TIP] If you're not using a second Wi-Fi network you can enter an SSID without a password you can connect to as a backup in case something went wrong with your Wi-Fi credentials. Configure MQTT ~ Look in your router for a newly connected device with the same name as the Wi-Fi access point. (In this example * tasmota-7718* .) If you don't have access to your router you can find your newly flashed device with an IP scanner: * Fing - for Android or iOS * Angry IP Scanner - open source for Linux, Windows and Mac. Requires Java. * Super Scan - Windows only too (free) * Tasmota Device Locator - Browser-based Open the IP address with your web browser and you have full access to Tasmota. Now is the time to set up MQTT and the last remaining, but equally important, step: Configure Module or Template ~ Configure your device using Templates in Configuration - Configure Template or Modules in Configuration - Configure Module . Your device running Tasmota is now ready to be controlled , automated or integrated in your smart home solution. Using Serial Terminal ~ If you flashed the device using serial-to-USB adapter (or it is a NodeMCU/D1 mini) you can take advantage of the existing connection and configure your device over the serial connection using Commands . First you will need a Serial Terminal program. In this example Termite on Windows is used. Download Termite and extract the .exe file, no installation necessary. Connect your serial-to-USB adapter or NodeMCU/D1 mini to the computer. Open Termite and set it to the proper COM port ( Termite selects the first available port by default ). Set Baud rate to 115200 and Forward to none. Connect your device to the serial-to-USB adapter. You should see the initial boot output in Termite. If your screen is empty type status in the bottom command bar and hit enter. If you get a return message from your device similar to the one displayed under purple status you're all set. To configure Tasmota you need to issue commands, some commands will reboot your device and to avoid that we will use the Backlog command feature. Configure your Wi-Fi network and a secondary Wi-Fi network Backlog ssid1 <yourssid>; password1 <your_password>; ssid2 <your_ssid2>; password2 <your_password> Device will restart and connect to your network. It will display your devices newly assigned IP. Direct your web browser to that IP address to access the Web UI for further configuration and contol. Configure MQTT broker address, MQTT credentials, unique device topic and OTA url to the latest official release Backlog mqtthost <yourhost>; mqttuser <user>; mqttpassword <password>; topic <unique_topic>; otaurl http://thehackbox.org/tasmota/release/tasmota.bin [!TIP] Keep your personal configuration in a text file and simply copy and paste the backlog commands to a newly flashed device. Commands and Backlog are powerful and in time you can learn to configure almost everything (NTP servers, longitude and latitude, custom device options, etc) with a few copy and paste moves. Your device is connected to your network and to the MQTT broker. One last thing to do is configure your device using Templates in Configuration - Configure Template or Modules in Configuration - Configure Module . Search for your device configuration template in our Device Templates Repository","title":"Initial Configuration"},{"location":"Initial-Configuration/#using-web-ui","text":"","title":"Using Web UI"},{"location":"Initial-Configuration/#configure-wi-fi","text":"Tasmota provides a wireless access point for easy Wi-Fi configuration. !> If you flashed using Tuya Convert this is the only option to set up your device. Connect your device to a power source and grab your smartphone (or tablet or laptop or any other web and Wi-Fi capable device). Search for a Wi-Fi AP named tasmota-xxxx (where xxxx is a number) and connect to it. In this example the Wi-Fi AP is named tasmota-7718 . When it connects to the network, you may get a warning that there is no Internet connection and be prompted to connect to a different network. Do not allow the mobile device to select a different network . ?> Wi-Fi manager server is active for only 3 minutes. If you miss the window you might have to disconnect your device from power and reconnect. After you have connected to the Tasmota Wi-Fi AP, open http://192.168.4.1 in a web browser on the smartphone (or whatever device you used). Depending on the phone, it will take you to the Tasmota configuration page automatically, or you will get a prompt to sign in to Wi-Fi network or authorize . Tapping on the AP name should also open the configuration page. At this page you can have Tasmota scan for available Wi-Fi networks. Select the right network from the list or enter the following: AP1 SSid - your Wi-Fi network name SSID's are case sensitive AP1 Password - password for your Wi-Fi AP Wi-Fi password has to be under 32 characters and without special characters (e.g. asterisks) or white spaces Recommended: AP2 SSid - alternative Wi-Fi network SSID AP2 Password - password for your alternative Wi-Fi AP Click the checkbox to see the password you enter to ensure that it is correct and that your mobile device has not inadvertently capitalized the first letter if it is supposed to be lower case nor autocorrected what you entered. ~~Double~~ Triple check the Wi-Fi credentials and click on Save to apply the settings. The device will restart and connect to your home network. The tasmota-xxxx network will not longer be present. Therefore your smartphone will automatically be disconnected and should connect back to its data network. [!TIP] If you're not using a second Wi-Fi network you can enter an SSID without a password you can connect to as a backup in case something went wrong with your Wi-Fi credentials.","title":"Configure Wi-Fi"},{"location":"Initial-Configuration/#configure-mqtt","text":"Look in your router for a newly connected device with the same name as the Wi-Fi access point. (In this example * tasmota-7718* .) If you don't have access to your router you can find your newly flashed device with an IP scanner: * Fing - for Android or iOS * Angry IP Scanner - open source for Linux, Windows and Mac. Requires Java. * Super Scan - Windows only too (free) * Tasmota Device Locator - Browser-based Open the IP address with your web browser and you have full access to Tasmota. Now is the time to set up MQTT and the last remaining, but equally important, step:","title":"Configure MQTT"},{"location":"Initial-Configuration/#configure-module-or-template","text":"Configure your device using Templates in Configuration - Configure Template or Modules in Configuration - Configure Module . Your device running Tasmota is now ready to be controlled , automated or integrated in your smart home solution.","title":"Configure Module or Template"},{"location":"Initial-Configuration/#using-serial-terminal","text":"If you flashed the device using serial-to-USB adapter (or it is a NodeMCU/D1 mini) you can take advantage of the existing connection and configure your device over the serial connection using Commands . First you will need a Serial Terminal program. In this example Termite on Windows is used. Download Termite and extract the .exe file, no installation necessary. Connect your serial-to-USB adapter or NodeMCU/D1 mini to the computer. Open Termite and set it to the proper COM port ( Termite selects the first available port by default ). Set Baud rate to 115200 and Forward to none. Connect your device to the serial-to-USB adapter. You should see the initial boot output in Termite. If your screen is empty type status in the bottom command bar and hit enter. If you get a return message from your device similar to the one displayed under purple status you're all set. To configure Tasmota you need to issue commands, some commands will reboot your device and to avoid that we will use the Backlog command feature. Configure your Wi-Fi network and a secondary Wi-Fi network Backlog ssid1 <yourssid>; password1 <your_password>; ssid2 <your_ssid2>; password2 <your_password> Device will restart and connect to your network. It will display your devices newly assigned IP. Direct your web browser to that IP address to access the Web UI for further configuration and contol. Configure MQTT broker address, MQTT credentials, unique device topic and OTA url to the latest official release Backlog mqtthost <yourhost>; mqttuser <user>; mqttpassword <password>; topic <unique_topic>; otaurl http://thehackbox.org/tasmota/release/tasmota.bin [!TIP] Keep your personal configuration in a text file and simply copy and paste the backlog commands to a newly flashed device. Commands and Backlog are powerful and in time you can learn to configure almost everything (NTP servers, longitude and latitude, custom device options, etc) with a few copy and paste moves. Your device is connected to your network and to the MQTT broker. One last thing to do is configure your device using Templates in Configuration - Configure Template or Modules in Configuration - Configure Module . Search for your device configuration template in our Device Templates Repository","title":"Using Serial Terminal"},{"location":"Integrations/","text":"Introduction ~ Tasmota easily integrates with many home automation solutions reporting status and sensor data and allowing complete control.","title":"Introduction"},{"location":"Integrations/#introduction","text":"Tasmota easily integrates with many home automation solutions reporting status and sensor data and allowing complete control.","title":"Introduction"},{"location":"JSON-Status-Responses/","text":"Table of Contents ~ JSON Changes Basic Response MQTT Domoticz POW Sensors AM2301 BMP280 DHT11 DS18B20 SHT3X (and DHT11, multiple Sensor example) Sonoff SC PMS5003 and HTU21 JSON Changes ~ temp note: for now (6.0.0a) the statetext overwrites the json power result (e.g. \"ON\" => \"AN\" or any other statetext the users enter) Basic Response ~ { \"Status\": { \"Module\": 1, \"FriendlyName\": \"XXX\", \"Topic\": \"sonoff\", \"ButtonTopic\": \"0\", \"Power\": 0, \"PowerOnState\": 0, \"LedState\": 1, \"SaveData\": 0, \"SaveState\": 1, \"ButtonRetain\": 0, \"PowerRetain\": 0 }, \"StatusPRM\": { \"Baudrate\": 115200, \"GroupTopic\": \"sonoffs\", \"OtaUrl\": \"XXX\", \"Uptime\": \"1 02:33:26\", \"Sleep\": 150, \"BootCount\": 32, \"SaveCount\": 72, \"SaveAddress\": \"FB000\" }, \"StatusFWR\": { \"Version\": \"5.12.0a\", \"BuildDateTime\": \"2018.02.11 16:15:40\", \"Boot\": 31, \"Core\": \"2_4_0\", \"SDK\": \"2.1.0(deb1901)\" }, \"StatusLOG\": { \"SerialLog\": 0, \"WebLog\": 4, \"SysLog\": 0, \"LogHost\": \"domus1\", \"LogPort\": 514, \"SSId1\": \"XXX\", \"SSId2\": \"XXX\", \"TelePeriod\": 300, \"SetOption\": \"00000001\" }, \"StatusMEM\": { \"ProgramSize\": 457, \"Free\": 544, \"Heap\": 23, \"ProgramFlashSize\": 1024, \"FlashSize\": 1024, \"FlashMode\": 3 }, \"StatusNET\": { \"Hostname\": \"XXX\", \"IPAddress\": \"192.168.178.XX\", \"Gateway\": \"192.168.178.XX\", \"Subnetmask\": \"255.255.255.XX\", \"DNSServer\": \"192.168.178.XX\", \"Mac\": \"2C:3A:E8:XX:XX:XX\", \"Webserver\": 2, \"WifiConfig\": 4 }, \"StatusTIM\": { \"UTC\": \"Thu Feb 15 00:00:50 2018\", \"Local\": \"Thu Feb 15 01:00:50 2018\", \"StartDST\": \"Sun Mar 25 02:00:00 2018\", \"EndDST\": \"Sun Oct 28 03:00:00 2018\", \"Timezone\": 1 }, \"StatusSNS\": { \"Time\": \"2018.02.15 01:00:50\", \"Switch1\": \"OFF\" }, \"StatusSTS\": { \"Time\": \"2018.02.15 01:00:50\", \"Uptime\": \"1 02:33:26\", \"Vcc\": 3.504, \"POWER\": \"OFF\", \"Wifi\": { \"AP\": 1, \"SSId\": \"XXX\", \"RSSI\": 100, \"APMac\": \"34:31:C4:XX:XX:XX\" } } } MQTT ~ After StatusNET \"StatusMQT\": { \"MqttHost\": \"192.168.XXX.XX\", \"MqttPort\": 1883, \"MqttClientMask\": \"DVES_%06X\", \"MqttClient\": \"DVES_4AXXXX\", \"MqttUser\": \"admin\", \"MAX_PACKET_SIZE\": 1000, \"KEEPALIVE\": 15 }, Domoticz ~ idx, nvalue, svalue without array ...\"StatusTIM\": { \"UTC\": \"Thu Feb 01 20:29:40 2018\", \"Local\": \"Thu Feb 01 21:29:40 2018\", \"StartDST\": \"Sun Mar 25 02:00:00 2018\", \"EndDST\": \"Sun Oct 28 03:00:00 2018\", \"Timezone\": 1 }, \"idx\": 286, \"nvalue\": 0, \"svalue\": \"19.7\", \"StatusSNS\": { \"Time\": \"2018.02.01 21:29:40\", \"DS18B20\": { \"Temperature\": 19.7 }, \"TempUnit\": \"C\" }, \"StatusSTS\": { ... POW ~ After StatusTIM \"StatusPTH\": { \"PowerLow\": 0, \"PowerHigh\": 0, \"VoltageLow\": 0, \"VoltageHigh\": 0, \"CurrentLow\": 0, \"CurrentHigh\": 0 }, \"StatusSNS\": { \"Time\": \"2018.02.04 23:17:01\", \"ENERGY\": { \"Total\": 3.185, \"Yesterday\": 3.058, \"Today\": 0.127, \"Power\": 0, \"Factor\": 0.00, \"Voltage\": 221, \"Current\": 0.000 } }, Back to Top Sensors ~ AM2301 ~ \"StatusSNS\": { \"Time\": \"2018.02.01 22:52:09\", \"AM2301\": { \"Temperature\": 15.5, \"Humidity\": 50.6 }, \"TempUnit\": \"C\" }, BMP280 ~ { \"StatusSNS\": { \"Time\": \"2018-02-10T22:46:34\", \"BMP280\": { \"Temperature\": 80.9, \"Pressure\": 984.4 } } } DHT11 ~ \"StatusSNS\": { \"Time\": \"2018.02.01 22:48:39\", \"DHT11\": { \"Temperature\": 12.0, \"Humidity\": 42.0 }, \"TempUnit\": \"C\" }, DS18B20 ~ \"StatusSNS\": { \"Time\": \"2018.02.01 21:29:40\", \"DS18B20\": { \"Temperature\": 19.7 }, \"TempUnit\": \"C\" }, SHT3X (and DHT11, multiple Sensor example) ~ { \"StatusSNS\": { \"Time\": \"2018-02-07T20:16:19\", \"DHT11\": { \"Temperature\": 78.8, \"Humidity\": 27.0 }, \"SHT3X\": { \"Temperature\": 74.8, \"Humidity\": 18.9 }, \"TempUnit\": \"F\" } } Sonoff SC ~ \"StatusSNS\": { \"Time\": \"2018-02-16T16:18:49\", \"Temperature\": 25, \"Humidity\": 83, \"Light\": 10, \"Noise\": 20, \"AirQuality\": 100, \"TempUnit\": \"C\" }, PMS5003 and HTU21 ~ \"StatusSNS\": { \"Time\": \"2018-02-16T16:22:12\", \"HTU21\": { \"Temperature\": 24.7, \"Humidity\": 32.1 }, \"PMS5003\": { \"CF1\": 1, \"CF2.5\": 2, \"CF10\": 2, \"PM1\": 1, \"PM2.5\": 2, \"PM10\": 2, \"PB0.3\": 423, \"PB0.5\": 116, \"PB1\": 17, \"PB2.5\": 1, \"PB5\": 0, \"PB10\": 0 }, \"TempUnit\": \"C\" }, Back to Top","title":"Table of Contents"},{"location":"JSON-Status-Responses/#table-of-contents","text":"JSON Changes Basic Response MQTT Domoticz POW Sensors AM2301 BMP280 DHT11 DS18B20 SHT3X (and DHT11, multiple Sensor example) Sonoff SC PMS5003 and HTU21","title":"Table of Contents"},{"location":"JSON-Status-Responses/#json-changes","text":"temp note: for now (6.0.0a) the statetext overwrites the json power result (e.g. \"ON\" => \"AN\" or any other statetext the users enter)","title":"JSON Changes"},{"location":"JSON-Status-Responses/#basic-response","text":"{ \"Status\": { \"Module\": 1, \"FriendlyName\": \"XXX\", \"Topic\": \"sonoff\", \"ButtonTopic\": \"0\", \"Power\": 0, \"PowerOnState\": 0, \"LedState\": 1, \"SaveData\": 0, \"SaveState\": 1, \"ButtonRetain\": 0, \"PowerRetain\": 0 }, \"StatusPRM\": { \"Baudrate\": 115200, \"GroupTopic\": \"sonoffs\", \"OtaUrl\": \"XXX\", \"Uptime\": \"1 02:33:26\", \"Sleep\": 150, \"BootCount\": 32, \"SaveCount\": 72, \"SaveAddress\": \"FB000\" }, \"StatusFWR\": { \"Version\": \"5.12.0a\", \"BuildDateTime\": \"2018.02.11 16:15:40\", \"Boot\": 31, \"Core\": \"2_4_0\", \"SDK\": \"2.1.0(deb1901)\" }, \"StatusLOG\": { \"SerialLog\": 0, \"WebLog\": 4, \"SysLog\": 0, \"LogHost\": \"domus1\", \"LogPort\": 514, \"SSId1\": \"XXX\", \"SSId2\": \"XXX\", \"TelePeriod\": 300, \"SetOption\": \"00000001\" }, \"StatusMEM\": { \"ProgramSize\": 457, \"Free\": 544, \"Heap\": 23, \"ProgramFlashSize\": 1024, \"FlashSize\": 1024, \"FlashMode\": 3 }, \"StatusNET\": { \"Hostname\": \"XXX\", \"IPAddress\": \"192.168.178.XX\", \"Gateway\": \"192.168.178.XX\", \"Subnetmask\": \"255.255.255.XX\", \"DNSServer\": \"192.168.178.XX\", \"Mac\": \"2C:3A:E8:XX:XX:XX\", \"Webserver\": 2, \"WifiConfig\": 4 }, \"StatusTIM\": { \"UTC\": \"Thu Feb 15 00:00:50 2018\", \"Local\": \"Thu Feb 15 01:00:50 2018\", \"StartDST\": \"Sun Mar 25 02:00:00 2018\", \"EndDST\": \"Sun Oct 28 03:00:00 2018\", \"Timezone\": 1 }, \"StatusSNS\": { \"Time\": \"2018.02.15 01:00:50\", \"Switch1\": \"OFF\" }, \"StatusSTS\": { \"Time\": \"2018.02.15 01:00:50\", \"Uptime\": \"1 02:33:26\", \"Vcc\": 3.504, \"POWER\": \"OFF\", \"Wifi\": { \"AP\": 1, \"SSId\": \"XXX\", \"RSSI\": 100, \"APMac\": \"34:31:C4:XX:XX:XX\" } } }","title":"Basic Response"},{"location":"JSON-Status-Responses/#mqtt","text":"After StatusNET \"StatusMQT\": { \"MqttHost\": \"192.168.XXX.XX\", \"MqttPort\": 1883, \"MqttClientMask\": \"DVES_%06X\", \"MqttClient\": \"DVES_4AXXXX\", \"MqttUser\": \"admin\", \"MAX_PACKET_SIZE\": 1000, \"KEEPALIVE\": 15 },","title":"MQTT"},{"location":"JSON-Status-Responses/#domoticz","text":"idx, nvalue, svalue without array ...\"StatusTIM\": { \"UTC\": \"Thu Feb 01 20:29:40 2018\", \"Local\": \"Thu Feb 01 21:29:40 2018\", \"StartDST\": \"Sun Mar 25 02:00:00 2018\", \"EndDST\": \"Sun Oct 28 03:00:00 2018\", \"Timezone\": 1 }, \"idx\": 286, \"nvalue\": 0, \"svalue\": \"19.7\", \"StatusSNS\": { \"Time\": \"2018.02.01 21:29:40\", \"DS18B20\": { \"Temperature\": 19.7 }, \"TempUnit\": \"C\" }, \"StatusSTS\": { ...","title":"Domoticz"},{"location":"JSON-Status-Responses/#pow","text":"After StatusTIM \"StatusPTH\": { \"PowerLow\": 0, \"PowerHigh\": 0, \"VoltageLow\": 0, \"VoltageHigh\": 0, \"CurrentLow\": 0, \"CurrentHigh\": 0 }, \"StatusSNS\": { \"Time\": \"2018.02.04 23:17:01\", \"ENERGY\": { \"Total\": 3.185, \"Yesterday\": 3.058, \"Today\": 0.127, \"Power\": 0, \"Factor\": 0.00, \"Voltage\": 221, \"Current\": 0.000 } }, Back to Top","title":"POW"},{"location":"JSON-Status-Responses/#sensors","text":"","title":"Sensors"},{"location":"JSON-Status-Responses/#am2301","text":"\"StatusSNS\": { \"Time\": \"2018.02.01 22:52:09\", \"AM2301\": { \"Temperature\": 15.5, \"Humidity\": 50.6 }, \"TempUnit\": \"C\" },","title":"AM2301"},{"location":"JSON-Status-Responses/#bmp280","text":"{ \"StatusSNS\": { \"Time\": \"2018-02-10T22:46:34\", \"BMP280\": { \"Temperature\": 80.9, \"Pressure\": 984.4 } } }","title":"BMP280"},{"location":"JSON-Status-Responses/#dht11","text":"\"StatusSNS\": { \"Time\": \"2018.02.01 22:48:39\", \"DHT11\": { \"Temperature\": 12.0, \"Humidity\": 42.0 }, \"TempUnit\": \"C\" },","title":"DHT11"},{"location":"JSON-Status-Responses/#ds18b20","text":"\"StatusSNS\": { \"Time\": \"2018.02.01 21:29:40\", \"DS18B20\": { \"Temperature\": 19.7 }, \"TempUnit\": \"C\" },","title":"DS18B20"},{"location":"JSON-Status-Responses/#sht3x-and-dht11-multiple-sensor-example","text":"{ \"StatusSNS\": { \"Time\": \"2018-02-07T20:16:19\", \"DHT11\": { \"Temperature\": 78.8, \"Humidity\": 27.0 }, \"SHT3X\": { \"Temperature\": 74.8, \"Humidity\": 18.9 }, \"TempUnit\": \"F\" } }","title":"SHT3X (and DHT11, multiple Sensor example)"},{"location":"JSON-Status-Responses/#sonoff-sc","text":"\"StatusSNS\": { \"Time\": \"2018-02-16T16:18:49\", \"Temperature\": 25, \"Humidity\": 83, \"Light\": 10, \"Noise\": 20, \"AirQuality\": 100, \"TempUnit\": \"C\" },","title":"Sonoff SC"},{"location":"JSON-Status-Responses/#pms5003-and-htu21","text":"\"StatusSNS\": { \"Time\": \"2018-02-16T16:22:12\", \"HTU21\": { \"Temperature\": 24.7, \"Humidity\": 32.1 }, \"PMS5003\": { \"CF1\": 1, \"CF2.5\": 2, \"CF10\": 2, \"PM1\": 1, \"PM2.5\": 2, \"PM10\": 2, \"PB0.3\": 423, \"PB0.5\": 116, \"PB1\": 17, \"PB2.5\": 1, \"PB5\": 0, \"PB10\": 0 }, \"TempUnit\": \"C\" }, Back to Top","title":"PMS5003 and HTU21"},{"location":"KNX/","text":"!> This feature is included only in tasmota-knx build. To use in other builds you must compile your own build . Add the following to user_config_override.h : #ifndef USE_KNX #define USE_KNX // Enable KNX IP Protocol Support (+9.4k code, +3k7 mem) #endif What is KNX? ~ The KNX IP Protocol is an international open standard for smart homes and smart buildings automation. It is a decentralized system. Each device can talk directly to each other without the need of a central controller or server. Any panel or server is just for telesupervision and for sending requests. KNX IP Protocol uses a UDP multicast on 224.0.23.12 : 3671 , so there is no need for a KNX Router unless you want to communicate to KNX Devices that are not in the WIFI Network (Twisted Pair, RF, Powerline). Each device has a physical address (like a fixed IP) as 1 . 1 . 0 and that address is used for configuration purposes. Each device can be configured with group addresses as 2 / 2 / 1 and that address can be used for sending/receiving commands. So, for example, if 2 devices that are configured with the 2 / 2 / 1 for turning on/off their outputs, and other device send Turn ON command to 2 / 2 / 1 , both devices will turn on their outputs. Integration ~ Several home automation systems have KNX support. For example, Home Assistant has a XKNX Python Library to connect to KNX devices using a KNX Router. If you don't have a KNX Router , you can use a Software KNX Router like KNXd on the same Raspberry Pi than Home Assistant. KNXd is used by Home Assistant for reading this UDP Multicast, although KNXd has other cool features that need extra hardware like connect to KNX devices by Twister Pair, Power Line or RF. If using the Home Assistant distribution called Hassio , everything for KNX is already included by default. If you use the ETS (KNX Configurator Software) you can add any TasmotaTasmota KNX as a dummy device. If the Tasmotadevice is connecting to a Wifi Repeater you might experience some issues receiving KNX Telegrams. This also applies to mDNS and Emulation features. Also, if using KNX IP Protocol, sleep needs to be 0 in order to avoid losing any telegram. Implemented Features ~ The implemented features, up to now, in KNX for Tasmota are: General: * buttons (just push) * relays (on/off/toggle) * lights (led strips, etc. but just on/off) Sensor lists that you can use in KNX is (only one sensor per type): * Temperature * Humidity * Energy (v, i, power) For using rules: * send KNX command (on/off) * receive KNX command (on/off) * send values by KNX (any float type, temperature for example) * receive a KNX read request Usage Examples ~ There are multiple possible configurations. Here are explained just a few as example. The options for selecting relays, buttons, sensors, etc. are only available if were configured on Configure Module Menu . To configure KNX, enter on the Configuration Menu of Tasmota and select Configure KNX. Note on KNX communication enhancement option: As Wifi Multicast communication is not reliable in some wifi router due to IGMP problems or Snooping, an enhancement was implemented. This option increase the reliability by reducing the chances of losing telegrams, sending the same telegram 3 times. In practice it works really good and it is enough for normal home use. When this option is on, Tasmota will ignore toggle commands by KNX if those are sent more than 1 toggle per second. Just 1 toggle per second is working fine. 1) Setting Several Tasmota to be controlled as one by a Home Automation System: ~ We can set one of the group address to be the same in all the devices so as to turn them on or off at the same time. In this case, so as to inform the status of all the relays to the Automation System, just one of the devices have to be configured as the responder. If you use the same Group Address for sending and receiving, you have to take into account not to make loops. DEVICE 1 DEVICE 2 2) Setting 2 Tasmota to be linked as stair lights: ~ We can set one device to send the status of its output and another to read that and follow. And the second device can send the status of its button and the first device will toggle. With this configuration we can avoid to make a loop. DEVICE 1 DEVICE 2 3) Setting a button as initiator of a scene: ~ Just setting one device to send the push of a button, and the rest just use that value to turn them on. In this case, there is no toggle. Every time the button is pushed, the turn on command is sent. DEVICE 1 DEVICE 2 4) Setting a Temperature sensor: ~ We can configure to send the value of temperature or humidity every teleperiod. This teleperiod can be configured. See TasmotaTasmota wiki . It is recommended also to set the reply temperature address. 5) Using rules: ~ More functionality can be added to Tasmota using rules. In the KNX Menu, can be set a Group Address to send data or commands by rules, as KNX TX1 to KNX TX5 In rules we can use the command KnxTx_Cmnd1 1 to send an ON state command to the group address set in KNX TX1 slot of the KNX menu. Also, we can use the command KnxTx_Val1 15 to send a 15 value to the group address set in KNX TX1 slot of the KNX menu. In the KNX Menu can be set a Group Address to receive commands by rules as KNX RX1 to KNX RX5 In rules we can use the events to catch the reception of COMMANDS from KNX to those RX Slots. Example: rule on event#knxrx_cmnd1 do var1 %value% endon to store the command received in the variable VAR1 In rules we can use the events to catch the reception of VALUES from KNX to those RX Slots. Example: rule on event#knxrx_val1 do var1 %value% endon to store the value received in the variable VAR1 Also, if a Read request is received from KNX Network, we can use that in a rule as for example: rule on event#knxrx_req1 do knxtx_val1 %var3% endon 6) Rule to send KNX Telegram with BH1750 Sensor Data: ~ If you want to send your sensor values by KNX every teleperiod time to the Group Address defined in KNX_TX1, you can use the following rule: rule1 1 rule1 on tele-BH1750#Illuminance do knxtx_val1 %value% endon If you want to send your sensor values by KNX only when it changes in a delta of 10 lx to the Group Address defined in KNX_TX1, you can use the following rule: rule1 1 rule1 on system#boot do backlog var1 0; var2 0 endon on BH1750#Illuminance>%var1% do backlog var1 %value%; knxtx_val1 %value%; var2 %value%; add1 5; sub2 5 endon on BH1750#Illuminance<%var2% do backlog var2 %value%; knxtx_val1 %value%; var1 %value%; add1 5; sub2 5 endon","title":"KNX"},{"location":"KNX/#what-is-knx","text":"The KNX IP Protocol is an international open standard for smart homes and smart buildings automation. It is a decentralized system. Each device can talk directly to each other without the need of a central controller or server. Any panel or server is just for telesupervision and for sending requests. KNX IP Protocol uses a UDP multicast on 224.0.23.12 : 3671 , so there is no need for a KNX Router unless you want to communicate to KNX Devices that are not in the WIFI Network (Twisted Pair, RF, Powerline). Each device has a physical address (like a fixed IP) as 1 . 1 . 0 and that address is used for configuration purposes. Each device can be configured with group addresses as 2 / 2 / 1 and that address can be used for sending/receiving commands. So, for example, if 2 devices that are configured with the 2 / 2 / 1 for turning on/off their outputs, and other device send Turn ON command to 2 / 2 / 1 , both devices will turn on their outputs.","title":"What is KNX?"},{"location":"KNX/#integration","text":"Several home automation systems have KNX support. For example, Home Assistant has a XKNX Python Library to connect to KNX devices using a KNX Router. If you don't have a KNX Router , you can use a Software KNX Router like KNXd on the same Raspberry Pi than Home Assistant. KNXd is used by Home Assistant for reading this UDP Multicast, although KNXd has other cool features that need extra hardware like connect to KNX devices by Twister Pair, Power Line or RF. If using the Home Assistant distribution called Hassio , everything for KNX is already included by default. If you use the ETS (KNX Configurator Software) you can add any TasmotaTasmota KNX as a dummy device. If the Tasmotadevice is connecting to a Wifi Repeater you might experience some issues receiving KNX Telegrams. This also applies to mDNS and Emulation features. Also, if using KNX IP Protocol, sleep needs to be 0 in order to avoid losing any telegram.","title":"Integration"},{"location":"KNX/#implemented-features","text":"The implemented features, up to now, in KNX for Tasmota are: General: * buttons (just push) * relays (on/off/toggle) * lights (led strips, etc. but just on/off) Sensor lists that you can use in KNX is (only one sensor per type): * Temperature * Humidity * Energy (v, i, power) For using rules: * send KNX command (on/off) * receive KNX command (on/off) * send values by KNX (any float type, temperature for example) * receive a KNX read request","title":"Implemented Features"},{"location":"KNX/#usage-examples","text":"There are multiple possible configurations. Here are explained just a few as example. The options for selecting relays, buttons, sensors, etc. are only available if were configured on Configure Module Menu . To configure KNX, enter on the Configuration Menu of Tasmota and select Configure KNX. Note on KNX communication enhancement option: As Wifi Multicast communication is not reliable in some wifi router due to IGMP problems or Snooping, an enhancement was implemented. This option increase the reliability by reducing the chances of losing telegrams, sending the same telegram 3 times. In practice it works really good and it is enough for normal home use. When this option is on, Tasmota will ignore toggle commands by KNX if those are sent more than 1 toggle per second. Just 1 toggle per second is working fine.","title":"Usage Examples"},{"location":"KNX/#1-setting-several-tasmota-to-be-controlled-as-one-by-a-home-automation-system","text":"We can set one of the group address to be the same in all the devices so as to turn them on or off at the same time. In this case, so as to inform the status of all the relays to the Automation System, just one of the devices have to be configured as the responder. If you use the same Group Address for sending and receiving, you have to take into account not to make loops. DEVICE 1 DEVICE 2","title":"1) Setting Several Tasmota to be controlled as one by a Home Automation System:"},{"location":"KNX/#2-setting-2-tasmota-to-be-linked-as-stair-lights","text":"We can set one device to send the status of its output and another to read that and follow. And the second device can send the status of its button and the first device will toggle. With this configuration we can avoid to make a loop. DEVICE 1 DEVICE 2","title":"2) Setting 2 Tasmota to be linked as stair lights:"},{"location":"KNX/#3-setting-a-button-as-initiator-of-a-scene","text":"Just setting one device to send the push of a button, and the rest just use that value to turn them on. In this case, there is no toggle. Every time the button is pushed, the turn on command is sent. DEVICE 1 DEVICE 2","title":"3) Setting a button as initiator of a scene:"},{"location":"KNX/#4-setting-a-temperature-sensor","text":"We can configure to send the value of temperature or humidity every teleperiod. This teleperiod can be configured. See TasmotaTasmota wiki . It is recommended also to set the reply temperature address.","title":"4) Setting a Temperature sensor:"},{"location":"KNX/#5-using-rules","text":"More functionality can be added to Tasmota using rules. In the KNX Menu, can be set a Group Address to send data or commands by rules, as KNX TX1 to KNX TX5 In rules we can use the command KnxTx_Cmnd1 1 to send an ON state command to the group address set in KNX TX1 slot of the KNX menu. Also, we can use the command KnxTx_Val1 15 to send a 15 value to the group address set in KNX TX1 slot of the KNX menu. In the KNX Menu can be set a Group Address to receive commands by rules as KNX RX1 to KNX RX5 In rules we can use the events to catch the reception of COMMANDS from KNX to those RX Slots. Example: rule on event#knxrx_cmnd1 do var1 %value% endon to store the command received in the variable VAR1 In rules we can use the events to catch the reception of VALUES from KNX to those RX Slots. Example: rule on event#knxrx_val1 do var1 %value% endon to store the value received in the variable VAR1 Also, if a Read request is received from KNX Network, we can use that in a rule as for example: rule on event#knxrx_req1 do knxtx_val1 %var3% endon","title":"5) Using rules:"},{"location":"KNX/#6-rule-to-send-knx-telegram-with-bh1750-sensor-data","text":"If you want to send your sensor values by KNX every teleperiod time to the Group Address defined in KNX_TX1, you can use the following rule: rule1 1 rule1 on tele-BH1750#Illuminance do knxtx_val1 %value% endon If you want to send your sensor values by KNX only when it changes in a delta of 10 lx to the Group Address defined in KNX_TX1, you can use the following rule: rule1 1 rule1 on system#boot do backlog var1 0; var2 0 endon on BH1750#Illuminance>%var1% do backlog var1 %value%; knxtx_val1 %value%; var2 %value%; add1 5; sub2 5 endon on BH1750#Illuminance<%var2% do backlog var2 %value%; knxtx_val1 %value%; var1 %value%; add1 5; sub2 5 endon","title":"6) Rule to send KNX Telegram with BH1750 Sensor Data:"},{"location":"LM75AD/","text":"!> This feature is included only in tasmota-sensors.bin The LM75AD is an I 2 C temperature sensor that converts temperature directly to digital signals from -55\u00b0C to +125\u00b0C and achieves an accuracy of 0.125\u00b0C Some features of the LM75A chip not implemented in this driver: - Programmable temperature threshold and hysteresis set points - Stand-alone operation as thermostat at power-up LM75A Datasheet Configuration ~ Wiring ~ LM75AD ESP8266 VCC 3.3V GND GND SDA GPIOx SCL GPIOy OS not used The driver currently only allows the use of a single LM75AD sensor on any of the addresses configurable through pins A0, A1 and A2. These are conveniently broken out on the breakout board either as pins or as solderable joints as can be seen on the example breakout board. These pins need to be tied down to either GND or VCC (3.3V) and the resulting I 2 C address will be set during power-up according to the table: Tasmota Settings ~ In the Configuration -> Configure Module page assign: 1. GPIOx to I2C SDA (6) 2. GPIOy to I2C SCL (5) After a reboot the driver will detect LM75AD automatically and display Temperature. Commands ~ TempOffset can be used for calibrating the measured temperature. This setting affects all temperature sensors on the device. Breakout Boards ~ Can also be used standalone if soldered to a board given the diagram is used R1 and R2 are pull-up resistors which are required by the I 2 C bus to operate properly. If you have other I 2 C sensors with pull-up resistors connected to the same I 2 C bus it's probably not necessary to have them.","title":"LM75AD"},{"location":"LM75AD/#configuration","text":"","title":"Configuration"},{"location":"LM75AD/#wiring","text":"LM75AD ESP8266 VCC 3.3V GND GND SDA GPIOx SCL GPIOy OS not used The driver currently only allows the use of a single LM75AD sensor on any of the addresses configurable through pins A0, A1 and A2. These are conveniently broken out on the breakout board either as pins or as solderable joints as can be seen on the example breakout board. These pins need to be tied down to either GND or VCC (3.3V) and the resulting I 2 C address will be set during power-up according to the table:","title":"Wiring"},{"location":"LM75AD/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: 1. GPIOx to I2C SDA (6) 2. GPIOy to I2C SCL (5) After a reboot the driver will detect LM75AD automatically and display Temperature.","title":"Tasmota Settings"},{"location":"LM75AD/#commands","text":"TempOffset can be used for calibrating the measured temperature. This setting affects all temperature sensors on the device.","title":"Commands"},{"location":"LM75AD/#breakout-boards","text":"Can also be used standalone if soldered to a board given the diagram is used R1 and R2 are pull-up resistors which are required by the I 2 C bus to operate properly. If you have other I 2 C sensors with pull-up resistors connected to the same I 2 C bus it's probably not necessary to have them.","title":"Breakout Boards"},{"location":"LedMask/","text":"Introduced in v6.6.0 LedMask command allows setting a bitmask which specifies which relays control the LED indicator used to display whether a relay is latched/powered. The order of the <bitmask> is from most significant bit (MSB) to least significant bit (LSB). Bit 15 (MSB) masks Relay16 through bit 0 (LSB) which masks Relay1, respectively. For each relay to be included in controlling the power LED, set its corresponding bit in the <bitmask> to 1 . <bitmask> bits without corresponding configured relay components have no effect and can be ignored. <bitmask> = bitwise value representing each relay. Values may be entered as either hexadecimal or decimal values (e.g., 0xFFFF = 65535). 0xFFFF (= 1111 1111 1111 1111) All relays control the power LED (default) LedState must be enabled (i.e., != 0 ) in order for LedMask to take effect. Examples: LedMask 0xFFFD Every relay, except Relay2, controls the power LED (0xFFFD = 1111 1111 1111 1101) LedMask 0x0002 Only Relay 2 controls the power LED (0x0002 = 0000 0000 0000 0010)","title":"LedMask"},{"location":"Lights/","text":"?> You know what lights do.... Right? \ud83d\udca1 Lights come in various shapes (bulb, strips, ceiling lights, ...) but in Tasmota they are separated in 3 categories: - Channel Controlled LEDs - Addressable LEDs - Status LEDs Controls ~ WebUI ~ Tasmota webUI displays Brightness , CT , White , Color Picker , Color Saturation or PWM Level sliders depending on the light component, the number of PWM channels configured and SetOptions used. Tasmota uses a HSB color model, which besides other more subtile differences compared to HSL means, that the color must be desaturated to reach complete black or white. Control Range Commands and details Brightness 0..100 (percent) Dimmer , HSBColor3 : Brightness of the light Hue 0..359 (degrees) HSBColor1 : Color as an angle in the color wheel Sat 0..100 (percent) HSBColor2 : saturation of the color, 0=grey/white, 100=pure color CT 153..500 (mireds) CT : white color temperature, from 153 (Cold White) to 500(Warm White) Console ~ See light commands for how to control lights. Light Types ~ Switched Lights aka Relays ~ Switched or On/Off lights are controlled through Relay GPIOs. If you define multiple relays, they are controlled with Power<x> starting at x=1 . Alexa : you can use Wemo emulation, your device will appear as a switch. You can change it to a light in the Alexa app. Alexa : if you have one or multiple relays, you can use Philips Hue emulation. All devices will appear as On/Off lights, and named accordingly to FriendlyName . Note: if you have only Echo Spot 2nd generation, your light will have a dummy dimmer. Configuration (see below) Commands Power Configuration none 1 Channel - Dimmable Light ~ 1 channel lights are often white lights with On/Off controls and Dimmer. Alexa : you can use Philips Hue emulation, the light will appear as White light with Dimmer. Configuration (see below) Commands Power , Dimmer Options Auto Power On , PWM Channel Configuration , Gamma Correction 2 Channels - CCT Light ~ 2 channels lights are white lights with correlated color temperature (CCT) controls from Cold White (CT=153) to Warm White (CT=500). Alexa : you can use Philips Hue emulation, the light will appear as White light with Color Temperature. Control through the Alexa app is limited to the CT range 199..383 . Configuration (see below) Commands Power , Dimmer , Color , White , CT Options Auto Power On , PWM Channel Configuration , Gamma Correction , PWM CT 3 Channels - RGB Lights ~ 3 channel lights are RGB color lights. You can set color either via RGB or HSB ( not HSL ). Alexa support also allows XY color, but that is not supported through commands. Alexa : you can use Philips Hue emulation, the light will appear as Color light. Configuration (see below) Commands Power , Dimmer , Color , HSBColor Options Auto Power On , PWM Channel Configuration , Gamma Correction , Channel Remapping 4 Channels - RGBW Lights ~ 4 channel lights are RGBW, i.e. RGB light and an additional White light. White can be either Warm White or Cold White depending on the manufacturer. Alexa : you can use Philips Hue emulation, the light will appear as Color light and White light with CT control. The CT control is only present to force pure white instead of RGB white. Changin CT will have no effect. Configuration (see below) Commands Power , Dimmer , Color , HSBColor , White Options Auto Power On , PWM Channel Configuration , Gamma Correction , Channel Remapping , White Blend Mode , RGB and White Split [!WARNING] There is no White only slider in the UI for 4 channel lights. Use White commands or set up White Blend Mode . [!DANGER] Some lights have limited power supply that do not allow all channels to be at full power at the same time. Be careful not to burn out your light if you force all channels via Color or RGB and White Split . 5 Channels - RGBCCT Lights ~ 5 channel lights are RGBCCT - a 3 channel RGB light and an additional 2 channel CCT light. Alexa : you can use Philips Hue emulation, the light will appear as Color light and White light with CT control. Configuration (see below) Commands Power , Dimmer , Color , HSBColor , White , CT Options Auto Power On , PWM Channel Configuration , Gamma Correction , Channel Remapping , White Blend Mode , RGB and White Split [!DANGER] Some lights have limited power supply that do not allow all channels to be at full power at the same time. Be careful not to burn out your light if you force all channels via Color or RGB and White Split Independent PWM Channels ~ Any combination of Relays and PWMs, when enabling SetOption68 1 . Splits off the light into individually controlled Channels (Useful when connecting multiple 1 channel strips to a single controller) Configuration (see below) Commands Power , Channel , Color Options Auto Power On , PWM Channel Configuration , Gamma Correction Light Options ~ Gamma Correction ~ Gamma Correction is enabled by default in Tasmota ( LedTable 1 ). Human eye perception of brightness is non linear, bringing back linearity needs a trick called Gamma Correction . Some lights have hardware gamma correction (f.e. Sonoff B1)., in which case software gamma correction should be disabled with LedTable 0 . The curve used: orange=ideal, blue=tasmota. [!TIP] How do I know if I have hardware gamma correction? If you find your light very dark even with Dimmer 40 , then you have probably hardware gamma correction. Solution: LedTable 0 . !> Internally Tasmota uses 10 bits resolution PWM to get smoother levels at low brightness. White Blend Mode ~ White Blend Mode mixes in the white channel with RGB colors while controlling the RGB light which results in a better and brighter color output. It is used only with 4 channel (RGBW) and 5 channel (RGBCCT) lights. Enable it by setting the last PWM channel to zero using RGBWWTable 255,255,255,255,0 . Calibration (optional) Generally white LEDs are brighter than RGB LEDs. If you want to keep the same brightness, you need to calibrate the white level. In this mode, any white component will be removed from RGB LEDs and sent to the white LEDs. This makes whites look much better. [!EXAMPLE] Color 30508000 will be converted to Color 0020503000 (0x30 is subtracted from RGB channels and added to the White channel) To calibrate a RGBW light: Color FFFFFF00 RGBWWTable 255,255,255,255,255 - reset to RGB mode RGBWWTable 255,255,255,<n>,0 - (begin the calibration process with <n> == 150) If too bright, decrease <n> . If too dim, increase <n> Go back to step 2 and iterate until satisfied with the color intensities. [!EXAMPLE] Calibration examples for specific devices: * Sonoff B1: RGBWWTable 255,255,255,35,0 * Teckin SB50: RGBWWTable 255,255,255,80,0 RGB and White Split ~ SetOption37 128 By default RGBW and RGBCCT lights can only be controlled in single mode, either RGB or White (f.e. Turning on CT lights turns off RGB lights and vice versa). Use SetOption37 128 to split RGB and White into 2 independent lights. If you are already using Channel Remapping, just add 128 to the value of SetOption37 . Channel Remapping ~ SetOption37 remoteMarkdownUrl Disable Auto Power On ~ Lights are always powered on when a light command or a webUI slider is used and automatically powered off when color is set to black or Dimmer is set to 0 . When enabling SetOption20 1 any change to webUI sliders or using commands CT , Dimmer , HSBColor3 , Color or Channel will not automatically power on the light if it is off. PWM CT ~ Module 48 Some CCT lights use PWM1 for brightness and PWM2 for color temperature (instead of PWM1 for Cold White and PWM2 for Warm White). For these lights, use Module 48 aka Philips Xiaomi mode. Channel Controlled LEDs ~ PWM Lights ~ Lights controlled using up to 5 channels (red, green, blue, cold white, warm white). Channels are controlled using PWM or APDM. PWM (Pulse Width Modulation) is the most common method of controlling LED lights. These lights are configured by assigning PWM1(i) through PWM5(i) components to their GPIOs; PWM<x>i means PWM is inverted. Depending on the number of used PWMs Tasmota will recognize the light as Channels PWM1 PWM2 PWM3 PWM4 PWM5 1 Brightness 2 Cold White Warm White 3 Red Green Blue 4 Red Green Blue White 5 Red Green Blue Cold White Warm White MY92xx ~ MY92xx family of drivers uses Adaptive Pulse Density Modulation. Configured in Tasmota by assigning MY92x1 DI and MY92x DCKI components to their GPIOs (some devices might have more than one MY92xx controller) Channel mapping for such devices is dependent on the controllers but is easily remapped using SetOption37 . SM16716 ~ SM16716 LEDs, sometimes mislabelled as WS2801. Configured in Tasmota by assigning SM16716 CLK , SM16716 DAT and SM16716 PWR component to their GPIOs. Some SM16716 bulbs have BGR order and need SetOption37 54 to work properly. PWM Dimmer Switches ~ Specific module (requires a custom binary) for Martin Jerry/acenx/Tessan/NTONPOWER SD0x PWM dimmer switches. Brightness of the load for these dimmers is controlled by a PWM GPIO pin. They typically have power, up and down buttons, a power status LED, five brightness LEDs and another status LED. Read more... Addressable LEDs ~ Lights where each LED is individually controlled. In these lights it is possible to adjust each LEDs power, color and brightness, all just with the use of a single GPIO pin. WebUI shows hue, saturation and brightness sliders and power toggle for these lights. Red and green color may be mixed up (observed for clone of Wemos RGB shield using Tasmota 8.1.0). WS2812 ~ Any light using WS2811, WS2812b, WS2813 or SK6812 LEDs falls into this component. They're also commonly called Neopixel lights. Configured in Tasmota by assigning WS2812 (7) component to its GPIO. For wiring, see instructions for LED strip or Wemos RGB shield . Status LEDs ~ Special subset of lights used to convey device status such as Wi-Fi and power. Read more...","title":"Lights"},{"location":"Lights/#controls","text":"","title":"Controls"},{"location":"Lights/#webui","text":"Tasmota webUI displays Brightness , CT , White , Color Picker , Color Saturation or PWM Level sliders depending on the light component, the number of PWM channels configured and SetOptions used. Tasmota uses a HSB color model, which besides other more subtile differences compared to HSL means, that the color must be desaturated to reach complete black or white. Control Range Commands and details Brightness 0..100 (percent) Dimmer , HSBColor3 : Brightness of the light Hue 0..359 (degrees) HSBColor1 : Color as an angle in the color wheel Sat 0..100 (percent) HSBColor2 : saturation of the color, 0=grey/white, 100=pure color CT 153..500 (mireds) CT : white color temperature, from 153 (Cold White) to 500(Warm White)","title":"WebUI"},{"location":"Lights/#console","text":"See light commands for how to control lights.","title":"Console"},{"location":"Lights/#light-types","text":"","title":"Light Types"},{"location":"Lights/#switched-lights-aka-relays","text":"Switched or On/Off lights are controlled through Relay GPIOs. If you define multiple relays, they are controlled with Power<x> starting at x=1 . Alexa : you can use Wemo emulation, your device will appear as a switch. You can change it to a light in the Alexa app. Alexa : if you have one or multiple relays, you can use Philips Hue emulation. All devices will appear as On/Off lights, and named accordingly to FriendlyName . Note: if you have only Echo Spot 2nd generation, your light will have a dummy dimmer. Configuration (see below) Commands Power Configuration none","title":"Switched Lights aka Relays"},{"location":"Lights/#1-channel-dimmable-light","text":"1 channel lights are often white lights with On/Off controls and Dimmer. Alexa : you can use Philips Hue emulation, the light will appear as White light with Dimmer. Configuration (see below) Commands Power , Dimmer Options Auto Power On , PWM Channel Configuration , Gamma Correction","title":"1 Channel - Dimmable Light"},{"location":"Lights/#2-channels-cct-light","text":"2 channels lights are white lights with correlated color temperature (CCT) controls from Cold White (CT=153) to Warm White (CT=500). Alexa : you can use Philips Hue emulation, the light will appear as White light with Color Temperature. Control through the Alexa app is limited to the CT range 199..383 . Configuration (see below) Commands Power , Dimmer , Color , White , CT Options Auto Power On , PWM Channel Configuration , Gamma Correction , PWM CT","title":"2 Channels - CCT Light"},{"location":"Lights/#3-channels-rgb-lights","text":"3 channel lights are RGB color lights. You can set color either via RGB or HSB ( not HSL ). Alexa support also allows XY color, but that is not supported through commands. Alexa : you can use Philips Hue emulation, the light will appear as Color light. Configuration (see below) Commands Power , Dimmer , Color , HSBColor Options Auto Power On , PWM Channel Configuration , Gamma Correction , Channel Remapping","title":"3 Channels - RGB Lights"},{"location":"Lights/#4-channels-rgbw-lights","text":"4 channel lights are RGBW, i.e. RGB light and an additional White light. White can be either Warm White or Cold White depending on the manufacturer. Alexa : you can use Philips Hue emulation, the light will appear as Color light and White light with CT control. The CT control is only present to force pure white instead of RGB white. Changin CT will have no effect. Configuration (see below) Commands Power , Dimmer , Color , HSBColor , White Options Auto Power On , PWM Channel Configuration , Gamma Correction , Channel Remapping , White Blend Mode , RGB and White Split [!WARNING] There is no White only slider in the UI for 4 channel lights. Use White commands or set up White Blend Mode . [!DANGER] Some lights have limited power supply that do not allow all channels to be at full power at the same time. Be careful not to burn out your light if you force all channels via Color or RGB and White Split .","title":"4 Channels - RGBW Lights"},{"location":"Lights/#5-channels-rgbcct-lights","text":"5 channel lights are RGBCCT - a 3 channel RGB light and an additional 2 channel CCT light. Alexa : you can use Philips Hue emulation, the light will appear as Color light and White light with CT control. Configuration (see below) Commands Power , Dimmer , Color , HSBColor , White , CT Options Auto Power On , PWM Channel Configuration , Gamma Correction , Channel Remapping , White Blend Mode , RGB and White Split [!DANGER] Some lights have limited power supply that do not allow all channels to be at full power at the same time. Be careful not to burn out your light if you force all channels via Color or RGB and White Split","title":"5 Channels - RGBCCT Lights"},{"location":"Lights/#independent-pwm-channels","text":"Any combination of Relays and PWMs, when enabling SetOption68 1 . Splits off the light into individually controlled Channels (Useful when connecting multiple 1 channel strips to a single controller) Configuration (see below) Commands Power , Channel , Color Options Auto Power On , PWM Channel Configuration , Gamma Correction","title":"Independent PWM Channels"},{"location":"Lights/#light-options","text":"","title":"Light Options"},{"location":"Lights/#gamma-correction","text":"Gamma Correction is enabled by default in Tasmota ( LedTable 1 ). Human eye perception of brightness is non linear, bringing back linearity needs a trick called Gamma Correction . Some lights have hardware gamma correction (f.e. Sonoff B1)., in which case software gamma correction should be disabled with LedTable 0 . The curve used: orange=ideal, blue=tasmota. [!TIP] How do I know if I have hardware gamma correction? If you find your light very dark even with Dimmer 40 , then you have probably hardware gamma correction. Solution: LedTable 0 . !> Internally Tasmota uses 10 bits resolution PWM to get smoother levels at low brightness.","title":"Gamma Correction"},{"location":"Lights/#white-blend-mode","text":"White Blend Mode mixes in the white channel with RGB colors while controlling the RGB light which results in a better and brighter color output. It is used only with 4 channel (RGBW) and 5 channel (RGBCCT) lights. Enable it by setting the last PWM channel to zero using RGBWWTable 255,255,255,255,0 .","title":"White Blend Mode"},{"location":"Lights/#rgb-and-white-split","text":"SetOption37 128 By default RGBW and RGBCCT lights can only be controlled in single mode, either RGB or White (f.e. Turning on CT lights turns off RGB lights and vice versa). Use SetOption37 128 to split RGB and White into 2 independent lights. If you are already using Channel Remapping, just add 128 to the value of SetOption37 .","title":"RGB and White Split"},{"location":"Lights/#channel-remapping","text":"SetOption37 remoteMarkdownUrl","title":"Channel Remapping"},{"location":"Lights/#disable-auto-power-on","text":"Lights are always powered on when a light command or a webUI slider is used and automatically powered off when color is set to black or Dimmer is set to 0 . When enabling SetOption20 1 any change to webUI sliders or using commands CT , Dimmer , HSBColor3 , Color or Channel will not automatically power on the light if it is off.","title":"Disable Auto Power On"},{"location":"Lights/#pwm-ct","text":"Module 48 Some CCT lights use PWM1 for brightness and PWM2 for color temperature (instead of PWM1 for Cold White and PWM2 for Warm White). For these lights, use Module 48 aka Philips Xiaomi mode.","title":"PWM CT"},{"location":"Lights/#channel-controlled-leds","text":"","title":"Channel Controlled LEDs"},{"location":"Lights/#pwm-lights","text":"Lights controlled using up to 5 channels (red, green, blue, cold white, warm white). Channels are controlled using PWM or APDM. PWM (Pulse Width Modulation) is the most common method of controlling LED lights. These lights are configured by assigning PWM1(i) through PWM5(i) components to their GPIOs; PWM<x>i means PWM is inverted. Depending on the number of used PWMs Tasmota will recognize the light as Channels PWM1 PWM2 PWM3 PWM4 PWM5 1 Brightness 2 Cold White Warm White 3 Red Green Blue 4 Red Green Blue White 5 Red Green Blue Cold White Warm White","title":"PWM Lights"},{"location":"Lights/#my92xx","text":"MY92xx family of drivers uses Adaptive Pulse Density Modulation. Configured in Tasmota by assigning MY92x1 DI and MY92x DCKI components to their GPIOs (some devices might have more than one MY92xx controller) Channel mapping for such devices is dependent on the controllers but is easily remapped using SetOption37 .","title":"MY92xx"},{"location":"Lights/#sm16716","text":"SM16716 LEDs, sometimes mislabelled as WS2801. Configured in Tasmota by assigning SM16716 CLK , SM16716 DAT and SM16716 PWR component to their GPIOs. Some SM16716 bulbs have BGR order and need SetOption37 54 to work properly.","title":"SM16716"},{"location":"Lights/#pwm-dimmer-switches","text":"Specific module (requires a custom binary) for Martin Jerry/acenx/Tessan/NTONPOWER SD0x PWM dimmer switches. Brightness of the load for these dimmers is controlled by a PWM GPIO pin. They typically have power, up and down buttons, a power status LED, five brightness LEDs and another status LED. Read more...","title":"PWM Dimmer Switches"},{"location":"Lights/#addressable-leds","text":"Lights where each LED is individually controlled. In these lights it is possible to adjust each LEDs power, color and brightness, all just with the use of a single GPIO pin. WebUI shows hue, saturation and brightness sliders and power toggle for these lights. Red and green color may be mixed up (observed for clone of Wemos RGB shield using Tasmota 8.1.0).","title":"Addressable LEDs"},{"location":"Lights/#ws2812","text":"Any light using WS2811, WS2812b, WS2813 or SK6812 LEDs falls into this component. They're also commonly called Neopixel lights. Configured in Tasmota by assigning WS2812 (7) component to its GPIO. For wiring, see instructions for LED strip or Wemos RGB shield .","title":"WS2812"},{"location":"Lights/#status-leds","text":"Special subset of lights used to convey device status such as Wi-Fi and power. Read more...","title":"Status LEDs"},{"location":"MCP230xx/","text":"MCP230xx - Microchip MCP23008 / MCP23017 I 2 C GPIO Expander ~ Technical Data from the manufacturer: * Microchip MCP23008 * Microchip MCP23017 Generally available breakout boards for the MCP23017 look similar to this: The MCP23008 has 8 IO pins which the MCP230xx driver uses as D0 - D7. The MCP23017 has 16 IO pins which the MCP230xx driver uses as D0 - D15. This is visualized in the circuit diagram below but it's important to note that the MCP23017 actually differentiates between PORTA (being A0 to A7) and PORTB (being B0 to B7) - The MCP230xx driver combines the two ports in sequence to translate to pins represented as D0 through D15 for the MCP23017. The chip can be connected quite easily, especially if you can source the DIP version of the chip. Here's a basic outline of what a typical circuit would require to be functional: You will need to pick an I2C address in either of the above scenario's using the address mapping according to pin A0, A1, and A2 as from the datasheet as follows: You will need to define the address you are using in user_config_override.h for the driver to know on which address the MCP23008/MCP23017 is expected to be found. #define USE_MCP230xx_ADDR 0x20 The MCP23008/MCP23017 chips allow for both INPUT and OUTPUT - Most of the functionality of the driver is focused on INPUT mode - especially since they allow interrupt reporting and are 5V tolerant. OUTPUT functionality is however available as pinmode 5 (Documented later in this Wiki) as an additional option for those who want to use the OUTPUT functionality using the Sensor29 command which consumes ~1Kbyte of flash. The driver is disabled by default in the Tasmota firmware so the only way to gain its use would be to perform a manual compilation of your own firmware. There are three different levels in which functionality may be enabled, in the following order, by adding these lines in user_config_override.h : #define USE_MCP230xx // Enable INPUT mode (pinmode 1 through 4) #define USE_MCP230xx_OUTPUT // Enable OUTPUT mode (pinmode 5) #define USE_MCP230xx_DISPLAYOUTPUT // Display state of OUTPUT pins on main Tasmota web interface The ESP8266 will automatically detect whether you have connected an MCP23008 (8 input) or MCP23017 (16 input) and will provide telemetry data in accordance with how the device was configured from within the Tasmota firmware. If OUTPUT is enabled, telemetry data for the current state of OUTPUT pins will also be provided by telemetry. MCP23008 / MCP23017 Pin numbers in Tasmota compared to datasheets ~ The table below outlines how the pins of the MCP23008/MCP23017 are assigned: Usage of the driver ~ The MCP230xx chip (or breakout board) must be connected to the ESP8266 and the I2C pins must be configured for the module similar to the following: One that is complete you may want to confirm that the Tasmota firmware is finding your MCP23008/MCP23017 chip by sending the command through serial or MQTT: I2Cscan You should see a response giving you an address within the range of the MCP23008/MCP23017 chip (0x20 through 0x27) which may look as follows MQT: stat/tasmota/RESULT = {\"I2CScan\":\"Device(s) found at 0x20\"} If the extender is not detected, check your wiring and pin configuration. The configuration of MCP23008/MCP23017 by using Sensor29 commands via the Console or MQTT messages. In order to use the MCP23008/MCP23017, add the following two lines in your user_config_override.h as the MCP chip support is not enabled by default. #define USE_MCP230xx #define USE_MCP230xx_ADDR 0x20 The MCP23008/MCP23017 supports I 2 C address range of 0x20 through 0x27. Take care that you are not using an address which is already used by another device (e.g., 0x27 is a known address for some I 2 C Liquid Crystal Displays). Device Configuration ~ The behavior of all pins on the MCP23008/MCP23017 can be reset to a specific setting/mode globally to simplify the initial configuration as follows Command Parameters Sensor29 MCP23008 / MCP23017 I 2 C GPIO Expander configuration Reset<x> = reset all pins x = 1..6 1 = INPUT mode, no reporting, no pull-up 2 = INPUT mode, report on CHANGE, pull-up enabled 3 = INPUT mode, report on LOW, pull-up enabled 4 = INPUT mode, report on HIGH, pull-up enabled 5 = OUTPUT mode (if enabled by #define USE_MCP230xx_OUTPUT ) 6 = inverted OUTPUT mode (if enabled by #define USE_MCP230xx_OUTPUT ) pin,pinmode{,intpullup\\|outstate{,repmode}} pin = the I/O pin on the MCP230xx chip 0..7 for MCP23008 0..15 for the MCP23017) pinmode = operational mode of the pin ( ?, 0..5 ) ? = query pin configuration 0 = Disabled (deprecated, but will be default for previously unconfigured devices) 1 = INPUT (Floating - only telemetry data will be sent according to configuration TelePeriod intervals) 2 = INPUT with INTERRUPT on CHANGE (will send an MQTT output on state change from LOW to HIGH and HIGH to LOW) 3 = INPUT with INTERRUPT on CHANGE to LOW (will send an MQTT output on state change only from HIGH to LOW) 4 = INPUT with INTERRUPT on CHANGE to HIGH (will send an MQTT output on state change only from LOW to HIGH) 5 = OUTPUT (if enabled with #define USE_MCP230xx_OUTPUT ) 6 = inverted OUTPUT (if enabled with #define USE_MCP230xx_OUTPUT ) intpullup (pinmode 1..4 ) . Pull-up resistors are disabled by default for pin mode 1 whilst enabled by default for pin modes 2..4 (because they are interrupt enabled pins and we do not want signal bounce). The internal pull-up on these pins may be disabled if necessary if you are biasing them externally. 0 = weak internal pull-up disabled (default for pinmode 1 ) 1 = weak internal pull-up enabled (default for pinmode 2..4 ) outstate (pinmode 5..6 ) = set the default state of an OUTPUT pin on reset/power-up. If your device is configured to save state ( SetOption0 = 1 ), the outstate setting will be ignored and the last known state of the pin will be applied during power-up/reset. 0/off = set output pin to OFF 1/on = set output pin state to ON 2/toggle = toggle output pin state repmode = reporting mode (optional). Applicable only for pinmode 2..4 . Reporting mode is disabled for pinmode 1 and for output pinmodes ( 5..6 ) 0 = interrupt using Event and report using telemetry (default) 1 = interrupt using Event only (no telemetry reported) 2 = report using telemetry only (no Event triggered) Examples: Sensor29 Reset1 MQT: stat/tasmota/RESULT = {\"Sensor29_D99\":{\"MODE\":1,\"PULL_UP\":\"OFF\",\"INT_MODE\":\"DISABLED\",\"STATE\":\"\"}} Pin and State is reported as 99 because it is set across all pins. Mode should correspond with the reset pinmode option used. Sensor29 0,? MQT: stat/tasmota/RESULT = {\"Sensor29_D0\":{\"MODE\":1,\"PULL_UP\":\"OFF\",\"INT_MODE\":\"DISABLED\",\"STATE\":\"ON\"}} Confirming that the pin is in pinmode 1 and that the pull-up resistor is not enabled. INT_MODE indicates the interrupt mode for pins which are interrupt enabled (pinmode 2 through 4) - In the example above it is disabled for pin mode 1 (INPUT without INTERRUPT) The current STATE of the pin as ON or OFF is reported as at the time the command is issued is also reported. IMPORTANT NOTICE ON USE OF INTERRUPTS ~ Only use interrupts on pins which are either explicitly pulled down GND or up to VCC externally as floating pins may cause unintended MQTT responses for pins which are floating. So unless your connected wire/device explicitly pulls the pin to GND or VCC only when conditions of an interrupt would be met it is recommended that you either do not set a pin for an interrupt mode or at least enable pull-up resistors for the unused pins with pullup = 1 when you perform your sensor29 pin,pinmode,pullup command. Examples of some pin configuration options: sensor29 4,1,0 - Will enable D4 for INPUT without internal pull-up resistor sensor29 3,1,1 - Will enable D3 for INPUT with the internal pull-up resistor ENABLED sensor29 5,2,1 - Will enable D5 for INPUT and report on change state from LOW to HIGH and HIGH to LOW via MQTT sensor29 6,3,1 - Will enable D6 for INPUT and report on change state from HIGH to LOW (note pull-up is also enabled) sensor29 2,4,0 - Will enable D2 for INPUT and report on change state from LOW to HIGH (note pull-up is not enabled) Pull-up resistor support is valid for all modes from 1 through 4 Default telemetry logging will occur for all pins as per the configured logging interval of the ESP8266 as configured in the Tasmota firmware options. The telemetry logging will push out to log and MQTT a JSON as follows: tele/tasmota/SENSOR = {\"Time\":\"2018-08-18T16:13:47\",\"MCP230XX\": \"D0\":0,\"D1\":0,\"D2\":1,\"D3\":0,\"D4\":0,\"D5\":0,\"D6\":0,\"D7\":1}} Again, this will depend on whether an MCP23008 or MCP23017 is used insofar that the number of pins/bits reported will be 8 (0 to 7) or 16 (0 to 15) respectively. INTERRUPT MODES AND USAGE ~ Interrupts will report for individual pins as and when the conditions which were configured are met and will look something like this: Interrupt message on HIGH for input pin 0 MQT : stat /tasmota/ RESULT = { \"Time\" : \"2018-08-19T16:04:50\" , \"MCP230XX_INT\" :{ \"D0\" : 1 , \"MS\" : 301 }} Interrupt message on LOW for input pin 1 MQT : stat /tasmota/ RESULT = { \"Time\" : \"2018-08-19T16:04:50\" , \"MCP230XX_INT\" :{ \"D1\" : 0 , \"MS\" : 519 }} The state of the pin captured during the interrupt is reported as Dx=y where x is the pin number and y is the state of the pin. In addition the number of milliseconds since the last interrupt occurred for the particular pin is also reported as MS=xx where xx is the number of milliseconds recorded. In addition to the MQTT message the driver will also execute an event command in the following format: event MCPINT_Dxx=y Where xx = the pin number from 0 through 7 (MCP23008) or 0 through 15 (MCP23017) and y the state of the pin as it was captured by the interrupt register of the MCP23008/MCP23017 chip. The complete output for an interrupt enabled pin would look like this: MQT : stat /tasmota/ RESULT = { \"Time\" : \"2018-08-19T16:08:28\" , \"MCP230XX_INT\" :{ \"D0\" : 0 , \"MS\" : 217353 }} SRC : Rule RSL : Group 0 , Index 1 , Command EVENT , Data MCPINT_D0 = 0 MQT : stat /tasmota/ RESULT = { \"Event\" : \"Done\" } MQT : stat /tasmota/ RESULT = { \"Time\" : \"2018-08-19T16:08:46\" , \"MCP230XX_INT\" :{ \"D0\" : 1 , \"MS\" : 18101 }} SRC : Rule RSL : Group 0 , Index 1 , Command EVENT , Data MCPINT_D0 = 1 MQT : stat /tasmota/ RESULT = { \"Event\" : \"Done\" } The latter makes it possible to integrate interrupt responses with rules for example: rule on event#MCPINT_D0=1 do power on endon on event#MCPINT_D0=0 do power off endon In the example above the rule would respond to an interrupt of HIGH on pin 0 of the MCP by executing command \"power on\" and respond to an interrupt of LOW on pin 0 with the command \"power off\" See the Wiki on Using Rules for more information on how this can be helpful to your requirements. If you require only one of the two reporting methods you may use the sensor29 command to configure the interrupt behavior according to your requirements using command: sensor29 pin,pinmode,pullup,intmode The intmode parameter is optional for pin modes 2 through 4 (those that support interrupts) and may be configured according to the table below depending on your requirements: Keep in mind that the MCP23008/MCP23017 chip will only store the last interrupt registered in the interrupt register and capture register - Because the interrupt register is only checked every 50 milliseconds by the Tasmota firmware you may experience missed interrupts if your incoming signals fluctuate/change faster than 20 times per second. ADVANCED FUNCTIONS ~ Several advanced functions have been added to extend the flexibility and interoperability of the MCP23008/MCP23017 with specific focus on adding functionality which is not present on the hardware's built-in GPIO pins and offloading some of the functionality that would normally be performed by rules or counters on the Tasmota device into the driver of the MCP23008/MCP23017. These include the following * INTPRI - Interrupt Priority, being able to control the rate at which the MCP23008/MCP23017 is polled to see if any interrupts has occurred since the previous poll. * INTDEF - Interrupt Deffer, being able to control the number of interrupts that are ignored on a specific pin before reporting would occur via telemetry and/or EVENT. * INTTIMER - Interrupt Timer which allows for time based counter reporting, specifically reporting the number of times an interrupt has occurred on interrupt enabled pins. * INTCNT - Works with INTTIMER to enable/disable counting for a specific pin. * INTRETAIN - Keep track of whether an interrupt occurred or not and defer reporting to next telemetry message. The above additions are described in further detail below. ADVANCED FUNCTION #1 - INTERRUPT PRIORITY (INTPRI) ~ The maximum interrupt polling rate is once per approximately 50 milliseconds - This is what the Tasmota firmware allows as a maximum and how it is configured in the MCP23008/MCP23017 driver by default. If you want to reduce the number of interrupt polls per second you may use the INTPRI command parameter as follows: sensor29 intpri Will give you the current setting via JSON response as follows: MQT: stat/tasmota/RESULT = {\"MCP230xx_INTPRI\":{\"D_99\":0}} To change the value you may use command as follows: sensor29 intpri,x Where x is the number of 50ms cycles (between 0 and 20) which will be skipped before the MCP23008/MCP23017 chip is polled for interrupt. The last interrupt recorded by the MCP23008/MCP23017 will be reported via the configured method. For example, lets assume you only want the interrupt polling to occur every 500ms (i.e. twice per second) you could do command: sensor29 intpri,10 // interrupt polled every 10*50 milliseconds, approximated ADVANCED FUNCTION #2 - INTERRUPT DEFER (INTDEF) ~ This setting is useful if you need to defer the reporting of an interrupt by event or telemetry until it has occurred at least X number of times. Syntax: sensor29 intdef,pin // Will provide current setting of pin sensor29 intdef,pin,x // Will set new deffer value to x (0-15) Examples: sensor29 intdef,pin,5 // Will only report interrupt when it occurs 5 times sensor29 intdef,pin,10 // Will only report interrupt when it has occured 10 times Interrupts occurring a number of times prior to the setting will be counted but ignored for reporting purposes. ADVANCED FUNCTION #3 - INTERRUPT TIMER (INTTIMER) ~ This function is used in conjunction with INTCOUNT (Documented below) It allows a timer to be configured over which period the number of interrupts will be counted. Syntax: sensor29 inttimer // Will provide the current amount of seconds for timer sensor29 inttimer,x // Allows setting number of seconds (x) for timer interval ADVANCED FUNCTION #4 - INTERRUPT COUNTER ENABLE (INTCNT) ~ Enable interrupt counting for a particular pin. This functionality works in conjunction with INTTIMER (Documented above) Syntax: sensor29 intcnt,pin // Readback current setting of interrupt counting for pin (0=OFF/1=ON) sensor29 intcnt,pin,x // Enable/Disable interrupt counting for pin (x=0=OFF,x=1=ON) Use case example could be if you want to count the number of times an interrupt occurred on a D0 over a period of 60 seconds. For this we will need the following: sensor29 inttimer,60 // Enable interrupt timer for 60 second interval sensor29 intcnt,0,1 // Enable interrupt counter for pin D0 The above will result in the number of interrupts that occur within the 60 second period configured to be counted and then reported via telemetry at the end of the 60 second time. A use case for this would be to determine the RPM of something, or perhaps the number of pulses received from an energy meter within a 60 second period to determine energy usage on a per minute bases... or wind speed from impulses received from an anemometer. ADVANCED FUNCTION #5 - INTERRUPT RETAIN (INTRETAIN) ~ This functionality disables immediate even and/or telemetry reporting for a specific pin that has been configured for any of the interrupt modes listed above. If this is enabled for a particular pin and the pin has an interrupt mode configured the fact that an interrupt condition was met will be remembered (but not reported immediately) and will be reported in a MQTT message when the next telemetry period occurs in the following format: {\"Time\":\"2018-12-06T23:59:26\",\"MCP_INTRETAIN\": {\"D0\":1,\"D1\":0,\"D2\":1,\"D3\":1,\"D4\":0,\"Value\":13}} In the example above it means that an interrupt occurred at some point during the previous telemetry period for pins D0, D2, and D3 as indicated by the 1's present for each pin - Pins with a value of 0 means that although the pin was configured for interrupt retain that no interrupt occurred during the previous telemetry period for that particular pin. For the sake of handling bit-wise operations within your home automation software the decimal value of the respective bits are also aggregated into the Value output included in the telemetry message. Syntax: sensor29 intretain,pin // Readback current setting of interrupt retain for a pin (0=OFF/1=ON) sensor29 intretain,pin,x // Enable/Disable interrupt counting for pin (x=0=OFF,x=1=ON) OUTPUT FUNCTIONS (PIN MODES 5 AND 6) ~ Enable OUTPUT support by removing the comment (#) for the following compiler directive to your user_config_override.h #define USE_MCP230xx_OUTPUT This will extend the sensor29 command enabling pinmode 5 and 6 (inverted) for output, for example: sensor29 0,5,0 // Configure pin 0 as OUTPUT and default to OFF on reset/power-up sensor29 0,5,1 // Configure pin 0 as OUTPUT and default to ON on reset/power-up sensor29 0,6,0 // Configure pin 0 as INVERTED OUTPUT and default to ON on reset/power-up sensor29 0,6,1 // Configure pin 0 as INVERTED OUTPUT and default to OFF on reset/power-up Confirmation will be sent using MQT, for example: MQT : stat /tasmota/ RESULT = { \"Sensor29_D2\" :{ \"MODE\" : 5 , \"PULL_UP\" : \"OFF\" , \"INT_MODE\" : \"DISABLED\" , \"STATE\" : \"OFF\" }} The only difference between pinmode 5 and pinmode 6 is that pinmode 5 will result in normal output state, i.e. pin will be LOW when OFF whereas pinmode 6 will cause the pin to be HIGH when OFF. This is useful when using relays which have inverted inputs. If SAVE_STATE / setoption0 is enabled in your firmware configuration then the last known state of the pin will be used on power-up/reset thereby ignoring the pull-up parameter in the commands above. To change the state of an output pin you may use: sensor29 0,ON // Turn pin ON (HIGH if pinmode 5 or LOW if pinmode 6(inverted)) sensor29 0,OFF // Turn pin OFF (LOW if pinmode 5 or HIGH if pinmode 6(inverted)) sensor29 0,T // Toggle the current state of pin from ON to OFF, or OFF to ON Telemetry response will be provided accordingly, for example: MQT : stat /tasmota/ RESULT = { \"S29cmnd_D0\" :{ \"COMMAND\" : \"ON\" , \"STATE\" : \"ON\" }} MQT : stat /tasmota/ RESULT = { \"S29cmnd_D0\" :{ \"COMMAND\" : \"OFF\" , \"STATE\" : \"OFF\" }} MQT : stat /tasmota/ RESULT = { \"S29cmnd_D0\" :{ \"COMMAND\" : \"TOGGLE\" , \"STATE\" : \"ON\" }} COMMAND = Command which was sent STATE = New state after execution of command Telemetry data is provided for pins which are enabled for output. For example, if pin 0 was enabled for OUTPUT the following additional telemetry message will be sent by MQTT at the same time as the normal telemetry interval occurs which reports the current states of pins. MQT : tele /tasmota/ SENSOR = { \"Time\" : \"2018-08-18T16:41:20\" , \"MCP230XX\" :{ \"D0\" : 0 , \"D1\" : 0 , \"D2\" : 1 , \"D3\" : 0 , \"D4\" : 0 , \"D5\" : 0 , \"D6\" : 0 , \"D7\" : 0 }} MQT : tele /tasmota/ SENSOR = { \"Time\" : \"2018-08-18T16:41:20\" , \"MCP230_OUT\" : { \"OUT_D4\" : \"OFF\" , \"END\" : 1 }} Note the MCP230XX telemetry which provides the current logic state of all the pins and then the second MQT telemetry as MCP230_OUT which indicates the current state of pins configured for OUTPUT - In this case pin 4 or D4 Remember to adhere to the current limitations of OUTPUT pins when using the device for switching external devices such as LED's - Relay's will need additional circuitry as the MCP23008/MCP23017 cannot drive relays directly - That being said most readily available relay pc boards available from vendors are optically isolated from the input so these will work perfectly.","title":"MCP230xx"},{"location":"MCP230xx/#mcp230xx-microchip-mcp23008-mcp23017-i2c-gpio-expander","text":"Technical Data from the manufacturer: * Microchip MCP23008 * Microchip MCP23017 Generally available breakout boards for the MCP23017 look similar to this: The MCP23008 has 8 IO pins which the MCP230xx driver uses as D0 - D7. The MCP23017 has 16 IO pins which the MCP230xx driver uses as D0 - D15. This is visualized in the circuit diagram below but it's important to note that the MCP23017 actually differentiates between PORTA (being A0 to A7) and PORTB (being B0 to B7) - The MCP230xx driver combines the two ports in sequence to translate to pins represented as D0 through D15 for the MCP23017. The chip can be connected quite easily, especially if you can source the DIP version of the chip. Here's a basic outline of what a typical circuit would require to be functional: You will need to pick an I2C address in either of the above scenario's using the address mapping according to pin A0, A1, and A2 as from the datasheet as follows: You will need to define the address you are using in user_config_override.h for the driver to know on which address the MCP23008/MCP23017 is expected to be found. #define USE_MCP230xx_ADDR 0x20 The MCP23008/MCP23017 chips allow for both INPUT and OUTPUT - Most of the functionality of the driver is focused on INPUT mode - especially since they allow interrupt reporting and are 5V tolerant. OUTPUT functionality is however available as pinmode 5 (Documented later in this Wiki) as an additional option for those who want to use the OUTPUT functionality using the Sensor29 command which consumes ~1Kbyte of flash. The driver is disabled by default in the Tasmota firmware so the only way to gain its use would be to perform a manual compilation of your own firmware. There are three different levels in which functionality may be enabled, in the following order, by adding these lines in user_config_override.h : #define USE_MCP230xx // Enable INPUT mode (pinmode 1 through 4) #define USE_MCP230xx_OUTPUT // Enable OUTPUT mode (pinmode 5) #define USE_MCP230xx_DISPLAYOUTPUT // Display state of OUTPUT pins on main Tasmota web interface The ESP8266 will automatically detect whether you have connected an MCP23008 (8 input) or MCP23017 (16 input) and will provide telemetry data in accordance with how the device was configured from within the Tasmota firmware. If OUTPUT is enabled, telemetry data for the current state of OUTPUT pins will also be provided by telemetry.","title":"MCP230xx - Microchip MCP23008 / MCP23017 I2C GPIO Expander"},{"location":"MCP230xx/#mcp23008-mcp23017-pin-numbers-in-tasmota-compared-to-datasheets","text":"The table below outlines how the pins of the MCP23008/MCP23017 are assigned:","title":"MCP23008 / MCP23017 Pin numbers in Tasmota compared to datasheets"},{"location":"MCP230xx/#usage-of-the-driver","text":"The MCP230xx chip (or breakout board) must be connected to the ESP8266 and the I2C pins must be configured for the module similar to the following: One that is complete you may want to confirm that the Tasmota firmware is finding your MCP23008/MCP23017 chip by sending the command through serial or MQTT: I2Cscan You should see a response giving you an address within the range of the MCP23008/MCP23017 chip (0x20 through 0x27) which may look as follows MQT: stat/tasmota/RESULT = {\"I2CScan\":\"Device(s) found at 0x20\"} If the extender is not detected, check your wiring and pin configuration. The configuration of MCP23008/MCP23017 by using Sensor29 commands via the Console or MQTT messages. In order to use the MCP23008/MCP23017, add the following two lines in your user_config_override.h as the MCP chip support is not enabled by default. #define USE_MCP230xx #define USE_MCP230xx_ADDR 0x20 The MCP23008/MCP23017 supports I 2 C address range of 0x20 through 0x27. Take care that you are not using an address which is already used by another device (e.g., 0x27 is a known address for some I 2 C Liquid Crystal Displays).","title":"Usage of the driver"},{"location":"MCP230xx/#device-configuration","text":"The behavior of all pins on the MCP23008/MCP23017 can be reset to a specific setting/mode globally to simplify the initial configuration as follows Command Parameters Sensor29 MCP23008 / MCP23017 I 2 C GPIO Expander configuration Reset<x> = reset all pins x = 1..6 1 = INPUT mode, no reporting, no pull-up 2 = INPUT mode, report on CHANGE, pull-up enabled 3 = INPUT mode, report on LOW, pull-up enabled 4 = INPUT mode, report on HIGH, pull-up enabled 5 = OUTPUT mode (if enabled by #define USE_MCP230xx_OUTPUT ) 6 = inverted OUTPUT mode (if enabled by #define USE_MCP230xx_OUTPUT ) pin,pinmode{,intpullup\\|outstate{,repmode}} pin = the I/O pin on the MCP230xx chip 0..7 for MCP23008 0..15 for the MCP23017) pinmode = operational mode of the pin ( ?, 0..5 ) ? = query pin configuration 0 = Disabled (deprecated, but will be default for previously unconfigured devices) 1 = INPUT (Floating - only telemetry data will be sent according to configuration TelePeriod intervals) 2 = INPUT with INTERRUPT on CHANGE (will send an MQTT output on state change from LOW to HIGH and HIGH to LOW) 3 = INPUT with INTERRUPT on CHANGE to LOW (will send an MQTT output on state change only from HIGH to LOW) 4 = INPUT with INTERRUPT on CHANGE to HIGH (will send an MQTT output on state change only from LOW to HIGH) 5 = OUTPUT (if enabled with #define USE_MCP230xx_OUTPUT ) 6 = inverted OUTPUT (if enabled with #define USE_MCP230xx_OUTPUT ) intpullup (pinmode 1..4 ) . Pull-up resistors are disabled by default for pin mode 1 whilst enabled by default for pin modes 2..4 (because they are interrupt enabled pins and we do not want signal bounce). The internal pull-up on these pins may be disabled if necessary if you are biasing them externally. 0 = weak internal pull-up disabled (default for pinmode 1 ) 1 = weak internal pull-up enabled (default for pinmode 2..4 ) outstate (pinmode 5..6 ) = set the default state of an OUTPUT pin on reset/power-up. If your device is configured to save state ( SetOption0 = 1 ), the outstate setting will be ignored and the last known state of the pin will be applied during power-up/reset. 0/off = set output pin to OFF 1/on = set output pin state to ON 2/toggle = toggle output pin state repmode = reporting mode (optional). Applicable only for pinmode 2..4 . Reporting mode is disabled for pinmode 1 and for output pinmodes ( 5..6 ) 0 = interrupt using Event and report using telemetry (default) 1 = interrupt using Event only (no telemetry reported) 2 = report using telemetry only (no Event triggered) Examples: Sensor29 Reset1 MQT: stat/tasmota/RESULT = {\"Sensor29_D99\":{\"MODE\":1,\"PULL_UP\":\"OFF\",\"INT_MODE\":\"DISABLED\",\"STATE\":\"\"}} Pin and State is reported as 99 because it is set across all pins. Mode should correspond with the reset pinmode option used. Sensor29 0,? MQT: stat/tasmota/RESULT = {\"Sensor29_D0\":{\"MODE\":1,\"PULL_UP\":\"OFF\",\"INT_MODE\":\"DISABLED\",\"STATE\":\"ON\"}} Confirming that the pin is in pinmode 1 and that the pull-up resistor is not enabled. INT_MODE indicates the interrupt mode for pins which are interrupt enabled (pinmode 2 through 4) - In the example above it is disabled for pin mode 1 (INPUT without INTERRUPT) The current STATE of the pin as ON or OFF is reported as at the time the command is issued is also reported.","title":"Device Configuration"},{"location":"MCP230xx/#important-notice-on-use-of-interrupts","text":"Only use interrupts on pins which are either explicitly pulled down GND or up to VCC externally as floating pins may cause unintended MQTT responses for pins which are floating. So unless your connected wire/device explicitly pulls the pin to GND or VCC only when conditions of an interrupt would be met it is recommended that you either do not set a pin for an interrupt mode or at least enable pull-up resistors for the unused pins with pullup = 1 when you perform your sensor29 pin,pinmode,pullup command. Examples of some pin configuration options: sensor29 4,1,0 - Will enable D4 for INPUT without internal pull-up resistor sensor29 3,1,1 - Will enable D3 for INPUT with the internal pull-up resistor ENABLED sensor29 5,2,1 - Will enable D5 for INPUT and report on change state from LOW to HIGH and HIGH to LOW via MQTT sensor29 6,3,1 - Will enable D6 for INPUT and report on change state from HIGH to LOW (note pull-up is also enabled) sensor29 2,4,0 - Will enable D2 for INPUT and report on change state from LOW to HIGH (note pull-up is not enabled) Pull-up resistor support is valid for all modes from 1 through 4 Default telemetry logging will occur for all pins as per the configured logging interval of the ESP8266 as configured in the Tasmota firmware options. The telemetry logging will push out to log and MQTT a JSON as follows: tele/tasmota/SENSOR = {\"Time\":\"2018-08-18T16:13:47\",\"MCP230XX\": \"D0\":0,\"D1\":0,\"D2\":1,\"D3\":0,\"D4\":0,\"D5\":0,\"D6\":0,\"D7\":1}} Again, this will depend on whether an MCP23008 or MCP23017 is used insofar that the number of pins/bits reported will be 8 (0 to 7) or 16 (0 to 15) respectively.","title":"IMPORTANT NOTICE ON USE OF INTERRUPTS"},{"location":"MCP230xx/#interrupt-modes-and-usage","text":"Interrupts will report for individual pins as and when the conditions which were configured are met and will look something like this: Interrupt message on HIGH for input pin 0 MQT : stat /tasmota/ RESULT = { \"Time\" : \"2018-08-19T16:04:50\" , \"MCP230XX_INT\" :{ \"D0\" : 1 , \"MS\" : 301 }} Interrupt message on LOW for input pin 1 MQT : stat /tasmota/ RESULT = { \"Time\" : \"2018-08-19T16:04:50\" , \"MCP230XX_INT\" :{ \"D1\" : 0 , \"MS\" : 519 }} The state of the pin captured during the interrupt is reported as Dx=y where x is the pin number and y is the state of the pin. In addition the number of milliseconds since the last interrupt occurred for the particular pin is also reported as MS=xx where xx is the number of milliseconds recorded. In addition to the MQTT message the driver will also execute an event command in the following format: event MCPINT_Dxx=y Where xx = the pin number from 0 through 7 (MCP23008) or 0 through 15 (MCP23017) and y the state of the pin as it was captured by the interrupt register of the MCP23008/MCP23017 chip. The complete output for an interrupt enabled pin would look like this: MQT : stat /tasmota/ RESULT = { \"Time\" : \"2018-08-19T16:08:28\" , \"MCP230XX_INT\" :{ \"D0\" : 0 , \"MS\" : 217353 }} SRC : Rule RSL : Group 0 , Index 1 , Command EVENT , Data MCPINT_D0 = 0 MQT : stat /tasmota/ RESULT = { \"Event\" : \"Done\" } MQT : stat /tasmota/ RESULT = { \"Time\" : \"2018-08-19T16:08:46\" , \"MCP230XX_INT\" :{ \"D0\" : 1 , \"MS\" : 18101 }} SRC : Rule RSL : Group 0 , Index 1 , Command EVENT , Data MCPINT_D0 = 1 MQT : stat /tasmota/ RESULT = { \"Event\" : \"Done\" } The latter makes it possible to integrate interrupt responses with rules for example: rule on event#MCPINT_D0=1 do power on endon on event#MCPINT_D0=0 do power off endon In the example above the rule would respond to an interrupt of HIGH on pin 0 of the MCP by executing command \"power on\" and respond to an interrupt of LOW on pin 0 with the command \"power off\" See the Wiki on Using Rules for more information on how this can be helpful to your requirements. If you require only one of the two reporting methods you may use the sensor29 command to configure the interrupt behavior according to your requirements using command: sensor29 pin,pinmode,pullup,intmode The intmode parameter is optional for pin modes 2 through 4 (those that support interrupts) and may be configured according to the table below depending on your requirements: Keep in mind that the MCP23008/MCP23017 chip will only store the last interrupt registered in the interrupt register and capture register - Because the interrupt register is only checked every 50 milliseconds by the Tasmota firmware you may experience missed interrupts if your incoming signals fluctuate/change faster than 20 times per second.","title":"INTERRUPT MODES AND USAGE"},{"location":"MCP230xx/#advanced-functions","text":"Several advanced functions have been added to extend the flexibility and interoperability of the MCP23008/MCP23017 with specific focus on adding functionality which is not present on the hardware's built-in GPIO pins and offloading some of the functionality that would normally be performed by rules or counters on the Tasmota device into the driver of the MCP23008/MCP23017. These include the following * INTPRI - Interrupt Priority, being able to control the rate at which the MCP23008/MCP23017 is polled to see if any interrupts has occurred since the previous poll. * INTDEF - Interrupt Deffer, being able to control the number of interrupts that are ignored on a specific pin before reporting would occur via telemetry and/or EVENT. * INTTIMER - Interrupt Timer which allows for time based counter reporting, specifically reporting the number of times an interrupt has occurred on interrupt enabled pins. * INTCNT - Works with INTTIMER to enable/disable counting for a specific pin. * INTRETAIN - Keep track of whether an interrupt occurred or not and defer reporting to next telemetry message. The above additions are described in further detail below.","title":"ADVANCED FUNCTIONS"},{"location":"MCP230xx/#advanced-function-1-interrupt-priority-intpri","text":"The maximum interrupt polling rate is once per approximately 50 milliseconds - This is what the Tasmota firmware allows as a maximum and how it is configured in the MCP23008/MCP23017 driver by default. If you want to reduce the number of interrupt polls per second you may use the INTPRI command parameter as follows: sensor29 intpri Will give you the current setting via JSON response as follows: MQT: stat/tasmota/RESULT = {\"MCP230xx_INTPRI\":{\"D_99\":0}} To change the value you may use command as follows: sensor29 intpri,x Where x is the number of 50ms cycles (between 0 and 20) which will be skipped before the MCP23008/MCP23017 chip is polled for interrupt. The last interrupt recorded by the MCP23008/MCP23017 will be reported via the configured method. For example, lets assume you only want the interrupt polling to occur every 500ms (i.e. twice per second) you could do command: sensor29 intpri,10 // interrupt polled every 10*50 milliseconds, approximated","title":"ADVANCED FUNCTION #1 - INTERRUPT PRIORITY (INTPRI)"},{"location":"MCP230xx/#advanced-function-2-interrupt-defer-intdef","text":"This setting is useful if you need to defer the reporting of an interrupt by event or telemetry until it has occurred at least X number of times. Syntax: sensor29 intdef,pin // Will provide current setting of pin sensor29 intdef,pin,x // Will set new deffer value to x (0-15) Examples: sensor29 intdef,pin,5 // Will only report interrupt when it occurs 5 times sensor29 intdef,pin,10 // Will only report interrupt when it has occured 10 times Interrupts occurring a number of times prior to the setting will be counted but ignored for reporting purposes.","title":"ADVANCED FUNCTION #2 - INTERRUPT DEFER (INTDEF)"},{"location":"MCP230xx/#advanced-function-3-interrupt-timer-inttimer","text":"This function is used in conjunction with INTCOUNT (Documented below) It allows a timer to be configured over which period the number of interrupts will be counted. Syntax: sensor29 inttimer // Will provide the current amount of seconds for timer sensor29 inttimer,x // Allows setting number of seconds (x) for timer interval","title":"ADVANCED FUNCTION #3 - INTERRUPT TIMER (INTTIMER)"},{"location":"MCP230xx/#advanced-function-4-interrupt-counter-enable-intcnt","text":"Enable interrupt counting for a particular pin. This functionality works in conjunction with INTTIMER (Documented above) Syntax: sensor29 intcnt,pin // Readback current setting of interrupt counting for pin (0=OFF/1=ON) sensor29 intcnt,pin,x // Enable/Disable interrupt counting for pin (x=0=OFF,x=1=ON) Use case example could be if you want to count the number of times an interrupt occurred on a D0 over a period of 60 seconds. For this we will need the following: sensor29 inttimer,60 // Enable interrupt timer for 60 second interval sensor29 intcnt,0,1 // Enable interrupt counter for pin D0 The above will result in the number of interrupts that occur within the 60 second period configured to be counted and then reported via telemetry at the end of the 60 second time. A use case for this would be to determine the RPM of something, or perhaps the number of pulses received from an energy meter within a 60 second period to determine energy usage on a per minute bases... or wind speed from impulses received from an anemometer.","title":"ADVANCED FUNCTION #4 - INTERRUPT COUNTER ENABLE (INTCNT)"},{"location":"MCP230xx/#advanced-function-5-interrupt-retain-intretain","text":"This functionality disables immediate even and/or telemetry reporting for a specific pin that has been configured for any of the interrupt modes listed above. If this is enabled for a particular pin and the pin has an interrupt mode configured the fact that an interrupt condition was met will be remembered (but not reported immediately) and will be reported in a MQTT message when the next telemetry period occurs in the following format: {\"Time\":\"2018-12-06T23:59:26\",\"MCP_INTRETAIN\": {\"D0\":1,\"D1\":0,\"D2\":1,\"D3\":1,\"D4\":0,\"Value\":13}} In the example above it means that an interrupt occurred at some point during the previous telemetry period for pins D0, D2, and D3 as indicated by the 1's present for each pin - Pins with a value of 0 means that although the pin was configured for interrupt retain that no interrupt occurred during the previous telemetry period for that particular pin. For the sake of handling bit-wise operations within your home automation software the decimal value of the respective bits are also aggregated into the Value output included in the telemetry message. Syntax: sensor29 intretain,pin // Readback current setting of interrupt retain for a pin (0=OFF/1=ON) sensor29 intretain,pin,x // Enable/Disable interrupt counting for pin (x=0=OFF,x=1=ON)","title":"ADVANCED FUNCTION #5 - INTERRUPT RETAIN (INTRETAIN)"},{"location":"MCP230xx/#output-functions-pin-modes-5-and-6","text":"Enable OUTPUT support by removing the comment (#) for the following compiler directive to your user_config_override.h #define USE_MCP230xx_OUTPUT This will extend the sensor29 command enabling pinmode 5 and 6 (inverted) for output, for example: sensor29 0,5,0 // Configure pin 0 as OUTPUT and default to OFF on reset/power-up sensor29 0,5,1 // Configure pin 0 as OUTPUT and default to ON on reset/power-up sensor29 0,6,0 // Configure pin 0 as INVERTED OUTPUT and default to ON on reset/power-up sensor29 0,6,1 // Configure pin 0 as INVERTED OUTPUT and default to OFF on reset/power-up Confirmation will be sent using MQT, for example: MQT : stat /tasmota/ RESULT = { \"Sensor29_D2\" :{ \"MODE\" : 5 , \"PULL_UP\" : \"OFF\" , \"INT_MODE\" : \"DISABLED\" , \"STATE\" : \"OFF\" }} The only difference between pinmode 5 and pinmode 6 is that pinmode 5 will result in normal output state, i.e. pin will be LOW when OFF whereas pinmode 6 will cause the pin to be HIGH when OFF. This is useful when using relays which have inverted inputs. If SAVE_STATE / setoption0 is enabled in your firmware configuration then the last known state of the pin will be used on power-up/reset thereby ignoring the pull-up parameter in the commands above. To change the state of an output pin you may use: sensor29 0,ON // Turn pin ON (HIGH if pinmode 5 or LOW if pinmode 6(inverted)) sensor29 0,OFF // Turn pin OFF (LOW if pinmode 5 or HIGH if pinmode 6(inverted)) sensor29 0,T // Toggle the current state of pin from ON to OFF, or OFF to ON Telemetry response will be provided accordingly, for example: MQT : stat /tasmota/ RESULT = { \"S29cmnd_D0\" :{ \"COMMAND\" : \"ON\" , \"STATE\" : \"ON\" }} MQT : stat /tasmota/ RESULT = { \"S29cmnd_D0\" :{ \"COMMAND\" : \"OFF\" , \"STATE\" : \"OFF\" }} MQT : stat /tasmota/ RESULT = { \"S29cmnd_D0\" :{ \"COMMAND\" : \"TOGGLE\" , \"STATE\" : \"ON\" }} COMMAND = Command which was sent STATE = New state after execution of command Telemetry data is provided for pins which are enabled for output. For example, if pin 0 was enabled for OUTPUT the following additional telemetry message will be sent by MQTT at the same time as the normal telemetry interval occurs which reports the current states of pins. MQT : tele /tasmota/ SENSOR = { \"Time\" : \"2018-08-18T16:41:20\" , \"MCP230XX\" :{ \"D0\" : 0 , \"D1\" : 0 , \"D2\" : 1 , \"D3\" : 0 , \"D4\" : 0 , \"D5\" : 0 , \"D6\" : 0 , \"D7\" : 0 }} MQT : tele /tasmota/ SENSOR = { \"Time\" : \"2018-08-18T16:41:20\" , \"MCP230_OUT\" : { \"OUT_D4\" : \"OFF\" , \"END\" : 1 }} Note the MCP230XX telemetry which provides the current logic state of all the pins and then the second MQT telemetry as MCP230_OUT which indicates the current state of pins configured for OUTPUT - In this case pin 4 or D4 Remember to adhere to the current limitations of OUTPUT pins when using the device for switching external devices such as LED's - Relay's will need additional circuitry as the MCP23008/MCP23017 cannot drive relays directly - That being said most readily available relay pc boards available from vendors are optically isolated from the input so these will work perfectly.","title":"OUTPUT FUNCTIONS (PIN MODES 5 AND 6)"},{"location":"MGC3130/","text":"MGC3130 ~ The MGC3130 is an electrical-field (E-field) based three-dimensional (3D) tracking and gesture controller from Microchip. There are several boards available, which are connected via I 2 C. USAGE: ~ Add #define USE_MGC3130 in sonoff/user_config_override.h flash the device before connecting the sensor board wire up SDA and SDL and configure as usual in TASMOTA wire up RESET and TRFR (names may vary on different boards) to free GPIO's and configure them accordingly (TRFR is GPIO: MGC3130_XFER) EXPECTED BEHAVIOUR: ~ after boot gestures (FLICK, EDGE_FLICK, TOUCH, TAP, DOUBLE_TAP) will be sensed and published via MQTT Flicks: Taps: you can select different modes with the COMMANDS, touch will always be sensed and report the duration in 1/20 seconds. Touch: the airwheel gesture will be sensed and published as \"AW\" via MQTT with values between 0 and 1023 - clockwise up Airwheel: after entering position mode the values for x,y,z will be sensed and published via MQTT with values between 0 and 1023 for x,y. Data is only published, when z is in the upper half (z values are between 0 and 511). Location sensing in active volume: near the surface you can move your finger without producing location data, i.e. to change the mode. at the moment the circle gestures ((COUNTER)CLOCKWISE) must be activated with the COMMAND: SENSOR91 1 (we must wait 250 ms after the start and can not activate it in the init function, this might differ depending on the board firmware) COMMANDS: ~ SENSOR36 0 - next mode SENSOR36 1 - gesture mode SENSOR36 2 - airwheel mode SENSOR36 3 - position mode (ATTENTION: this will send a lot of data!) MQTT-messages: ~ The terminology follows the documentation from MICROCHIP, but is shortened to save space especially for RULES. The board is to be viewed like a map, where UP is NORTH and RIGHT is EAST an so on. The big central part of the surface is CENTRE. A movement (FLICK) from LEFT to RIGHT is translated to FLICK-WEST-EAST and then finally shortened to {FL_WE:1}. If you only do a flick at the left edge (with a short movement to the right) this will be EDGE-FLICK-WEST-EAST and then in the final message: {E_FL_WE:1}. A TOUCH (leaving your finger on the board) reports the location and the duration (in counts of 50ms). So touching the centre for a second, publishes messages from {TH_C:1} up to (approx.) {TH_C:20}. Touching for less than 1,25 seconds triggers a TAP-message in the moment of leaving the surface, so on the lower edge we will see: {TP_S:1} (plus some {TH_S:1...x} for the contact duration). Double Tap (like a double click on your mouse) works similar, but will (at the moment) always trigger a (single) TAP at the same position. Example for the upper edge: {DT_N:1} and before that: {TP_N:1} and some {TH_N:1...x}. Airwheel is a circular finger movement above the sensor, which will trigger a message {AW:0 ... 1023}. In position mode we get {X:0...1023,Y:0...1023,Z:0...511}, where X and Y are 0 in the lower left (west-south) corner. The z value is not published in close proximity to the surface in order to have a chance to switch to another mode with a TOUCH, TAP or DOUBLE-TAP. So the active sensing volume is in the upper z-half of the theoretical maximum sensing volume. EXAMPLES: ~ A possible solution to cycle through the modes only with the sensor by double tapping the centre is using RULES: rule1 on Tele-MGC3130#DT_C do sensor91 0 endon or with a \"long\" touch of a second rule1 on Tele-MGC3130#TH_C > 20 do sensor91 0 endon CONSIDERATIONS: ~ This is an extremely versatile sensor and the main problem is not to get it to work somehow in TASMOTA, but to make it usable in a sensible way. We can measure and publish all kinds of data in parallel, but this will likely end up in an unusable situation. It is important to have a basic understanding of the sensor, to not get confused with seemingly unreasonable messages (DOUBLE TAP triggers a TOUCH (or more than one), then a TAP (after the first lift of the finger) and then a DOUBLE TAP. The naming conventions of the gestures are according to the data sheets from Microchip, because if we only would have simple FLICKS, it would have made it easy to use: UP, DOWN, LEFT, RIGHT. But we have EDGE FLICKS and various TOUCHES too, and so the direction name could be ambiguous. That's why we (have to) use NORTH-SOUTH, EAST-WEST ... and NORTH, SOUTH, .... and CENTRE. To make the MQTT messages not too long, some useful abbreviations have to be found. This is definitely work in progress. KNOWN ISSUES: ~ After the initial flashing the ESP8266/TASMOTA can freeze at startup with a connected sensor board. If this happens disconnect the wires from the MGC3130-board (I 2 C-wires should be enough), reboot and reconnect. Keep in mind, that in general many things will interfere with an electrical field. In certain places it can simply be impossible to use such kind of sensor. For testing reasons it is fine to connect the ESP8266-device to the USB-Port of a computer (for POWER and SERIAL), but this will likely lead to weird effects in some cases (i.e. reading of nonsense-location-data by simply touching the keyboard of a connected laptop). The chip can saturate the I 2 C-bus and additional I 2 C-devices can lead to problems. The driver was developed and tested on a SKYWRITER-board from PIMORONI. The behavior of other boards can not be guaranteed. TO-BE-DONE: ~ Ideas are welcome and will be integrated if possible.","title":"MGC3130"},{"location":"MGC3130/#mgc3130","text":"The MGC3130 is an electrical-field (E-field) based three-dimensional (3D) tracking and gesture controller from Microchip. There are several boards available, which are connected via I 2 C.","title":"MGC3130"},{"location":"MGC3130/#usage","text":"Add #define USE_MGC3130 in sonoff/user_config_override.h flash the device before connecting the sensor board wire up SDA and SDL and configure as usual in TASMOTA wire up RESET and TRFR (names may vary on different boards) to free GPIO's and configure them accordingly (TRFR is GPIO: MGC3130_XFER)","title":"USAGE:"},{"location":"MGC3130/#expected-behaviour","text":"after boot gestures (FLICK, EDGE_FLICK, TOUCH, TAP, DOUBLE_TAP) will be sensed and published via MQTT Flicks: Taps: you can select different modes with the COMMANDS, touch will always be sensed and report the duration in 1/20 seconds. Touch: the airwheel gesture will be sensed and published as \"AW\" via MQTT with values between 0 and 1023 - clockwise up Airwheel: after entering position mode the values for x,y,z will be sensed and published via MQTT with values between 0 and 1023 for x,y. Data is only published, when z is in the upper half (z values are between 0 and 511). Location sensing in active volume: near the surface you can move your finger without producing location data, i.e. to change the mode. at the moment the circle gestures ((COUNTER)CLOCKWISE) must be activated with the COMMAND: SENSOR91 1 (we must wait 250 ms after the start and can not activate it in the init function, this might differ depending on the board firmware)","title":"EXPECTED BEHAVIOUR:"},{"location":"MGC3130/#commands","text":"SENSOR36 0 - next mode SENSOR36 1 - gesture mode SENSOR36 2 - airwheel mode SENSOR36 3 - position mode (ATTENTION: this will send a lot of data!)","title":"COMMANDS:"},{"location":"MGC3130/#mqtt-messages","text":"The terminology follows the documentation from MICROCHIP, but is shortened to save space especially for RULES. The board is to be viewed like a map, where UP is NORTH and RIGHT is EAST an so on. The big central part of the surface is CENTRE. A movement (FLICK) from LEFT to RIGHT is translated to FLICK-WEST-EAST and then finally shortened to {FL_WE:1}. If you only do a flick at the left edge (with a short movement to the right) this will be EDGE-FLICK-WEST-EAST and then in the final message: {E_FL_WE:1}. A TOUCH (leaving your finger on the board) reports the location and the duration (in counts of 50ms). So touching the centre for a second, publishes messages from {TH_C:1} up to (approx.) {TH_C:20}. Touching for less than 1,25 seconds triggers a TAP-message in the moment of leaving the surface, so on the lower edge we will see: {TP_S:1} (plus some {TH_S:1...x} for the contact duration). Double Tap (like a double click on your mouse) works similar, but will (at the moment) always trigger a (single) TAP at the same position. Example for the upper edge: {DT_N:1} and before that: {TP_N:1} and some {TH_N:1...x}. Airwheel is a circular finger movement above the sensor, which will trigger a message {AW:0 ... 1023}. In position mode we get {X:0...1023,Y:0...1023,Z:0...511}, where X and Y are 0 in the lower left (west-south) corner. The z value is not published in close proximity to the surface in order to have a chance to switch to another mode with a TOUCH, TAP or DOUBLE-TAP. So the active sensing volume is in the upper z-half of the theoretical maximum sensing volume.","title":"MQTT-messages:"},{"location":"MGC3130/#examples","text":"A possible solution to cycle through the modes only with the sensor by double tapping the centre is using RULES: rule1 on Tele-MGC3130#DT_C do sensor91 0 endon or with a \"long\" touch of a second rule1 on Tele-MGC3130#TH_C > 20 do sensor91 0 endon","title":"EXAMPLES:"},{"location":"MGC3130/#considerations","text":"This is an extremely versatile sensor and the main problem is not to get it to work somehow in TASMOTA, but to make it usable in a sensible way. We can measure and publish all kinds of data in parallel, but this will likely end up in an unusable situation. It is important to have a basic understanding of the sensor, to not get confused with seemingly unreasonable messages (DOUBLE TAP triggers a TOUCH (or more than one), then a TAP (after the first lift of the finger) and then a DOUBLE TAP. The naming conventions of the gestures are according to the data sheets from Microchip, because if we only would have simple FLICKS, it would have made it easy to use: UP, DOWN, LEFT, RIGHT. But we have EDGE FLICKS and various TOUCHES too, and so the direction name could be ambiguous. That's why we (have to) use NORTH-SOUTH, EAST-WEST ... and NORTH, SOUTH, .... and CENTRE. To make the MQTT messages not too long, some useful abbreviations have to be found. This is definitely work in progress.","title":"CONSIDERATIONS:"},{"location":"MGC3130/#known-issues","text":"After the initial flashing the ESP8266/TASMOTA can freeze at startup with a connected sensor board. If this happens disconnect the wires from the MGC3130-board (I 2 C-wires should be enough), reboot and reconnect. Keep in mind, that in general many things will interfere with an electrical field. In certain places it can simply be impossible to use such kind of sensor. For testing reasons it is fine to connect the ESP8266-device to the USB-Port of a computer (for POWER and SERIAL), but this will likely lead to weird effects in some cases (i.e. reading of nonsense-location-data by simply touching the keyboard of a connected laptop). The chip can saturate the I 2 C-bus and additional I 2 C-devices can lead to problems. The driver was developed and tested on a SKYWRITER-board from PIMORONI. The behavior of other boards can not be guaranteed.","title":"KNOWN ISSUES:"},{"location":"MGC3130/#to-be-done","text":"Ideas are welcome and will be integrated if possible.","title":"TO-BE-DONE:"},{"location":"MH-Z19B/","text":"!> This feature is included only in tasmota-sensors.bin MH-Z19B CO 2 Sensor (Serial) ~ The MH-Z19 sensor is manufactured by Winsen Lt., China and the measurement method used is based on the non-dispersive infrared ( NDIR ) principle to detect the existence of CO 2 in the air. Key features according to the manufacturer are: * good sensitivity * non-oxygen dependent * long life * built-in temperature compensation * UART serial interface and Pulse Width Modulation (PWM) output Principle of operation: The main components of an NDIR sensor are an infrared source (lamp), a sample chamber or light tube, a light filter and an infrared detector. The IR light is directed through the sample chamber towards the detector. In parallel there is another chamber with an enclosed reference gas, typically nitrogen. The gas in the sample chamber causes absorption of specific wavelengths according to the Beer\u00f1Lambert law, and the attenuation of these wavelengths is measured by the detector to determine the gas concentration. The detector has an optical filter in front of it that eliminates all light except the wavelength that the selected gas molecules can absorb. See also the datasheet . Buy example: AliExpress.com: MH-Z19B-Infrared-CO2-Sensor-for-CO2-Monitor-NDIR-Gas-Sensor-CO2-gas-sensor Operating current < 18mA average Connecting the MH-Z19B to a Wemos D1 mini ~ Wemos D1 Mini MH-Z19B VCC +5V Vin GND GND TX Rx RX Tx In some situations if you only get 0 ppm displayed it may be necessary to set \"TX GPIO1\" to \"MHZ Rx\" and \"RX GPIO3\" to \"MHZ Tx\" and correspondingly reverse the cabling for RX/TX. See here for more details. Tasmota Settings ~ In the Configuration -> Configure Module page, select the following for Wemos D1 mini: 1. Module Type: 18 Generic 2. TX GPIO1 Serial Out: 60 MHZ Tx 3. RX GPIO3 Serial In: 61 MHZ Rx For Sonoff Basic: 1. Module Type: 01 Sonoff Basic 2. GPIO01 60 MHZ Tx 3. GPIO03 61 MHZ Rx Tasmota Main ~ After reboot of the device the MHZ-19B measurements are shown. Measure range can be selected with command: sensor15 1000 for 1000 ppm range sensor15 2000 for 2000 ppm range sensor15 3000 for 3000 ppm range sensor15 5000 for 5000 ppm range Full commands list for the sensor","title":"MH Z19B"},{"location":"MH-Z19B/#mh-z19b-co2-sensor-serial","text":"The MH-Z19 sensor is manufactured by Winsen Lt., China and the measurement method used is based on the non-dispersive infrared ( NDIR ) principle to detect the existence of CO 2 in the air. Key features according to the manufacturer are: * good sensitivity * non-oxygen dependent * long life * built-in temperature compensation * UART serial interface and Pulse Width Modulation (PWM) output Principle of operation: The main components of an NDIR sensor are an infrared source (lamp), a sample chamber or light tube, a light filter and an infrared detector. The IR light is directed through the sample chamber towards the detector. In parallel there is another chamber with an enclosed reference gas, typically nitrogen. The gas in the sample chamber causes absorption of specific wavelengths according to the Beer\u00f1Lambert law, and the attenuation of these wavelengths is measured by the detector to determine the gas concentration. The detector has an optical filter in front of it that eliminates all light except the wavelength that the selected gas molecules can absorb. See also the datasheet . Buy example: AliExpress.com: MH-Z19B-Infrared-CO2-Sensor-for-CO2-Monitor-NDIR-Gas-Sensor-CO2-gas-sensor Operating current < 18mA average","title":"MH-Z19B CO2 Sensor (Serial)"},{"location":"MH-Z19B/#connecting-the-mh-z19b-to-a-wemos-d1-mini","text":"Wemos D1 Mini MH-Z19B VCC +5V Vin GND GND TX Rx RX Tx In some situations if you only get 0 ppm displayed it may be necessary to set \"TX GPIO1\" to \"MHZ Rx\" and \"RX GPIO3\" to \"MHZ Tx\" and correspondingly reverse the cabling for RX/TX. See here for more details.","title":"Connecting the MH-Z19B to a Wemos D1 mini"},{"location":"MH-Z19B/#tasmota-settings","text":"In the Configuration -> Configure Module page, select the following for Wemos D1 mini: 1. Module Type: 18 Generic 2. TX GPIO1 Serial Out: 60 MHZ Tx 3. RX GPIO3 Serial In: 61 MHZ Rx For Sonoff Basic: 1. Module Type: 01 Sonoff Basic 2. GPIO01 60 MHZ Tx 3. GPIO03 61 MHZ Rx","title":"Tasmota Settings"},{"location":"MH-Z19B/#tasmota-main","text":"After reboot of the device the MHZ-19B measurements are shown. Measure range can be selected with command: sensor15 1000 for 1000 ppm range sensor15 2000 for 2000 ppm range sensor15 3000 for 3000 ppm range sensor15 5000 for 5000 ppm range Full commands list for the sensor","title":"Tasmota Main"},{"location":"MI-HM10/","text":"Mijia-BLE-sensors via HM-10 ~ The HM-10 is a 3.3v Bluetooth 4.0 module based on the TI CC2540/1-Chip. It is made by Jinan Huamao and one of a whole family of Bluetooth devices. In reality the chance to buy a clone on the \u201eusual\u201c distribution channels (BG, AE, Ebay, \u2026) is sky-high. In order to get them to work in Tasmota it is mandatory to flash the original firmware on it, which is described elsewhere. Example: https://circuitdigest.com/microcontroller-projects/how-to-flash-the-firmware-on-cloned-hm-10-ble-module-using-arduino-uno (Note: it is even possible to do this without soldering by directly sticking male jumper wire connectors through the plastic foil of some boards). The communication with the ESP8266 works over serial connection using AT-commands and the driver expects the default baud rate of firmware>700 which is 115200. The expected firmware version is 707. Other versions may work too, but before raising an issue on GitHub a test with this version is mandatory. Getting data from BT-Xiaomi-Devices: ~ Different vendors offer BT-solutions with different accessibilities under the MIJIA-brand. A common solution is the use of so-called \u201eMiBeacons\u201c which are BLE advertisement packets with a certain data structure, which are broadcasted by the devices automatically. These packets already contain the sensor data and can be passively received by other devices. Most of the \u201eolder\u201c BT-sensor-devices use unencrypted messages, which can be read by all kinds of BLE-devices or even a NRF24L01. The big advantage is the power efficiency as no active bi-directional connection has to be established. This is therefore the preferred option, if technically possible. With the arrival of the (cheap) LYWSD03 came the problem of encrypted data in MiBeacons, which to date has not been successfully decrypted in open source projects. At least the device allows the use of a simple BLE connection without any encrypted authentication and the reading of the sensor data using normal subscription methods to GATT-services. This is more power hungry than the passive reading of BLE advertisements. Tasmota-HM10-driver ~ prerequisites: -firmware 707 (other versions may work, but this is undefined behavior) -simple serial cable connection -HM-10 is set to default baud rate of 115200 (if not look for HM10BAUD-command) -uncomment #ifdef USE_HM10 in my_user_config.h -select GPIO-pins \"HM10 RX\" and \"HM10 TX\" expected behavior: The driver will set a few options of the HM-10 A discovery scan will search for known sensors (Mi Flora, MJ_HT_V1, LYWSD02, LYWSD03) LYWSD0x-sensors will be connected at a given interval, a subscription is established for 5 seconds and temperature/humidity/battery will be read. After deconnection return to point 3 after the interval. command interface: hm10scan start new discovery scan hm10period x set or show interval in seconds between sensor read cycles (is set to the value of teleperiod at start) hm10baud x set or show the speed of the serial interface of the esp8266, not of the hm10 hm10at xxxx sends AT-commands,e.g. hm10at verr? results in AT+VERR? hm10time x sets the time of sensor x (if it is a LYWSD02) to the system-UTC-time and the timezone of Tasmota. Sensors are ordered from 0 to n in the order of the arrival. supported sensors: LYWSD02 LYWSD03 not supported: Mi Flora and MJ_HT_V1 will be shown in the WEB-UI, but at the moment no sensor readings will be received.","title":"Mijia-BLE-sensors via HM-10"},{"location":"MI-HM10/#mijia-ble-sensors-via-hm-10","text":"The HM-10 is a 3.3v Bluetooth 4.0 module based on the TI CC2540/1-Chip. It is made by Jinan Huamao and one of a whole family of Bluetooth devices. In reality the chance to buy a clone on the \u201eusual\u201c distribution channels (BG, AE, Ebay, \u2026) is sky-high. In order to get them to work in Tasmota it is mandatory to flash the original firmware on it, which is described elsewhere. Example: https://circuitdigest.com/microcontroller-projects/how-to-flash-the-firmware-on-cloned-hm-10-ble-module-using-arduino-uno (Note: it is even possible to do this without soldering by directly sticking male jumper wire connectors through the plastic foil of some boards). The communication with the ESP8266 works over serial connection using AT-commands and the driver expects the default baud rate of firmware>700 which is 115200. The expected firmware version is 707. Other versions may work too, but before raising an issue on GitHub a test with this version is mandatory.","title":"Mijia-BLE-sensors via HM-10"},{"location":"MI-HM10/#getting-data-from-bt-xiaomi-devices","text":"Different vendors offer BT-solutions with different accessibilities under the MIJIA-brand. A common solution is the use of so-called \u201eMiBeacons\u201c which are BLE advertisement packets with a certain data structure, which are broadcasted by the devices automatically. These packets already contain the sensor data and can be passively received by other devices. Most of the \u201eolder\u201c BT-sensor-devices use unencrypted messages, which can be read by all kinds of BLE-devices or even a NRF24L01. The big advantage is the power efficiency as no active bi-directional connection has to be established. This is therefore the preferred option, if technically possible. With the arrival of the (cheap) LYWSD03 came the problem of encrypted data in MiBeacons, which to date has not been successfully decrypted in open source projects. At least the device allows the use of a simple BLE connection without any encrypted authentication and the reading of the sensor data using normal subscription methods to GATT-services. This is more power hungry than the passive reading of BLE advertisements.","title":"Getting data from BT-Xiaomi-Devices:"},{"location":"MI-HM10/#tasmota-hm10-driver","text":"","title":"Tasmota-HM10-driver"},{"location":"MIBLE/","text":"Experimental BLE-Bridge for certain Mijia-Bluetooth-Sensor using the NRF24L01(+) ~ NRF24l01(+) and Bluetooth ~ This chip is manufactured by Nordic Semiconductors as a single chip transceiver in the 2,4 GHz band. There are many applications in wireless consumer products and the chip is well-known in many Arduino-projects as a versatile low-cost-module. In recent years solutions were found to use this chip for limited Bluetooth-Low-Energy communication. One of the first articles about this topic can be found here: https://dmitry.gr/?r=05.Projects&proj=11.%20Bluetooth%20LE%20fakery Several further work was done later on by different developers and a working bridge to read sensor data from a XIAOMI MJ_HT_V1 already exists. The fundamental principle is, that some of these sensors send its data as a usual BLE-advertisement packet with a proprietary data format at the end of the payload. These packets had to fit into the 32 bytes of the FIFO-RX-buffer of the NRF24L01, otherwise the \"later\" bytes were lost. For the Tasmota-driver a new solution was found. The basic idea is to use some constant ID-bytes of the BLE-packets as the PDU-type for the NRF24l01. Thus, all bytes before these ID-bytes are lost and the size restriction for the payload is successfully circumvented. That way it is possible to read the sensor data from a Mi Flora sensor, which is positioned outside of the 32-byte-range. Of course there is still no bidirectional \"real\" BLE-communication, only advertisements can be read. USAGE: ~ Uncomment #USE_SPI, #USE_NRF24 and #USE_MIBLE in 'my_user_config.h' and configure the pins vor SPI_DC and SPI_CS while connecting the hardware SPI pins 12 - 14(MOSI, MISO and CLOCK). !! \u26a0\ufe0f In order to simplify the code, the pin names from the SPI-display-drivers are used \u26a0\ufe0f !! For the NRF24L01 SPI_DC translates to CSN and SPI_CS to CE. No additional steps are necessary. The initial log should like this: 00 : 00 : 00 NRF24L01 initialized 00 : 00 : 00 NRF24L01 + detected 00 : 00 : 00 MIBLE : started The driver will do the rest automatically and starts to look for known \"special\" packets, which will be used to extract the sensor readings. Web-GUI and TELE-messages will be populated with the sensor data. This can take a while after start and may be influenced by the general traffic on the 2,4 GHz-band. For the first driver vers\u00edon multiple MJ_HT_V1-sensors and Flora-sensors are supported. They will be discriminated by using the company-assigned ID of the BLE Public Device Address (= the \"lower\" 24 bits). So a TELE-message could like look this: 10 : 13 : 38 RSL : stat /tasmota/ STATUS8 = { \"StatusSNS\" :{ \"Time\" : \"2019-12-18T10:13:38\" , \"Flora-6ab577\" :{ \"Temperature\" : 21.7 , \"Illuminance\" : 21 , \"Humidity\" : 0 , \"Fertility\" : 0 }, \"MJ_HT_V1-3108be\" :{ \"Temperature\" : 22.3 , \"Humidity\" : 56.1 }, \"TempUnit\" : \"C\" }} As the NRF24L01 can only read BLE-advertisements, only the data in these advertisements is accessible. All sensors have an additional GATT-interface with more data in it, but it can not be read with a NRF24l01. As we can not use a checksum to test data integrity of the packet, only data of sensors, which adresses showed up more than once (default = 3 times) will be published. Internally from time to time \"fake\" sensors will be created, when there was data corruption in the address bytes. These will be removed automatically. Working sensors: ~ !> It can not be ruled out, that changes in the device firmware may break the functionality of this driver completely !! The naming conventions in the product range of bluetooth sensors in XIAOMI-universe can be a bit confusing. The exact same sensor can be advertised under slightly different names depending on the seller (Mijia, Xiaomi, Cleargrass, ...). MJ_HT_V1: ~ Model: LYWSDCGQ/01ZM This device works with an AAA-battery for several months and the driver can read temperature, humidity and battery level. Mi Flora: ~ Works with a CR2032-coin-cell and provides temperature, illuminance, (soil-)humidity and (soil-)fertility. LYWSD02: ~ This device has an E-Ink-Display, works with 2 x CR2032-coin-cells and the driver can read temperature and humidity. Python code to compute and set the value for the time characteristic with a generic BLE-tool: https://github.com/arendst/Tasmota/pull/7564#issuecomment-576396125 Potential \"candidates\": ~ Based on published data, the chance to support following sensors in the future is quite good: CGG1 (similar to the LYWSDCGQ/01ZM , but with E-Ink-Display and CR2430-coin-cell) The situation for the new (and cheap) LYWSD03MMC (small, rectangular form) is different, as the sensor data in the advertisements is encrypted (or even absent at all).","title":"Experimental BLE-Bridge for certain Mijia-Bluetooth-Sensor using the NRF24L01(+)"},{"location":"MIBLE/#experimental-ble-bridge-for-certain-mijia-bluetooth-sensor-using-the-nrf24l01","text":"","title":"Experimental BLE-Bridge for certain Mijia-Bluetooth-Sensor using the NRF24L01(+)"},{"location":"MIBLE/#nrf24l01-and-bluetooth","text":"This chip is manufactured by Nordic Semiconductors as a single chip transceiver in the 2,4 GHz band. There are many applications in wireless consumer products and the chip is well-known in many Arduino-projects as a versatile low-cost-module. In recent years solutions were found to use this chip for limited Bluetooth-Low-Energy communication. One of the first articles about this topic can be found here: https://dmitry.gr/?r=05.Projects&proj=11.%20Bluetooth%20LE%20fakery Several further work was done later on by different developers and a working bridge to read sensor data from a XIAOMI MJ_HT_V1 already exists. The fundamental principle is, that some of these sensors send its data as a usual BLE-advertisement packet with a proprietary data format at the end of the payload. These packets had to fit into the 32 bytes of the FIFO-RX-buffer of the NRF24L01, otherwise the \"later\" bytes were lost. For the Tasmota-driver a new solution was found. The basic idea is to use some constant ID-bytes of the BLE-packets as the PDU-type for the NRF24l01. Thus, all bytes before these ID-bytes are lost and the size restriction for the payload is successfully circumvented. That way it is possible to read the sensor data from a Mi Flora sensor, which is positioned outside of the 32-byte-range. Of course there is still no bidirectional \"real\" BLE-communication, only advertisements can be read.","title":"NRF24l01(+) and Bluetooth"},{"location":"MIBLE/#usage","text":"Uncomment #USE_SPI, #USE_NRF24 and #USE_MIBLE in 'my_user_config.h' and configure the pins vor SPI_DC and SPI_CS while connecting the hardware SPI pins 12 - 14(MOSI, MISO and CLOCK). !! \u26a0\ufe0f In order to simplify the code, the pin names from the SPI-display-drivers are used \u26a0\ufe0f !! For the NRF24L01 SPI_DC translates to CSN and SPI_CS to CE. No additional steps are necessary. The initial log should like this: 00 : 00 : 00 NRF24L01 initialized 00 : 00 : 00 NRF24L01 + detected 00 : 00 : 00 MIBLE : started The driver will do the rest automatically and starts to look for known \"special\" packets, which will be used to extract the sensor readings. Web-GUI and TELE-messages will be populated with the sensor data. This can take a while after start and may be influenced by the general traffic on the 2,4 GHz-band. For the first driver vers\u00edon multiple MJ_HT_V1-sensors and Flora-sensors are supported. They will be discriminated by using the company-assigned ID of the BLE Public Device Address (= the \"lower\" 24 bits). So a TELE-message could like look this: 10 : 13 : 38 RSL : stat /tasmota/ STATUS8 = { \"StatusSNS\" :{ \"Time\" : \"2019-12-18T10:13:38\" , \"Flora-6ab577\" :{ \"Temperature\" : 21.7 , \"Illuminance\" : 21 , \"Humidity\" : 0 , \"Fertility\" : 0 }, \"MJ_HT_V1-3108be\" :{ \"Temperature\" : 22.3 , \"Humidity\" : 56.1 }, \"TempUnit\" : \"C\" }} As the NRF24L01 can only read BLE-advertisements, only the data in these advertisements is accessible. All sensors have an additional GATT-interface with more data in it, but it can not be read with a NRF24l01. As we can not use a checksum to test data integrity of the packet, only data of sensors, which adresses showed up more than once (default = 3 times) will be published. Internally from time to time \"fake\" sensors will be created, when there was data corruption in the address bytes. These will be removed automatically.","title":"USAGE:"},{"location":"MIBLE/#working-sensors","text":"!> It can not be ruled out, that changes in the device firmware may break the functionality of this driver completely !! The naming conventions in the product range of bluetooth sensors in XIAOMI-universe can be a bit confusing. The exact same sensor can be advertised under slightly different names depending on the seller (Mijia, Xiaomi, Cleargrass, ...).","title":"Working sensors:"},{"location":"MIBLE/#mj_ht_v1","text":"Model: LYWSDCGQ/01ZM This device works with an AAA-battery for several months and the driver can read temperature, humidity and battery level.","title":"MJ_HT_V1:"},{"location":"MIBLE/#mi-flora","text":"Works with a CR2032-coin-cell and provides temperature, illuminance, (soil-)humidity and (soil-)fertility.","title":"Mi Flora:"},{"location":"MIBLE/#lywsd02","text":"This device has an E-Ink-Display, works with 2 x CR2032-coin-cells and the driver can read temperature and humidity. Python code to compute and set the value for the time characteristic with a generic BLE-tool: https://github.com/arendst/Tasmota/pull/7564#issuecomment-576396125","title":"LYWSD02:"},{"location":"MIBLE/#potential-candidates","text":"Based on published data, the chance to support following sensors in the future is quite good: CGG1 (similar to the LYWSDCGQ/01ZM , but with E-Ink-Display and CR2430-coin-cell) The situation for the new (and cheap) LYWSD03MMC (small, rectangular form) is different, as the sensor data in the advertisements is encrypted (or even absent at all).","title":"Potential \"candidates\":"},{"location":"MLX90614/","text":"!> This feature is not included in precompiled binaries. To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_MLX90614 #define USE_MLX90614 // [ I2cDriver32 ] Enable MLX90614 ir temp sensor ( I2C address 0x5a ) ( + 0.6 k code ) #endif The MLX90614 is an infrared thermometer for non-contact temperature measurements. Configuration ~ Wiring ~ MLX90614 ESP8266 GND GND VCC 3.3V SDA GPIOx SCL GPIOy Tasmota Settings ~ In the Configuration -> Configure Module page assign: 1. GPIOx to I2C SDA (6) 2. GPIOy to I2C SCL (5) After a reboot the driver will detect MLX90614 automatically and display Temperature measurements. Sensor sends a tele/%topic%/SENSOR JSON reponse: tele/tasmota/SENSOR = { \"Time\" : \"2019-11-11T00:03:30\" , \"MLX90614\" :{ \"OBJTMP\" : 23.8 , \"AMBTMP\" : 22.7 }} Breakout Boards ~ MLX90615 ~ This driver will also work with MLX90615 sensor with some code alterations. Change lines 26-30 # define I2_ADR_IRT 0 x5b # define MLX90614_RAWIR1 0 x05 # define MLX90614_TA 0 x26 # define MLX90614_TOBJ1 0 x27","title":"MLX90614"},{"location":"MLX90614/#configuration","text":"","title":"Configuration"},{"location":"MLX90614/#wiring","text":"MLX90614 ESP8266 GND GND VCC 3.3V SDA GPIOx SCL GPIOy","title":"Wiring"},{"location":"MLX90614/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: 1. GPIOx to I2C SDA (6) 2. GPIOy to I2C SCL (5) After a reboot the driver will detect MLX90614 automatically and display Temperature measurements. Sensor sends a tele/%topic%/SENSOR JSON reponse: tele/tasmota/SENSOR = { \"Time\" : \"2019-11-11T00:03:30\" , \"MLX90614\" :{ \"OBJTMP\" : 23.8 , \"AMBTMP\" : 22.7 }}","title":"Tasmota Settings"},{"location":"MLX90614/#breakout-boards","text":"","title":"Breakout Boards"},{"location":"MLX90614/#mlx90615","text":"This driver will also work with MLX90615 sensor with some code alterations. Change lines 26-30 # define I2_ADR_IRT 0 x5b # define MLX90614_RAWIR1 0 x05 # define MLX90614_TA 0 x26 # define MLX90614_TOBJ1 0 x27","title":"MLX90615"},{"location":"MPR121/","text":"MPR121 I 2 C Proximity Capacitive Touch Sensor Controller ~ 12-button or touch pad I 2 C controller Driver supports up to 4x MPR121 controllers (= 48 buttons per ESP8266) Electrodes can be covered with adhesive paper and adhesive plastic foil for labeling and symbols Break-out and touch button PCBs ~ 2\u20ac at AliExpress Break-out PCB ~ $8 at Adafruit Technical Data from the manufacturer ~ MPR121 Fact sheet MPR121 Data sheet AN3889 MPR121 capacitive sensing settings AN3890 MPR121 capacitive sensing filtering and timing AN3891 MPR121 touch sensing baseline system AN3892 MPR121 touch sensing jitter and false touch rejection AN3893 MPR121 proximity sensing AN3894 MPR121 LED driver system AN3895 MPR121 serial communication AN4600 MPR121 Designing a Touch Panel MPR121 Evaluation board schematics Wiring breakout boards ~ Breakout ESP8266 VCC/VIN +3.3VDC GND GND SCL GPIO I 2 SCL SDA GPIO I 2 SDA IRQ NC I 2 C address selection ~ Connect the ADD(R) pin/pad to one of the following pins/pads: Address ADD(R) 0x5A NC 0x5B +3.3VDC 0x5C GPIO I 2 SDA 0x5D GPIO I 2 SCL Tasmota SettingsCompile Tasmota with #define USE_MPR121 added in user_config_override.h ~ The driver will detect the I 2 C addresses of the MPR121s automatically. The MPR121 chip (or breakout board) must be connected to the ESP8266 and the I 2 C GPIO pins must be configured: Generally available types of breakout boards ~","title":"MPR121 I<sup>2</sup>C Proximity Capacitive Touch Sensor Controller"},{"location":"MPR121/#mpr121-i2c-proximity-capacitive-touch-sensor-controller","text":"12-button or touch pad I 2 C controller Driver supports up to 4x MPR121 controllers (= 48 buttons per ESP8266) Electrodes can be covered with adhesive paper and adhesive plastic foil for labeling and symbols Break-out and touch button PCBs ~ 2\u20ac at AliExpress Break-out PCB ~ $8 at Adafruit","title":"MPR121 I2C Proximity Capacitive Touch Sensor Controller"},{"location":"MPR121/#technical-data-from-the-manufacturer","text":"MPR121 Fact sheet MPR121 Data sheet AN3889 MPR121 capacitive sensing settings AN3890 MPR121 capacitive sensing filtering and timing AN3891 MPR121 touch sensing baseline system AN3892 MPR121 touch sensing jitter and false touch rejection AN3893 MPR121 proximity sensing AN3894 MPR121 LED driver system AN3895 MPR121 serial communication AN4600 MPR121 Designing a Touch Panel MPR121 Evaluation board schematics","title":"Technical Data from the manufacturer"},{"location":"MPR121/#wiring-breakout-boards","text":"Breakout ESP8266 VCC/VIN +3.3VDC GND GND SCL GPIO I 2 SCL SDA GPIO I 2 SDA IRQ NC","title":"Wiring breakout boards"},{"location":"MPR121/#i2c-address-selection","text":"Connect the ADD(R) pin/pad to one of the following pins/pads: Address ADD(R) 0x5A NC 0x5B +3.3VDC 0x5C GPIO I 2 SDA 0x5D GPIO I 2 SCL","title":"I2C address selection"},{"location":"MPR121/#tasmota-settingscompile-tasmota-with-define-use_mpr121-added-in-user_config_overrideh","text":"The driver will detect the I 2 C addresses of the MPR121s automatically. The MPR121 chip (or breakout board) must be connected to the ESP8266 and the I 2 C GPIO pins must be configured:","title":"Tasmota SettingsCompile Tasmota with #define USE_MPR121 added in user_config_override.h"},{"location":"MPR121/#generally-available-types-of-breakout-boards","text":"","title":"Generally available types of breakout boards"},{"location":"MPU-6050/","text":"!> This feature is not included in precompiled binaries. To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_MPU6050 #define USE_MPU6050 // [ I2cDriver25 ] Enable MPU6050 sensor ( I2C address 0x68 AD0 low or 0x69 AD0 high ) ( + 3 K3 of code and 188 Bytes of RAM ) #define USE_MPU6050_DMP // Enable in MPU6050 to use the DMP on the chip , should create better results ( + 8 k6 of code ) #endif The MPU-6050 combines a 3-axis gyroscope and a 3-axis accelerometer on the same silicon die, together with an onboard Digital Motion Processor\u2122 (DMP\u2122), which processes complex 6-axis MotionFusion algorithms. Datasheet Configuration ~ Wiring ~ MPU-6050 ESP8266 GND GND VCC 3.3V SDA GPIOx SCL GPIOy XDA XCL AD0 INT Tasmota Settings ~ In the Configuration -> Configure Module page assign: 1. GPIOx to I2C SDA (6) 2. GPIOy to I2C SCL (5) After a reboot the driver will detect MCU-69050 automatically and display measurements. Sensor sends a tele/%topic%/SENSOR JSON reponse: tele/tasmota/SENSOR = { \"Time\" : \"2019-12-10T19:37:50\" , \"MPU6050\" :{ \"Temperature\" : 27.7 , \"AccelXAxis\" : -7568.00 , \"AccelYAxis\" : -776.00 , \"AccelZAxis\" : 12812.00 , \"GyroXAxis\" : 270.00 , \"GyroYAxis\" : -741.00 , \"GyroZAxis\" : 700.00 }, \"TempUnit\" : \"C\" } Digital Motion Processor Enabled If you define flag #define USE_MPU6050_DMP // Enable in MPU6050 to use the DMP on the chip, should create better results (+8k6 of code) enabling Digital Motion Processor\u2122 (DMP\u2122) you will get additional Yaw, Pitch and Roll measurements and more accurate measurements overall Sensor sends an expanded tele/%topic%/SENSOR JSON reponse: tele/tasmota/SENSOR = { \"Time\" : \"2019-12-10T19:24:55\" , \"MPU6050\" :{ \"Temperature\" : 25.0 , \"AccelXAxis\" : 756.00 , \"AccelYAxis\" : -1409.00 , \"AccelZAxis\" : 2152.00 , \"GyroXAxis\" : 0.00 , \"GyroYAxis\" : -1.00 , \"GyroZAxis\" : 10.00 , \"Yaw\" : 0.86 , \"Pitch\" : -1.45 , \"Roll\" : -10.76 }, \"TempUnit\" : \"C\" } Breakout Boards ~","title":"MPU 6050"},{"location":"MPU-6050/#configuration","text":"","title":"Configuration"},{"location":"MPU-6050/#wiring","text":"MPU-6050 ESP8266 GND GND VCC 3.3V SDA GPIOx SCL GPIOy XDA XCL AD0 INT","title":"Wiring"},{"location":"MPU-6050/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: 1. GPIOx to I2C SDA (6) 2. GPIOy to I2C SCL (5) After a reboot the driver will detect MCU-69050 automatically and display measurements. Sensor sends a tele/%topic%/SENSOR JSON reponse: tele/tasmota/SENSOR = { \"Time\" : \"2019-12-10T19:37:50\" , \"MPU6050\" :{ \"Temperature\" : 27.7 , \"AccelXAxis\" : -7568.00 , \"AccelYAxis\" : -776.00 , \"AccelZAxis\" : 12812.00 , \"GyroXAxis\" : 270.00 , \"GyroYAxis\" : -741.00 , \"GyroZAxis\" : 700.00 }, \"TempUnit\" : \"C\" }","title":"Tasmota Settings"},{"location":"MPU-6050/#breakout-boards","text":"","title":"Breakout Boards"},{"location":"MQTT-Overviev/","text":"MQTT Message flow ~ Here is a diagram showing the connection phase and the network transactions required to turn a sonoff device on. In a typical setup, you'll have multiple devices on the left-hand side. There are lots of ways to control your devices. One typically uses a laptop/desktop to configure and test your Sonoffs and perhaps a smartphone to keep track of what's happening. In the long run you might want to integrate your device in a home-automation system like node-RED, openHAB, HomeAssistant, HomeBridge, Domoticz, ... MQTT Message Prefixes ~ Message Issued by Intent cmnd devices shown on the right-hand side control the Sonoff; set configuration; ask for status stat the Sonoffs on the left-hand side report back status or configuration message tele some Sonoffs (like temperature measuring devices) report unsolicited telemetry info at periodic intervals These are prefix1 , prefix2 & prefix3 in the code Configuring MQTT ~ MQTT settings can be initially setup in the web interface and thereafter configured by commands. Enable MQTT Enable MQTT with the tickbox under Configuration -> Configuration Other Configure MQTT Settings Once enabled MQTT can be configured at Configuration -> Configure MQTT. Field Size Default(my_user_config.h) Notes Host name 32 MQTT_HOST=mqtt_broker.com Remote URL or ip address. Note that without a special firmware build SSL is NOT supported. Port uint MQTT_PORT=1883 0-65535 Client Id 32 MQTT_CLIENT_ID=DVES_%06X FallBack topic of this device, will be unique for every device; logged by the MQTT server Username 32 MQTT_USER=DVES_USER Username for MQTT server authentication Password 32 MQTT_PASS=DVES_PASS Password for MQTT server authentication Topic 32 MQTT_TOPIC=sonoff User friendly topic name; usually describes the location or use of this device; used in the MQTT commands and responses; should be unique Full Topic 100 %prefix%/%topic% Format string used to assemble the MQTT commands Note: By default firmware will search for an MQTT broker using mDNS by searching for a tcp record mqtt.local. However the use of local mDNS hostnames (ex: mqtt_home.local) is not supported, if you want to use a broker on your local network you need to use its local IP or rely on a local DNS to resolve the hostnames. Programming examples for the Sonoff-MQTT-OTA-Arduino ~ TL;DR ~ mosquitto_sub -h mqtt_server_name.com -t stat/my_sonoff/POWER -v # listen for status mosquitto_pub -h mqtt_server_name.com -t cmnd/my_sonoff/power -m 1 # turn on the light General ~ See the wiki's command list for the definitive list of operations that you can perform. The first word in the column marked Command is the text that you need to put at the end of a cmnd string when you issue a publication message. The second word is the contents of the payload. If there is no second word, you can simply send an empty payload. For example: Command Description Power Show current power state as On or Off Power on Turn power On Power off Turn power Off To execute these, issue (publish) these MQTT requests MQTT topic MQTT payload cmnd/my_device/power <empty> cmnd/my_device/power on cmnd/my_device/power off The sonoff will respond with these publications: MQTT topic MQTT payload stat/my_device/POWER ON stat/my_device/POWER ON stat/my_device/POWER OFF If you have subscribed to these stat messages, you can be informed of changes on the device. Connecting to MQTT You'll need an MQTT server somewhere to communicate with your Sonoff. Some people use publicly available servers, such as iot.eclipse.org. List of brokers Other people think the MQTT server should reside inside your private LAN. You could use a Raspberry/Orange Pi, or just about any Linux machine as the server/broker; you might even squeeze it into your router if you're using OpenWRT. Topics The middle word of the 'topic' phrase indicates the name of the device. You can communicate with a sonoff using its topic name, its group name or its FallBack topic name (like DVES_123456). At the time the sonoff connects with the MQTT server, the sonoff subscribes to +++\"cmnd/my-topic/#\", \"cmnd/group-topic/#\" and \"cmnd/fallback-topic/#\",+++ and listens on all those names. You can find the group name using \"status 0\" and the FallBack topic using \"status 6\" or both on the Information page in WebUI. Creating your own MQTT server/broker See these sites: - Rufio howto - Wingsquare howto - Instructables howto on Raspberry Pi Linux/Cygwin command line ~ You can install the mosquitto client system using either - [Cygwin] setup mosquitto_client - [Ubuntu/Debian] apt install mosquitto_client - [Centos/Fedora] yum install mosquitto_client Controlling (Publishing) You can control the relay in your Sonoff with mosquitto_pub. Suppose your Sonoff topic is \"my_house_living_room\" and your mqtt broker is \"control_central\". To turn on the Sonoff, type this on the command line: mosquitto_pub -h control_central -t cmnd/my_house_living_room/power -m 1 You can turn the Sonoff back off again with: mosquitto_pub -h control_central -t cmnd/my_house_living_room/power -m 0 If you want to find out what state your sonoff is, issue this command with an empty payload to trigger a status response (see below for how to listen): mosquitto_pub -h control_central -t cmnd/my_house_living_room/status -n Listening (Subscribing) To keep track of your sonoff, just subscribe to messages starting with stat , followed by your topic. For example, to pick up status messages from your sonoff, use mosquitto_sub -h control_central -t stat/my_house_living_room/STATUS -v The optional -v will show you the topic and payload. These Sonoffs can provide specific information if you wish. To just monitor the relay state, try mosquitto_sub -h control_central -t stat/my_house_living_room/POWER You can also use wildcards in your subscription. To pick up every message from this sonoff, you can use mosquitto_sub -h control_central -t stat/my_house_living_room/+ and then some other code to just pick out the messages you want. If you have a collection of sonoffs, you can listen to them all by either using the group topic mosquitto_sub -h control_central -t stat/my_house_collection/POWER or by using a wildcard in the 2nd position mosquitto_sub -h control_central -t stat/+/POWER Python ~ Of course you can always call system() or subprocess() to run the mosquitto_pub and mosquitto_sub command lines as shown above. But if you wish, you can install the paho-mqtt package and communicate with MQTT using Python objects. Let's turn the lights on, wait a few seconds, turn them off, check the status and wait for a time stamp import paho.mqtt.client as mqtt , time , sys last_topic = \"\" last_payload = \"\" # main def on_connect ( client , userdata , flags , rc ): print ( \"Connected\" ) client . is_connected = True def on_message ( client , userdata , message ): ''' note: message is a tuple of (topic, payload, qos, retain)''' global last_topic , last_payload last_topic = message . topic last_payload = message . payload print ( \"Got a message with topic: [\" + last_topic + \"] and payload [\" + last_payload + \"]\" ) client = mqtt . Client () # if you need a username and/or password for mqtt uncomment next line # client.username_pw_set(\"myusr\", password=\"mypwd\") client . on_connect = on_connect client . on_message = on_message client . is_connected = False client . loop_start () client . connect ( \"control_central\" ) # replace \"control_central\" with ip address or name of server time . sleep ( 6 ) if not client . is_connected : print ( \"problem connecting to the MQTT server; please check your settings\" ) sys . exit ( 1 ) # edit subscribe and publish lines and use yours like \"stat/tasmota/POWER\" client . subscribe ( \"stat/my_house_living_room/POWER\" ) client . publish ( \"cmnd/my_house_living_room/power\" , \"1\" ) # wait a little bit time . sleep ( 15 ) client . publish ( \"cmnd/my_house_living_room/power\" , \"0\" ) # ask for system status time . sleep ( 1 ) client . subscribe ( \"stat/my_house_living_room/STATUS\" ) client . publish ( \"cmnd/my_house_living_room/status\" , None ) # now wait for a time stamp from the sonoff; this could take an hour client . subscribe ( \"tele/my_house_living_room/+\" ) # if using tasmota-sensors.bin next section will not work unless you replace \"STATE\" with \"SENSOR\" while 1 : if last_topic . startswith ( \"tele/\" ) and last_topic . endswith ( \"STATE\" ): locate_time = last_payload . find ( b '\"Time\":' ) the_time = last_payload [ locate_time + 8 : locate_time + 8 + 19 ] print ( \"the sonoff thinks the time is: \" + the_time . decode ( \"utf-8\" )) break time . sleep ( 5 ) client . loop_stop () client . disconnect () Ref: Python MQTT JavaScript ~ Using the node module MQTT.js you can connect to the MQTT broker, send messages and listen to topics. The example uses code compatible with Node v4 or later. 'use strict' ; const mqtt = require ( 'mqtt' ); const broker = 'mqtt://192.168.0.13' ; // MQTT Broker hostname/IP address const client = mqtt . connect ( broker ); // MQTT Client const device = 'switch1' ; // Sonoff device identifier let state = 'OFF' ; let timer ; client . on ( 'connect' , function () { console . log ( ` ${ Date . now () } Client connected to ${ broker } ` ); client . subscribe ( `stat/ ${ device } /+` ); client . subscribe ( `tele/ ${ device } /+` ); client . publish ( `cmnd/ ${ device } /status` ); timer = setInterval ( loop , 2000 ); }); client . on ( 'message' , function ( topic , message ) { if ( topic === `stat/ ${ device } /POWER` ) { state = message . toString (); } console . log ( ` ${ Date . now () } RX ${ topic } ${ message } ` ); }); function loop () { if ( ! client . connected ) { return timer && timer . clearInterval (); } let newState = state === 'OFF' ? 'ON' : 'OFF' ; client . publish ( `cmnd/ ${ device } /power` , newState ); console . log ( ` ${ Date . now () } TX cmnd/ ${ device } /power ${ newState } ` ); } Ref: Node MQTT.js Android phone MQTT Dashboard ~ The MQTT Dashboard provides the ability to connect and control Sonoff devices directly. On the first page, enter the details of how your phone should connect to the MQTT broker. On the SUBSCRIBE page, you can create widgets which listen for publications from the Sonoff. A typical subscription for a power controller might be stat/my_device/POWER You could also pick up all your devices with stat/+/POWER On the PUBLISH page, you can create widgets to toggle or on/off your Sonoff. Typically you'd send a cmnd/my_device/power as the topic, and on or off as the publish value . Note that you can also have separate words on the app's user interface, such as illuminated and extinguished ; these are not sent out via MQTT, they're just user interface. Alternatively, if you're using a home automation system, there may be an Andriod/iOS app to link to your home automation. That's not covered in this how-to. Troubleshooting ~ CONNECT FAILED ~ MQTT : CONNECT FAILED x . x . x . x : x , rc { code }. Retry in 10 seconds Status codes ~ -4: MQTT_CONNECTION_TIMEOUT - the server didn't respond within the keepalive time -3: MQTT_CONNECTION_LOST - the network connection was broken -2: MQTT_CONNECT_FAILED - the network connection failed -1: MQTT_DISCONNECTED - the client is disconnected cleanly 0: MQTT_CONNECTED - the client is connected 1: MQTT_CONNECT_BAD_PROTOCOL - the server doesn't support the requested version of MQTT 2: MQTT_CONNECT_BAD_CLIENT_ID - the server rejected the client identifier 3: MQTT_CONNECT_UNAVAILABLE - the server was unable to accept the connection 4: MQTT_CONNECT_BAD_CREDENTIALS - the username/password were rejected 5: MQTT_CONNECT_UNAUTHORIZED - the client was not authorized to connect Debug Tools ~ MQTT Snooper - Sniffer App on Android MQTT Explorer - Desktop Application If mosquitto is installed, command-line: mosquitto_sub -h mqtt-host -v -t \"#\"","title":"MQTT Overviev"},{"location":"MQTT-Overviev/#mqtt-message-flow","text":"Here is a diagram showing the connection phase and the network transactions required to turn a sonoff device on. In a typical setup, you'll have multiple devices on the left-hand side. There are lots of ways to control your devices. One typically uses a laptop/desktop to configure and test your Sonoffs and perhaps a smartphone to keep track of what's happening. In the long run you might want to integrate your device in a home-automation system like node-RED, openHAB, HomeAssistant, HomeBridge, Domoticz, ...","title":"MQTT Message flow"},{"location":"MQTT-Overviev/#mqtt-message-prefixes","text":"Message Issued by Intent cmnd devices shown on the right-hand side control the Sonoff; set configuration; ask for status stat the Sonoffs on the left-hand side report back status or configuration message tele some Sonoffs (like temperature measuring devices) report unsolicited telemetry info at periodic intervals These are prefix1 , prefix2 & prefix3 in the code","title":"MQTT Message Prefixes"},{"location":"MQTT-Overviev/#configuring-mqtt","text":"MQTT settings can be initially setup in the web interface and thereafter configured by commands.","title":"Configuring MQTT"},{"location":"MQTT-Overviev/#programming-examples-for-the-sonoff-mqtt-ota-arduino","text":"","title":"Programming examples for the Sonoff-MQTT-OTA-Arduino"},{"location":"MQTT-Overviev/#tldr","text":"mosquitto_sub -h mqtt_server_name.com -t stat/my_sonoff/POWER -v # listen for status mosquitto_pub -h mqtt_server_name.com -t cmnd/my_sonoff/power -m 1 # turn on the light","title":"TL;DR"},{"location":"MQTT-Overviev/#general","text":"See the wiki's command list for the definitive list of operations that you can perform. The first word in the column marked Command is the text that you need to put at the end of a cmnd string when you issue a publication message. The second word is the contents of the payload. If there is no second word, you can simply send an empty payload. For example: Command Description Power Show current power state as On or Off Power on Turn power On Power off Turn power Off To execute these, issue (publish) these MQTT requests MQTT topic MQTT payload cmnd/my_device/power <empty> cmnd/my_device/power on cmnd/my_device/power off The sonoff will respond with these publications: MQTT topic MQTT payload stat/my_device/POWER ON stat/my_device/POWER ON stat/my_device/POWER OFF If you have subscribed to these stat messages, you can be informed of changes on the device.","title":"General"},{"location":"MQTT-Overviev/#linuxcygwin-command-line","text":"You can install the mosquitto client system using either - [Cygwin] setup mosquitto_client - [Ubuntu/Debian] apt install mosquitto_client - [Centos/Fedora] yum install mosquitto_client","title":"Linux/Cygwin command line"},{"location":"MQTT-Overviev/#python","text":"Of course you can always call system() or subprocess() to run the mosquitto_pub and mosquitto_sub command lines as shown above. But if you wish, you can install the paho-mqtt package and communicate with MQTT using Python objects. Let's turn the lights on, wait a few seconds, turn them off, check the status and wait for a time stamp import paho.mqtt.client as mqtt , time , sys last_topic = \"\" last_payload = \"\" # main def on_connect ( client , userdata , flags , rc ): print ( \"Connected\" ) client . is_connected = True def on_message ( client , userdata , message ): ''' note: message is a tuple of (topic, payload, qos, retain)''' global last_topic , last_payload last_topic = message . topic last_payload = message . payload print ( \"Got a message with topic: [\" + last_topic + \"] and payload [\" + last_payload + \"]\" ) client = mqtt . Client () # if you need a username and/or password for mqtt uncomment next line # client.username_pw_set(\"myusr\", password=\"mypwd\") client . on_connect = on_connect client . on_message = on_message client . is_connected = False client . loop_start () client . connect ( \"control_central\" ) # replace \"control_central\" with ip address or name of server time . sleep ( 6 ) if not client . is_connected : print ( \"problem connecting to the MQTT server; please check your settings\" ) sys . exit ( 1 ) # edit subscribe and publish lines and use yours like \"stat/tasmota/POWER\" client . subscribe ( \"stat/my_house_living_room/POWER\" ) client . publish ( \"cmnd/my_house_living_room/power\" , \"1\" ) # wait a little bit time . sleep ( 15 ) client . publish ( \"cmnd/my_house_living_room/power\" , \"0\" ) # ask for system status time . sleep ( 1 ) client . subscribe ( \"stat/my_house_living_room/STATUS\" ) client . publish ( \"cmnd/my_house_living_room/status\" , None ) # now wait for a time stamp from the sonoff; this could take an hour client . subscribe ( \"tele/my_house_living_room/+\" ) # if using tasmota-sensors.bin next section will not work unless you replace \"STATE\" with \"SENSOR\" while 1 : if last_topic . startswith ( \"tele/\" ) and last_topic . endswith ( \"STATE\" ): locate_time = last_payload . find ( b '\"Time\":' ) the_time = last_payload [ locate_time + 8 : locate_time + 8 + 19 ] print ( \"the sonoff thinks the time is: \" + the_time . decode ( \"utf-8\" )) break time . sleep ( 5 ) client . loop_stop () client . disconnect () Ref: Python MQTT","title":"Python"},{"location":"MQTT-Overviev/#javascript","text":"Using the node module MQTT.js you can connect to the MQTT broker, send messages and listen to topics. The example uses code compatible with Node v4 or later. 'use strict' ; const mqtt = require ( 'mqtt' ); const broker = 'mqtt://192.168.0.13' ; // MQTT Broker hostname/IP address const client = mqtt . connect ( broker ); // MQTT Client const device = 'switch1' ; // Sonoff device identifier let state = 'OFF' ; let timer ; client . on ( 'connect' , function () { console . log ( ` ${ Date . now () } Client connected to ${ broker } ` ); client . subscribe ( `stat/ ${ device } /+` ); client . subscribe ( `tele/ ${ device } /+` ); client . publish ( `cmnd/ ${ device } /status` ); timer = setInterval ( loop , 2000 ); }); client . on ( 'message' , function ( topic , message ) { if ( topic === `stat/ ${ device } /POWER` ) { state = message . toString (); } console . log ( ` ${ Date . now () } RX ${ topic } ${ message } ` ); }); function loop () { if ( ! client . connected ) { return timer && timer . clearInterval (); } let newState = state === 'OFF' ? 'ON' : 'OFF' ; client . publish ( `cmnd/ ${ device } /power` , newState ); console . log ( ` ${ Date . now () } TX cmnd/ ${ device } /power ${ newState } ` ); } Ref: Node MQTT.js","title":"JavaScript"},{"location":"MQTT-Overviev/#android-phone-mqtt-dashboard","text":"The MQTT Dashboard provides the ability to connect and control Sonoff devices directly. On the first page, enter the details of how your phone should connect to the MQTT broker. On the SUBSCRIBE page, you can create widgets which listen for publications from the Sonoff. A typical subscription for a power controller might be stat/my_device/POWER You could also pick up all your devices with stat/+/POWER On the PUBLISH page, you can create widgets to toggle or on/off your Sonoff. Typically you'd send a cmnd/my_device/power as the topic, and on or off as the publish value . Note that you can also have separate words on the app's user interface, such as illuminated and extinguished ; these are not sent out via MQTT, they're just user interface. Alternatively, if you're using a home automation system, there may be an Andriod/iOS app to link to your home automation. That's not covered in this how-to.","title":"Android phone MQTT Dashboard"},{"location":"MQTT-Overviev/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"MQTT-Overviev/#connect-failed","text":"MQTT : CONNECT FAILED x . x . x . x : x , rc { code }. Retry in 10 seconds","title":"CONNECT FAILED"},{"location":"MQTT-Overviev/#status-codes","text":"-4: MQTT_CONNECTION_TIMEOUT - the server didn't respond within the keepalive time -3: MQTT_CONNECTION_LOST - the network connection was broken -2: MQTT_CONNECT_FAILED - the network connection failed -1: MQTT_DISCONNECTED - the client is disconnected cleanly 0: MQTT_CONNECTED - the client is connected 1: MQTT_CONNECT_BAD_PROTOCOL - the server doesn't support the requested version of MQTT 2: MQTT_CONNECT_BAD_CLIENT_ID - the server rejected the client identifier 3: MQTT_CONNECT_UNAVAILABLE - the server was unable to accept the connection 4: MQTT_CONNECT_BAD_CREDENTIALS - the username/password were rejected 5: MQTT_CONNECT_UNAUTHORIZED - the client was not authorized to connect","title":"Status codes"},{"location":"MQTT-Overviev/#debug-tools","text":"MQTT Snooper - Sniffer App on Android MQTT Explorer - Desktop Application If mosquitto is installed, command-line: mosquitto_sub -h mqtt-host -v -t \"#\"","title":"Debug Tools"},{"location":"MQTT/","text":"MQTT is the main protocol for controlling Tasmota devices If you have no knowledge of what MQTT is, you can learn about it from MQTT Essentials articles. After you have a working MQTT broker you need to configure Tasmota to communicate with it. Configure MQTT ~ If you flashed a precompiled .bin or didn't enter MQTT info in user_config_override.h before compiling you have to configure it on your device first. Configure MQTT using WebUI ~ Go to Configuration -> Configure Other and make sure \"MQTT Enable\" box is checked. Once MQTT is enabled you need to set it up using Configuration -> Configure MQTT . Tip While here, you might as well change the Friendly Name into something more descriptive than generic \"Tasmota\". This is a must for Home Assistant autodiscovery feature. For a basic setup you only need to set Host , User and Password but it is recommended to change Topic to avoid issues. Each device should have a unique Topic . Host = your MQTT broker address or IP ( mDNS is not available in the official Tasmota builds , means no .local domain!) Port = your MQTT broker port (default port is set to 1883) Client = device's unique identifier. In 99% of cases it's okay to leave it as is, however some Cloud-based MQTT brokers require a ClientID connected to your account. User = username for authenticating on your MQTT broker Password = password for authenticating on your MQTT broker Topic = unique identifying topic for your device (e.g. hallswitch , kitchen-light ). %topic% in wiki references to this. It is recommended to use a single word for the topic. FullTopic = full topic definition . Modify it if you want to use multi-level topics for your devices, for example lights/%prefix%/%topic%/ or %prefix%/top_floor/bathroom/%topic%/ etc. Configure MQTT using Backlog ~ Using a serial connection or the WebUI Console you can issue (or even better, paste a premade) Backlog command for quick and easy MQTT setup. Backlog mqtthost < mqtt_broker_address > ; mqttport < mqtt_broker_port > ; mqttuser < username > ; mqttpassword < password > ; topic < device_topic > After a reboot all necessary MQTT settings are configured. Don't forget, you can use Backlog for all commands! Commands over MQTT ~ To send commands and view responses you'll need an MQTT client . Commands over MQTT are issued to Tasmota by using cmnd/%topic%/<command> <parameter> . If there is no <parameter> (an empty MQTT message/payload), a query is sent for current status of the <command> . Tip If you are using mosquitto_pub , you can issue an empty payload using the -n command line option. If your MQTT client cannot issue an empty payload, you can use the single character ? instead. Command flow ~ The following example will go in depth on what happens when you send an MQTT command. A device was flashed and configured with the FullTopic as default %prefix%/%topic%/ and the Topic set to tasmota_switch . We want to see the current status of the switch and change it. By looking at the commands table we can learn about the POWER command and options associated with it. Ask the device for status js cmnd/tasmota_switch/Power \u2190 // an empty message/payload sends a status query \u21b3 stat/tasmota_switch/RESULT \u2192 {\"POWER\":\"OFF\"} \u21b3 stat/tasmota_switch/POWER \u2192 OFF We can see that the switch (device's relay) is turned off. Send a command to toggle the relay js cmnd/tasmota_switch/Power \u2190 \"TOGGLE\" \u21b3 // Power for relay 1 is toggled \u21b3 stat/tasmota_switch/RESULT \u2192 {\"POWER\":\"ON\"} \u21b3 stat/tasmota_switch/POWER \u2192 ON We've sent the toggle command and received confirmation that the switch is turned on. Tip By default, Tasmota replies to all commands through .../RESULT . This behavior can be changed using SetOption4 , which makes the commands reply on the endpoint matching the command name, ex. cmnd/tasmota/PowerOnState will send a response on cmnd/tasmota/POWERONSTATE . Examples ~ In the following examples %topic% is tasmota , FullTopic is %prefix%/%topic%/ , and prefixes are default cmnd/stat/tele : The relay can be controlled with cmnd/tasmota/POWER on , cmnd/tasmota/POWER off or cmnd/tasmota/POWER toggle . Tasmota will send a MQTT status message like stat/tasmota/POWER ON . The power state message can be sent with the retain flag set. Enable this with cmnd/tasmota/PowerRetain on . The telemetry messages can also be sent with the retain flag, but this is a compile option. See #1071 . For Sonoff Dual or Sonoff 4CH the relays need to be addressed with cmnd/tasmota/POWER<x> , where {x} is the relay number from 1 to 2 (Sonoff Dual) or from 1 to 4 (Sonoff 4CH). cmnd/tasmota/POWER4 off turns off the 4th relay on a Sonoff 4CH. MQTT topic can be changed with cmnd/tasmota/Topic tasmota1 which reboots Tasmota and changes the %topic% to tasmota1 . From that point on MQTT commands should look like cmnd/tasmota1/POWER on . The OTA firmware location can be made known to tasmota with cmnd/tasmota/OtaUrl http://thehackbox.org/tasmota/release/tasmota.bin . Reset to default with cmnd/tasmota/OtaUrl 1 . Upgrade OTA firmware from the OtaUrl server with cmnd/tasmota/Upgrade 1 . Show all status information with cmnd/tasmota/Status 0 . The button can send a MQTT message to the broker that in turn will switch the relay. To configure this you need to perform cmnd/tasmota/ButtonTopic tasmota where tasmota equals to Topic. The message can also be provided with the retain flag by cmnd/tasmota/ButtonRetain on . Sonoff Pow (and any device with sensors) status can be requested manually with cmnd/tasmota/status 8 . Additionally, Tasmota periodically sends telemetry every TelePeriod , which defaults to 300 seconds (5 minutes). When a Sonoff Pow (and any device with power metering sensors) threshold like PowerLow has been met a message tele/tasmota/POWER_LOW ON will be sent. When the error is corrected a message tele/tasmota/POWER_LOW OFF will be sent. While most MQTT commands will result in a message in JSON format the power status feedback will always be returned like stat/tasmota/POWER ON as well. Telemetry data will be sent by prefix tele like tele/tasmota/SENSOR {\"Time\":\"2017-02-16T10:13:52\", \"DS18B20\":{\"Temperature\":20.6}} MQTT Topic Definition ~ FullTopic ~ This is the MQTT topic used to communicate with Tasmota over MQTT. It is created using tokens placed within a user definable string (100 character limit). The tokens are substituted dynamically at run-time. Available substitution tokens are: - %prefix% = one of three prefixes as defined by commands Prefix1 (default = cmnd ) , Prefix2 (default = stat ) and Prefix3 (default = tele ) . - %topic% = one of five topics as defined by commands Topic , GroupTopic , ButtonTopic , SwitchTopic and MqttClient . - %hostname% = the hostname of the device as defined through the web UI (default = %s-%04d ) or via Hostname command. - %id% = MAC address of the device. Tip These substitution tokens will be used in examples across the documentation If FullTopic does not contain the %topic% token, the device will not subscribe to GroupTopic and FallbackTopic . Tip The order of %prefix% and %topic% doesn't matter, unless you have enabled Auto-discovery for Home Assistant ( SetOption19 ). Enabling this option re-formats the FullTopic to required order. Using the tokens the following example topics can be made: - FullTopic %prefix%/%topic%/ default - FullTopic tasmota/%topic%/%prefix%/ - FullTopic tasmota/bedroom/%topic%/%prefix%/ - FullTopic penthouse/bedroom1/bathroom2/%topic%/%prefix%/ - FullTopic %prefix%/home/cellar/%topic%/ %prefix% Tasmota uses 3 prefixes for forming a FullTopic: cmnd - prefix to issue commands; ask for status stat - reports back status or configuration message tele - reports telemetry info at specified intervals Tip To solve possible MQTT topic loops it is strongly suggested that you use the %prefix% token in all of your FullTopics. Status and telemetry do not need a prefix. %topic% ~ All MQTT status messages will be sent using the configurable %topic% which must be made unique by the user. It can be called bedroom but it could also be called XP-TS_10 as long as the user knows what it is and where to find it. ?> Default Topic is tasmota_XXXX where XXXX is unique and derives from the MAC address The use of the %topic% token is mandatory in case you want to use ButtonTopic and/or SwitchTopic . It also provides for GroupTopic and Fallback Topic functionality. Tip Use %prefix% and %topic% tokens at all time within your FullTopic definition! GroupTopic ~ Having two devices with the same topic allowed for MQTT commands to be sent once to make the devices act in conjunction. That inspired a third topic called GroupTopic. Devices with the same GroupTopic will all listen to that GroupTopic and react to the same MQTT command sent to it. You can use this to take global actions like updating firmware on all devices or split up devices into different groups using a unique GroupTopic for each group. ?> Default GroupTopic is tasmotas FallBack Topic ~ Initially Tasmota had one MQTT configurable topic planned called Topic. It soon became apparent that when two devices come online with the same topic this would be a challenge, to say the least! Tasmota then introduced a unique, non-configurable \"FallBack Topic\" that allows MQTT communication regardless of the configurable topic. This fallback topic is just what it is meant to be: a fallback topic in case of emergency! By default the Fallback Topic is DVES_XXXXXX_fb where xxxxxx is derived from the last 6 charactes of the device's MAC address (excluding : ). It might look something like this: DVES_3D5E26_fb . You can find out the DVES code by looking at Information page in the webUI or issuing Status 6 : 12 : 36 : 17 MQT: stat/tasmota/STATUS 6 = { \"StatusMQT\" :{ \"MqttHost\" : \"1.1.1.1\" , \"MqttPort\" : 1883 , \"MqttClientMask\" : \"DVES_%06X\" , \"MqttClient\" : \"DVES_3D5E26\" , \"MqttUser\" : \"tasmota\" , \"MqttCount\" : 1 , \"MAX_PACKET_SIZE\" : 1000 , \"KEEPALIVE\" : 30 }} Retained MQTT Messages ~ If MQTT is defined and PowerRetain is used the last state will be stored permanently in MQTT database. Command Description PowerRetain Show current MQTT power retain state. 0 / off = disable MQTT power retain on status update (default) 1 / on = enable MQTT power retain on status update BUT , a message in your MQTT broker flagged as 'retained' will always override the PowerOnState . This is usually the main cause for \"ghost switching\". Learn more in MQTT retained messages explained . Check out this tutorial for troubleshooting switch ghosting. Clearing Retained Messages ~ To check, if there is a retain flag set for the switch's power topic, monitor cmnd/+/power in a MQTT client (recommended MQTT.fx for Windows or Eclipse Mosquitto in linux). You can use Tasmota Device Manager to clear all retained messages for selected device with a single click. ![Tasmota Device Manager]_media/tdm-retained.png) or use the following tutorials/forum threads: Clearing retained messages with mosquitto Remove retained messages in Home Assistant Remove retained messages in hass.io MQTT addon","title":"MQTT"},{"location":"MQTT/#configure-mqtt","text":"If you flashed a precompiled .bin or didn't enter MQTT info in user_config_override.h before compiling you have to configure it on your device first.","title":"Configure MQTT"},{"location":"MQTT/#configure-mqtt-using-webui","text":"Go to Configuration -> Configure Other and make sure \"MQTT Enable\" box is checked. Once MQTT is enabled you need to set it up using Configuration -> Configure MQTT . Tip While here, you might as well change the Friendly Name into something more descriptive than generic \"Tasmota\". This is a must for Home Assistant autodiscovery feature. For a basic setup you only need to set Host , User and Password but it is recommended to change Topic to avoid issues. Each device should have a unique Topic . Host = your MQTT broker address or IP ( mDNS is not available in the official Tasmota builds , means no .local domain!) Port = your MQTT broker port (default port is set to 1883) Client = device's unique identifier. In 99% of cases it's okay to leave it as is, however some Cloud-based MQTT brokers require a ClientID connected to your account. User = username for authenticating on your MQTT broker Password = password for authenticating on your MQTT broker Topic = unique identifying topic for your device (e.g. hallswitch , kitchen-light ). %topic% in wiki references to this. It is recommended to use a single word for the topic. FullTopic = full topic definition . Modify it if you want to use multi-level topics for your devices, for example lights/%prefix%/%topic%/ or %prefix%/top_floor/bathroom/%topic%/ etc.","title":"Configure MQTT using WebUI"},{"location":"MQTT/#configure-mqtt-using-backlog","text":"Using a serial connection or the WebUI Console you can issue (or even better, paste a premade) Backlog command for quick and easy MQTT setup. Backlog mqtthost < mqtt_broker_address > ; mqttport < mqtt_broker_port > ; mqttuser < username > ; mqttpassword < password > ; topic < device_topic > After a reboot all necessary MQTT settings are configured. Don't forget, you can use Backlog for all commands!","title":"Configure MQTT using Backlog"},{"location":"MQTT/#commands-over-mqtt","text":"To send commands and view responses you'll need an MQTT client . Commands over MQTT are issued to Tasmota by using cmnd/%topic%/<command> <parameter> . If there is no <parameter> (an empty MQTT message/payload), a query is sent for current status of the <command> . Tip If you are using mosquitto_pub , you can issue an empty payload using the -n command line option. If your MQTT client cannot issue an empty payload, you can use the single character ? instead.","title":"Commands over MQTT"},{"location":"MQTT/#command-flow","text":"The following example will go in depth on what happens when you send an MQTT command. A device was flashed and configured with the FullTopic as default %prefix%/%topic%/ and the Topic set to tasmota_switch . We want to see the current status of the switch and change it. By looking at the commands table we can learn about the POWER command and options associated with it. Ask the device for status js cmnd/tasmota_switch/Power \u2190 // an empty message/payload sends a status query \u21b3 stat/tasmota_switch/RESULT \u2192 {\"POWER\":\"OFF\"} \u21b3 stat/tasmota_switch/POWER \u2192 OFF We can see that the switch (device's relay) is turned off. Send a command to toggle the relay js cmnd/tasmota_switch/Power \u2190 \"TOGGLE\" \u21b3 // Power for relay 1 is toggled \u21b3 stat/tasmota_switch/RESULT \u2192 {\"POWER\":\"ON\"} \u21b3 stat/tasmota_switch/POWER \u2192 ON We've sent the toggle command and received confirmation that the switch is turned on. Tip By default, Tasmota replies to all commands through .../RESULT . This behavior can be changed using SetOption4 , which makes the commands reply on the endpoint matching the command name, ex. cmnd/tasmota/PowerOnState will send a response on cmnd/tasmota/POWERONSTATE .","title":"Command flow"},{"location":"MQTT/#examples","text":"In the following examples %topic% is tasmota , FullTopic is %prefix%/%topic%/ , and prefixes are default cmnd/stat/tele : The relay can be controlled with cmnd/tasmota/POWER on , cmnd/tasmota/POWER off or cmnd/tasmota/POWER toggle . Tasmota will send a MQTT status message like stat/tasmota/POWER ON . The power state message can be sent with the retain flag set. Enable this with cmnd/tasmota/PowerRetain on . The telemetry messages can also be sent with the retain flag, but this is a compile option. See #1071 . For Sonoff Dual or Sonoff 4CH the relays need to be addressed with cmnd/tasmota/POWER<x> , where {x} is the relay number from 1 to 2 (Sonoff Dual) or from 1 to 4 (Sonoff 4CH). cmnd/tasmota/POWER4 off turns off the 4th relay on a Sonoff 4CH. MQTT topic can be changed with cmnd/tasmota/Topic tasmota1 which reboots Tasmota and changes the %topic% to tasmota1 . From that point on MQTT commands should look like cmnd/tasmota1/POWER on . The OTA firmware location can be made known to tasmota with cmnd/tasmota/OtaUrl http://thehackbox.org/tasmota/release/tasmota.bin . Reset to default with cmnd/tasmota/OtaUrl 1 . Upgrade OTA firmware from the OtaUrl server with cmnd/tasmota/Upgrade 1 . Show all status information with cmnd/tasmota/Status 0 . The button can send a MQTT message to the broker that in turn will switch the relay. To configure this you need to perform cmnd/tasmota/ButtonTopic tasmota where tasmota equals to Topic. The message can also be provided with the retain flag by cmnd/tasmota/ButtonRetain on . Sonoff Pow (and any device with sensors) status can be requested manually with cmnd/tasmota/status 8 . Additionally, Tasmota periodically sends telemetry every TelePeriod , which defaults to 300 seconds (5 minutes). When a Sonoff Pow (and any device with power metering sensors) threshold like PowerLow has been met a message tele/tasmota/POWER_LOW ON will be sent. When the error is corrected a message tele/tasmota/POWER_LOW OFF will be sent. While most MQTT commands will result in a message in JSON format the power status feedback will always be returned like stat/tasmota/POWER ON as well. Telemetry data will be sent by prefix tele like tele/tasmota/SENSOR {\"Time\":\"2017-02-16T10:13:52\", \"DS18B20\":{\"Temperature\":20.6}}","title":"Examples"},{"location":"MQTT/#mqtt-topic-definition","text":"","title":"MQTT Topic Definition"},{"location":"MQTT/#fulltopic","text":"This is the MQTT topic used to communicate with Tasmota over MQTT. It is created using tokens placed within a user definable string (100 character limit). The tokens are substituted dynamically at run-time. Available substitution tokens are: - %prefix% = one of three prefixes as defined by commands Prefix1 (default = cmnd ) , Prefix2 (default = stat ) and Prefix3 (default = tele ) . - %topic% = one of five topics as defined by commands Topic , GroupTopic , ButtonTopic , SwitchTopic and MqttClient . - %hostname% = the hostname of the device as defined through the web UI (default = %s-%04d ) or via Hostname command. - %id% = MAC address of the device. Tip These substitution tokens will be used in examples across the documentation If FullTopic does not contain the %topic% token, the device will not subscribe to GroupTopic and FallbackTopic . Tip The order of %prefix% and %topic% doesn't matter, unless you have enabled Auto-discovery for Home Assistant ( SetOption19 ). Enabling this option re-formats the FullTopic to required order. Using the tokens the following example topics can be made: - FullTopic %prefix%/%topic%/ default - FullTopic tasmota/%topic%/%prefix%/ - FullTopic tasmota/bedroom/%topic%/%prefix%/ - FullTopic penthouse/bedroom1/bathroom2/%topic%/%prefix%/ - FullTopic %prefix%/home/cellar/%topic%/","title":"FullTopic"},{"location":"MQTT/#topic","text":"All MQTT status messages will be sent using the configurable %topic% which must be made unique by the user. It can be called bedroom but it could also be called XP-TS_10 as long as the user knows what it is and where to find it. ?> Default Topic is tasmota_XXXX where XXXX is unique and derives from the MAC address The use of the %topic% token is mandatory in case you want to use ButtonTopic and/or SwitchTopic . It also provides for GroupTopic and Fallback Topic functionality. Tip Use %prefix% and %topic% tokens at all time within your FullTopic definition!","title":"%topic%"},{"location":"MQTT/#grouptopic","text":"Having two devices with the same topic allowed for MQTT commands to be sent once to make the devices act in conjunction. That inspired a third topic called GroupTopic. Devices with the same GroupTopic will all listen to that GroupTopic and react to the same MQTT command sent to it. You can use this to take global actions like updating firmware on all devices or split up devices into different groups using a unique GroupTopic for each group. ?> Default GroupTopic is tasmotas","title":"GroupTopic"},{"location":"MQTT/#fallback-topic","text":"Initially Tasmota had one MQTT configurable topic planned called Topic. It soon became apparent that when two devices come online with the same topic this would be a challenge, to say the least! Tasmota then introduced a unique, non-configurable \"FallBack Topic\" that allows MQTT communication regardless of the configurable topic. This fallback topic is just what it is meant to be: a fallback topic in case of emergency! By default the Fallback Topic is DVES_XXXXXX_fb where xxxxxx is derived from the last 6 charactes of the device's MAC address (excluding : ). It might look something like this: DVES_3D5E26_fb . You can find out the DVES code by looking at Information page in the webUI or issuing Status 6 : 12 : 36 : 17 MQT: stat/tasmota/STATUS 6 = { \"StatusMQT\" :{ \"MqttHost\" : \"1.1.1.1\" , \"MqttPort\" : 1883 , \"MqttClientMask\" : \"DVES_%06X\" , \"MqttClient\" : \"DVES_3D5E26\" , \"MqttUser\" : \"tasmota\" , \"MqttCount\" : 1 , \"MAX_PACKET_SIZE\" : 1000 , \"KEEPALIVE\" : 30 }}","title":"FallBack Topic"},{"location":"MQTT/#retained-mqtt-messages","text":"If MQTT is defined and PowerRetain is used the last state will be stored permanently in MQTT database. Command Description PowerRetain Show current MQTT power retain state. 0 / off = disable MQTT power retain on status update (default) 1 / on = enable MQTT power retain on status update BUT , a message in your MQTT broker flagged as 'retained' will always override the PowerOnState . This is usually the main cause for \"ghost switching\". Learn more in MQTT retained messages explained . Check out this tutorial for troubleshooting switch ghosting.","title":"Retained MQTT Messages"},{"location":"MQTT/#clearing-retained-messages","text":"To check, if there is a retain flag set for the switch's power topic, monitor cmnd/+/power in a MQTT client (recommended MQTT.fx for Windows or Eclipse Mosquitto in linux). You can use Tasmota Device Manager to clear all retained messages for selected device with a single click. ![Tasmota Device Manager]_media/tdm-retained.png) or use the following tutorials/forum threads: Clearing retained messages with mosquitto Remove retained messages in Home Assistant Remove retained messages in hass.io MQTT addon","title":"Clearing Retained Messages"},{"location":"MacOSX-Server/","text":"Mac OSX comes with a built in web server, although it's not running by default. Starting the web server can be done by running: sudo apachectl start To start the server, you'll be asked for your user's password. Opening your localhost will show you 'it works!', which will tell you that much - it works. The folder to put files in is /Library/WebServer/Documents You may wish to create a subfolder for the firmware files. Use the IP address of this local web server to OTA flash Tasmota. You can determine your IP address here . For example, http://192.168.1.123/tasmota.bin Issue this command to stop the web server when your are done flashing: sudo apachectl stop Note: The MAMP web server does not seem to deliver the results as expected!","title":"MacOSX Server"},{"location":"Modules/","text":"Module is a firmware supported device which has specific code to enable its features. Configure Module page in the webUI is used to configure your device as one of the modules and to configure additional components connected to one of the free GPIO pins of the device. Warning New Modules are added to Tasmota only if a device requires additional code for new functions. Use Templates first to configure your device if it's not in the module list. Tip Use Generic module Module 18 to have almost all GPIO pins available. Each module is assigned a number which is used in Template configuration or when using Module command. # Name Module specifics 0 Template Module for currently active template. Named after the template NAME field. If a template is not active it will display Generic (0) . Do not use it until you configure a template , use Generic (18) instead 1 Sonoff Basic 2 Sonoff RF 3 Sonoff SV 4 Sonoff TH 5 Sonoff Dual Process relay and button via hardware serial interface using GPIO01 and GPIO03. Change the baud rate to 19200 bps. Process buttons as single press only 6 Sonoff POW 7 Sonoff 4Ch 8 Sonoff S2X 9 Slampher 10 Sonoff Touch Invert LedState 1 functionality 11 Sonoff LED Set light type to 2 PWM channels disregarding SetOption15. Fix device specific LED instabilities by disabling GPIO04, GPIO5 and GPIO14 12 1 Channel 13 4 Channel See Sonoff Dual 14 Motor C/AC Force all relays ON at power up and disable command PowerOnState 15 ElectroDragon 16 EXS Relay(s) Enable pulse latching using even/odd numbered relay pairs 17 WION 18 Generic Show Wemos specific pin information in GUI 19 Sonoff Dev 20 H801 Change hardware UART Tx from GPIO01 to GPIO02 21 Sonoff SC Enable and process data via hardware serial interface using GPIO01 and GPIO03. Change the baud rate to 19200 bps 22 Sonoff BN-SZ Set light type to 1 PWM channel disregarding SetOption15 23 Sonoff 4Ch Pro Button handling disregarding SetOption13 only allowing single press to enable RF learning while holding the button 24 Huafan SS 25 Sonoff Bridge Enable and Process data via hardware serial interface using GPIO01 and GPIO03. Change the baud rate to 19200 bps. Process 16 buttons in web GUI. Enable EFM8BB1 firmware upload 26 Sonoff B1 Set light type to RGBWC using MY92x1 27 Ailight Set light type to RGBW using MY92x1 28 Sonoff T1 1Ch See Sonoff Touch 29 Sonoff T1 2Ch See Sonoff Touch 30 Sonoff T1 3Ch See Sonoff Touch 31 Supla Espablo 32 Witty Cloud 33 Yunshan Relay 34 MagicHome 35 Luani HVIO 36 KMC 70011 37 Arilux LC01 38 Arilux LC11 39 Sonoff Dual R2 Process buttons as single press only 40 Arilux LC06 41 Sonoff S31 Selects component types for the CSE7766 (serial connected energy monitoring chip) with Rx and Tx hardware serial (even parity) on GPIO01 and GPIO03 respectively. Sets serial interface to 4800 baud and disables serial logging 42 Zengge WF017 43 Sonoff Pow R2 44 Sonoff IFan02 Enable command FanSpeed . Disable Interlock and PulseTime . Tune status information, MQTT data and GUI. Sync with microcontroller. Process Domoticz Fan state 45 Blitzwolf SHP Module specific power monitoring calibration 46 Shelly 1 47 Shelly 2 48 Xiaomi Philips Process color temperature using PWM2 and intensity using PWM1 49 Neo Coolcam 50 ESP SwitCh 51 Obi Socket 52 Teckin 53 APLIC WDP303075 54 TuyaMCU Enable and process data via software or hardware serial interface using component 107 and 108. Change the baud rate to 9600 bps. Process all buttons. Read more... 55 Gosund SP1 v23 56 Armtronix Dimmers Enable and process data via software or hardware serial interface using component 148 and 149. Change baudrate to 115200 bps. 57 SK03 Outdoor (Tuya) 58 PS-16-DZ Enable and process data via software or hardware serial interface using component 148 and 149. Change the baud rate to 19200 bps. 59 Teckin US 60 Manzoku Strip (EU 4) 61 Obi Socket 2 62 YTF IR Bridge Disable serial interface to stop loopback. 63 Digoo DG-SP202 64 KA10 65 Luminea ZX2820 66 Mi Desk Lamp Process rotary and Button1 data specific to this device 67 SP10 68 WAGA CHCZ02MB 69 SYF05 70 Sonoff L1 71 Sonoff iFan03 72 EX-Store Dimmer 73 PWM Dimmer For MJ-SD01/acenx/NTONPOWER PWM dimmers. Read more... 74 Sonoff D1 Dimmer Serial logging is disabled by the Tasmota code for several modules and components (e.g., Sonoff POW, Sonoff S31, Sonoff Dual (v1), Tuya dimmers, PZEM components, etc.). Serial communication is used by these devices to transfer the data from the MCU chip to the ESP chip. Do not enable serial logging ( SerialLog 0 ) on these devices. It can cause the device software to crash. Supported Modules","title":"Modules"},{"location":"Moisture-Sensor-and-Chirp%21-Sensor/","text":"!> This feature is not included in precompiled binaries. To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_CHIRP #define USE_CHIRP #endif Chirp! I 2 C moisture sensor is the sensor-only version of the original Chirp! sensor. The \"sensor mode only\" (without the chirp function) is the preferred sensor variant for Tasmota. It provides additional temperature readings. Chirp! is a plant watering alarm which uses capacitive sensing to measure moisture. It provides ambient light readings and works in Tasmota, but is not the recommended version. Additional References: - Catnip electronics - Plant Watering Alarm Connecting to an ESP82xx ~ Use a standard I 2 C connection plus 3.3V and GND. Device Configuration ~ In the Configuration -> Configure Other page, enter and activate the following template: {\"NAME\":\"HW-655 PZEM\",\"GPIO\":[0,0,0,0,6,5,0,0,0,0,0,0,0],\"FLAG\":0,\"BASE\":18} BASE: Generic (18) GPIO4 : I2C SDA (06) GPIO5 : I2C SCL (05) At boot time the driver will scan the I 2 C bus for CHIRP moisture sensors and enumerate them starting with 0. The sensor has a default I 2 C address of 0x20 , which can be changed within the driver so that multiple sensors are possible. Write access to the sensor is potentially dangerous!! Only change the I 2 C address while only one is sensor connected, using a stable power supply, and if you are familiar with how to flash the sensor. Commands ~ Command Description CHIRPSCAN Re-scan the I 2 C bus and re-enumerate the sensors. CHIRPSELECT Select the active sensor, which can receive commands. To select the first sensor use CHIRPSELECT 0 . CHIRPSET Set the new I 2 C address for the selected sensor. Use decimal address. To change active sensor to 0x1f (=31) use CHIRPSET 31 . CHIRPSLEEP Put the selected sensor into sleep mode. CHIRPWAKE Wake the selected (sleeping) sensor. CHIRPRESET Reset the selected sensor. Sensor readings ~ The original explanation from the manufacturer can be found on this tindie page . It is important to understand, that the light sensor does not provide LUX but a relative reading ( 0..65535 ), where more light means a lower value! The term DARKNESS is used in Tasmota. !! \u26a0\ufe0f PLEASE USE TelePeriod OF 20 OR GREATER \u26a0\ufe0f !! The driver will sync with the TelePeriod and start the measure cycle about 17 seconds before the next telemetry message. You can issue a Status 8 and any time to output that last sensor readings. Known issues ~ The sensor is relatively slow and therefore the driver will (try to) slow down the I 2 C bus-speed and extend the CLOCKSTRETCHLIMIT. A long discussion about it can be found here . The problem seems to occur mostly when the sensor wakes up from sleep. That is why the implemented auto-sleep-wake function is currently deactivated in the driver. Typically when you get readings of 0 for all 3 measurements, then the I 2 C bus is likely \"frozen\". The expected result for I2CSCAN on the console is {\"I2CScan\":\"Error 4 at 0x01\"} . A restart ( Restart 1 ) of Tasmota should be enough, but you may need to power cycle the device. Different ESP Cores may lead to different behavior. It is possible to flash incorrect firmware to a sensor (chirp vs non-chirp). This will very likely lead to nonsense temperature readings. Multiple sensors on one I 2 C bus were tested successfully, but are not guaranteed to work due to multiple possible reasons (power, cabling, ...). Your mileage may vary.","title":"Chirp! moisture sensor"},{"location":"Moisture-Sensor-and-Chirp%21-Sensor/#connecting-to-an-esp82xx","text":"Use a standard I 2 C connection plus 3.3V and GND.","title":"Connecting to an ESP82xx"},{"location":"Moisture-Sensor-and-Chirp%21-Sensor/#device-configuration","text":"In the Configuration -> Configure Other page, enter and activate the following template: {\"NAME\":\"HW-655 PZEM\",\"GPIO\":[0,0,0,0,6,5,0,0,0,0,0,0,0],\"FLAG\":0,\"BASE\":18} BASE: Generic (18) GPIO4 : I2C SDA (06) GPIO5 : I2C SCL (05) At boot time the driver will scan the I 2 C bus for CHIRP moisture sensors and enumerate them starting with 0. The sensor has a default I 2 C address of 0x20 , which can be changed within the driver so that multiple sensors are possible. Write access to the sensor is potentially dangerous!! Only change the I 2 C address while only one is sensor connected, using a stable power supply, and if you are familiar with how to flash the sensor.","title":"Device Configuration"},{"location":"Moisture-Sensor-and-Chirp%21-Sensor/#commands","text":"Command Description CHIRPSCAN Re-scan the I 2 C bus and re-enumerate the sensors. CHIRPSELECT Select the active sensor, which can receive commands. To select the first sensor use CHIRPSELECT 0 . CHIRPSET Set the new I 2 C address for the selected sensor. Use decimal address. To change active sensor to 0x1f (=31) use CHIRPSET 31 . CHIRPSLEEP Put the selected sensor into sleep mode. CHIRPWAKE Wake the selected (sleeping) sensor. CHIRPRESET Reset the selected sensor.","title":"Commands"},{"location":"Moisture-Sensor-and-Chirp%21-Sensor/#sensor-readings","text":"The original explanation from the manufacturer can be found on this tindie page . It is important to understand, that the light sensor does not provide LUX but a relative reading ( 0..65535 ), where more light means a lower value! The term DARKNESS is used in Tasmota. !! \u26a0\ufe0f PLEASE USE TelePeriod OF 20 OR GREATER \u26a0\ufe0f !! The driver will sync with the TelePeriod and start the measure cycle about 17 seconds before the next telemetry message. You can issue a Status 8 and any time to output that last sensor readings.","title":"Sensor readings"},{"location":"Moisture-Sensor-and-Chirp%21-Sensor/#known-issues","text":"The sensor is relatively slow and therefore the driver will (try to) slow down the I 2 C bus-speed and extend the CLOCKSTRETCHLIMIT. A long discussion about it can be found here . The problem seems to occur mostly when the sensor wakes up from sleep. That is why the implemented auto-sleep-wake function is currently deactivated in the driver. Typically when you get readings of 0 for all 3 measurements, then the I 2 C bus is likely \"frozen\". The expected result for I2CSCAN on the console is {\"I2CScan\":\"Error 4 at 0x01\"} . A restart ( Restart 1 ) of Tasmota should be enough, but you may need to power cycle the device. Different ESP Cores may lead to different behavior. It is possible to flash incorrect firmware to a sensor (chirp vs non-chirp). This will very likely lead to nonsense temperature readings. Multiple sensors on one I 2 C bus were tested successfully, but are not guaranteed to work due to multiple possible reasons (power, cabling, ...). Your mileage may vary.","title":"Known issues"},{"location":"NRF24L01/","text":"!> This feature is not included in precompiled binaries. To use it you must compile your build . Add the following to user_config_override.h : #define USE_SPI // Hardware SPI using GPIO12(MISO), GPIO13(MOSI) and GPIO14(CLK) in addition to two user selectable GPIOs(CS and DC) #ifndef USE_NRF24 #define USE_NRF24 // Add SPI support for RF24L01(+) (+2k6 code) #define USE_MIBLE // BLE-bridge for some Mijia-BLE-sensors (+4k7 code) #endif This chip is manufactured by Nordic Semiconductors as a single chip transceiver in the 2,4 GHz band. There are many applications of this chip in many projects as a versatile very low cost wireless module. In recent years solutions were found to use this chip for limited Bluetooth-Low-Energy communication. One of the first articles about this topic can be found here . Subsequently, further work was done by several developers and a working bridge to read sensor data from a Xiaomi MJ_HT_V1 BLE sensor was created. The fundamental principle is, that some of these sensors send its data as a usual BLE-advertisement packet with a proprietary data format at the end of the payload. These packets had to fit into the 32 bytes of the FIFO-RX-buffer of the RF24L01, otherwise the \"later\" bytes were lost. A new solution was found for the Tasmota driver. The basic idea is to use some constant ID-bytes of the BLE-packets as the PDU-type for the NRF24l01. Thus, all bytes before these ID-bytes are lost and the size restriction for the payload is successfully circumvented. That way it is possible to read the sensor data from a Mi Flora sensor, which is positioned outside of the 32-byte-range. Of course there is still no bidirectional \"real\" BLE-communication, only advertisements can be read. Configuration ~ Wiring ~ Configure the pins for SPI_DC and SPI_CS while connecting the hardware SPI pins 12 - 14 (MOSI, MISO and CLOCK). Tip In order to simplify the code, the pin names from the SPI-display-drivers are used in the webUI! For nRF24L01 SPI_DC translates to CSN and SPI_CS to CE. Tasmota Settings ~ No additional steps are necessary. The initial log should like this: 00 : 00 : 00 NRF24L01 initialized 00 : 00 : 00 NRF24L01 + detected 00 : 00 : 00 MIBLE : started The driver will do the rest automatically and start to look for known \"special\" packets, which will be used to extract the sensor readings. webUI and TELE-messages will be populated with sensor data. This can take a while after start and may be influenced by the general traffic on the 2,4 GHz band. For a complete overview of supported devices, commands and features read the Bluetooth article .","title":"NRF24L01"},{"location":"NRF24L01/#configuration","text":"","title":"Configuration"},{"location":"NRF24L01/#wiring","text":"Configure the pins for SPI_DC and SPI_CS while connecting the hardware SPI pins 12 - 14 (MOSI, MISO and CLOCK). Tip In order to simplify the code, the pin names from the SPI-display-drivers are used in the webUI! For nRF24L01 SPI_DC translates to CSN and SPI_CS to CE.","title":"Wiring"},{"location":"NRF24L01/#tasmota-settings","text":"No additional steps are necessary. The initial log should like this: 00 : 00 : 00 NRF24L01 initialized 00 : 00 : 00 NRF24L01 + detected 00 : 00 : 00 MIBLE : started The driver will do the rest automatically and start to look for known \"special\" packets, which will be used to extract the sensor readings. webUI and TELE-messages will be populated with sensor data. This can take a while after start and may be influenced by the general traffic on the 2,4 GHz band. For a complete overview of supported devices, commands and features read the Bluetooth article .","title":"Tasmota Settings"},{"location":"NodeRed/","text":"Home automation system examples with Pi, Tasmota and Node-Red Detailed setting up Node-Red and mosquitto on a Raspberry PI and initial control of a Sonoff Switch: https://www.instructables.com/id/Powerful-Standalone-Home-Automation-System-Pi-Sono/ Detailed setting up of sensors and LEDs using Tasmota: https://www.instructables.com/id/Home-Automation-Tasmota-Sensors-LEDs-Develo/ Credits: @MikePRoberts ESP8266 OTA Firmware Upgrade Manager and Server https://flows.nodered.org/flow/888b4cd95250197eb429b2f40d188185 Dynamically Populate Dashboard with Buttons to Tasmota-Sonoff Devices https://flows.nodered.org/flow/1541bcbba48bb088ec1503dba109f63c","title":"NodeRed"},{"location":"OTA-over-SCP/","text":"How to setup and configure \"OTA over SCP\" upload for PlatformIO. The uploader pushes .bin files to remote OTA server using SCP (SSH connection). Images can be served to Tasmotas from there. Configuration ~ To upload .bin images to OTA server using SCP, edit the following lines under target environment: ; *** Upload file to OTA server using SCP upload_port = USER@HOST:/path extra_scripts = pio/sftp-uploader.py upload_port should be modified to reflect user, host and path on the host where images should be uploaded. Requirements ~ SSH communication between the build server and OTA server should be pre-configured so that it doesn't require password (pre-shared keys). Add the pre-shared key ~ On a linux client machine type the following to generate the key. Press enter three times (without any input): ssh-keygen -t rsa -C \"YOUR OWN KEY DESCRIPTION\" Copy the key to your ssh server. You need to confirm this action. Use your server ssh password (one last time): ssh-copy-id -i ~/.ssh/id_rsa.pub USER@HOST Optionally, reload the ssh service: sudo /etc/init.d/ssh restart Upload Tasmota ~ Easy compilation and upload can be performed from the icons at the left side of the PlatformIO screen or use Ctrl + Alt + U to upload (will build if needed).","title":"OTA over SCP"},{"location":"OTA-over-SCP/#configuration","text":"To upload .bin images to OTA server using SCP, edit the following lines under target environment: ; *** Upload file to OTA server using SCP upload_port = USER@HOST:/path extra_scripts = pio/sftp-uploader.py upload_port should be modified to reflect user, host and path on the host where images should be uploaded.","title":"Configuration"},{"location":"OTA-over-SCP/#requirements","text":"SSH communication between the build server and OTA server should be pre-configured so that it doesn't require password (pre-shared keys).","title":"Requirements"},{"location":"OTA-over-SCP/#add-the-pre-shared-key","text":"On a linux client machine type the following to generate the key. Press enter three times (without any input): ssh-keygen -t rsa -C \"YOUR OWN KEY DESCRIPTION\" Copy the key to your ssh server. You need to confirm this action. Use your server ssh password (one last time): ssh-copy-id -i ~/.ssh/id_rsa.pub USER@HOST Optionally, reload the ssh service: sudo /etc/init.d/ssh restart","title":"Add the pre-shared key"},{"location":"OTA-over-SCP/#upload-tasmota","text":"Easy compilation and upload can be performed from the icons at the left side of the PlatformIO screen or use Ctrl + Alt + U to upload (will build if needed).","title":"Upload Tasmota"},{"location":"Octoprint/","text":"OctoPrint ~ OctoPrint provides a snappy web interface for controlling consumer 3D printers. It is Free Software and released under the GNU Affero General Public License V3 by Gina H\u00e4u\u00dfge. Its website can be found at http://www.octoprint.org. OctoPrint-Tasmota ~ Jneilliii wrote a plugin to control your Sonoff device with tasmota firmware via OctoPrint, for example shutdown the printer after a print has finished. Repository: https://github.com/jneilliii/OctoPrint-Tasmota","title":"OctoPrint"},{"location":"Octoprint/#octoprint","text":"OctoPrint provides a snappy web interface for controlling consumer 3D printers. It is Free Software and released under the GNU Affero General Public License V3 by Gina H\u00e4u\u00dfge. Its website can be found at http://www.octoprint.org.","title":"OctoPrint"},{"location":"Octoprint/#octoprint-tasmota","text":"Jneilliii wrote a plugin to control your Sonoff device with tasmota firmware via OctoPrint, for example shutdown the printer after a print has finished. Repository: https://github.com/jneilliii/OctoPrint-Tasmota","title":"OctoPrint-Tasmota"},{"location":"P1-Smart-Meter/","text":"Kaifa MA105C Energy Meter ~ In this example the Kaifa MA105C meter is used and might work with other meters as well. Schematics ~ The transistor makes sure that the RxD signal is converted and inverted to 3.3v Tasmota Settings ~ In the Configuration -> Configure Module page, select module Generic (18) From the web console set the serial delimiter to 10 (newline). This makes Tasmota publish each line of the telegram separately to mqtt. SerialDelimiter 10 SerialSend Example output ~ Below an example of the telegram message published (per line) to mqtt. From here your HA system can process the data required for your needs. 16 : 59 : 39 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"/KFM5KAIFA-METER\" } 16 : 59 : 39 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"\" } 16 : 59 : 39 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"1-3:0.2.8(42)\" } 16 : 59 : 39 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"0-0:1.0.0(190104170020W)\" } 16 : 59 : 39 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"0-0:96.1.1(4530303235303030303639363432393136)\" } 16 : 59 : 39 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:1.8.1(002342.060*kWh)\" } 16 : 59 : 39 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:1.8.2(002566.728*kWh)\" } 16 : 59 : 39 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:2.8.1(000000.000*kWh)\" } 16 : 59 : 39 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:2.8.2(000000.000*kWh)\" } 16 : 59 : 39 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"0-0:96.14.0(0002)\" } 16 : 59 : 40 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:1.7.0(00.428*kW)\" } 16 : 59 : 40 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:2.7.0(00.000*kW)\" } 16 : 59 : 40 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"0-0:96.7.21(00000)\" } 16 : 59 : 40 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"0-0:96.7.9(00000)\" } 16 : 59 : 40 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:99.97.0(1)(0-0:96.7.19)(000101000001W)(2147483647*s)\" } 16 : 59 : 40 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:32.32.0(00000)\" } 16 : 59 : 40 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:32.36.0(00000)\" } 16 : 59 : 40 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"0-0:96.13.1()\" } 16 : 59 : 40 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"0-0:96.13.0()\" } 16 : 59 : 40 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:31.7.0(002*A)\" } 16 : 59 : 40 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:21.7.0(00.453*kW)\" } 16 : 59 : 40 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:22.7.0(00.000*kW)\" } 16 : 59 : 40 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"0-1:24.1.0(003)\" } 16 : 59 : 40 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"0-1:96.1.0(4730303332353631323736373836373136)\" } 16 : 59 : 40 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"0-1:24.2.1(190104160000W)(02949.209*m3)\" } 16 : 59 : 40 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"!EE58\" } Description of each line ~ see also DSMR 5.0 - P1 Companion Standard Header information - {\"SerialReceived\":\"/KFM5KAIFA-METER\"} Empty line - {\"SerialReceived\":\"\"} Version information for P1 output - {\"SerialReceived\":\"1-3:0.2.8(42)\"} Date-time stamp of the P1 message - {\"SerialReceived\":\"0-0:1.0.0(181227093413W)\"} Equipment identifier - {\"SerialReceived\":\"0-0:96.1.1(4530303235303030303639363432393136)\"} electricityUsedTariff1 >> Meter Reading electricity delivered to client (Tariff 1) in 0,001 kWh - {\"SerialReceived\":\"1-0:1.8.1(002293.192*kWh)\"} electricityUsedTariff2 >> Meter Reading electricity delivered to client (Tariff 2) in 0,001 kWh - {\"SerialReceived\":\"1-0:1.8.2(002523.640*kWh)\"} Meter Reading electricity delivered by client (Tariff 1) in 0,001 kWh - {\"SerialReceived\":\"1-0:2.8.1(000000.000*kWh)\"} Meter Reading electricity delivered by client (Tariff 2) in 0,001 kWh - {\"SerialReceived\":\"1-0:2.8.2(000000.000*kWh)\"} electricityActiveTariff >> Tariff indicator electricity. The tariff indicator can also be used to switch tariff dependent loads e.g boilers. This is the responsibility of the P1 user - {\"SerialReceived\":\"0-0:96.14.0(0002)\"} Actual electricity power delivered (+P) in 1 Watt resolution - {\"SerialReceived\":\"1-0:1.7.0(00.474*kW)\"} Actual electricity power received (-P) in 1 Watt resolution - {\"SerialReceived\":\"1-0:2.7.0(00.000*kW)\"} Number of power failures in any phase - {\"SerialReceived\":\"0-0:96.7.21(00000)\"} Number of long power failures in any phase - {\"SerialReceived\":\"0-0:96.7.9(00000)\"} Power Failure Event Log (long power failures) - {\"SerialReceived\":\"1-0:99.97.0(1)(0-0:96.7.19)(000101000001W)(2147483647*s)\"} Number of voltage sags in phase L1 - {\"SerialReceived\":\"1-0:32.32.0(00000)\"} Number of voltage swells in phase L1 - {\"SerialReceived\":\"1-0:32.36.0(00000)\"} Text message max 1024 characters. - {\"SerialReceived\":\"0-0:96.13.1()\"} Text message max 1024 characters. - {\"SerialReceived\":\"0-0:96.13.0()\"} Instantaneous current L1 in A resolution - {\"SerialReceived\":\"1-0:31.7.0(002*A)\"} Instantaneous active power L1 (+P) in W resolution - {\"SerialReceived\":\"1-0:21.7.0(00.474*kW)\"} Instantaneous active power L1 (-P) in W resolution - {\"SerialReceived\":\"1-0:22.7.0(00.000*kW)\"} Device-Type - {\"SerialReceived\":\"0-1:24.1.0(003)\"} Equipment identifier (Gas) - {\"SerialReceived\":\"0-1:96.1.0(4730303332353631323736373836373136)\"} GasMeterReadingFiveMinutes >> Last 5-minute value (temperature converted), gas delivered to client in m3, including decimal values and capture time - {\"SerialReceived\":\"0-1:24.2.1(181227090000W)(02910.491*m3)\"} {\"SerialReceived\":\"!5E3E\"} Additional info * Kaifa Meters (Dutch) * DSMR 5.0 - P1 Companion Standard","title":"Kaifa MA105C Energy Meter"},{"location":"P1-Smart-Meter/#kaifa-ma105c-energy-meter","text":"In this example the Kaifa MA105C meter is used and might work with other meters as well.","title":"Kaifa MA105C Energy Meter"},{"location":"P1-Smart-Meter/#schematics","text":"The transistor makes sure that the RxD signal is converted and inverted to 3.3v","title":"Schematics"},{"location":"P1-Smart-Meter/#tasmota-settings","text":"In the Configuration -> Configure Module page, select module Generic (18) From the web console set the serial delimiter to 10 (newline). This makes Tasmota publish each line of the telegram separately to mqtt. SerialDelimiter 10 SerialSend","title":"Tasmota Settings"},{"location":"P1-Smart-Meter/#example-output","text":"Below an example of the telegram message published (per line) to mqtt. From here your HA system can process the data required for your needs. 16 : 59 : 39 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"/KFM5KAIFA-METER\" } 16 : 59 : 39 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"\" } 16 : 59 : 39 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"1-3:0.2.8(42)\" } 16 : 59 : 39 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"0-0:1.0.0(190104170020W)\" } 16 : 59 : 39 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"0-0:96.1.1(4530303235303030303639363432393136)\" } 16 : 59 : 39 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:1.8.1(002342.060*kWh)\" } 16 : 59 : 39 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:1.8.2(002566.728*kWh)\" } 16 : 59 : 39 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:2.8.1(000000.000*kWh)\" } 16 : 59 : 39 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:2.8.2(000000.000*kWh)\" } 16 : 59 : 39 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"0-0:96.14.0(0002)\" } 16 : 59 : 40 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:1.7.0(00.428*kW)\" } 16 : 59 : 40 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:2.7.0(00.000*kW)\" } 16 : 59 : 40 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"0-0:96.7.21(00000)\" } 16 : 59 : 40 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"0-0:96.7.9(00000)\" } 16 : 59 : 40 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:99.97.0(1)(0-0:96.7.19)(000101000001W)(2147483647*s)\" } 16 : 59 : 40 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:32.32.0(00000)\" } 16 : 59 : 40 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:32.36.0(00000)\" } 16 : 59 : 40 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"0-0:96.13.1()\" } 16 : 59 : 40 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"0-0:96.13.0()\" } 16 : 59 : 40 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:31.7.0(002*A)\" } 16 : 59 : 40 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:21.7.0(00.453*kW)\" } 16 : 59 : 40 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"1-0:22.7.0(00.000*kW)\" } 16 : 59 : 40 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"0-1:24.1.0(003)\" } 16 : 59 : 40 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"0-1:96.1.0(4730303332353631323736373836373136)\" } 16 : 59 : 40 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"0-1:24.2.1(190104160000W)(02949.209*m3)\" } 16 : 59 : 40 MQT: tele/wemos -9 /RESULT = { \"SerialReceived\" : \"!EE58\" }","title":"Example output"},{"location":"P1-Smart-Meter/#description-of-each-line","text":"see also DSMR 5.0 - P1 Companion Standard Header information - {\"SerialReceived\":\"/KFM5KAIFA-METER\"} Empty line - {\"SerialReceived\":\"\"} Version information for P1 output - {\"SerialReceived\":\"1-3:0.2.8(42)\"} Date-time stamp of the P1 message - {\"SerialReceived\":\"0-0:1.0.0(181227093413W)\"} Equipment identifier - {\"SerialReceived\":\"0-0:96.1.1(4530303235303030303639363432393136)\"} electricityUsedTariff1 >> Meter Reading electricity delivered to client (Tariff 1) in 0,001 kWh - {\"SerialReceived\":\"1-0:1.8.1(002293.192*kWh)\"} electricityUsedTariff2 >> Meter Reading electricity delivered to client (Tariff 2) in 0,001 kWh - {\"SerialReceived\":\"1-0:1.8.2(002523.640*kWh)\"} Meter Reading electricity delivered by client (Tariff 1) in 0,001 kWh - {\"SerialReceived\":\"1-0:2.8.1(000000.000*kWh)\"} Meter Reading electricity delivered by client (Tariff 2) in 0,001 kWh - {\"SerialReceived\":\"1-0:2.8.2(000000.000*kWh)\"} electricityActiveTariff >> Tariff indicator electricity. The tariff indicator can also be used to switch tariff dependent loads e.g boilers. This is the responsibility of the P1 user - {\"SerialReceived\":\"0-0:96.14.0(0002)\"} Actual electricity power delivered (+P) in 1 Watt resolution - {\"SerialReceived\":\"1-0:1.7.0(00.474*kW)\"} Actual electricity power received (-P) in 1 Watt resolution - {\"SerialReceived\":\"1-0:2.7.0(00.000*kW)\"} Number of power failures in any phase - {\"SerialReceived\":\"0-0:96.7.21(00000)\"} Number of long power failures in any phase - {\"SerialReceived\":\"0-0:96.7.9(00000)\"} Power Failure Event Log (long power failures) - {\"SerialReceived\":\"1-0:99.97.0(1)(0-0:96.7.19)(000101000001W)(2147483647*s)\"} Number of voltage sags in phase L1 - {\"SerialReceived\":\"1-0:32.32.0(00000)\"} Number of voltage swells in phase L1 - {\"SerialReceived\":\"1-0:32.36.0(00000)\"} Text message max 1024 characters. - {\"SerialReceived\":\"0-0:96.13.1()\"} Text message max 1024 characters. - {\"SerialReceived\":\"0-0:96.13.0()\"} Instantaneous current L1 in A resolution - {\"SerialReceived\":\"1-0:31.7.0(002*A)\"} Instantaneous active power L1 (+P) in W resolution - {\"SerialReceived\":\"1-0:21.7.0(00.474*kW)\"} Instantaneous active power L1 (-P) in W resolution - {\"SerialReceived\":\"1-0:22.7.0(00.000*kW)\"} Device-Type - {\"SerialReceived\":\"0-1:24.1.0(003)\"} Equipment identifier (Gas) - {\"SerialReceived\":\"0-1:96.1.0(4730303332353631323736373836373136)\"} GasMeterReadingFiveMinutes >> Last 5-minute value (temperature converted), gas delivered to client in m3, including decimal values and capture time - {\"SerialReceived\":\"0-1:24.2.1(181227090000W)(02910.491*m3)\"} {\"SerialReceived\":\"!5E3E\"} Additional info * Kaifa Meters (Dutch) * DSMR 5.0 - P1 Companion Standard","title":"Description of each line"},{"location":"PAJ7620/","text":"!> This feature is not included in precompiled binaries. To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_PAJ7620 #define USE_PAJ7620 // PAJ7620 gesture sensor (I2C address 0x73) (+2.5k code) #endif PAJ7620U2 is an integrated gesture recognition I 2 C sensor from PixArt-Imaging Inc. based on infrared. It also has built-in proximity detection and can sense various properties like position (x,y,z) and speed. Gesture recognition seems to be more stable than with the APDS-9960 , which on the other hand is a lot cheaper. Configuration ~ Wiring ~ Breakout ESP8266 VCC/VIN +3.3VDC GND GND SCL GPIOy SDA GPIOx INT NC Tasmota Settings ~ In the Configuration -> Configure Module page assign: 1. GPIOx to I2C SDA (6) 2. GPIOy to I2C SCL (5) After a reboot the driver will detect the PAJ7620 automatically. After restart Tasmota needs some time to completely configure its state. In this time frame it is likely to miss some gestures. This should stabilize after a few moments. Commands ~ To use the sensor you need to switch to the desired mode of operation with Sensor50 <x> where \\ = 0\u20265 . It will not appear in the webUI but it can be observed via MQTT messages in console. 0 - Off Sensor muted, no readings in Tasmota. 1 - Gesture Mode Reports gesture movement with: \u2003 Up \u2003 Down \u2003 Left \u2003 Right \u2003 Near \u2003 Far \u2003 CW (clockwise rotation) \u2003 CCW (counter-clockwise rotation) As expected, \"Near\" and \"Far\" gestures are tricky and you have to train your movements to catch them. Sometimes the sensor reports \"Near\" and \"Far\" at once (which will be discarded). There is some postprocessing to allow the object (hand or finger) to move into the sensing area and delay the initial direction report (up, down, left, right) to give the chance to trigger (the intended) \"Near\" or \"Far\" movement. Especially \"Far\" is a bit harder to achieve. example: \u2026{Up:1} = up gesture once \u2026{Left:3} = left gesture 3 times in a row, without any other gesture in between 2 - Proximity Mode Arbitrary values between 0 (far away) and 255 (very near) are given. Exit from the sensor field will always give at least one \"zero message\". tele is only triggered, when the value has changed. example: \u2026{Proximity:255} = close proximity, almost touching the sensor \u2026{Proximity:0} = object has left the sensing area 3 - Corner Mode Sensing area is organised in quarters. An object in one of the corners will trigger the corresponding number. 1 2 3 4 example: \u2026{Corner:2} = object in upper right corner 4 - PIN Mode: A fluent movement of an object through a given sequence of corners (similar to unlocking a smartphone) will trigger a valid \"PIN\". The next corner must be reached in about 0.7 seconds. example: \u2026{PIN:1} = valid PIN 5 - Cursor Mode: Shows x- and y-coordinates. Mainly intended for debugging and \"seeing\" the sensing area. This reads only the upper 5-bit-values, which automatically removes much of the jitter, giving values between 0 and 15. example: \u2026{x:1, y:15} = upper left corner The sensor provides some more goodies, like velocity of an object, so if someone has a fancy use case for this, feel free to open a feature request. Of course it would be possible to mix the modes, but this can produce a lot of MQTT-messages. This could be added later upon user request (based on real world use cases). Breakout boards ~","title":"PAJ7620"},{"location":"PAJ7620/#configuration","text":"","title":"Configuration"},{"location":"PAJ7620/#wiring","text":"Breakout ESP8266 VCC/VIN +3.3VDC GND GND SCL GPIOy SDA GPIOx INT NC","title":"Wiring"},{"location":"PAJ7620/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: 1. GPIOx to I2C SDA (6) 2. GPIOy to I2C SCL (5) After a reboot the driver will detect the PAJ7620 automatically. After restart Tasmota needs some time to completely configure its state. In this time frame it is likely to miss some gestures. This should stabilize after a few moments.","title":"Tasmota Settings"},{"location":"PAJ7620/#commands","text":"To use the sensor you need to switch to the desired mode of operation with Sensor50 <x> where \\ = 0\u20265 . It will not appear in the webUI but it can be observed via MQTT messages in console.","title":"Commands"},{"location":"PAJ7620/#breakout-boards","text":"","title":"Breakout boards"},{"location":"PCA9685/","text":"PCA9685: 16-channel, 12-bit PWM I 2 C-bus LED controller ~ Technical Data: Product Information from NXP IMPLEMENTATION STATUS IN TASMOTA ~ The PCA9685 driver is implemented in such a way that it may be used as standard individual OUTPUT pins, or as PWM capable OUTPUT pins - The latter offloads the PWM functionality from the ESP8266 insofar that the PCA9685 will continue to perform its configured output PWM/ON/OFF state without direct control or intervention from the Tasmota firmware. Support was added in line with the datasheet specification insofar that the PWM frequency can be set from 24hz all the way up to 1526hz. This driver does not currently have any perpetual settings so will revert to a base frequency of 50hz (usually suitable for most applications) and will be set in an OFF state for all pins during power-up and/or reset. The latter may change as the driver grows in cases where user requirements and development requirements are met. USAGE OF THE PCA9685 DRIVER IN TASMOTA ~ The driver needs to be connected to the I 2 C bus of your Tasmota powered device (note that most Sonoff devices will not have reachable I 2 C pins so it's applicable to a limited number, so most likely only applicable to bare ESP8266 or WeMos type users. If you modify a Sonoff or similar device to gain access to the I 2 C bus please be aware that other problems may persist and that for such use cases support in Tasmota chat or Issues is not guaranteed in any way whatsoever) The driver is not included during the compilation of the standard released binaries so in order to use this driver you will need to create a development environment for yourself and uncomment these two lines in my_user_config.h #define USE_PCA9685 #define USE_PCA9685_ADDR 0x40 #define USE_PCA9685_FREQ 50 // Support is for 24 to 1526 Hz For information on how to set up a development environment please check the wiki on Arduino IDE (the easiest, probably) or PlatformIO Note that the I 2 C selection must correspond with how you have wired the module or chip as incorrect addressing will result in the PCA9685 not being detected. The valid I 2 C address range is 0x40 through 0x47 for the PCA9685 and most off-the-shelf modules would likely default to 0x40. If you are unsure please use I2Cscan from Tasmota console to scan for devices on the I 2 C bus and you should find a device within the mentioned range. You may also get a discovery on 0x70 but please do not use this address as it is a broadcast address and the driver does not currently support its implementation. Also be aware of other I 2 C devices you have connected to the same Tasmota driven device in order to avoid I 2 C address conflicts. Once connected, correctly flashed, and configured Tasmota will detect the device automatically on startup. DRIVER USAGE ~ There is no web interface for this driver. The driver is used via MQTT or console command using the following available commands and their respective parameters driver15 pwmf,frequency // where frequency is the PWM frequency from 24 to 1526 in Hz driver15 pwm,pin,pwmvalue // where pin = LED pin 0 through 15 and pwmvalue is the pulse width between 0 and 4096 driver15 pwm,pin,ON // Fully turn a specific pin/LED ON driver15 pwm,pin,OFF // Fully turn a specific pin/LED OFF driver15 reset // Reset to power-up settings - i.e. F=50hz and all pins in OFF state driver15 status // Will return a JSON string containing all the current settings / parameters OTHER IMPORTANT INFORMATION ~ Please remember to consider the voltage and current limitations of the chip and per pin output current limitations as outlined in the datasheet. You may also get a discovery on 0x70 but please do not use this address as it is a broadcast address and the driver does not currently support its implementation. Also be aware of other I 2 C devices you have connected to the same Tasmota driven device in order to avoid I 2 C address conflicts. OUTSTANDING FEATURE REQUESTS ~ Dimming ON / OFF a dimming value in a certain time and fade on \"ON / OFF\" (Not yet scheduled for implementation) Allow usage of RGBW in pairs of 4 PWM outputs (i.e. drive 4 x 4pin RGBW LED's) (Not yet scheduled for implementation)","title":"PCA9685"},{"location":"PCA9685/#pca9685-16-channel-12-bit-pwm-i2c-bus-led-controller","text":"Technical Data: Product Information from NXP","title":"PCA9685: 16-channel, 12-bit PWM I2C-bus LED controller"},{"location":"PCA9685/#implementation-status-in-tasmota","text":"The PCA9685 driver is implemented in such a way that it may be used as standard individual OUTPUT pins, or as PWM capable OUTPUT pins - The latter offloads the PWM functionality from the ESP8266 insofar that the PCA9685 will continue to perform its configured output PWM/ON/OFF state without direct control or intervention from the Tasmota firmware. Support was added in line with the datasheet specification insofar that the PWM frequency can be set from 24hz all the way up to 1526hz. This driver does not currently have any perpetual settings so will revert to a base frequency of 50hz (usually suitable for most applications) and will be set in an OFF state for all pins during power-up and/or reset. The latter may change as the driver grows in cases where user requirements and development requirements are met.","title":"IMPLEMENTATION STATUS IN TASMOTA"},{"location":"PCA9685/#usage-of-the-pca9685-driver-in-tasmota","text":"The driver needs to be connected to the I 2 C bus of your Tasmota powered device (note that most Sonoff devices will not have reachable I 2 C pins so it's applicable to a limited number, so most likely only applicable to bare ESP8266 or WeMos type users. If you modify a Sonoff or similar device to gain access to the I 2 C bus please be aware that other problems may persist and that for such use cases support in Tasmota chat or Issues is not guaranteed in any way whatsoever) The driver is not included during the compilation of the standard released binaries so in order to use this driver you will need to create a development environment for yourself and uncomment these two lines in my_user_config.h #define USE_PCA9685 #define USE_PCA9685_ADDR 0x40 #define USE_PCA9685_FREQ 50 // Support is for 24 to 1526 Hz For information on how to set up a development environment please check the wiki on Arduino IDE (the easiest, probably) or PlatformIO Note that the I 2 C selection must correspond with how you have wired the module or chip as incorrect addressing will result in the PCA9685 not being detected. The valid I 2 C address range is 0x40 through 0x47 for the PCA9685 and most off-the-shelf modules would likely default to 0x40. If you are unsure please use I2Cscan from Tasmota console to scan for devices on the I 2 C bus and you should find a device within the mentioned range. You may also get a discovery on 0x70 but please do not use this address as it is a broadcast address and the driver does not currently support its implementation. Also be aware of other I 2 C devices you have connected to the same Tasmota driven device in order to avoid I 2 C address conflicts. Once connected, correctly flashed, and configured Tasmota will detect the device automatically on startup.","title":"USAGE OF THE PCA9685 DRIVER IN TASMOTA"},{"location":"PCA9685/#driver-usage","text":"There is no web interface for this driver. The driver is used via MQTT or console command using the following available commands and their respective parameters driver15 pwmf,frequency // where frequency is the PWM frequency from 24 to 1526 in Hz driver15 pwm,pin,pwmvalue // where pin = LED pin 0 through 15 and pwmvalue is the pulse width between 0 and 4096 driver15 pwm,pin,ON // Fully turn a specific pin/LED ON driver15 pwm,pin,OFF // Fully turn a specific pin/LED OFF driver15 reset // Reset to power-up settings - i.e. F=50hz and all pins in OFF state driver15 status // Will return a JSON string containing all the current settings / parameters","title":"DRIVER USAGE"},{"location":"PCA9685/#other-important-information","text":"Please remember to consider the voltage and current limitations of the chip and per pin output current limitations as outlined in the datasheet. You may also get a discovery on 0x70 but please do not use this address as it is a broadcast address and the driver does not currently support its implementation. Also be aware of other I 2 C devices you have connected to the same Tasmota driven device in order to avoid I 2 C address conflicts.","title":"OTHER IMPORTANT INFORMATION"},{"location":"PCA9685/#outstanding-feature-requests","text":"Dimming ON / OFF a dimming value in a certain time and fade on \"ON / OFF\" (Not yet scheduled for implementation) Allow usage of RGBW in pairs of 4 PWM outputs (i.e. drive 4 x 4pin RGBW LED's) (Not yet scheduled for implementation)","title":"OUTSTANDING FEATURE REQUESTS"},{"location":"PID-Control/","text":"This extension adds a PID (Proportional Integral Derivative) feature into the Tasmota software. The PID algorithm is one designed to be used to control real-world processes that the users of Sonoff devices are likely to encounter. This includes room heating/cooling, temperature control when brewing, and a multitude of other processes. The PID tuning parameters are designed to be meaningful in the real world (rather than the abstract Ki Kd Kp that are often used which are completely meaningless to most). The algorithm is based on that in the node-red node node-red-contrib-pid which has been well received. In use it can either regularly be given the current process value via MQTT or if the device has a sensor attached then that sensor can be used to read the process value. So using a TH10 with a DS18B20 the complete PID loop control can be build into the device so that the process will continue to be controlled even if the wifi is down. This is a very cost effective way of achieving PID control. The algorithm allows the relay to be used in a time proportioned way using the Time Proportioned output extension. The loop tuning parameters can be set at build time and can be adjusted at run time via MQTT. To add the feature into the standard Tasmotta s/w (at least version 5.12.0 is required) then have a look at the pid_branch of the tasmota fork at https://github.com/colinl/Sonoff-Tasmota/tree/pid_branch. Pick up from there the files in the folder lib/ProcessControl (which are from this process-control repository ) and sonoff/xdrv_91_timeprop.ino and sonoff/xdrv_92_pid.ino and add them into your Tasmota sources. The PID code adds about 4.3k and the Timeprop code another 1.2k Instructions for setup are in the two xdrv files. The ESP8266 will run the PID algorithm at 1 cycle per second, which is much faster than is needed for the sort of processes Sonoff devices are usually associated with. It rather clobbers the Tasmota terminal output in the web browser at that rate so it is getting near to the limit. The maximum anyone is likely to need it running at is maybe once every 5 seconds, and the majority of home IoT applications probably nearer once per minute would be sufficient, so the device is well up to the task. Help with using the PID algorithm and with loop tuning can be found at http://blog.clanlaw.org.uk/2018/01/09/PID-tuning-with-node-red-contrib-pid.html This is directed towards using the algorithm in the node-red node node-red-contrib-pid but the algorithm here is based on the same code so the tuning technique described there should work just the same. Due to limited hardware availability this has so far only been tested in a Sonoff Basic and a TH10, if there are any issues running this on other hardware let me know. For any issues please submit an issue to the Tasmota fork on gitub or ask on the sonoff mailing list .","title":"PID Control"},{"location":"PIR-Motion-Sensors/","text":"PIR motion sensors, albeit called sensors, are configured as switches in Tasmota since they basically report motion ( 1 ) or no motion ( 0 ) to the device. Most PIR's are single wire and they require connecting to VCC, GND and one GPIO. In this guide we will use GPIO15 as the pin that the PIR output is connected to. Tasmota Settings ~ In Configuration -> Configure Module menu change GPIO15 to Switch1 . If there already is a Switch1 simply choose the next in line. Same applies if you're connecting more than 1 PIR on a single device. A configured PIR will not appear in the web UI in any form. To make it report like a sensor we need a rule that will send movement triggers to an MQTT topic. SwitchMode1 1 SwitchTopic 0 Rule1 on Switch1#state=1 do publish stat/%topic%/PIR1 ON endon on Switch1#state=0 do Publish stat/%topic%/PIR1 OFF endon Rule1 1 You can change ( PIR1 ) and the message ( ON / OFF ) to whatever suits your needs. %topic% is the configured device topic. Look in console for motion detection messages [20:24:03] stat/%topic%/PIR1 ON to verify everything is working optional: Before using rules configure any GPIO that doesn't have anything connected to it as Relay1 . This creates a dummy relay which is triggered by the PIR so you can see the changes in the web UI. This method is not recommended for daily use and should only be used for testing. A more advanced example of rules with PIRs. AM312 ~ AM312 works even on 3.3v instead of 5v (like HC-SR501) which makes it perfect for ESP8266 devices without a 5V line (like Sonoff Basic). It is also less prone to false triggers due to Wi-Fi interference. Pinout ~ Pin marked VOUT is connected to a free GPIO pin on the device. This PIR goes to off state after a few seconds so we need to use this rule instead of the one in the example. Rule1 on Switch1#state=1 do Backlog Publish stat/%topic%/PIR1 ON; RuleTimer1 30 endon on Rules#Timer=1 do Publish stat/%topic%/PIR1 OFF endon With this it will stay ON for 30 seconds then send OFF message and the timer restarts every time there's an ON trigger. Another use case as a hand wave switch . HC-SR501 ~ Pinout ~ MH-SR602 ~ This is a very small version of a PIR that is able to modify the sensitivity and delay by soldering resistors. With factory settings this PIR goes to off state after a few seconds so we need to use this rule instead of the one in the example. Rule1 on Switch1#state=1 do Backlog Publish stat/%topic%/PIR1 ON; RuleTimer1 30 endon on Rules#Timer=1 do Publish stat/%topic%/PIR1 OFF endon With this it will stay ON for 30 seconds then send OFF message and the timer restarts every time there's an ON trigger. Pinout ~","title":"PIR Motion Sensors"},{"location":"PIR-Motion-Sensors/#tasmota-settings","text":"In Configuration -> Configure Module menu change GPIO15 to Switch1 . If there already is a Switch1 simply choose the next in line. Same applies if you're connecting more than 1 PIR on a single device. A configured PIR will not appear in the web UI in any form. To make it report like a sensor we need a rule that will send movement triggers to an MQTT topic. SwitchMode1 1 SwitchTopic 0 Rule1 on Switch1#state=1 do publish stat/%topic%/PIR1 ON endon on Switch1#state=0 do Publish stat/%topic%/PIR1 OFF endon Rule1 1 You can change ( PIR1 ) and the message ( ON / OFF ) to whatever suits your needs. %topic% is the configured device topic. Look in console for motion detection messages [20:24:03] stat/%topic%/PIR1 ON to verify everything is working optional: Before using rules configure any GPIO that doesn't have anything connected to it as Relay1 . This creates a dummy relay which is triggered by the PIR so you can see the changes in the web UI. This method is not recommended for daily use and should only be used for testing. A more advanced example of rules with PIRs.","title":"Tasmota Settings"},{"location":"PIR-Motion-Sensors/#am312","text":"AM312 works even on 3.3v instead of 5v (like HC-SR501) which makes it perfect for ESP8266 devices without a 5V line (like Sonoff Basic). It is also less prone to false triggers due to Wi-Fi interference.","title":"AM312"},{"location":"PIR-Motion-Sensors/#pinout","text":"Pin marked VOUT is connected to a free GPIO pin on the device. This PIR goes to off state after a few seconds so we need to use this rule instead of the one in the example. Rule1 on Switch1#state=1 do Backlog Publish stat/%topic%/PIR1 ON; RuleTimer1 30 endon on Rules#Timer=1 do Publish stat/%topic%/PIR1 OFF endon With this it will stay ON for 30 seconds then send OFF message and the timer restarts every time there's an ON trigger. Another use case as a hand wave switch .","title":"Pinout"},{"location":"PIR-Motion-Sensors/#hc-sr501","text":"","title":"HC-SR501"},{"location":"PIR-Motion-Sensors/#pinout_1","text":"","title":"Pinout"},{"location":"PIR-Motion-Sensors/#mh-sr602","text":"This is a very small version of a PIR that is able to modify the sensitivity and delay by soldering resistors. With factory settings this PIR goes to off state after a few seconds so we need to use this rule instead of the one in the example. Rule1 on Switch1#state=1 do Backlog Publish stat/%topic%/PIR1 ON; RuleTimer1 30 endon on Rules#Timer=1 do Publish stat/%topic%/PIR1 OFF endon With this it will stay ON for 30 seconds then send OFF message and the timer restarts every time there's an ON trigger.","title":"MH-SR602"},{"location":"PIR-Motion-Sensors/#pinout_2","text":"","title":"Pinout"},{"location":"PN532/","text":"PN532 HSU Driver for Tasmota ~ The PN532 is a highly integrated transceiver module for contactless communication at 13.56 MHz based on the 80C51 microcontroller core. The datasheet for the PN532 chip is available here: https://www.nxp.com/docs/en/nxp/data-sheets/PN532_C1.pdf Please note that although the datasheet mentions that the PN532 can be used on SPI, I 2 C and HSUART that only the HSU interface is implemented in the Tasmota driver. PN532 Breakout boards ~ Since the PN532 chip itself is surface mount and requires some external components to operate the best is probably to obtain a breakout board similar to the one below from your favourite online supplier. Please make sure the breakout board you order has the HSU pins (SCL=TX and SDA=RX) broken out as it will be very difficult to add them manually - Usually they have them but for good measure just make sure. PN532 Configuration in Tasmota ~ The driver for the PN532 is not included in any of the default release binaries so you will need to compile your own binary for the purpose of using the PN532. To enable it prior to compilation you need to add the following one or more lines in your user_config_override.h file, depending on your use-case (don't use Core 2.3.0, the core has issues with software serial ). Please note that the DATA field functionality has proven to work on some cards/tags but not all cards/tags - Please see Issue https://github.com/arendst/Tasmota/issues/4941 for more information about this. #define USE_PN532_HSU #define USE_PN532_DATA_FUNCTION #define USE_PN532_CAUSE_EVENTS The latter is only necessary if you need to perform actions on the local device using rules. If you only plan to handle the resulting scanned information on your home automation software then you do not need to uncomment #define USE_PN532_CAUSE_EVENTS as it has no use if you are not going to take an action on the device itself. Please note that USE_PN532_DATA_FUNCTIONS are experimental - See Issue https://github.com/arendst/Tasmota/issues/4941 for more information as we are still researching the limitations of this usage because it seems not all cards are supported by this driver and/or the PN532 module. Once you have compiled and uploaded your new firmware you will need to configure the usual (such as your wifi configuration and MQTT server configuration etc) and when complete proceed to enable GPIO pins for PN532 Tx and PN532 Rx on your ESP8266 device. For this example we will configure it using D1 (connected to SCL) and D2 (connected to SDA) as follows - you can follow the buttons pressed from left to right in the image below: The module will reboot when you save this configuration. Configuring and Connecting the PN532 to your ESP8266 based module ~ First make sure that your device is powered off and that all power connections are removed. As mentioned earlier the PN532 breakout boards usually have pins broken out for all three protocols supported by the PN532 but we are only interested in the HSU interface as that is all the driver currently supports. For this reason breakout boards have either micro dip switches as shown in the image below, or they have pads on the PC board which you need to bridge out with solder to select which mode the PN532 will operate in. After selecting the correct protocol mode and connecting the HSU TX/RX pins of the PN532 to the pins you configured on your ESP8266 board you can power it up and the PN532 should be detected automatically. During start-up the following information should be visible in your console output: 00 : 00 : 00 NFC : PN532 NFC Reader detected ( V1 . 6 ) If the device was not found please check your wiring and configuration and confirm that everything is as it should be. Using the PN532 on Tasmota ~ Tasmota will scan for a new card detect 4 times per second and if found will report it via immediate telemetry and in addition cause an event if you chose to uncomment #define USE_PN532_CAUSE_EVENTS prior to compiling your firmware. The output on the console will look similar to the below when a new card is detected 18 : 23 : 24 MQT : tele /tasmota/ SENSOR = { \"Time\" : \"2019-01-10T18:23:24\" , \"PN532\" :{ \"UID\" : \"94D8FC5F\" , \"DATA\" : \"\" }} 18 : 23 : 24 MQT : stat /tasmota/ RESULT = { \"Event\" : \"Done\" } 18 : 23 : 25 MQT : stat /tasmota/ RESULT = { \"Event\" : \"Done\" } The UID of the card/tag is reported and any text stored in BLOCK 1 of a Mifare Classic card (up to 15 characters in length) is reported in the DATA field of the JSON sent via telemetry. Please note that the DATA field cannot contain spaces. The content of the DATA on BLOCK 1 of a Mifare Classic card can be set as follows Sensor40 S,ILOVETASMOTA Once executed the very next card/tag that is presented to the reader will be programmed accordingly and the data will be retained on the card/tag until either changed or erased. To erase the content of the DATA field the following command may be used Sensor40 E Once executed the very next card/tag that is presented to the reader will have its BLOCK 1 erased. Text logging of the above two actions are also presented during the process for information purposes. Using the UID and DATA of a presented card in Tasmota ~ When a card is presented to the PN532 under normal operating conditions up to 3 ways of using the data is possible. The first is the immediate telemetry generated which looks as follows 18 : 31 : 39 MQT : tele /tasmota/ SENSOR = { \"Time\" : \"2019-01-10T18:31:39\" , \"PN532\" :{ \"UID\" : \"94D8FC5F\" , \"DATA\" : \"ILOVETASMOTA\" }} Since this is an immediate telemetry generation as opposed to the sensor data you would normally be expected to be presented when the telemetry period occurs, this telemetry data is not directly usable on the device itself. It is generated and immediately transmitted over MQTT and the purpose of this is so that immediate action may be taken by any home automation software you are using with the data obtained from the card/tag as opposed to waiting for the telemetry period to expire and be sent with normal telemetry data. For the purpose of using card/tag data on the device itself you will need to use rules along with the events that are caused - Remember to use events you need to uncomment the #define USE_PN532_CAUSE_EVENTS directive prior to building/compiling your firmware. Example rule for responding to a specific UID on the device when a card/tag matching a specific UID is presented rule on EVENT#PN532_UID=94D8FC5F do power on endon Example output/result: 18 : 39 : 20 MQT : tele /tasmota/ SENSOR = { \"Time\" : \"2019-01-10T18:39:20\" , \"PN532\" :{ \"UID\" : \"94D8FC5F\" , \"DATA\" : \"ILOVETASMOTA\" }} 18 : 39 : 20 MQT : stat /tasmota/ RESULT = { \"Event\" : \"Done\" } 18 : 39 : 20 RUL : EVENT # PN532_UID = 94 D8FC5F performs \"power on\" 18 : 39 : 20 MQT : stat /tasmota/ RESULT = { \"POWER\" : \"ON\" } 18 : 39 : 20 MQT : stat /tasmota/ POWER = ON 18 : 39 : 20 MQT : stat /tasmota/ RESULT = { \"Event\" : \"Done\" } Example rule for responding to a specific DATA content that was previously programmed to one or more cards using the Sensor40 S,xxxx command on EVENT#PN532_DATA=ILOVETASMOTA do power on endon 18 : 41 : 12 MQT : tele /tasmota/ SENSOR = { \"Time\" : \"2019-01-10T18:41:12\" , \"PN532\" :{ \"UID\" : \"94D8FC5F\" , \"DATA\" : \"ILOVETASMOTA\" }} 18 : 41 : 13 MQT : stat /tasmota/ RESULT = { \"Event\" : \"Done\" } 18 : 41 : 13 MQT : stat /tasmota/ RESULT = { \"Event\" : \"Done\" } 18 : 41 : 13 RUL : EVENT # PN532_DATA = ILOVETASMOTA performs \"power on\" 18 : 41 : 13 MQT : stat /tasmota/ RESULT = { \"POWER\" : \"ON\" } 18 : 41 : 13 MQT : stat /tasmota/ POWER = ON","title":"PN532"},{"location":"PN532/#pn532-hsu-driver-for-tasmota","text":"The PN532 is a highly integrated transceiver module for contactless communication at 13.56 MHz based on the 80C51 microcontroller core. The datasheet for the PN532 chip is available here: https://www.nxp.com/docs/en/nxp/data-sheets/PN532_C1.pdf Please note that although the datasheet mentions that the PN532 can be used on SPI, I 2 C and HSUART that only the HSU interface is implemented in the Tasmota driver.","title":"PN532 HSU Driver for Tasmota"},{"location":"PN532/#pn532-breakout-boards","text":"Since the PN532 chip itself is surface mount and requires some external components to operate the best is probably to obtain a breakout board similar to the one below from your favourite online supplier. Please make sure the breakout board you order has the HSU pins (SCL=TX and SDA=RX) broken out as it will be very difficult to add them manually - Usually they have them but for good measure just make sure.","title":"PN532 Breakout boards"},{"location":"PN532/#pn532-configuration-in-tasmota","text":"The driver for the PN532 is not included in any of the default release binaries so you will need to compile your own binary for the purpose of using the PN532. To enable it prior to compilation you need to add the following one or more lines in your user_config_override.h file, depending on your use-case (don't use Core 2.3.0, the core has issues with software serial ). Please note that the DATA field functionality has proven to work on some cards/tags but not all cards/tags - Please see Issue https://github.com/arendst/Tasmota/issues/4941 for more information about this. #define USE_PN532_HSU #define USE_PN532_DATA_FUNCTION #define USE_PN532_CAUSE_EVENTS The latter is only necessary if you need to perform actions on the local device using rules. If you only plan to handle the resulting scanned information on your home automation software then you do not need to uncomment #define USE_PN532_CAUSE_EVENTS as it has no use if you are not going to take an action on the device itself. Please note that USE_PN532_DATA_FUNCTIONS are experimental - See Issue https://github.com/arendst/Tasmota/issues/4941 for more information as we are still researching the limitations of this usage because it seems not all cards are supported by this driver and/or the PN532 module. Once you have compiled and uploaded your new firmware you will need to configure the usual (such as your wifi configuration and MQTT server configuration etc) and when complete proceed to enable GPIO pins for PN532 Tx and PN532 Rx on your ESP8266 device. For this example we will configure it using D1 (connected to SCL) and D2 (connected to SDA) as follows - you can follow the buttons pressed from left to right in the image below: The module will reboot when you save this configuration.","title":"PN532 Configuration in Tasmota"},{"location":"PN532/#configuring-and-connecting-the-pn532-to-your-esp8266-based-module","text":"First make sure that your device is powered off and that all power connections are removed. As mentioned earlier the PN532 breakout boards usually have pins broken out for all three protocols supported by the PN532 but we are only interested in the HSU interface as that is all the driver currently supports. For this reason breakout boards have either micro dip switches as shown in the image below, or they have pads on the PC board which you need to bridge out with solder to select which mode the PN532 will operate in. After selecting the correct protocol mode and connecting the HSU TX/RX pins of the PN532 to the pins you configured on your ESP8266 board you can power it up and the PN532 should be detected automatically. During start-up the following information should be visible in your console output: 00 : 00 : 00 NFC : PN532 NFC Reader detected ( V1 . 6 ) If the device was not found please check your wiring and configuration and confirm that everything is as it should be.","title":"Configuring and Connecting the PN532 to your ESP8266 based module"},{"location":"PN532/#using-the-pn532-on-tasmota","text":"Tasmota will scan for a new card detect 4 times per second and if found will report it via immediate telemetry and in addition cause an event if you chose to uncomment #define USE_PN532_CAUSE_EVENTS prior to compiling your firmware. The output on the console will look similar to the below when a new card is detected 18 : 23 : 24 MQT : tele /tasmota/ SENSOR = { \"Time\" : \"2019-01-10T18:23:24\" , \"PN532\" :{ \"UID\" : \"94D8FC5F\" , \"DATA\" : \"\" }} 18 : 23 : 24 MQT : stat /tasmota/ RESULT = { \"Event\" : \"Done\" } 18 : 23 : 25 MQT : stat /tasmota/ RESULT = { \"Event\" : \"Done\" } The UID of the card/tag is reported and any text stored in BLOCK 1 of a Mifare Classic card (up to 15 characters in length) is reported in the DATA field of the JSON sent via telemetry. Please note that the DATA field cannot contain spaces. The content of the DATA on BLOCK 1 of a Mifare Classic card can be set as follows Sensor40 S,ILOVETASMOTA Once executed the very next card/tag that is presented to the reader will be programmed accordingly and the data will be retained on the card/tag until either changed or erased. To erase the content of the DATA field the following command may be used Sensor40 E Once executed the very next card/tag that is presented to the reader will have its BLOCK 1 erased. Text logging of the above two actions are also presented during the process for information purposes.","title":"Using the PN532 on Tasmota"},{"location":"PN532/#using-the-uid-and-data-of-a-presented-card-in-tasmota","text":"When a card is presented to the PN532 under normal operating conditions up to 3 ways of using the data is possible. The first is the immediate telemetry generated which looks as follows 18 : 31 : 39 MQT : tele /tasmota/ SENSOR = { \"Time\" : \"2019-01-10T18:31:39\" , \"PN532\" :{ \"UID\" : \"94D8FC5F\" , \"DATA\" : \"ILOVETASMOTA\" }} Since this is an immediate telemetry generation as opposed to the sensor data you would normally be expected to be presented when the telemetry period occurs, this telemetry data is not directly usable on the device itself. It is generated and immediately transmitted over MQTT and the purpose of this is so that immediate action may be taken by any home automation software you are using with the data obtained from the card/tag as opposed to waiting for the telemetry period to expire and be sent with normal telemetry data. For the purpose of using card/tag data on the device itself you will need to use rules along with the events that are caused - Remember to use events you need to uncomment the #define USE_PN532_CAUSE_EVENTS directive prior to building/compiling your firmware. Example rule for responding to a specific UID on the device when a card/tag matching a specific UID is presented rule on EVENT#PN532_UID=94D8FC5F do power on endon Example output/result: 18 : 39 : 20 MQT : tele /tasmota/ SENSOR = { \"Time\" : \"2019-01-10T18:39:20\" , \"PN532\" :{ \"UID\" : \"94D8FC5F\" , \"DATA\" : \"ILOVETASMOTA\" }} 18 : 39 : 20 MQT : stat /tasmota/ RESULT = { \"Event\" : \"Done\" } 18 : 39 : 20 RUL : EVENT # PN532_UID = 94 D8FC5F performs \"power on\" 18 : 39 : 20 MQT : stat /tasmota/ RESULT = { \"POWER\" : \"ON\" } 18 : 39 : 20 MQT : stat /tasmota/ POWER = ON 18 : 39 : 20 MQT : stat /tasmota/ RESULT = { \"Event\" : \"Done\" } Example rule for responding to a specific DATA content that was previously programmed to one or more cards using the Sensor40 S,xxxx command on EVENT#PN532_DATA=ILOVETASMOTA do power on endon 18 : 41 : 12 MQT : tele /tasmota/ SENSOR = { \"Time\" : \"2019-01-10T18:41:12\" , \"PN532\" :{ \"UID\" : \"94D8FC5F\" , \"DATA\" : \"ILOVETASMOTA\" }} 18 : 41 : 13 MQT : stat /tasmota/ RESULT = { \"Event\" : \"Done\" } 18 : 41 : 13 MQT : stat /tasmota/ RESULT = { \"Event\" : \"Done\" } 18 : 41 : 13 RUL : EVENT # PN532_DATA = ILOVETASMOTA performs \"power on\" 18 : 41 : 13 MQT : stat /tasmota/ RESULT = { \"POWER\" : \"ON\" } 18 : 41 : 13 MQT : stat /tasmota/ POWER = ON","title":"Using the UID and DATA of a presented card in Tasmota"},{"location":"PS-16-DZ-Dimmer/","text":"PS-16-DZ Dimmer ~ The PS-16-DZ dimmer uses eWeLink app same as Sonoff devices. It's available from Amazon and Aliexpress . It may under different name, but the model number is PS-16-DZ. Pics ~ Opened it up, found a ESP8285 and a Nuvoton N76E003. Flash and GPIO pins ~ Remove the ESP8285 daughter card DLX-MKCK01 from the main board and flash Tasmota. pin1 RST -> N76E003 P0.5/PWM2 pin2 TXD -> N76E003 P0.7/RXD pin3 RXD -> N76E003 P0.6/TXD pin4 GPIO13/MTCK -> LED pin5 3.3V pin6 GND Communication between ESP8285 and N76E003 ~ It uses AT command to communicate between ESP8285 and N76E003 over UART at 19200 baud. Turn on the switch from ESP8266 : Send from ESP8266 AT + UPDATE = \"sequence\" : \"1528335040032\" , \"switch\" : \"on\" Receive from MCU AT + RESULT = \"sequence\" : 1528335040032 \" Send from ESP8266: AT+SEND=ok After 0.7s Receive from MCU AT+UPDATE=\" switch \":\" on \",\" bright \":44 Send from ESP8266: AT+SEND=ok Turn off the switch from ESP8266: Send from ESP8266 AT+UPDATE=\" sequence \":\" 1528335118327 \",\" switch \":\" off \" Receive from MCU AT+RESULT=\" sequence \":1528335118327\" Send from ESP8266 : AT + SEND = ok After 0 . 7 s Receive from MCU AT + UPDATE = \"switch\" : \"on\" , \"bright\" : 44 Send from ESP8266 : AT + SEND = ok Change brightness to 44 from ESP8266 : Send from ESP8266 : AT + UPDATE = \"sequence\" : \"1528335181502\" , \"bright\" : 44 Receive from MCU AT + RESULT = \"sequence\" : 1528335181502 \" Send from ESP8266: AT+SEND=ok After 0.7s Receive from MCU AT+UPDATE=\" switch \":\" on \",\" bright \":44 Send from ESP8266: AT+SEND=ok Turn on the switch with faceplate button: Received from MCU AT+UPDATE=\" switch \":\" on \",\" bright \":44 Send from ESP8266: AT+SEND=ok Turn off the switch with faceplate button: Received from MCU AT+UPDATE=\" switch \":\" off \",\" bright \":44 Send from ESP8266: AT+SEND=ok Change the brightness to 52 with faceplate button: Received from MCU AT+UPDATE=\" switch \":\" on \",\" bright \" : 52 Send from ESP8266 : AT + SEND = ok Holding the middle button on faceplate to reset the device : Received from MCU AT + SETTING = enterESPTOUCH Send from ESP8266 : AT + SETTING = enterESPTOUCH The sequence number is a 13 digits unix timestamp (in milliseconds). The data after \"bright\" is the brightness. The maximum of the brightness is 100 and the minimum is 10. There is one byte 0x1B at the end of each AT command.","title":"PS-16-DZ Dimmer"},{"location":"PS-16-DZ-Dimmer/#ps-16-dz-dimmer","text":"The PS-16-DZ dimmer uses eWeLink app same as Sonoff devices. It's available from Amazon and Aliexpress . It may under different name, but the model number is PS-16-DZ.","title":"PS-16-DZ Dimmer"},{"location":"PS-16-DZ-Dimmer/#pics","text":"Opened it up, found a ESP8285 and a Nuvoton N76E003.","title":"Pics"},{"location":"PS-16-DZ-Dimmer/#flash-and-gpio-pins","text":"Remove the ESP8285 daughter card DLX-MKCK01 from the main board and flash Tasmota. pin1 RST -> N76E003 P0.5/PWM2 pin2 TXD -> N76E003 P0.7/RXD pin3 RXD -> N76E003 P0.6/TXD pin4 GPIO13/MTCK -> LED pin5 3.3V pin6 GND","title":"Flash and GPIO pins"},{"location":"PS-16-DZ-Dimmer/#communication-between-esp8285-and-n76e003","text":"It uses AT command to communicate between ESP8285 and N76E003 over UART at 19200 baud. Turn on the switch from ESP8266 : Send from ESP8266 AT + UPDATE = \"sequence\" : \"1528335040032\" , \"switch\" : \"on\" Receive from MCU AT + RESULT = \"sequence\" : 1528335040032 \" Send from ESP8266: AT+SEND=ok After 0.7s Receive from MCU AT+UPDATE=\" switch \":\" on \",\" bright \":44 Send from ESP8266: AT+SEND=ok Turn off the switch from ESP8266: Send from ESP8266 AT+UPDATE=\" sequence \":\" 1528335118327 \",\" switch \":\" off \" Receive from MCU AT+RESULT=\" sequence \":1528335118327\" Send from ESP8266 : AT + SEND = ok After 0 . 7 s Receive from MCU AT + UPDATE = \"switch\" : \"on\" , \"bright\" : 44 Send from ESP8266 : AT + SEND = ok Change brightness to 44 from ESP8266 : Send from ESP8266 : AT + UPDATE = \"sequence\" : \"1528335181502\" , \"bright\" : 44 Receive from MCU AT + RESULT = \"sequence\" : 1528335181502 \" Send from ESP8266: AT+SEND=ok After 0.7s Receive from MCU AT+UPDATE=\" switch \":\" on \",\" bright \":44 Send from ESP8266: AT+SEND=ok Turn on the switch with faceplate button: Received from MCU AT+UPDATE=\" switch \":\" on \",\" bright \":44 Send from ESP8266: AT+SEND=ok Turn off the switch with faceplate button: Received from MCU AT+UPDATE=\" switch \":\" off \",\" bright \":44 Send from ESP8266: AT+SEND=ok Change the brightness to 52 with faceplate button: Received from MCU AT+UPDATE=\" switch \":\" on \",\" bright \" : 52 Send from ESP8266 : AT + SEND = ok Holding the middle button on faceplate to reset the device : Received from MCU AT + SETTING = enterESPTOUCH Send from ESP8266 : AT + SETTING = enterESPTOUCH The sequence number is a 13 digits unix timestamp (in milliseconds). The data after \"bright\" is the brightness. The maximum of the brightness is 100 and the minimum is 10. There is one byte 0x1B at the end of each AT command.","title":"Communication between ESP8285 and N76E003"},{"location":"PWM-dimmer-switch/","text":"PWM Dimmer ~ The PWM Dimmer module adds support for Martin Jerry/acenx/Tessan/NTONPOWER SD0x PWM dimmer switches. The brightness of the load for these dimmers is controlled by a PWM GPIO pin. They typically have power, up and down buttons, a powered-on LED, five brightness LEDs and another status LED. Examples are: https://www.amazon.com/dp/B07FXYSVR1 , https://www.amazon.com/dp/B07V26Q3VD , https://www.amazon.com/dp/B07K67D43J , https://www.amazon.com/dp/B07TTGFWFM To include PWM dimmer support in the build, define USE_PWM_DIMMER in your user_config_override. This adds 4.5K to the code size. The light module is not required for PWM dimmer operation so you can #undef USE_LIGHT to reduce the firmware bin size. To enable PWM dimmer operation, select the PWM Dimmer module. PWM Dimmer Operation ~ Pressing and releasing the power button toggles the power on/off. If the toggle turns the power on, the load is returned to the last brightness it was adjusted to. If Fade is enabled, the load is faded on/off at the rate defined by the Speed setting. When the power is on, holding the down or up button decreases/increases the brightness. The brightness can also be changed using just the power button. When the power is on, holding the power button alternately increases or decreases the brightness. Initially, holding the power button increases the brightness. Releasing and then holding the power button again decreases the brightness. When the power is off, pressing and releasing the down or up button turns the power on at a temporary brightness of the low/high levels set by the DimmerPreset command. Turning the power on at the low preset can also be accomplished by holding the power button while the power is off. The dimmer presets are intended to enable quickly turning on a light to a dim or bright level without changing the normal desired brightness. Turning the power on to a preset does not change the brightness the load will be set to when the switch is turned on the next time. For example, if the light is on and you adjust the brightness to 80 and then turn the light off, when you turn it back on, the brightness will return to 80. If you turn the power off again and then press the down button, the light will be turned on with a brightness of the low preset. If you then turn the light off and on again, the brightness will return to 80. When the power is off, holding the down or up button publishes an MQTT EVENT command. The topic follows the format of the Full Topic with a prefix of Event (ex. cmnd/LightSwitch1/EVENT). The MQTT payload is Trigger#, where # is 1 if the down button is held or 2 if the up button is held. These triggers can be used in rules on remote devices (ON Event#Trigger1) or by automation software to trigger automations such as scene changes. For example, the Event topic Trigger1 payload could trigger the automation software to turn on the previous scene in a list and the Trigger2 payload could trigger the automation software to turn on the next scene in a list. If there are LED\u2019s defined in the template, they are turned on to indicate the current brightness. More LEDs are turned on at higher brightnesses. The LedTimeout command enables/disables an LED timeout. If LED timeout is enabled, the LED\u2019s turn off five seconds after the last change in brightness. Note that the lowest LED and the blue power LED are always on when the power is on. The LED timeout can also be enabled/disabled by holding the power button while tapping (pressing and releasing quickly) the down button. The LEDLink LED can be used as a nightlight/powered-off indicator. The PoweredOffLed command enables/disables turning the LEDLink LED on when the power is off. The powered-off indicator can also be enabled/disabled by holding the power button and tapping the up button. Holding the power button, tapping the down button and then tapping or holding the down or up button sends a device group message to set RGB lights in the device group to the previous/next fixed color. The command is sent/value is adjusted once every .5 seconds for as long as the button is held. The color sequence as defined by the Light module is red, green, blue, orange, light green, light blue, amber, cyan, purple, yellow, pink, white using RGB channels, white using CT channels. Holding the power button, tapping the up button and then tapping or holding the down or up button publishes an MQTT Event command. The command is sent/value is adjusted once every .5 seconds for as long as the button is held. The MQTT topic is as described above. The MQTT payload is Trigger#, where # is 3 if the down button is held or 4 if the up button is held. Holding the down or up button alone for over 10 seconds executes the WiFiConfig 2 command. Pressing and releasing any button publishes an MQTT TOGGLE command for the button. Holding a button publishes an MQTT HOLD command followed by an MQTT OFF command when the button is released. When Device Groups are enabled, the PWM Dimmer brightness presets are kept in sync across all switches in the group. The powered-off LED and LED timeout settings are specific to each switch. Changing them does not replicate the change to the other switches in the group. Commands ~ Command Parameters BriPreset <low>,<high> = set brightness low and high presets 1..255 = set brightness preset + = increase brightness preset - = decrease brightness preset SetOption86 Set brightness LED timeout 0 = disable timeout (default) 1 = enable timeout SetOption87 Set powered-off LED (nightlight) 0 = disable powered-off LED (default) 1 = enable powered-off LED SetOption88 Set remote device mode 0 = disable remote device mode(default) 1 = enable remote device mode Remote Device Mode ~ Remote device mode allows PWM Dimmer switches to control remote devices. With remote device mode enabled, each button controls a different device. Note that dimmer switches with toggle-style down/up buttons have limited functionality as remote device mode switches because you can not push the down and up buttons simultaneously. To include remote device mode support in the build, define USE_PWM_DIMMER_REMOTE in your user_config_override. Remote device mode support requires device group support so USE_DEVICE_GROUPS is automatically defined if USE_PWM_DIMMER_REMOTE is defined. Remote device mode support adds 0.7K to the code size in addition to the code size required for device groups support. To enable remote device mode, execute the command SetOption88 1 (the device will restart). Each remote device must be running firmware with device group support and have remote device support enabled. The remote devices do not need to be built with PWM dimmer support nor do they need to be switches. If a remote device is a PWM dimmer, the device acts like a 3-way dimmer switch would and may or may not have a load connected to it. It\u2019s also possible to use a PWM dimmer switch without a load to act as a wall switch to control the power, brightness and color of one or more smart lights with Tasmota with device group support loaded on them. With remote device mode is enabled, button 1 is the power button for the local device while buttons 2 and 3 are the power buttons for remote devices. Group names for buttons 2 and 3 are set by the GroupTopic2 and GroupTopic3 commands respectively. Note that the button numbers are defined by the module template and can be in any physical order on the switch (button 1 can be defined as the top button, the middle button or the bottom button). Button combinations that publish MQTT Event commands use a topic in the format cmnd/%group-topic%/EVENT. Pressing and releasing a power button toggles the power on all devices in the group assigned to the button. When the power is on, holding the button alternately increases or decreases the brightness. When the power is off, holding the button turns the power on at a temporary brightness of the low level set by the BriPreset command. While holding a power button, the other two buttons act like the down and up buttons for the remote device. All the functions performed by the down and up buttons in non-remote device mode are available in remote device mode. While holding button 1, button 2 performs the functions of the down button and button 3 performs the functions of the up button. While holding button 2, button 1 performs the functions of the down button and button 3 performs the functions of the up button. While holding button 3, button 1 performs the functions of the down button and button 2 performs the functions of the up button.","title":"PWM Dimmer"},{"location":"PWM-dimmer-switch/#pwm-dimmer","text":"The PWM Dimmer module adds support for Martin Jerry/acenx/Tessan/NTONPOWER SD0x PWM dimmer switches. The brightness of the load for these dimmers is controlled by a PWM GPIO pin. They typically have power, up and down buttons, a powered-on LED, five brightness LEDs and another status LED. Examples are: https://www.amazon.com/dp/B07FXYSVR1 , https://www.amazon.com/dp/B07V26Q3VD , https://www.amazon.com/dp/B07K67D43J , https://www.amazon.com/dp/B07TTGFWFM To include PWM dimmer support in the build, define USE_PWM_DIMMER in your user_config_override. This adds 4.5K to the code size. The light module is not required for PWM dimmer operation so you can #undef USE_LIGHT to reduce the firmware bin size. To enable PWM dimmer operation, select the PWM Dimmer module.","title":"PWM Dimmer"},{"location":"PWM-dimmer-switch/#pwm-dimmer-operation","text":"Pressing and releasing the power button toggles the power on/off. If the toggle turns the power on, the load is returned to the last brightness it was adjusted to. If Fade is enabled, the load is faded on/off at the rate defined by the Speed setting. When the power is on, holding the down or up button decreases/increases the brightness. The brightness can also be changed using just the power button. When the power is on, holding the power button alternately increases or decreases the brightness. Initially, holding the power button increases the brightness. Releasing and then holding the power button again decreases the brightness. When the power is off, pressing and releasing the down or up button turns the power on at a temporary brightness of the low/high levels set by the DimmerPreset command. Turning the power on at the low preset can also be accomplished by holding the power button while the power is off. The dimmer presets are intended to enable quickly turning on a light to a dim or bright level without changing the normal desired brightness. Turning the power on to a preset does not change the brightness the load will be set to when the switch is turned on the next time. For example, if the light is on and you adjust the brightness to 80 and then turn the light off, when you turn it back on, the brightness will return to 80. If you turn the power off again and then press the down button, the light will be turned on with a brightness of the low preset. If you then turn the light off and on again, the brightness will return to 80. When the power is off, holding the down or up button publishes an MQTT EVENT command. The topic follows the format of the Full Topic with a prefix of Event (ex. cmnd/LightSwitch1/EVENT). The MQTT payload is Trigger#, where # is 1 if the down button is held or 2 if the up button is held. These triggers can be used in rules on remote devices (ON Event#Trigger1) or by automation software to trigger automations such as scene changes. For example, the Event topic Trigger1 payload could trigger the automation software to turn on the previous scene in a list and the Trigger2 payload could trigger the automation software to turn on the next scene in a list. If there are LED\u2019s defined in the template, they are turned on to indicate the current brightness. More LEDs are turned on at higher brightnesses. The LedTimeout command enables/disables an LED timeout. If LED timeout is enabled, the LED\u2019s turn off five seconds after the last change in brightness. Note that the lowest LED and the blue power LED are always on when the power is on. The LED timeout can also be enabled/disabled by holding the power button while tapping (pressing and releasing quickly) the down button. The LEDLink LED can be used as a nightlight/powered-off indicator. The PoweredOffLed command enables/disables turning the LEDLink LED on when the power is off. The powered-off indicator can also be enabled/disabled by holding the power button and tapping the up button. Holding the power button, tapping the down button and then tapping or holding the down or up button sends a device group message to set RGB lights in the device group to the previous/next fixed color. The command is sent/value is adjusted once every .5 seconds for as long as the button is held. The color sequence as defined by the Light module is red, green, blue, orange, light green, light blue, amber, cyan, purple, yellow, pink, white using RGB channels, white using CT channels. Holding the power button, tapping the up button and then tapping or holding the down or up button publishes an MQTT Event command. The command is sent/value is adjusted once every .5 seconds for as long as the button is held. The MQTT topic is as described above. The MQTT payload is Trigger#, where # is 3 if the down button is held or 4 if the up button is held. Holding the down or up button alone for over 10 seconds executes the WiFiConfig 2 command. Pressing and releasing any button publishes an MQTT TOGGLE command for the button. Holding a button publishes an MQTT HOLD command followed by an MQTT OFF command when the button is released. When Device Groups are enabled, the PWM Dimmer brightness presets are kept in sync across all switches in the group. The powered-off LED and LED timeout settings are specific to each switch. Changing them does not replicate the change to the other switches in the group.","title":"PWM Dimmer Operation"},{"location":"PWM-dimmer-switch/#commands","text":"Command Parameters BriPreset <low>,<high> = set brightness low and high presets 1..255 = set brightness preset + = increase brightness preset - = decrease brightness preset SetOption86 Set brightness LED timeout 0 = disable timeout (default) 1 = enable timeout SetOption87 Set powered-off LED (nightlight) 0 = disable powered-off LED (default) 1 = enable powered-off LED SetOption88 Set remote device mode 0 = disable remote device mode(default) 1 = enable remote device mode","title":"Commands"},{"location":"PWM-dimmer-switch/#remote-device-mode","text":"Remote device mode allows PWM Dimmer switches to control remote devices. With remote device mode enabled, each button controls a different device. Note that dimmer switches with toggle-style down/up buttons have limited functionality as remote device mode switches because you can not push the down and up buttons simultaneously. To include remote device mode support in the build, define USE_PWM_DIMMER_REMOTE in your user_config_override. Remote device mode support requires device group support so USE_DEVICE_GROUPS is automatically defined if USE_PWM_DIMMER_REMOTE is defined. Remote device mode support adds 0.7K to the code size in addition to the code size required for device groups support. To enable remote device mode, execute the command SetOption88 1 (the device will restart). Each remote device must be running firmware with device group support and have remote device support enabled. The remote devices do not need to be built with PWM dimmer support nor do they need to be switches. If a remote device is a PWM dimmer, the device acts like a 3-way dimmer switch would and may or may not have a load connected to it. It\u2019s also possible to use a PWM dimmer switch without a load to act as a wall switch to control the power, brightness and color of one or more smart lights with Tasmota with device group support loaded on them. With remote device mode is enabled, button 1 is the power button for the local device while buttons 2 and 3 are the power buttons for remote devices. Group names for buttons 2 and 3 are set by the GroupTopic2 and GroupTopic3 commands respectively. Note that the button numbers are defined by the module template and can be in any physical order on the switch (button 1 can be defined as the top button, the middle button or the bottom button). Button combinations that publish MQTT Event commands use a topic in the format cmnd/%group-topic%/EVENT. Pressing and releasing a power button toggles the power on all devices in the group assigned to the button. When the power is on, holding the button alternately increases or decreases the brightness. When the power is off, holding the button turns the power on at a temporary brightness of the low level set by the BriPreset command. While holding a power button, the other two buttons act like the down and up buttons for the remote device. All the functions performed by the down and up buttons in non-remote device mode are available in remote device mode. While holding button 1, button 2 performs the functions of the down button and button 3 performs the functions of the up button. While holding button 2, button 1 performs the functions of the down button and button 3 performs the functions of the up button. While holding button 3, button 1 performs the functions of the down button and button 2 performs the functions of the up button.","title":"Remote Device Mode"},{"location":"PZEM-0XX/","text":"PZEM is a dedicated separate energy monitor, device calibration in Tasmota is not supported. PZEM-004 ~ The PZEM-004T together with a Sonoff Basic provide a good clamp on energy monitor. Parts needed ~ Sonoff Basic PZEM-004T Resistor 1k Enclosure Power cable Preparation ~ Install Tasmota on the Sonoff Basic and confirm it is functional before connecting the PZEM-004T to its serial interface. Hardware connections ~ As the PZEM-004T expects 5V serial data and the Sonoff Basic only provides up to 3V3, the expected optocoupler input power of the PZEM-004T has to be reduced. This can be accomplished by soldering a 1k resistor between the joints shown below (modification works for version v.1.0 and v.3.0). PZEM-004T v.1.0 PZEM-004T v.3.0 Connect the serial interface of the Sonoff Basic with the serial interface of the PZEM-004T. See pictures regarding used colors and connections. 3V3/5V Red Rx Yellow Tx Green Gnd Grey (Image re-used from https://www.instructables.com/id/Use-Homie-Firmware-to-Drive-Sonoff-Switch-Module-E/ Thanks @amayii0) As the PZEM004T is functioning better on 5V, it can be obtained from the Voltage regulator as shown in this image. Cut the power cable in two and connect the input wires to both Sonoff Basic and PZEM-004T. Route one of the power output wires through the PZEM-004T core and connect the output wires to the Sonoff Basic output. As most parts are connected to high voltage AC it is recommended to fit the hardware in a solid enclosure. Software configuration ~ Configure the GPIO's for hardware serial connection as shown below. IMPORTANT: If using the connections as following, the communication works in all cores due to TASMOTA using hardware serial. If the user wants to use other GPIOs for communication, TASMOTA will emulate a serial interface using software serial. This feature does not work using core 2.3.0 due to insufficient RAM. To use the software serial feature, you must use a core version of 2.4.2 or greater. Device Template PZEM-004T version prior to V3: {\"NAME\":\"HW-655 PZEM\",\"GPIO\":[0,62,0,63,0,0,0,0,0,0,0,0,0],\"FLAG\":0,\"BASE\":1} PZEM-004T version V3: {\"NAME\":\"HW-655 PZEM\",\"GPIO\":[0,62,0,98,0,0,0,0,0,0,0,0,0],\"FLAG\":0,\"BASE\":1} The PZEM-004T together with a HW-655 Relay provide a good clamp-on energy monitor for a 240V clothes dryer. Parts needed ~ Circuit Box 3-prong Dryer Electrical Cord (Note - some households use a 4-prong plug) 3-prong Dryer Receptacle (Note - some households use a 4-prong plug) PZEM-004T HW-655 w/ ESP-01 ESHION SPSD-5S AC-DC 5V Buck Converter 4-pin Serial Connector DuPont Connectors & 22 AWG wire Preparation ~ Install TASMOTA ( tasmota.bin ) is sufficient) on the ESP-01 and confirm it is functional before connecting the PZEM-004T to its serial interface. Use of pins other that the default hardware serial GPIO (01 & 03) ( requires 2.4.2 ESP Core or higher ) in order for TASMOTA to emulate a serial interface using software serial. Hardware connections ~ Connect the serial interface of the HW-655 with the serial interface of the PZEM-004T. As most parts are connected to high voltage AC it is recommended to fit the hardware in a solid enclosure. Software configuration ~ Device Template PZEM-004T version prior to V3: {\"NAME\":\"HW-655 PZEM\",\"GPIO\":[0,63,0,62,0,0,0,0,0,0,0,0,0],\"FLAG\":0,\"BASE\":18} PZEM-004T version V3: {\"NAME\":\"HW-655 PZEM\",\"GPIO\":[0,98,0,62,0,0,0,0,0,0,0,0,0],\"FLAG\":0,\"BASE\":18} Use the module template to configure the GPIO's for hardware serial connection. IMPORTANT: If using the connections as following, the communication works in all cores due to TASMOTA using hardware serial. If the user wants to use other GPIOs for communication, TASMOTA will emulate a serial interface using software serial. This feature does not work using core 2.3.0 due to insufficient RAM. To use the software serial feature, you must use a core version of 2.4.2 or greater. Connected Power Meter using PZEM-004T, Wemos D1 Mini and a 1602 I 2 C display ~ Parts needed ~ Wemos D1 Mini PZEM-004T 1kOhm Resistor (optional - see alternate wiring) Enclosure 5V buck converter power supply (search for \"700ma 3.5w 5v\" on usual stores...) I 2 C 1602 LCD Display (I had issues with green one, I 2 C address 0x3F, while no problems with blue ones, address 0x27) Mains Power cable Mammuth Clamps Preparation ~ You need to compile your own Tasmota firmware as none of the pre-compiled binaries have support for display and PZEM module. Set up your preferred IDE as described in wiki Enable IDE to Use Custom Settings ~ Create user_config_override.h in the tasmota folder and paste the contents of this sample configuration file . PlatformIO Rename platformio_override_sample.ini . to platformio_override.ini Enter platformio run -e <variant-name> Examples: platformio run -e tasmota-sensors platformio run -e tasmota-DE Arduino IDE Edit my_user_config.h . Uncomment the statement by removing the \"//\" in front of the line: #define USE_CONFIG_OVERRIDE Click compile Flash the binary on the Wemos D1 Mini and confirm it is functional before connecting the PZEM-004T to its serial interface. Tasmota Parameter Configuration ~ Device Template PZEM-004T version prior to V3: {\"NAME\":\"HW-655 PZEM\",\"GPIO\":[0,63,0,62,6,5,0,0,0,0,0,0,0],\"FLAG\":0,\"BASE\":18} PZEM-004T version V3: {\"NAME\":\"HW-655 PZEM\",\"GPIO\":[0,98,0,62,6,5,0,0,0,0,0,0,0],\"FLAG\":0,\"BASE\":18} use I2CScan to detect your device address use DeviceAddress XXX (where XXX is the decimal converted address found) to set the I 2 C address set TelePeriod 10 to have the display refresh every 10 seconds (you can't go under this value) set DisplayModel 1 , and DisplayMode 0 finally, add a Rule to display values (I choose these): Rule1 ON Tele - ENERGY#Power DO DisplayText [ z ] [ x1y0 ]% value % W ENDON ON Tele - ENERGY#Today DO DisplayText [ x8y0 ]% value % Wh ENDON ON Tele - ENERGY#Voltage DO DisplayText [ x1y1 ]% value % V ENDON ON Tele - ENERGY#Current DO DisplayText [ x8y1 ]% value % A ENDON remember to enable the rule, with Rule1 1 Images and Wiring diagram ~ DANGER - MAINS VOLTAGE . Be sure to crimp connectors and use heat-shrinking tube wherever possible/needed, and tightly secure any screw. How it looks, from web GUI: How it looks, from enclosure: You can set the contrast using the little trimmer/pot on back of the display. I cut a bit of the corners from the display to have it flush with border, and used two hexagonal plastic standoffs with nuts and bolts to secure it to transparent top. Mains IN, mains OUT, all sealed: Wiring Diagram: * Check images below for more information about the 1kOhm resistor needed to shift the voltage to 5V from 3V3 for the PZEM-004T serial connection. PZEM-004T v.1.0 PZEM-004T v.3.0 Calibration ~ Per Theo - As the PZEM is a dedicated energy monitor, device calibration in TASMOTA is currently not supported. PZEM-016 ~ - PZEM016 Energy Monitoring - RS485 to TTL serial modification DO NOT PERFORM THIS MODIFICATION WITHOUT REMOVING POWER FROM THE PZEM FIRST! Note : the PZEM-016 TTL output is at 5V signal levels. There are varying schools of thought on whether the ESP82xx has 5V tolerant GPIO. You may want to use a level shifter for the serial communications signals to bring them to the recommended 3.3V. PZEM-016 modules can be converted from RS485 to TTL serial level devices by simply removing the internal MAX485 chip and adding two internal jumper wires. This will bring the serial port connections out via the four-pin terminal block. Pin A is now TTL serial out (Tx) and pin B TTL serial in (Rx). The modification retains the optical isolation used by the PZEM for safety to ensure no high voltages on the outputs. You can use a voltage level shifter to power the ESP82xx from the PZEM-016 module's 5V power. This may also require a 470uf 35V capacitor across the 5V line to work reliably. Tasmota Configuration It is recommended to use GPIO1/GPIO3 or GPIO13/GPIO15 for the most reliable serial communications. You can use any GPIO but anything else will use serial emulation (software). Software serial is not supported with the 2.3 Arduino Core. GPIO Component PZEM 1 PZEM0XX Tx (62) Pin B 3 PZEM016 Rx (98) Pin A","title":"PZEM 0XX"},{"location":"PZEM-0XX/#pzem-004","text":"The PZEM-004T together with a Sonoff Basic provide a good clamp on energy monitor.","title":"PZEM-004"},{"location":"PZEM-0XX/#parts-needed","text":"Sonoff Basic PZEM-004T Resistor 1k Enclosure Power cable","title":"Parts needed"},{"location":"PZEM-0XX/#preparation","text":"Install Tasmota on the Sonoff Basic and confirm it is functional before connecting the PZEM-004T to its serial interface.","title":"Preparation"},{"location":"PZEM-0XX/#hardware-connections","text":"As the PZEM-004T expects 5V serial data and the Sonoff Basic only provides up to 3V3, the expected optocoupler input power of the PZEM-004T has to be reduced. This can be accomplished by soldering a 1k resistor between the joints shown below (modification works for version v.1.0 and v.3.0). PZEM-004T v.1.0 PZEM-004T v.3.0 Connect the serial interface of the Sonoff Basic with the serial interface of the PZEM-004T. See pictures regarding used colors and connections. 3V3/5V Red Rx Yellow Tx Green Gnd Grey (Image re-used from https://www.instructables.com/id/Use-Homie-Firmware-to-Drive-Sonoff-Switch-Module-E/ Thanks @amayii0) As the PZEM004T is functioning better on 5V, it can be obtained from the Voltage regulator as shown in this image. Cut the power cable in two and connect the input wires to both Sonoff Basic and PZEM-004T. Route one of the power output wires through the PZEM-004T core and connect the output wires to the Sonoff Basic output. As most parts are connected to high voltage AC it is recommended to fit the hardware in a solid enclosure.","title":"Hardware connections"},{"location":"PZEM-0XX/#software-configuration","text":"Configure the GPIO's for hardware serial connection as shown below. IMPORTANT: If using the connections as following, the communication works in all cores due to TASMOTA using hardware serial. If the user wants to use other GPIOs for communication, TASMOTA will emulate a serial interface using software serial. This feature does not work using core 2.3.0 due to insufficient RAM. To use the software serial feature, you must use a core version of 2.4.2 or greater. Device Template PZEM-004T version prior to V3: {\"NAME\":\"HW-655 PZEM\",\"GPIO\":[0,62,0,63,0,0,0,0,0,0,0,0,0],\"FLAG\":0,\"BASE\":1} PZEM-004T version V3: {\"NAME\":\"HW-655 PZEM\",\"GPIO\":[0,62,0,98,0,0,0,0,0,0,0,0,0],\"FLAG\":0,\"BASE\":1} The PZEM-004T together with a HW-655 Relay provide a good clamp-on energy monitor for a 240V clothes dryer.","title":"Software configuration"},{"location":"PZEM-0XX/#parts-needed_1","text":"Circuit Box 3-prong Dryer Electrical Cord (Note - some households use a 4-prong plug) 3-prong Dryer Receptacle (Note - some households use a 4-prong plug) PZEM-004T HW-655 w/ ESP-01 ESHION SPSD-5S AC-DC 5V Buck Converter 4-pin Serial Connector DuPont Connectors & 22 AWG wire","title":"Parts needed"},{"location":"PZEM-0XX/#preparation_1","text":"Install TASMOTA ( tasmota.bin ) is sufficient) on the ESP-01 and confirm it is functional before connecting the PZEM-004T to its serial interface. Use of pins other that the default hardware serial GPIO (01 & 03) ( requires 2.4.2 ESP Core or higher ) in order for TASMOTA to emulate a serial interface using software serial.","title":"Preparation"},{"location":"PZEM-0XX/#hardware-connections_1","text":"Connect the serial interface of the HW-655 with the serial interface of the PZEM-004T. As most parts are connected to high voltage AC it is recommended to fit the hardware in a solid enclosure.","title":"Hardware connections"},{"location":"PZEM-0XX/#software-configuration_1","text":"Device Template PZEM-004T version prior to V3: {\"NAME\":\"HW-655 PZEM\",\"GPIO\":[0,63,0,62,0,0,0,0,0,0,0,0,0],\"FLAG\":0,\"BASE\":18} PZEM-004T version V3: {\"NAME\":\"HW-655 PZEM\",\"GPIO\":[0,98,0,62,0,0,0,0,0,0,0,0,0],\"FLAG\":0,\"BASE\":18} Use the module template to configure the GPIO's for hardware serial connection. IMPORTANT: If using the connections as following, the communication works in all cores due to TASMOTA using hardware serial. If the user wants to use other GPIOs for communication, TASMOTA will emulate a serial interface using software serial. This feature does not work using core 2.3.0 due to insufficient RAM. To use the software serial feature, you must use a core version of 2.4.2 or greater.","title":"Software configuration"},{"location":"PZEM-0XX/#connected-power-meter-using-pzem-004t-wemos-d1-mini-and-a-1602-i2c-display","text":"","title":"Connected Power Meter using PZEM-004T, Wemos D1 Mini and a 1602 I2C display"},{"location":"PZEM-0XX/#parts-needed_2","text":"Wemos D1 Mini PZEM-004T 1kOhm Resistor (optional - see alternate wiring) Enclosure 5V buck converter power supply (search for \"700ma 3.5w 5v\" on usual stores...) I 2 C 1602 LCD Display (I had issues with green one, I 2 C address 0x3F, while no problems with blue ones, address 0x27) Mains Power cable Mammuth Clamps","title":"Parts needed"},{"location":"PZEM-0XX/#preparation_2","text":"You need to compile your own Tasmota firmware as none of the pre-compiled binaries have support for display and PZEM module. Set up your preferred IDE as described in wiki","title":"Preparation"},{"location":"PZEM-0XX/#enable-ide-to-use-custom-settings","text":"Create user_config_override.h in the tasmota folder and paste the contents of this sample configuration file .","title":"Enable IDE to Use Custom Settings"},{"location":"PZEM-0XX/#tasmota-parameter-configuration","text":"Device Template PZEM-004T version prior to V3: {\"NAME\":\"HW-655 PZEM\",\"GPIO\":[0,63,0,62,6,5,0,0,0,0,0,0,0],\"FLAG\":0,\"BASE\":18} PZEM-004T version V3: {\"NAME\":\"HW-655 PZEM\",\"GPIO\":[0,98,0,62,6,5,0,0,0,0,0,0,0],\"FLAG\":0,\"BASE\":18} use I2CScan to detect your device address use DeviceAddress XXX (where XXX is the decimal converted address found) to set the I 2 C address set TelePeriod 10 to have the display refresh every 10 seconds (you can't go under this value) set DisplayModel 1 , and DisplayMode 0 finally, add a Rule to display values (I choose these): Rule1 ON Tele - ENERGY#Power DO DisplayText [ z ] [ x1y0 ]% value % W ENDON ON Tele - ENERGY#Today DO DisplayText [ x8y0 ]% value % Wh ENDON ON Tele - ENERGY#Voltage DO DisplayText [ x1y1 ]% value % V ENDON ON Tele - ENERGY#Current DO DisplayText [ x8y1 ]% value % A ENDON remember to enable the rule, with Rule1 1","title":"Tasmota Parameter Configuration"},{"location":"PZEM-0XX/#images-and-wiring-diagram","text":"DANGER - MAINS VOLTAGE . Be sure to crimp connectors and use heat-shrinking tube wherever possible/needed, and tightly secure any screw. How it looks, from web GUI: How it looks, from enclosure: You can set the contrast using the little trimmer/pot on back of the display. I cut a bit of the corners from the display to have it flush with border, and used two hexagonal plastic standoffs with nuts and bolts to secure it to transparent top. Mains IN, mains OUT, all sealed: Wiring Diagram: * Check images below for more information about the 1kOhm resistor needed to shift the voltage to 5V from 3V3 for the PZEM-004T serial connection. PZEM-004T v.1.0 PZEM-004T v.3.0","title":"Images and Wiring diagram"},{"location":"PZEM-0XX/#calibration","text":"Per Theo - As the PZEM is a dedicated energy monitor, device calibration in TASMOTA is currently not supported.","title":"Calibration"},{"location":"PZEM-0XX/#pzem-016","text":"- PZEM016 Energy Monitoring - RS485 to TTL serial modification DO NOT PERFORM THIS MODIFICATION WITHOUT REMOVING POWER FROM THE PZEM FIRST! Note : the PZEM-016 TTL output is at 5V signal levels. There are varying schools of thought on whether the ESP82xx has 5V tolerant GPIO. You may want to use a level shifter for the serial communications signals to bring them to the recommended 3.3V. PZEM-016 modules can be converted from RS485 to TTL serial level devices by simply removing the internal MAX485 chip and adding two internal jumper wires. This will bring the serial port connections out via the four-pin terminal block. Pin A is now TTL serial out (Tx) and pin B TTL serial in (Rx). The modification retains the optical isolation used by the PZEM for safety to ensure no high voltages on the outputs. You can use a voltage level shifter to power the ESP82xx from the PZEM-016 module's 5V power. This may also require a 470uf 35V capacitor across the 5V line to work reliably. Tasmota Configuration It is recommended to use GPIO1/GPIO3 or GPIO13/GPIO15 for the most reliable serial communications. You can use any GPIO but anything else will use serial emulation (software). Software serial is not supported with the 2.3 Arduino Core. GPIO Component PZEM 1 PZEM0XX Tx (62) Pin B 3 PZEM016 Rx (98) Pin A","title":"PZEM-016"},{"location":"PlatformIO-CLI/","text":"How to flash the Tasmota firmware onto a device using the platformio command line interface. This manual was tested on Ubuntu 17.10. Prerequisites ~ Install Python and PIP ~ sudo apt-get install python-pip Install PlatformIO CLI ~ sudo pip install -U platformio Download the Tasmota source code ~ Either download the latest Tasmota Source code from https://github.com/arendst/Tasmota/ and extract it or clone the Git repository: 'git clone https://github.com/arendst/Tasmota.git` Select the environment ~ The default environment configuration can be used to easily generate Tasmota firmware variants (sonoff, sensors, display, etc.). If you're not sure which binary is the right one for you, consult the builds table or just start with tasmota.bin . To build and/or flash exactly one of these, use the -e command line argument (e.g., -e tasmota-sensors ). Alternatively, uncomment (i.e., remove the leading ; ) the desired env_default line in the platformio.ini file and do not use the -e argument on the command. ; *** Uncomment one of the lines below to build/upload only one environment ;default_envs = tasmota ;default_envs = tasmota-ircustom ; alternative to 'tasmota' with full IR protocols activated, you will need to disable some features to keep code not too big ;default_envs = tasmota-minimal ;default_envs = tasmota-basic ;default_envs = tasmota-knx ;default_envs = tasmota-sensors ;default_envs = tasmota-display ;default_envs = tasmota-ir ;default_envs = tasmota-BG ;default_envs = tasmota-BR ;default_envs = tasmota-CN ;default_envs = tasmota-CZ ;default_envs = tasmota-DE ;default_envs = tasmota-ES ;default_envs = tasmota-FR ;default_envs = tasmota-GR ;default_envs = tasmota-HE ;default_envs = tasmota-HU ;default_envs = tasmota-IT ;default_envs = tasmota-KO ;default_envs = tasmota-NL ;default_envs = tasmota-PL ;default_envs = tasmota-PT ;default_envs = tasmota-RU ;default_envs = tasmota-SE ;default_envs = tasmota-SK ;default_envs = tasmota-TR ;default_envs = tasmota-TW ;default_envs = tasmota-UK Compile and upload ~ Once all the prerequisites are in place, compiling and uploading is one simple command. Execute this from within the Tasmota source code directory: platformio run -e <variant> --target upload --upload-port <port> Just make sure to replace <port> with the actual serial port your device is connected to. On Windows these interfaces are named COM ports (COM1, COM2, etc.). On Linux these interfaces are named TTY ports (e.g., /dev/ttyUSB0, /dev/ttyUSB1, etc.)]. Depending on your configuration your user account may need to be in the dialout group .","title":"PlatformIO CLI"},{"location":"PlatformIO-CLI/#prerequisites","text":"","title":"Prerequisites"},{"location":"PlatformIO-CLI/#install-python-and-pip","text":"sudo apt-get install python-pip","title":"Install Python and PIP"},{"location":"PlatformIO-CLI/#install-platformio-cli","text":"sudo pip install -U platformio","title":"Install PlatformIO CLI"},{"location":"PlatformIO-CLI/#download-the-tasmota-source-code","text":"Either download the latest Tasmota Source code from https://github.com/arendst/Tasmota/ and extract it or clone the Git repository: 'git clone https://github.com/arendst/Tasmota.git`","title":"Download the Tasmota source code"},{"location":"PlatformIO-CLI/#select-the-environment","text":"The default environment configuration can be used to easily generate Tasmota firmware variants (sonoff, sensors, display, etc.). If you're not sure which binary is the right one for you, consult the builds table or just start with tasmota.bin . To build and/or flash exactly one of these, use the -e command line argument (e.g., -e tasmota-sensors ). Alternatively, uncomment (i.e., remove the leading ; ) the desired env_default line in the platformio.ini file and do not use the -e argument on the command. ; *** Uncomment one of the lines below to build/upload only one environment ;default_envs = tasmota ;default_envs = tasmota-ircustom ; alternative to 'tasmota' with full IR protocols activated, you will need to disable some features to keep code not too big ;default_envs = tasmota-minimal ;default_envs = tasmota-basic ;default_envs = tasmota-knx ;default_envs = tasmota-sensors ;default_envs = tasmota-display ;default_envs = tasmota-ir ;default_envs = tasmota-BG ;default_envs = tasmota-BR ;default_envs = tasmota-CN ;default_envs = tasmota-CZ ;default_envs = tasmota-DE ;default_envs = tasmota-ES ;default_envs = tasmota-FR ;default_envs = tasmota-GR ;default_envs = tasmota-HE ;default_envs = tasmota-HU ;default_envs = tasmota-IT ;default_envs = tasmota-KO ;default_envs = tasmota-NL ;default_envs = tasmota-PL ;default_envs = tasmota-PT ;default_envs = tasmota-RU ;default_envs = tasmota-SE ;default_envs = tasmota-SK ;default_envs = tasmota-TR ;default_envs = tasmota-TW ;default_envs = tasmota-UK","title":"Select the environment"},{"location":"PlatformIO-CLI/#compile-and-upload","text":"Once all the prerequisites are in place, compiling and uploading is one simple command. Execute this from within the Tasmota source code directory: platformio run -e <variant> --target upload --upload-port <port> Just make sure to replace <port> with the actual serial port your device is connected to. On Windows these interfaces are named COM ports (COM1, COM2, etc.). On Linux these interfaces are named TTY ports (e.g., /dev/ttyUSB0, /dev/ttyUSB1, etc.)]. Depending on your configuration your user account may need to be in the dialout group .","title":"Compile and upload"},{"location":"PlatformIO/","text":"How to setup and configure PlatformIO for Tasmota compilation and upload. Download PlatformIO ~ Download PlatformIO from http://platformio.org/ Install PlatformIO ~ Install PlatformIO to a known folder. Download Tasmota ~ Download the latest Tasmota Source code from https://github.com/arendst/Tasmota and unzip to another known folder. Configure PlatformIO ~ Copy files ~ Copy all files from the Tasmota Source code into your PlatformIO base folder. Change IDE parameters ~ The default environment configuration can be used to easily generate Tasmota firmware variants (sonoff, sensors, display, etc.). If you're not sure which binary is the right one for you, consult the builds table or just start with tasmota.bin . To build and/or flash exactly one of these, uncomment (i.e., remove the leading ; ) the env_default line for the variant you need. To compile more than one binary variant, uncomment all of the desired env_default lines in the platformio.ini file. Compile Tasmota ~ Select Build from the menu. Upload Tasmota ~ PlatformIO uses the serial interface to upload the firmware to your device. On Windows these interfaces are named COM ports (COM1, COM2, etc.). On Linux these interfaces are named TTY ports (e.g., /dev/ttyUSB0, /dev/ttyUSB1, etc.). Put device into programming mode ~ When performing a firmware upload do not connect the device to AC . Use a 3.3v DC power supply such as that provided by your serial programming adapter. Put the device in programming mode by grounding pin GPIO0 and then applying power (e.g., connecting your computer to the serial adapter). Grounding pin GPIO0 can often be achieved by pressing the button on the device or using a wire between GPIO0 and GND if the button is not available. Deviations may apply. Perform serial upload ~ Select Upload from the menu. NOTE: For a proper device initialization after first firmware upload power down and power up the device.","title":"PlatformIO"},{"location":"PlatformIO/#download-platformio","text":"Download PlatformIO from http://platformio.org/","title":"Download PlatformIO"},{"location":"PlatformIO/#install-platformio","text":"Install PlatformIO to a known folder.","title":"Install PlatformIO"},{"location":"PlatformIO/#download-tasmota","text":"Download the latest Tasmota Source code from https://github.com/arendst/Tasmota and unzip to another known folder.","title":"Download Tasmota"},{"location":"PlatformIO/#configure-platformio","text":"","title":"Configure PlatformIO"},{"location":"PlatformIO/#copy-files","text":"Copy all files from the Tasmota Source code into your PlatformIO base folder.","title":"Copy files"},{"location":"PlatformIO/#change-ide-parameters","text":"The default environment configuration can be used to easily generate Tasmota firmware variants (sonoff, sensors, display, etc.). If you're not sure which binary is the right one for you, consult the builds table or just start with tasmota.bin . To build and/or flash exactly one of these, uncomment (i.e., remove the leading ; ) the env_default line for the variant you need. To compile more than one binary variant, uncomment all of the desired env_default lines in the platformio.ini file.","title":"Change IDE parameters"},{"location":"PlatformIO/#compile-tasmota","text":"Select Build from the menu.","title":"Compile Tasmota"},{"location":"PlatformIO/#upload-tasmota","text":"PlatformIO uses the serial interface to upload the firmware to your device. On Windows these interfaces are named COM ports (COM1, COM2, etc.). On Linux these interfaces are named TTY ports (e.g., /dev/ttyUSB0, /dev/ttyUSB1, etc.).","title":"Upload Tasmota"},{"location":"PlatformIO/#put-device-into-programming-mode","text":"When performing a firmware upload do not connect the device to AC . Use a 3.3v DC power supply such as that provided by your serial programming adapter. Put the device in programming mode by grounding pin GPIO0 and then applying power (e.g., connecting your computer to the serial adapter). Grounding pin GPIO0 can often be achieved by pressing the button on the device or using a wire between GPIO0 and GND if the button is not available. Deviations may apply.","title":"Put device into programming mode"},{"location":"PlatformIO/#perform-serial-upload","text":"Select Upload from the menu. NOTE: For a proper device initialization after first firmware upload power down and power up the device.","title":"Perform serial upload"},{"location":"Power-Monitoring-Calibration/","text":"!> You need to calibrate your power monitoring device as correct measurements are influenced by hardware and timing differences. Your power monitoring capable device flashed with Tasmota and configured with the correct module/template that supports power monitoring An AC capable calibrated multi-meter A known wattage load with a power factor as close to 1 as possible (e.g., a resistive load) for best results [!NOTE] A resistive load device is any device which draws a constant amount of power. For example, an incandescent or halogen light bulb (best choice since their power draw is declared on them). An electric kettle, heater, or blow dryer are also options but you will also need a power meter since the power draw could vary. [!DANGER] Do not use switch mode driven devices such as LED lamps, computer equipment, or inductive/capacitive devices such as motors! (optional) A calibrated power meter (a.k.a Kill-a-Watt) or AC multi-meter Setup ~ Connect the load (e.g., a 60W incandescent light bulb) to your device (optional) Plug your load into the Kill-a-Watt Open two Tasmota web UI browser windows for your power monitoring device: Click on Console in one browser window Keep the other on the main page to view the Power telemetry data Turn the power on to your device. Be sure to turn the output on so the load is powered on as well Wait a few seconds for the readings to stabilize Calibration Procedure ~ Verify the Power reading in the web UI (optionally with the power meter as well) for the expected wattage. Adjust the power offset if needed (in Watts): PowerSet 60.0 If you're using something other than a 60W bulb, enter your load's power rating Verify the Voltage reading. Adjust the voltage offset if needed (in Volts): VoltageSet <voltage> Replace <voltage> with your standard voltage or with reading on your multi-meter if you have one. Your voltage will vary depending on the electrical standards and your electrical grid Verify the Current reading by calculating current value (amperage) using this formula: P (W) /V (V) =I (A) . Adjust the current offset if needed (in milliAmps (mA=A*1000)): CurrentSet <current> Replace <current> with your calculated value (in milliAmps) CurrentSet calculation: P/V=I 1000 * Watts/Volts = milliAmperes [!EXAMPLE] 1000*(60.0/235.5) = 254.777 Confirm the validity of your calibration process checking Power Factor from the web UI which should be as close as possible to 1.00 . In theory resistive loads will always provide a power factor of 1.00. If that is not the case, we recommend you repeat the calibration process and make sure everything was done correctly. Fine Tuning ~ This procedure requires the use of a calibrated power meter or AC multi-meter. Commands CurrentCal , PowerCal and VoltageCal allow fine tuning of the power calibration. Repeat the procedure below for each of the readings: Current, Power, and Voltage using the corresponding calibration command ( CurrentCal , PowerCal , and VoltageCal respectively). Take note that the offset ranges vary for each command . Check the reading using a multi-meter Compare it with the reading on the Tasmota web UI If there is an observed difference, change the offset value by issuing the calibration command in the Console (e.g., PowerCal 10000 ) Adjust the offset value up or down until the readings on the multi-meter and the web page are as close as possible Known Issues ~ Power monitoring chips like the HLW8032 (Blitzwolf SHP5) and CSE7766 (Sonoff S31, Sonoff POW R2) occasionally report invalid power measurements for load values below 5W. During this situation it sometimes reports a valid load. By setting SetOption39 to 128 (default) it must read at least 128 invalid power readings before reporting there is no load. To discard all loads below 6W simply set SetOption39 1 ( 0 will reset to default on next restart) so it will report no load below 6W.","title":"Power Monitoring Calibration"},{"location":"Power-Monitoring-Calibration/#setup","text":"Connect the load (e.g., a 60W incandescent light bulb) to your device (optional) Plug your load into the Kill-a-Watt Open two Tasmota web UI browser windows for your power monitoring device: Click on Console in one browser window Keep the other on the main page to view the Power telemetry data Turn the power on to your device. Be sure to turn the output on so the load is powered on as well Wait a few seconds for the readings to stabilize","title":"Setup"},{"location":"Power-Monitoring-Calibration/#calibration-procedure","text":"Verify the Power reading in the web UI (optionally with the power meter as well) for the expected wattage. Adjust the power offset if needed (in Watts): PowerSet 60.0 If you're using something other than a 60W bulb, enter your load's power rating Verify the Voltage reading. Adjust the voltage offset if needed (in Volts): VoltageSet <voltage> Replace <voltage> with your standard voltage or with reading on your multi-meter if you have one. Your voltage will vary depending on the electrical standards and your electrical grid Verify the Current reading by calculating current value (amperage) using this formula: P (W) /V (V) =I (A) . Adjust the current offset if needed (in milliAmps (mA=A*1000)): CurrentSet <current> Replace <current> with your calculated value (in milliAmps) CurrentSet calculation: P/V=I 1000 * Watts/Volts = milliAmperes [!EXAMPLE] 1000*(60.0/235.5) = 254.777 Confirm the validity of your calibration process checking Power Factor from the web UI which should be as close as possible to 1.00 . In theory resistive loads will always provide a power factor of 1.00. If that is not the case, we recommend you repeat the calibration process and make sure everything was done correctly.","title":"Calibration Procedure"},{"location":"Power-Monitoring-Calibration/#fine-tuning","text":"This procedure requires the use of a calibrated power meter or AC multi-meter. Commands CurrentCal , PowerCal and VoltageCal allow fine tuning of the power calibration. Repeat the procedure below for each of the readings: Current, Power, and Voltage using the corresponding calibration command ( CurrentCal , PowerCal , and VoltageCal respectively). Take note that the offset ranges vary for each command . Check the reading using a multi-meter Compare it with the reading on the Tasmota web UI If there is an observed difference, change the offset value by issuing the calibration command in the Console (e.g., PowerCal 10000 ) Adjust the offset value up or down until the readings on the multi-meter and the web page are as close as possible","title":"Fine Tuning"},{"location":"Power-Monitoring-Calibration/#known-issues","text":"Power monitoring chips like the HLW8032 (Blitzwolf SHP5) and CSE7766 (Sonoff S31, Sonoff POW R2) occasionally report invalid power measurements for load values below 5W. During this situation it sometimes reports a valid load. By setting SetOption39 to 128 (default) it must read at least 128 invalid power readings before reporting there is no load. To discard all loads below 6W simply set SetOption39 1 ( 0 will reset to default on next restart) so it will report no load below 6W.","title":"Known Issues"},{"location":"PowerOnState/","text":"PowerOnState Functionality ~ Command Description PowerOnState Control relay state after powering up the device. 0 / OFF = keep relay(s) OFF after power up 1 / ON = turn relay(s) ON after power up 2 / TOGGLE = toggle relay(s) from last saved state 3 = switch relay(s) to their last saved state (default) 4 = turn relay(s) ON and disable further relay control 5 = after a PulseTime period turn relay(s) ON (acts as inverted PulseTime mode) The PowerOnState device configuration parameter is applied when the device is initially powered up. It does not apply to device warm restarts . Tasmota tracks the relays' state in a masked variable. A set bit ( 1 ) means the corresponding relay is turned ON. The associated GPIO state will be high or low according to whether the relay is configured as Relay<x> or Relay<x>i . Every command for setting the relay state is \"recorded\" in the variable and saved to flash (depending on SetOption0 ). The setting of the relay GPIO is then executed. After a warm restart , the mask variable is re-initialised with the saved state from flash and the relay(s) set to that state. PowerOnState is not executed. During any a device restart, the relay power feedback state is scanned according to the setting of SetOption63 . Scanning the relay state attempts to READ from GPIOs that are configured as relays, i.e., OUTPUTS! The result will not always be what is expected as it depends on how the device relays are wired to the GPIO. SetOption63 was introduced to make this scan optional. With SetOption63 set to 0 (the default), each GPIO assigned as a Relay<x> or Relay<x>i is scanned using 'digitalRead' . The mask variable will be updated with the detected values. The state of the relay(s) will not be changed. READING from an OUTPUT GPIO may result in the mask value being different from the state the relays are in. Thus, SetOption63 was introduced to disable the startup scan for devices where the scan leads to undefined results. SetOption63 is executed after PowerOnState or restart initialization.","title":"PowerOnState"},{"location":"PowerOnState/#poweronstate-functionality","text":"Command Description PowerOnState Control relay state after powering up the device. 0 / OFF = keep relay(s) OFF after power up 1 / ON = turn relay(s) ON after power up 2 / TOGGLE = toggle relay(s) from last saved state 3 = switch relay(s) to their last saved state (default) 4 = turn relay(s) ON and disable further relay control 5 = after a PulseTime period turn relay(s) ON (acts as inverted PulseTime mode) The PowerOnState device configuration parameter is applied when the device is initially powered up. It does not apply to device warm restarts . Tasmota tracks the relays' state in a masked variable. A set bit ( 1 ) means the corresponding relay is turned ON. The associated GPIO state will be high or low according to whether the relay is configured as Relay<x> or Relay<x>i . Every command for setting the relay state is \"recorded\" in the variable and saved to flash (depending on SetOption0 ). The setting of the relay GPIO is then executed. After a warm restart , the mask variable is re-initialised with the saved state from flash and the relay(s) set to that state. PowerOnState is not executed. During any a device restart, the relay power feedback state is scanned according to the setting of SetOption63 . Scanning the relay state attempts to READ from GPIOs that are configured as relays, i.e., OUTPUTS! The result will not always be what is expected as it depends on how the device relays are wired to the GPIO. SetOption63 was introduced to make this scan optional. With SetOption63 set to 0 (the default), each GPIO assigned as a Relay<x> or Relay<x>i is scanned using 'digitalRead' . The mask variable will be updated with the detected values. The state of the relay(s) will not be changed. READING from an OUTPUT GPIO may result in the mask value being different from the state the relays are in. Thus, SetOption63 was introduced to disable the startup scan for devices where the scan leads to undefined results. SetOption63 is executed after PowerOnState or restart initialization.","title":"PowerOnState Functionality"},{"location":"Project-AM312-and-Sonoff-R2/","text":"This use case represents a method to use AM312 as a \"wave hand toggle\" (for under-cabinet kitchen LED). Please note that this solution isn't working in 100% (this sensor has a detection range of a few meters, to decrease the range you can remove the lens from the sensor but still it will pick up movement from 50 cm. You can create the Tasmota rule that will disable AM312 toggle action when the light is on and turn off the power after a few minutes. The gesture sensor APDS-9960 should work better for \"hand-wave\" toggle. Wiring for Sonoff Basic R2 ~ As the R2 version doesn't have GPIO14 exposed you can use GPIO3 (RX) as the AM312 data pin. GPIO2 goes high during the boot (it would toggle the switch then). AM312 ESP8255 device VCC 3V3 or VCC VOUT GPIO3 (RX) GND GND Remember to remove the lens to lower the sensitivity of the sensor. Configuration the module Go to IP of the device, next Configuration --> Configure Module --> set \"GPIO3 Serial In\" to \"Switch1 (9)\" Go to Console and type \" SwitchMode 4 \" ( detailed description of SwitchModes ) to enable toggle switch type. Set rule to turn off light after X amount of seconds (mentioned workaround): rule1 on Switch1#State=2 do backlog Power1 1; RuleTimer1 180 endon on Rules#Timer=1 do backlog Power1 0 endon rule1 1 Rule explanation: Switch1#State=2 - fire the event when switch1 is toggled, Power1 1 - turn on power, RuleTimer1 180 - set Timer1 to 180 seconds and start counting, Rules#Timer=1 - fire the event when Timer1 has stopped, Power1 0 - turn off power. This rule will turn off the light after 3 minutes, if the movement will be detected prior, the timer will be restarted and will count the time from the beginning. Instead of point 3, you can set below rules in order to ignore the second and next movements. It will just turn off the power after 3 minutes. rule1 on Switch1#State=2 do backlog Power1 1; RuleTimer1 180; Rule1 0; Rule2 1 endon rule2 on Rules#Timer=1 do backlog Power1 0; Rule1 1; Rule2 0 endon on Switch1#State=2 do break backlog rule1 1; rule2 0 Rules explanation: rule1 on Switch1#State=2 do backlog Power1 1; RuleTimer1 180; Rule1 0; Rule2 1 endon : Switch1#State=2 - fire the event when switch1 is toggled, Power1 1 - turn on power, RuleTimer1 180 - set Timer1 to 180 seconds and start counting, Rule1 0 - disable Rule1, Rule2 1 - enable Rule2. rule2 on Rules#Timer=1 do backlog Power1 0; Rule1 1; Rule2 0 endon on Switch1#State=2 do break : Rules#Timer=1 - fire the event when Timer1 has stopped Power1 0 - turn off power Rule1 1 - enable Rule1 Rule2 0 - disable Rule2 Switch1#State=2 do break - ignore toggling","title":"Project AM312 and Sonoff R2"},{"location":"Project-AM312-and-Sonoff-R2/#wiring-for-sonoff-basic-r2","text":"As the R2 version doesn't have GPIO14 exposed you can use GPIO3 (RX) as the AM312 data pin. GPIO2 goes high during the boot (it would toggle the switch then). AM312 ESP8255 device VCC 3V3 or VCC VOUT GPIO3 (RX) GND GND Remember to remove the lens to lower the sensitivity of the sensor.","title":"Wiring for Sonoff Basic R2"},{"location":"Python-HTTP-OTA-Server/","text":"Introduction ~ Tasmota firmware can be upgraded using 'Firmware Upgrade' option on the main menu and selecting an OTA URL to fetch (and flash) a new firmware on the device. To use this feature, firmware files need to be hosted on an HTTP web server (e.g., http://thehackbox.org/tasmota). Alternatively, users can to deploy a local HTTP server with Apache, Nginx, or other software solutions. Python makes available the Flask (micro)framework that can be used at different levels of complexity due to its modular architecture. A simple HTTP server (hello-world) can be deployed with only six lines of Python code. A Flask application to offer Tasmota firmware images for OTA upgrades is available as part of the available tools . Requirements ~ Switching to superuser privileges and installing additional packages (and libraries) on a Linux/Windows box. Python3 (follow instruction related to your operating system) netifaces and Flask libraries - can be installed by 'pip' package manager: pip install netifaces flask Instructions ~ Copy Tasmota firmware binary files in 'tools/fw' directory. A set of pre-built firmware binary files can be downloaded from the Tasmota repository . Configure your Tasmota device with your firmware server URL: Firmware Upgrade -> Upgrade by web server: http://<ip_address>:5000/tasmota.bin or use the following command: Backlog OTAURL http://<ip_address>:5000/tasmota.bin; Upgrade 1 Usage ~ To start Python HTTP server: python fw-server.py -d <net_iface> (default: eth0) or python fw-server.py -i <ip_address> Example: python fw-server.py -d wlan0 or python fw-server.py -i 192.168.1.1 Note: On Windows it is advisable to use '-i' option because Windows uses UUID naming for network interfaces that are difficult to enter. Linux server: ~ If your MQTT broker is hosted on a local server, you may want your firmware web server used for Tasmota OTA updates to reside on the same server. Follow these steps to create it as a service: - Copy the python script on the Linux server: $ sudo su # mkdir /srv/tasmota/fw_server/fw # cd /srv/tasmota/fw_server # wget https://github.com/arendst/Tasmota/tree/development/tools/fw_server/fw-server.py - Create a new file named tasmota.service in /etc/systemd/system/ and paste these lines (replace XYZ by your username): ``` [Unit] Description=Local OTA server for Tasmota Requires=network.target After=network.target multi-user.target [Service] User=XYZ Type=idle ExecStart=/usr/bin/python /srv/tasmota/fw_server/fw-server.py -d wlan0 Restart=on-failure [Install] WantedBy=multi-user.target - User rights: The files and directories have been created as `root` but this is not desirable. Invoke the following commands (replace the four instances of `XYZ` by your username): # chown -hR XYZ:XYZ /srv/tasmota # chown XYZ:XYZ /etc/systemd/system/tasmota.service - Run the service: # systemctl daemon-reload # systemctl enable tasmota.service # systemctl start tasmota.service ``` If the server is rebooted, the service will automatically restart. - Check that the service is active and running: # systemctl status tasmota.service - Test the server: Copy new firmware files to the /srv/tasmota/fw_server/fw folder. Ensure that they have XYZ user rights in a similar fashion as shown above. You can use scp or a samba share. Copy the firmware files into the folder ( firmware.bin in the example below). The service can be tested from any browser by issuing the address http://<ip_address>:5000/firmware.bin were <ip_address> is the address of the Linux server. If the web server becomes unresponsive: After a power failure, your wlan0 IP may resolve to an invalid value like 169.254.5.153 because your LAN gateway was not ready when the web server restarted. If you notice that the OTA mechanism is broken, try to download the file from a browser. If you can't, then restart the service and check the status. Log in using a terminal session and enter: $ sudo su # systemctl restart tasmota.service # systemctl status tasmota.service If you recognize the IP address of your server on the last line of the status output, the web server should be OK. You can confirm that your OTA web server is restored by trying to download a file using your web browser. PlatformIO: If you want PlatformIO to be able to upload your compiled binaries to the local server, you'll still have to setup ssh with ssh-keygen in order to use the Tasmota script pio/sftp-uploader.py without a password.","title":"Python HTTP OTA Server"},{"location":"Python-HTTP-OTA-Server/#introduction","text":"Tasmota firmware can be upgraded using 'Firmware Upgrade' option on the main menu and selecting an OTA URL to fetch (and flash) a new firmware on the device. To use this feature, firmware files need to be hosted on an HTTP web server (e.g., http://thehackbox.org/tasmota). Alternatively, users can to deploy a local HTTP server with Apache, Nginx, or other software solutions. Python makes available the Flask (micro)framework that can be used at different levels of complexity due to its modular architecture. A simple HTTP server (hello-world) can be deployed with only six lines of Python code. A Flask application to offer Tasmota firmware images for OTA upgrades is available as part of the available tools .","title":"Introduction"},{"location":"Python-HTTP-OTA-Server/#requirements","text":"Switching to superuser privileges and installing additional packages (and libraries) on a Linux/Windows box. Python3 (follow instruction related to your operating system) netifaces and Flask libraries - can be installed by 'pip' package manager: pip install netifaces flask","title":"Requirements"},{"location":"Python-HTTP-OTA-Server/#instructions","text":"Copy Tasmota firmware binary files in 'tools/fw' directory. A set of pre-built firmware binary files can be downloaded from the Tasmota repository . Configure your Tasmota device with your firmware server URL: Firmware Upgrade -> Upgrade by web server: http://<ip_address>:5000/tasmota.bin or use the following command: Backlog OTAURL http://<ip_address>:5000/tasmota.bin; Upgrade 1","title":"Instructions"},{"location":"Python-HTTP-OTA-Server/#usage","text":"To start Python HTTP server: python fw-server.py -d <net_iface> (default: eth0) or python fw-server.py -i <ip_address> Example: python fw-server.py -d wlan0 or python fw-server.py -i 192.168.1.1 Note: On Windows it is advisable to use '-i' option because Windows uses UUID naming for network interfaces that are difficult to enter.","title":"Usage"},{"location":"Python-HTTP-OTA-Server/#linux-server","text":"If your MQTT broker is hosted on a local server, you may want your firmware web server used for Tasmota OTA updates to reside on the same server. Follow these steps to create it as a service: - Copy the python script on the Linux server: $ sudo su # mkdir /srv/tasmota/fw_server/fw # cd /srv/tasmota/fw_server # wget https://github.com/arendst/Tasmota/tree/development/tools/fw_server/fw-server.py - Create a new file named tasmota.service in /etc/systemd/system/ and paste these lines (replace XYZ by your username): ``` [Unit] Description=Local OTA server for Tasmota Requires=network.target After=network.target multi-user.target [Service] User=XYZ Type=idle ExecStart=/usr/bin/python /srv/tasmota/fw_server/fw-server.py -d wlan0 Restart=on-failure [Install] WantedBy=multi-user.target - User rights: The files and directories have been created as `root` but this is not desirable. Invoke the following commands (replace the four instances of `XYZ` by your username): # chown -hR XYZ:XYZ /srv/tasmota # chown XYZ:XYZ /etc/systemd/system/tasmota.service - Run the service: # systemctl daemon-reload # systemctl enable tasmota.service # systemctl start tasmota.service ``` If the server is rebooted, the service will automatically restart. - Check that the service is active and running: # systemctl status tasmota.service - Test the server: Copy new firmware files to the /srv/tasmota/fw_server/fw folder. Ensure that they have XYZ user rights in a similar fashion as shown above. You can use scp or a samba share. Copy the firmware files into the folder ( firmware.bin in the example below). The service can be tested from any browser by issuing the address http://<ip_address>:5000/firmware.bin were <ip_address> is the address of the Linux server. If the web server becomes unresponsive: After a power failure, your wlan0 IP may resolve to an invalid value like 169.254.5.153 because your LAN gateway was not ready when the web server restarted. If you notice that the OTA mechanism is broken, try to download the file from a browser. If you can't, then restart the service and check the status. Log in using a terminal session and enter: $ sudo su # systemctl restart tasmota.service # systemctl status tasmota.service If you recognize the IP address of your server on the last line of the status output, the web server should be OK. You can confirm that your OTA web server is restored by trying to download a file using your web browser. PlatformIO: If you want PlatformIO to be able to upload your compiled binaries to the local server, you'll still have to setup ssh with ssh-keygen in order to use the Tasmota script pio/sftp-uploader.py without a password.","title":"Linux server:"},{"location":"RCWL-0516/","text":"RCWL-0516 microwave radar motion sensor module uses a \u201cmicrowave Doppler radar\u201d technique to detect moving objects. Its advantage over traditional PIRs is that it can detect presence through obstacles with a sensing distance of 3m average in real life conditions. Configuration ~ Wiring ~ RCWL-0516 ESP266 GND GND VIN 5V OUT GPIOx Tasmota Settings ~ In the Configuration -> Configure Module page assign: - GPIOx to Switch1 (9) A configured RCWL-0516 will not appear in the web UI, only the console displays the status of Switch1 as POWER . Continue to use RCWL-0516 just as any other PIR in Tasmota. Buy from AliExpress Features of RCWL-0516 RCWL-0516 Datasheet RCWL-0516 GitHub","title":"RCWL 0516"},{"location":"RCWL-0516/#configuration","text":"","title":"Configuration"},{"location":"RCWL-0516/#wiring","text":"RCWL-0516 ESP266 GND GND VIN 5V OUT GPIOx","title":"Wiring"},{"location":"RCWL-0516/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: - GPIOx to Switch1 (9) A configured RCWL-0516 will not appear in the web UI, only the console displays the status of Switch1 as POWER . Continue to use RCWL-0516 just as any other PIR in Tasmota. Buy from AliExpress Features of RCWL-0516 RCWL-0516 Datasheet RCWL-0516 GitHub","title":"Tasmota Settings"},{"location":"RDM6300/","text":"RDM6300 125KHz cardreader mini-module is designed for reading code from 125KHz card compatible read-only tags and read/write card. Configuration ~ Sensor uses serial interface for communication. Wiring ~ RDM6300 ESP8266 TX GPIOx RX GPIOy Pin3 unused GND GND VCC 5V Tasmota Settings ~ In the Configuration -> Configure Module page assign: 1. GPIOx to SerBr Tx (71) 2. GPIOy to SerBr Rx (72) If the RFID Tag is held in front of the Antenna the reader starts sending the Tag ID. The Tag Id is prefaced with a 0x02 and the end is delimited with a 0x03. If the reader reads the tag multiple times you would get one line with multiple times the Tag ID. For this to seperate you can add a SerialDelimiter of 0x03. This will split the result from the serial into serveral single mqtt messages. But (probably) all the messages wil be prepended with a binary 0x02. Set SerialDelimiter to 3 SerialDelimiter 3 OpenHab ~ sonoff-rfid.items: // tele/sonoff-rfid-1/RESULT {\"SSerialReceived\":\"01020304FAFA\"} String RFID_1 \"RFID [%s]\" {mqtt=\"<[broker:tele/sonoff-rfid-1/RESULT:state:JSONPATH($.SSerialReceived)]\"} Breakout Boards ~","title":"RDM6300"},{"location":"RDM6300/#configuration","text":"Sensor uses serial interface for communication.","title":"Configuration"},{"location":"RDM6300/#wiring","text":"RDM6300 ESP8266 TX GPIOx RX GPIOy Pin3 unused GND GND VCC 5V","title":"Wiring"},{"location":"RDM6300/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: 1. GPIOx to SerBr Tx (71) 2. GPIOy to SerBr Rx (72) If the RFID Tag is held in front of the Antenna the reader starts sending the Tag ID. The Tag Id is prefaced with a 0x02 and the end is delimited with a 0x03. If the reader reads the tag multiple times you would get one line with multiple times the Tag ID. For this to seperate you can add a SerialDelimiter of 0x03. This will split the result from the serial into serveral single mqtt messages. But (probably) all the messages wil be prepended with a binary 0x02. Set SerialDelimiter to 3 SerialDelimiter 3","title":"Tasmota Settings"},{"location":"RDM6300/#openhab","text":"sonoff-rfid.items: // tele/sonoff-rfid-1/RESULT {\"SSerialReceived\":\"01020304FAFA\"} String RFID_1 \"RFID [%s]\" {mqtt=\"<[broker:tele/sonoff-rfid-1/RESULT:state:JSONPATH($.SSerialReceived)]\"}","title":"OpenHab"},{"location":"RDM6300/#breakout-boards","text":"","title":"Breakout Boards"},{"location":"Receiving-Infrared-Remote-Control-Data/","text":"An inexpensive IR sensor such as a TSOP1838 can be connected to a device running Tasmota. Configure a free device GPIO as 'IRrecv (51)'. When Tasmota receives an IR message, the data portion of the payload has the same format as the IRsend parameter. {\"IrReceived\":{\"Protocol\":\" \",\"Bits\": ,\"Data\": }} This JSON payload data can be used in a rule such as: ON IrReceived#Data= DO ENDON If the data is received on an unknown protocol, setoption58 1 See here .","title":"Receiving Infrared Remote Control Data"},{"location":"Rule-Cookbook/","text":"","title":"Rule Cookbook"},{"location":"Rules/","text":"Rules expand the functionality of Tasmota with user configurable flexible logic Tasmota provides a Rule feature heavily inspired by the ESPEasy implementation while maintaining a small memory footprint. Automation solutions can be implemented without having to add dedicated code or use external solutions. Rules perform actions based on triggers (e.g., switch state change, temperature threshold, events like system boot, a defined timer elapsing, custom defined events, etc.) They are stored in flash and therefore will survive a reboot. Note Most pre-compiled builds have the Rules feature enabled. If you are >compiling your own firmware, in order to use rules, include #define USE_RULES in user_config_override.h . List of Rules Commands Rule Syntax ~ Rule definition statement ON <trigger> DO <command> [ENDON | BREAK] ON - marks the beginning of a rule definition <trigger> - what condition needs to occur for the rule to execute DO - what the rule is to perform if the <trigger> condition is met ENDON - marks the end of a rule. It can be followed by another rule. BREAK - marks the end of a rule. BREAK will stop the execution of the remaining rules that follow this rule within the rule set. If a rule that ends with BREAK is triggered, the following rules in that rule set will not be executed. This allows the rules to somewhat simulate an \"IF/ELSE\" statement. Rule sets are defined by using the Rule<x> command. After defining a rule set, you have to enable it (turn it on) using Rule<x> 1 . Similarly you can disable the rule set using Rule<x> 0 . There are three separate rule sets called Rule1 , Rule2 and Rule3 . Each rule set can contain as many rules as can fit within the 511 character limit. Whenever a rule set is enabled all the rules in it will be active. If the character count of the rules in the set exceed the limit, split the rules into another rule set. If you have a long list of rules, verify the rules have all fit by inspecting the resulting log. Rules inside a rule set Rule<x> are concatenated and entered as a single statement. Rule<x> ON <trigger1> DO <command> ENDON ON <trigger2> DO <command> ENDON ... Spaces after ON , around DO , and before ENDON or BREAK are mandatory. A rule is not case sensitive. Rule Trigger ~ A rule trigger can consist of: [TriggerName]#[ValueName] [TriggerName]#[ValueName][comparison][value] [SensorName]#[ValueName] [SensorName]#[ValueName][comparison][value] Tele-[SensorName]#[ValueName] A trigger may be used in more than one rule. This may be required for some cases of using IF/ELSE since an IF statement cannot be used within a Backlog . Rule Trigger Comparison Operators Operator Function = equal to (used for string comparison) == equal to (used for numerical comparison) > greater than < lesser than != not equal to >= greater than or equal to <= lesser than or equal to \\| used for modulo operation with remainder = 0 (exact division) Examples of Available Triggers Trigger When it occurs Analog#A0div10 when the A0 input changes by more than 1% it provides a value between 0 and 100 Button2#State when a button changes state: 0 = OFF 1 = ON 2 = TOGGLE 3 = HOLD Clock#Timer=3 when global Timer3 is activated Dimmer#Boot occurs after Tasmota starts Dimmer#State when the value for Dimmer is changed Event#eventName when command Event eventName is executed. You can define your own event values and trigger them with the Event command. FanSpeed#Data=3 when the fan speed is set to 3 Mem<x>#State when the value for Mem<x> is changed Http#Initialized Mqtt#Connected when MQTT is connected Mqtt#Disconnected when MQTT is disconnected Power1#Boot Relay1 state before Wi-Fi and MQTT are connected and before Time sync but after PowerOnState is executed. Power#Boot triggers before System#Boot. This trigger's value will be the last state of Relay1 if PowerOnState is set to its default value ( 3 ). Power1#State when a power output is changed use Power1#state=0 and Power1#state=1 for comparison, not =off or =on Power2 for Relay2, etc. Rules#Timer=1 when countdown RuleTimer1 expires Switch1#Boot occurs after Tasmota starts before it is initializated. Switch1#State when a switch changes to state use Switch1#state=0 and Switch1#state=1 for comparison, not =off or =on 0 = OFF 1 = ON 2 = TOGGLE 3 = HOLD ( SwitchTopic 0 must be set for this to trigger) 4 = INC_DEC (increment or decrement dimmer) 5 = INV (change from increment to decrement dimmer and vice versa) 6 = CLEAR (button released for the time set with SetOption32 ) System#Boot occurs once after Tasmota is fully intialized (after the INFO1, INFO2 and INFO3 console messages). System#Boot triggers after Wi-Fi and MQTT (if enabled) are connected. If you need a trigger prior to every service being initialized, use Power1#Boot System#Save executed just before a planned restart Time#Initialized once when NTP is initialized and time is in sync Time#Initialized>120 once, 120 seconds after NTP is initialized and time is in sync Time#Minute every minute Time#Minute|5 every five minutes Time#Minute=241 every day once at 04:01 (241 minutes after midnight) Time#Set every hour when NTP makes time in sync Var<x>#State when the value for Var<x> is changed (triggers whenever a value is written to Var<x> even if its the same value) Wifi#Connected when Wi-Fi is connected Wifi#Disconnected when Wi-Fi is disconnected Tele-Wifi1#AP when a teleperiod message is sent with the number of the used AP Tele-Wifi1#Ssid when a teleperiod message is sent with the name of the used AP Tele-Wifi1#Bssid when a teleperiod message is sent with the name of the bSSID Tele-Wifi1#Channel when a teleperiod message is sent with the number of the wifi channel used Tele-Wifi1#RSSI when a teleperiod message is sent with the RSSI LEVEL Tele-Wifi1#LinkCount when a teleperiod message is sent with the number of wifi disconnections Tele-Wifi1#Downtime when a teleperiod message is sent with the total seconds of wifi disconnections Every command with a JSON payload response has an associated rule trigger. Trigger When it occurs <command>#Data A one level JSON payload such as {\"command\":\"value\"} . For example, for {\"Fanspeed\":3}, the trigger is Fanspeed#Data . <command>#level1#level2#levelN A multi-level level JSON payload such as {\"level1\":{\"level2\":{\"levelN\":\"value\"}}} does NOT have the #Data trigger. Instead, the trigger for these responses is level1#level2#levelN . For example, for {\"PulseTime2\":{\"Set\":0,\"Remaining\":0}}, the triggers are PulseTime2#Set and PulseTime2#Remaining . Connected sensors can be a trigger in the form as they are represented in the TelePeriod and Status 8 JSON payloads. Trigger When it occurs DS18B20#Temperature whenever the temperature of sensor DS18B20 changes DS18B20#Temperature<20 whenever the temperature of sensor DS18B20 is below 20 degrees BME280#Humidity==55.5 whenever the humidity of sensor BEM280 equals 55.5% INA219#Current>0.100 whenever the current drawn is more than 0.1A Energy#Power>100 whenever the power used is more than 100W When the payload consists of an array of data eg: ENERGY\":{Current\":[1.320,2.100]} Trigger When it occurs Energy#Current[N] N = Number of the field. 1 for the first 1.320 , 2 for the second 2.100 etc. Energy#Current[1]>1.000 whenever the first value of Energy#Current is higher than 1.000. To trigger only at TelePeriod time, prefix the sensor with the word Tele- . Trigger When it occurs Tele-AM2301#Temperature sensor AM2301 Temperature value when the TelePeriod JSON payload is output Hardware and software serial interface, RF, IR and TuyaMCU are also supported based on their JSON status message: Trigger When it occurs TuyaReceived#Data=<hex_string> whenever <hex_string> is received with TuyaMCU component SerialReceived#Data=<string> whenever <string> is received via hardware serial SSerialReceived#Data=<string> whenever <string> is received via software serial IrReceived#Data=801 whenever an IR signal for a RC5 remote control button 1 is received IrReceived#Data=0x00FF9867 whenever an IR signal with hex code 0x00FF9867 is received RfReceived#RfKey=4 whenever the RF Bridge receives a recognized RfKey 4 signal RfReceived#Data=0xE8329E whenever an RF signal with hex code 0xE8329E is received Rule Command ~ A rule command can be any command listed in the Commands list . The command's <parameter> can be replaced with %value% which will use the value of the trigger. ON Switch1#State DO Power %value% ENDON To accomplish a rule with one trigger but several commands, you need to use Backlog : ON <trigger> DO Backlog <command1>; <command2>; <command3> ENDON Appending new rule onto an existing rule set Use the + character to append a new rule to the rule set. For example: Existing Rule1: ON Rules#Timer=1 DO Mem2 %time% ENDON Rule to append: ON Button1#state DO POWER TOGGLE ENDON Command: Rule1 + ON button1#state DO POWER TOGGLE ENDON Resulting in Rule1 ON Rules # Timer = 1 DO Mem2 % time % ENDON ON Button1 # state DO POWER TOGGLE ENDON You can duplicate the same trigger on many lines. Rule on power2 # state = 1 do power1 1 endon on power2 # state = 1 do RuleTimer1 100 endon Rule Variables ~ There are ten available variables (double precision reals) in Tasmota, Var1..Var5 and Mem1..Mem5 . All Var will be empty strings when the program starts. The value of all Mem persists after a reboot. They provide a means to store the trigger %value% to be used in any rule. The value of a Var<x> and Mem<x> can be: - any number - any text - %var1% to %var5% - %mem1% to %mem5% - %time% - %timestamp% - %uptime% - %sunrise% - %sunset% - %utctime% - %topic% To set the value for Var<x> and Mem<x> use the command - Var<x> <value> - Mem<x> <value> The <value> can also be the value of the trigger of the rule. - Set Var2 to the temperature of the AM2301 sensor - ON AM2301#Temperature DO Var2 %value% ENDON - Set Var4 to Var2's value - ON Event#temp DO Var4 %Var2% ENDON - Set Mem2 to the current time (minutes elapsed since midnight) - ON Rules#Timer=1 DO Mem2 %time% ENDON - After a Wi-Fi reconnect event, publish a payload containing timestamps of when Wi-Fi was disconnected in From: and when Wi-Fi re-connected in To: to stat/topic/BLACKOUT . haskell Rule1 ON wifi#disconnected DO Var1 %timestamp% ENDON ON wifi#connected DO Var2 %timestamp% ENDON ON mqtt#connected DO Publish stat/topic/BLACKOUT {\"From\":\"%Var1%\",\"To\":\"%Var2%\"} ENDON Delete rule To clear / delete use quote(s): Rule1 \" Conditional Rules ~ This feature is not included in precompiled binaries. To use it you must compile your build . Add the following to user_config_override.h : #define USE_EXPRESSION // Add support for expression evaluation in rules (+3k2 code, +64 bytes mem) #define SUPPORT_IF_STATEMENT // Add support for IF statement in rules (+4k2 code, -332 bytes mem) Major features Support IF, ELSEIF, ELSE Support for <comparison> and <logical expression> as condition Support for executing multiple commands Support for nested IF statements Available free RAM is the only limit for logical operators, parenthesis, and nested IF statements. Syntax <if-statement> IF (<logical-expression>) <statement-list> {ELSEIF (<logical-expression>) <statement-list>} [ELSE <statement-list>] ENDIF <logical-expression> <comparison-expression> ( <comparison-expression> | <logical-expression> ) {{ AND | OR } <logical-expression> } ( <logical-expression> ) { AND | OR } <logical expression> } <comparison-expression> <expression> { = | < | > | | | == | <= | >= | != } <expression> <statement-list> <statement> { ; <statement> } <statement> { <Tasmota-command> | <if-statement> } In English IF statement supports 3 formats: IF (<logical-expression>) <statement-list> ENDIF IF (<logical-expression>) <statement-list> ELSE <statement-list> ENDIF IF (<logical-expression>) <statement-list> [ELSEIF (<logical-expression>) <statement-list> ] ELSE <statement-list> ENDIF The outermost <if-statement> cannot be chained with other Tasmota commands in a Backlog . For example, Backlog Power1 0; IF var1==1 Power1 1 ENDIF , is NOT permitted. Commands chained with <if-statement> are allowed in a <statement-list> . For example, IF ENERGY#Current>10 Power1 0; IF var1==1 Power1 1 ENDIF ENDIF , is permitted. <logical-expression> Examples: - VAR1>=10 - Multiple comparison expressions with logical operator AND or OR between them. AND has higher priority than OR . For example: UPTIME>100 AND MEM1==1 OR MEM2==1 Parenthesis can be used to change the priority of logical expression. For example: UPTIME>100 AND (MEM1==1 OR MEM2==1) - The following variables can be used in <condition> : Symbol Description VAR<x> variable (<x> = 1..MAX_RULE_VARS , e.g., VAR2 ) MEM<x> persistent variable (<x> = 1..MAX_RULE_MEMS , e.g., MEM3 ) TIME minutes past midnight UPTIME uptime minutes UTCTIME UTC time, UNIX timestamp, seconds since 01/01/1970 LOCALTIME local time, UNIX timestamp SUNRISE current sunrise time (minutes past midnight) SUNSET current sunset time (minutes past midnight) <statement-list> - A Tasmota command (e.g., LedPower on ) - Another IF statement ( IF ... ENDIF ) - Multiple Tasmota commands or IF statements separated by ; . For example: Power1 off; LedPower on; IF (Mem1==0) Var1 Var1+1; Mem1 1 ENDIF; Delay 10; Power1 on Backlog is implied and is not required (saves rule set buffer space). But not like this: Power1 off; LedPower on; IF (Mem1==0) Var1 Var1+1; Mem1 1 ENDIF; Delay 10; Power1 on You should split it in two lines like: on power2#state=1 do Power1 off; LedPower on; endon on power2#state=1 do IF (Mem1==0) Var1 Var1+1; Mem1 1 ENDIF; Delay 10; Power1 on endon [!EXAMPLE] Rule used to control pressure cooker with a Sonoff S31. Once it is finished cooking, shut off the power immediately. Rule1 on system#boot do var1 0 endon on energy#power>100 do if (var1!=1) ruletimer1 0;var1 1 endif endon on tele-energy#power<50 do if (var1==1) var1 2;ruletimer1 600 endif endon on rules#timer=1 do backlog var1 0;power off endon Expressions in Rules ~ This feature is not included in precompiled binaries. To use it you must compile your build . Add the following to user_config_override.h : #define USE_EXPRESSION // Add support for expression evaluation in rules (+3k2 code, +64 bytes mem) #define SUPPORT_IF_STATEMENT // Add support for IF statement in rules (+4k2 code, -332 bytes mem) Beginning with Tasmota version 6.4.1.14, an optional feature for using mathematical expressions in rules was introduced. Supported Commands Once the feature is enabled, the use of expressions is supported in the following commands: Var Mem RuleTimer If conditional statement (requires #define SUPPORT_IF_STATEMENT ) Syntax Expressions can use of the following operators. They are listed by the order of operations priority, from higher to lower. ( ) (parentheses are used to explicitly control the order of operations) ^ (power) % (modulo, division by zero returns modulo \"0\") * and / (multiplication and division; division by zero returns \"0\") + and - (addition and subtraction) [!EXAMPLE] * 1+2*2 results in 5.0 as the multiplication is done first due to its higher priority * (1+2)*2 results in 6.0 In addition to numeric constants, the following symbolic values can be used: Symbol Description VAR<x> variable (<x> = 1..MAX_RULE_VARS , e.g., VAR2 ) MEM<x> persistent variable (<x> = 1..MAX_RULE_MEMS , e.g., MEM3 ) TIME minutes past midnight UPTIME uptime minutes UTCTIME UTC time, UNIX timestamp, seconds since 01/01/1970 LOCALTIME local time, UNIX timestamp SUNRISE current sunrise time (minutes past midnight) SUNSET current sunset time (minutes past midnight) [!EXAMPLE] Mem1=((0.5*Var1)+10)*0.7 To use expressions in the Var , Mem and RuleTimer commands, an equal sign ( = ) character has to be used after the command. If not, the traditional syntax interpretation is used. Statement Var1 Result Var1=42 42 Var1 1+1 \"1+1\" (the literal string) Var1=1+1 2 Var1=sunset-sunrise duration of daylight in minutes Rule Cookbook ~ Use long press action on a switch ~ [!NOTE] This example is for GPIOs defined as switches not buttons Activate long press action with Switchmode 5 and shorten long press time to 2 seconds ( Setoption32 20 ). Long pressing on switch1 sends POWER 2 (toggle action) command to the tasmota02 device Backlog SwitchMode 5; SetOption32 20 Rule on switch1#state=3 do publish cmnd/tasmota02/POWER 2 endon Rule 1 Notice we use Rule which edits Rule1 rule set. They can be used interchangeably. Execute any MQTT message when a button is pressed ~ When a button is pressed the user has the possibility to send a MQTT message based on FullTopic and ButtonTopic. This MQTT message is going to be received by the MQTT Broker and if there is any other device(s) subscripted to that Topic, it will receive also that message. So this approach can be used for sending messages/commands to MQTT Broker to Home Automation System, and/or sending messages/commands to MQTT Broker to other device(s). A problem with this solution is that on a Sonoff 4CH all four buttons will be sending the same MQTT topic using only a different Power index number like cmnd/ButtonTopic/power3 toggle . By using a rule a single button can now send any MQTT message allowing much more flexibility. Hardware - Sonoff 4CH Software - Tasmota compiled with #define USE_RULES - Disable ButtonTopic as it overrides rules for buttons: ButtonTopic 0 Rule Rule1 on button1#state do publish cmnd/ring2/power %value% endon on button2#state do publish cmnd/strip1/power %value% endon (You will likely need to enable this rule if it's the first time you've used them) \"Rule1 on\". Result - When button 1 is pressed the rule kicks in and sends a MQTT message substituting variable %value% with the button state like cmnd/ring2/power 2 . When button 2 is pressed a MQTT message like cmnd/strip1/power 2 will be sent. Execute several commands when a Timer expires ~ The default Timer1..16 functionality allows for controlling one output to either off, on, toggle or blink. When rules are enabled the blink option will be replaced by rule functionality allowing much more flexibility. Hardware - Sonoff 4CH Software - Tasmota compiled with #define USE_RULES - Configure timer5 for rule execution when activated: console Timer5 {\"Arm\":1,\"Mode\":0,\"Time\":\"16:00\",\"Days\":\"1111111\",\"Repeat\":1,\"Action\":3} - Rule console Rule1 on clock#Timer=5 do backlog power2 on;power1 off;power3 2 endon Result - When the timer expires the rule kicks in and set Power1 to OFF, Power2 to ON and Toggles Power3 If you want to have blink functionality define a rule like on clock#Timer=5 do power 3 endon Usage of one-shot (once) ~ The rule command once option provides the possibility to trigger only once on a slow change while the change is still within the bounds of the test. Rule on ENERGY#Current>0.100 do publish tool/tablesaw/power 1 endon on ENERGY#Current<0.100 do publish tool/tablesaw/power 0 endon This creates a rule to publish MQTT commands whenever a Sonoff POW has current passing through it. Used as is, it will publish MQTT commands repeatedly, over and over, while current is >0.100 ... but, executing another command: Rule 5 Now the MQTT message will be sent once, and only once, while the condition is met. This is perfect for thermostat on/off depending on temperature, bathroom extractor fan on/off depending on humidity, workshop dust collector on/off depending on whether some dust-producing machine is running. It meets the 'hard thermostat' requests that have been common. Use of variables and tele- ~ Using variables allows for storing sensor results to be used in composing a single HA message like used with Domoticz. To prevent flooding Domoticz with messages we only want to send a message at TelePeriod time. This is achieved by prefixing the <SensorName> with the label tele- . This example will use a variable storing the temperature to be used together with humidity in one Domoticz MQTT message. Hardware - Sonoff TH or Wemos D1 mini - AM2301 Temperature and Humidity sensor Software - Tasmota compiled with #define USE_RULES - Home Automation tool Domoticz configured with a virtual sensor Temp+Hum using Idx 134 Rule Rule on tele-am2301-12#temperature do var1 %value% endon on tele-am2301-12#humidity do publish domoticz/in {\"idx\":134,\"svalue\":\"%var1%;%value%;1\"} endon Result - As a result of the tele- prefix the rules will be checked at TelePeriod time for sensor AM2301-12 Temperature and Humidity. The first rule will use the Temperature stored in %value% and save it in %var1% for future use. The second rule will use the Humidity stored in %value% and the Temperature stored in %var1% to compose a single MQTT message suitable for Domoticz. Clever Dickies now finally have a way to send Temperatures from multiple DS18B20 to Domoticz. Use a potentiometer ~ Connecting a potentiometer to the Analog A0 input and a rule can be used to control the dimmer state of any device. Hardware - Wemos D1 mini - Potentiometer of 2k2 connected to Gnd, A0 and 3V3 - WS2812 LED Software - Tasmota compiled with #define USE_RULES Rule on analog#a0div10 do dimmer %value% endon Result - Turning the potentiometer the voltage on the analog input will change resulting in a value change of 0 (Off) to 100 for the trigger. Using this value to control the dimmer of the WS2812 will control the brightness of the led(s) Rule on analog#a0div10 do publish cmnd/grouplight/dimmer %value% endon Result - This time all lights configured with GroupTopic grouplight will change their brightness according to the potentiometer position. NOTE: You might want to execute command SaveData 2 to reduce flash writes ;-) Setting variables ~ Demonstrate the use of variables. Make sure to execute commands Rule 4 (Disable one-shot detection) first when trying the following example. Set a variable Rule on event#setvar1 do var1 %value% endon Command: event setvar1=1 View a variable rule on event#getvar1 do var1 endon Command: event getvar1 Toggle a variable Rule on event#togglevar1 do event toggling1=%var1% endon on event#toggling1<1 do event setvar1=1 endon on event#toggling1>0 do event setvar1=0 endon on event#setvar1 do var1 %value% endon ``` Command: `event togglevar1` Show Messages: ```console Rule on event#message do publish stat/[topic]/log %value% endon Command: event message=INIT All event commands can be executed from: console: event anyname=number mqtt: cmnd/[topic]/event anyname=number Everything together: Rule1 on event#togglevar1 do event toggling1=%var1% endon on event#toggling1<1 do event setvar1=1 endon on event#toggling1>0 do event setvar1=0 endon on event#setvar1 do var1 %value% endon on event#getvar1 do var1 endon on event#message do publish stat/mqttTopic/log %value% endon [!NOTE] The following won't work: Rule1 on event#setvar1 do backlog var1 %value%; power1 %var1% endon At least not as you probably would expect. The var1 value used by the power1 command will be the value present before the backlog command is executed. This is so, because the rule will replace %var1% BEFORE the backlog commands are put in the backlog command stream. Control device LEDs with Relays ~ If a device has more than one relay and LEDs on different GPIOs (not connected to the relay) you need to use rules to display current relay status on LEDs. This example is a 3 gang wall switch. Instead of LEDs you need to assign 3 dummy relays that will be controlled when the real relays are switched to reflect their status. Backlog ledmask 0x0000; setoption13 1; seriallog 0 rule1 on power1#state do power4 %value% endon on power2#state do power5 %value% endon on power3#state do power6 %value% endon rule1 1 Note: This method doubles the number of flash writes. Link to the device Thermostat Example ~ As example, to be used on a Sonoff TH10 with Sensor Si7021 This example turn on and off an output based on the temperature value and the upper set point and the lower set point. It waits until is enabled by pressing the button or by mqtt message 1 to mem1. This value is remembered. So if power cycle occurs, will resume operation. The set point values can be changed on the fly by mqtt or console commands If the Temperature sensor disconnects, the outputs will shutdown until the sensor is back again and will resume operation. When the device is power up, the thermostat also waits until the sensor value to resume operation. Initial Config: Available physical button as switch1 Relay1 will be used the controller Rules must be used to control Relay so the pushbutton must only control switch1 and not directly control the relay - For this we use SwitchMode1 3 as described below and create the necessary rules because the pushbutton control of the relay is only disabled when the rules are in place. Initial config on console: SwitchMode1 3 <- Use the switch1 as pushbutton (It will allow us to disable the link between the button and the relay by inserting a rule to dictate what the pushbutton will do - NOTE: Until rules are created the pushbutton will still control the relay! ) Rule1 1 <- turn on rules Rule1 4 <- turn off one-shot rule TelePeriod 60 <- check temp every minute SetOption26 1 <- use power1 on mqtt messages SetOption0 0 <- dont save relay status on eeprom PowerOnState 0 <- start all relays off Mem1 0 <- thermostat status: 0-off 1-enabled - View or set by MQTT cmnd/mqttTopic/mem1 Mem2 25 <- setpoint Temp upper limit - View or set by MQTT cmnd/mqttTopic/mem2 Mem3 23 <- setpoint Temp lower limit - View or set by MQTT cmnd/mqttTopic/mem3 Var1 0 <- thermostat actual status: 1-OK 0-NOT READY - View by MQTT cmnd/mqttTopic/var1 Rules: On boot start a watchdog timer to check temp sensor connection. Rule on system#boot do RuleTimer1 70 endon An available button is configured as switch to set thermostat ON or OFF Rule1 on switch1#state do backlog event toggling1=%mem1% endon on event#toggling1=0 do mem1 1 endon on event#toggling1=1 do mem1 0 endon Check temp sensor connection. If fails, set to off and turn off thermostat. Also continue checking Rule on Rules#Timer=1 do backlog var1 0; RuleTimer1 70; power1 0 endon Resets checking timer if temperature is connected Rule on tele-SI7021#temperature do backlog var1 1; RuleTimer1 30; event ctrl_ready=1; event temp_demand=%value% endon Thermostat control - upper limit and lower limit and enabled Rule1 on event#ctrl_ready>%mem1% do var1 0 endon on event#temp_demand>%mem2% do power1 0 endon on event#temp_demand<%mem3% do power1 %var1% endon Thermostat can be turned On by: * pushing button * by command on local console: mem1 1 * by command on any other console: publish cmnd/mqttTopic/mem1 1 * or MQTT at: cmnd/mqttTopic/mem1 1 Thermostat can be turned Off by: * pushing button * by command on local console: mem1 0 * by command on any other console: publish cmnd/mqttTopic/mem1 0 * or MQTT at: cmnd/mqttTopic/mem1 0 To get the status: * mem1 <- thermostat status: 0-off 1-enabled - View or set by MQTT cmnd/mqttTopic/mem1 * mem2 <- setpoint Temp upper limit - View or set by MQTT cmnd/mqttTopic/mem2 * mem3 <- setpoint Temp lower limit - View or set by MQTT cmnd/mqttTopic/mem3 * var1 <- thermostat actual status: 1-OK 0-NOT READY - View by MQTT cmnd/mqttTopic/var1 Everything together: INITIAL CONFIG: (Note: RuleTimer1 must be greater that TelePeriod for expected results) backlog SwitchMode1 3; Rule 1; Rule 4; TelePeriod 60; SetOption26 1; SetOption0 0; poweronstate 0; mem1 0; mem2 25; mem3 23; var1 0 RULES: Rule1 on system#boot do RuleTimer1 70 endon on Switch1#State do event toggling1=%mem1% endon on event#toggling1=0 do mem1 1 endon on event#toggling1=1 do mem1 0 endon on Rules#Timer=1 do backlog var1 0; RuleTimer1 70; power1 0 endon on tele-SI7021#temperature do backlog var1 1; RuleTimer1 70; event ctrl_ready=1; event temp_demand=%value% endon on event#ctrl_ready>%mem1% do var1 0 endon on event#temp_demand>%mem2% do power1 0 endon on event#temp_demand<%mem3% do power1 %var1% endon EXAMPLE RULES WITHOUT TEMP SENSOR TO TEST THE THERMOSTAT RULES Rule1 on system#boot do RuleTimer1 70 endon on Switch1#State do event toggling1=%mem1% endon on event#toggling1=0 do mem1 1 endon on event#toggling1=1 do mem1 0 endon on Rules#Timer=1 do backlog var1 0; RuleTimer1 70; power1 0 endon on event#temp do backlog var1 1; RuleTimer1 70; event ctrl_ready=1; event temp_demand=%value% endon on event#ctrl_ready>%mem1% do var1 0 endon on event#temp_demand>%mem2% do power1 0 endon on event#temp_demand<%mem3% do power1 %var1% endon TESTS: * Push the button1. The thermostat changes to ENABLED (mem1=1) * on console: event temp=20 (now the system receives like a tele message from temperature sensor) and will turn on the relay1 (to heat) * on console: event temp=26 (the thermostat turn off the heater) * on console: event temp=22 (the thermostat turn on the heater) * wait more than a minute without using the event temp and the thermostat will turn off as there is no temperature value (like a sensor error or disconnection) * will resume when using again the event temp * console mem1 0, DISABLED, console mem1 1, ENABLED TIMERS: * With the above the timers can be used to control mem1 and add a schedule to when the thermostat will be enabled Rule2 on Clock#Timer=1 do mem1 1 endon on Clock#Timer=2 do mem1 0 endon Solar heater control ~ In a swimming pool, a filter pump and a solar panel is installed. When the sun is shining, the pump should push water through the solar panel, to heat the pool. When it's night or cloudy, the pump should be off, to avoid cooling the pool water through the solar panel. The pump is controlled by a Sonoff TH10 with 2x DS18B20 sensors connected. 3 rules: Pump should start when solar panel is more than 2 deg warmer than the pool water Pump should stop when solar panel is less than 1 deg warmer than the pool water Pump should not start if the solar panel is below 25 deg Celsius. t1 : pool temp t2 : panel temp var1 : in valid panel temp range? var2 : off threshold temp for panel var3 : on threshold temp for panel mem3 : lowest valid panel temp mem3 25 rule1 on DS18B20-1#temperature do event t1=%value% endon on DS18B20-2#temperature do event t2=%value% endon on event#t2>%mem3% do var1 1; endon on event#t2<=%mem3% do var1 0; endon on event#t1 do backlog var2 %value%; add2 1; endon on event#t1 do backlog var3 %value%; add3 2; endon on event#t2>%var3% do power1 %var1%; endon on event#t2<%var2% do power1 0; endon rule1 1 To test the rule without having the sensors in place, simply enter the events for t1 and t2 in the console: Backlog event t1=21;event t2=30 And watch the relay turn on and off based on the values. Please note that this example does not support manual override or handle missing sensor data. Take a look at Thermostat Example for examples. Energy Saving Smart Switch ~ Example of a switch controlling a light with a condition of a required amount of lux. When the switch is on, the light will turn on but only when you have less than 100 lux in that room. While if the switch is off the light will be off. Rule1 on switch1#state=1 do var1 100 endon on switch1#state=0 do backlog var1 0; power1 off endon on APDS9960#Ambient<%var1% do power1 on endon All together to work as a rule: Rule 1 Rule1 on switch1#state=1 do var1 100 endon on switch1#state=0 do backlog var1 0; power1 off endon on APDS9960#Ambient<%var1% do power1 on endon Time-delayed Auto-off Switch ~ Rule: Rule1 on button1#state do backlog power1 %value%; RuleTimer1 600 endon on Rules#Timer=1 do power1 off endon Result: on button1#state do backlog power1 %value%; On Button press the Light will toggle on/off RuleTimer1 600 endon Additionally RuleTimer1 will begin to countdown 10 minutes on Rules#Timer=1 do power1 off endon After the RuleTimer1 expires the light will be turned off (if you forgot to turn it off) Time-delay After Switch Off ~ Rule1 on switch1#state=1 do backlog power1 on; ruletimer1 0 endon on switch1#state=0 do ruletimer1 300 endon on rules#timer=1 do power1 0 endon backlog switchmode1 1; rule1 1 Legend: ruletimer1 300 sets a 5 minute timer. After that time, fan will be switched off. If during the defined 5 minutes (or in general - when timer is counting) you the switch on, the timer will be canceled. switchmode1 1 sets the switch in follow mode (LOW=off, HIGH=on) If you have inverted switch (LOW=on, HIGH=off) then use switchmode1 2 Auto-off Motion Sense Switch ~ Example works fine on a Wemos D1 Mini. Used as night light with motion sensor or as ambient light on floor or kitchen. I connect an LED Strip WS2812 on D1 and the PIR on D2 and a LDR on A0 (voltage divider with 10k ohm resistor) PIR example: HR-SC501 The Settings are: 18 Generic D1 WS2812 D2 Switch1 LDR on Wemos A0 (activated in user_config_override.h) and type the following statements in the Console: Rules: SwitchMode1 1 Rule1 on analog#a0<400 do backlog Rule3 0; Rule2 1 endon on analog#a0>500 do backlog Rule2 0; Rule3 1 endon Rule2 on switch1#state do backlog power1 1; RuleTimer1 30 endon on Rules#Timer=1 do power1 off endon Rule3 on switch1#state do power1 off endon Activate Rule1 with one shot detection Backlog Rule1 1; Rule1 6 Optional Backlog Rule2 4; Rule3 4 Result: * on analog#a0>400 disable Rule3 and activate Rule2 * on analog#a0>500 disable Rule2 and activate Rule3 * Rule2 activates the LEDs for RuleTimer1 30 seconds on each trigger from PIR the RuleTimer start again. on Rules#Timer=1 do power1 off The LEDs turn off after the RuleTimer expires * Rule3 is active on daylight and pipe the PIR signal in a power1 off signal. The LEDs stay off. Controlling Timers Enabled from a Switch ~ Assuming that your switch is on GPIO00 and configured as Switch1 : SwitchMode1 1 Rule1 on Switch1#state=1 do Timers 0 endon on Switch1#state=0 do Timers 1 endon Rule1 1 Switchmode1 1 will make Switch1#state be 1 when ON and 0 when OFF If you don't set Switchmode1 or it is equal 0, it will only have Switch1#state=2 (toggle) and the previous rule will not work. Toggle a Relay only when holding the button for 2 seconds ~ The following example is to explain how to catch and use the HOLD feature for buttons. Behavior: Disable Button1 Short Press and Toggle Relay1 only when holding button1 for 2 Seconds. Type in the console: Backlog ButtonTopic 0; SetOption1 1; SetOption32 20 Rule1 on button1#state=3 do power1 2 endon on button1#state=2 do delay endon Rule1 1 Commands Explanation ButtonTopic 0 : (default) To not use topics for buttons SetOption1 1 : Allow only single, double and hold press button actions SetOption32 20 : Set key hold time from 0.1 to 10 seconds (20 = 2 seconds) Rule on button1#state=3 do power1 2 endon : When holding the button1 for 2 seconds it will toggle relay 1 (state = 3 means HOLD) on button1#state=2 do delay endon : Do nothing when short pressing the button1 (state = 2 means TOGGLE) Rule1 1 : To enable rules NOTE: There is no state value for \"double press\" for Buttons. It is designed that double press will toggle the relay. See Multi-Press Functions for more information. In the case you do not want the double press feature you can configure your button as switch and also set SwitchMode that fits your use case (such as SwitchMode 5 to make the switch behave like a pushbutton) [SWITCH does not support double press] Another example but using switch instead of button: Backlog SwitchTopic1 0; SwitchMode1 5; SetOption32 20 Rule1 on switch1#state=3 do power1 2 endon on switch1#state=2 do delay endon Rule1 1 Make Sure Light is on at Night ~ Using Timers, you can set a light to turn on and off to illuminate a street/patio by night. But if the device has no power at the trigger time, then, when it powers up, the light will be off all night. So, as a fail-safe, implement a conditional control to be checked at Tasmota Startup. Set Timers to turn on your light at Sunset and Turn off at sunrise. Use poweronstate 0 in order to start with lights off when powering up your device. Set the following rules: Rule1 on Time#Initialized do backlog event checksunrise=%time%; event checksunset=%time% endon on event#checksunset>%sunset% do power1 1 endon on event#checksunrise<%sunrise% do power1 1 endon The previous rules are conditionals that represent the following logic: IF %time%>%sunset DO power1 1 / IF %time%<%sunrise DO power1 1 Turn On Light Before Dawn and At Dusk ~ Turn on light at dusk until your nighttime and again in the morning before dawn. What if the sun sets after your nighttime, as in during the summer? Then the timer will turn off the light at \"night\", but then the Sunset timer will turn it on again, so it stays on all night. Rule1 on Time#Initialized do event chkSun endon on Time#Minute=%sunset% do event chkSun endon on Time#Minute=%mem2% do event chkSun endon on Time#Minute=%sunrise% do event chkSun endon on Time#Minute=%mem1% do event chkSun endon Rule2 on event#chkSun do backlog var1 0; event chkSunrise=%time%; event chkSunset=%time%; event chkmorn=%time%; event chknight=%time%; event setPower endon on event#chkSunrise<%sunrise% do var1 1 endon on event#chkSunset>=%sunset% do var1 1 endon on event#chkmorn<%mem1% do var1 0 endon on event#chknight>=%mem2% do var1 0 endon on event#setPower do power1 %var1% endon Backlog mem1 360; mem2 1350 Backlog Rule1 1; Rule2 1 Explanation: - When device restarts, calculate if the light should be on or off on Time#Initialized do event chkSun endon Calculate if the light should be on or off on Time#Minute=%sunset% do event chkSun endon on Time#Minute=%mem2% do event chkSun endon on Time#Minute=%sunrise% do event chkSun endon on Time#Minute=%mem1% do event chkSun endon Calculate if the light should be on or off on event#chkSun do backlog Assume off var1 0; Trigger each event with the current time event chkSunrise=%time%; event chkSunset=%time%; event chkmorn=%time%; event chknight=%time%; event setPower End rule endon If before sunrise, turn on on event#chkSunrise<%sunrise% do var1 1 endon If past sunset, turn on on event#chkSunset>=%sunset% do var1 1 endon But if before Morning time ( mem1 ), do not turn on on event#chkmorn<%mem1% do var1 0 endon Or if after Night time ( mem2 ), do not turn on on event#chknight>=%mem2% do var1 0 endon Perform on/off state on event#setPower do power1 %var1% endon Set variables for Morning (06h00) and Night (22h30) times Backlog mem1 360; mem2 1350 Turn on the rule sets Backlog Rule1 1; Rule2 1 Enable a PIR Switch only at night ~ PreInfo: - PIR HC-SR501 - GPIO14 09 Switch1 (Sonoff Basic) - Jumper outside ( like this ) - Lat and Lng set in config Commands: SwitchMode1 1 Rule1 on Switch1#state=1 do backlog event checksunrise=%time%; event checksunset=%time% endon on event#checksunrise<%sunrise% do power1 1 endon on event#checksunset>%sunset% do power1 1 endon Rule1 1 Using Clock Timer to control a Luminance triggered switch (only in mornings) ~ Background: Tasmota powers a Sonoff Basic attached to a TS-2561 Luminance Sensor. This switch toggles a lamp ON or OFF. The switch should work as below: i) during daytime (sunrise-sunset): ON when it is too dark (<150 lx) and OFF when it gets brighter (>175 lx). ii) during evenings it ignores the sensor and turns on at sunset and turns off after about 5 hours Approach: Used a combination of Clock Timers and Rule to do this. Timer 1: Power ON switch at Sunset Powers on the switch at sunset with an offset of 20 minutes. Repeats every day. Timer1 {\"Arm\":1,\"Mode\":2,\"Time\":\"-00:20\",\"Window\":0,\"Days\":\"1111111\",\"Repeat\":1,\"Output\":1,\"Action\":1} Timer 2: Power OFF switch at Night. Turns power OFF at 23.00hrs. Repeats every day. Timer2 {\"Arm\":1,\"Mode\":0,\"Time\":\"23:00\",\"Window\":0,\"Days\":\"1111111\",\"Repeat\":1,\"Output\":1,\"Action\":0} Timer 3: Trigger Luminance Rule at Sunrise Start watching the Lux sensor 15 minutes after sunrise. Timer3 {\"Arm\":1,\"Mode\":1,\"Time\":\"00:15\",\"Window\":0,\"Days\":\"1111111\",\"Repeat\":1,\"Output\":1,\"Action\":3} Rule 1: Main Rule to check Luminance If Luminance is less than 150lx, power ON. If it goes beyond 175lx, power OFF. Rule1 on tele-TSL2561#Illuminance<150 do power1 1 endon on tele-TSL2561#Illuminance>175 do power1 0 endon Rule1 1 Rule 2: Trigger Rule1 only in the Mornings This ensures that Rule1 is triggered when Timer3 starts (in the morning) and stops when Timer1 starts (in the evenings). Rule2 on Clock#Timer=3 do Rule1 1 endon on Clock#Timer=4 do Rule1 0 endon Rule2 1 Button with single press, double press, and hold ~ You can have all 3 actions but only if defining your GPIO as button. In this case the double press will toggle the relay. There is also an option to swap the actions of the single press and double press . BUTTON WITH 3 DIFFERENT ACTIONS As an example: [assuming Button1] single press : Turn relay 1 double press : send a mqtt message hold 2 secs : send another mqtt message ```console Backlog ButtonTopic 0; SetOption1 1; SetOption11 1; SetOption32 20 Rule1 on button1#state=3 do publish cmnd/topicHOLD/power 2 endon on button1#state=2 do publish cmnd/topicDOUBLEPRESS/power 2 endon Rule1 1 ``` Another example: [assuming Button1] single press : send a mqtt message double press : Turn relay 1 hold 2 secs : send another mqtt message ```console Backlog ButtonTopic 0; SetOption1 1; SetOption11 0; SetOption32 20 Rule1 on button1#state=3 do publish cmnd/topicHOLD/power 2 endon on button1#state=2 do publish cmnd/topicSINGLEPRESS/power 2 endon Rule1 1 ``` Note: SetOption11 0 SWITCHES WITH 2 DIFFERENT ACTIONS Switches do not have double press feature Example: [assuming a connected pushbutton configured as Switch1] single press : Do nothing hold 2 secs : Toggle relay 1 ```console Backlog SwitchTopic1 0; SwitchMode1 5; SetOption32 20 Rule1 on Switch1#State=3 do Power1 2 endon on Switch1#State=2 do Delay endon Rule1 1 ``` Perform any action on single/double press (for switches AND buttons) ~ SwitchMode 5 Rule1 on switch1#state==2 do add1 1 endon on switch1#state==2 do power1 2 endon on var1#state!=0 do backlog delay 6;var1 0 endon on var1#state==2 do publish cmnd/othertasmota/POWER toggle endon Rule1 on Explanation: - each toggle of the switch triggers first condition and adds 1 to our variable (var1 in the example), - each toggle of the switch toggles the associated relay ( Power1 2 - but can do anything else instead, Publish for example) - when var1 changes to non zero, we set it back to 0 but after a Delay (arbitrarily chosen 6 here - 0.6 seconds) - when var1 reaches 2 (i.e. the switch has been toggled twice within the last 0.6 seconds), desired action is triggered (here: Publish to othertasmota ) Result: Every time you press the switch, your light toggles state (as it should). If you do press the switch twice in a rapid succession (i.e., double-click), you can trigger a different action (e.g., on a remote device). External switch to enable or disable doorbell relay with HTTP call ~ When you want to send MQTT messages ( we use domoticz in this example ) and choose when you want the relay on or off, by simply sending HTTP commands to trigger an event. Initial Config: - PushButton Doorbell - (Sonoff Basic R1) GPIO14 - Switch4 (12) Connect the Switch to GND and the GPIO on your device. Be sure put a 4.7k resistor between VCC(3.3v) and the GPIO. This prevents ghost switching (capacitor is optional) See: YouTube Dont forget to change the IDX value Commands: Backlog SwitchTopic 0; SwitchMode4 2; SetOption0 0; PowerOnState 0 var1 1 Rule1 on event#doorbell do var1 %value% endon on switch4#state=1 do publish domoticz/in {\"idx\":11,\"nvalue\":1} endon on switch4#state=1 do power1 %var1% endon on switch4#state=0 do publish domoticz/in {\"idx\":11,\"nvalue\":0} endon on switch4#state=0 do power1 0 endon Rule1 1 Usage: Turn off the relay by calling the event using HTTP: http://<tasmotaIP>/cm?cmnd=event%20doorbell=0 Turn on the relay by calling the event using HTTP: http://<tasmotaIP>/cm?cmnd=event%20doorbell=1 If your Tasmota device is password protected, which is most common, then use the following HTTP commands instead. Make sure you change <tasmotaUsername> and <tasmotaPassword> Off: http://<tasmotaIP>/cm?&user=<tasmotaUsername>&password=<tasmotaPassword>&cmnd=event%20doorbell=0 On: http://<tasmotaIP>/cm?&user=<tasmotaUsername>&password=<tasmotaPassword>&cmnd=event%20doorbell=1 Force automatic re-connection to MQTT server via SD DNS ~ In order to search for the MQTT server using SD-DNS service (a.k.a. Bonjour or Zero Network Configuration) the suggested configuration is to leave the MQTT Host field blank. The standard behavior of Tasmota is - searches for _mqtt._tcp service - resolve that to the proper IP address - connect to it - in case the connection is successful, retain the IP address and use that in the subsequent connections The above is not proper, though, in case you have a redundant MQTT (e.g., two MQTT server synchronized). In such case, when the active MQTT fails for any reason, the expected behavior is to achieve automatic re-connection to the other MQTT server. That can be easily configured defining the following rule on the device console: Rule1 on Mqtt#Disconnected do MqttHost 0 endon Rule1 1 If the MqttHost field already contains an IP, you have to delete it using the web interface or the following MQTT command: mosquitto_pub -h mqtt_server.local -t \"cmnd/mqttTopic/MqttHost\" -m '' Change distance to percentage ~ When measuring distance and you have the need to see it in percentage of distance. In the example 100% is everything below 69cm and 0% is everything above 128cm. This is used for showing fill percentage of a wood pellets storage. Rule1 on tele-SR04#distance do backlog var1 %value%; event checklimit=%value%; event senddistance endon on event#checklimit>128 do var1 128 endon on event#checklimit<69 do var1 68 endon on event#senddistance do backlog SCALE1 %var1%, 128, 69, 0, 100; event pubdata endon on event#pubdata do publish tele/pannrum-temp/SENSOR %var1% endon Rule1 1 Distinguish Switch1 and Switch2 (without the use of Relay1 and Relay2) ~ When two (or more) switches are defined as input and you want to distinguish these in the RESULT topic without the use of Relays, then consider the following rules. SwitchMode1 1 will make Switch1#state to be 1 when ON and 0 when OFF SwitchMode1 1 SwitchMode2 1 will make Switch2#state to be 1 when ON and 0 when OFF SwitchMode2 1 Publish json with key POWER1 and value %value% Rule1 on switch1#state do publish stat/wemos-4/RESULT {\"POWER1\":\"%value%\"} endon Publish json with key POWER2 and value %value% Rule2 on switch2#state do publish stat/wemos-4/RESULT {\"POWER2\":\"%value%\"} endon Enable Rule1 Rule1 1 Enable Rule2 Rule2 1 Output: RUL : SWITCH1 # STATE performs \"publish stat/wemos-4/RESULT {\" POWER1 \":\" 1 \"}\" MQT : stat /wemos-4/ RESULT = { \"POWER1\" : \"1\" } RUL : SWITCH2 # STATE performs \"publish stat/wemos-4/RESULT {\" POWER2 \":\" 1 \"}\" MQT : stat /wemos-4/ RESULT = { \"POWER2\" : \"1\" } RUL : SWITCH1 # STATE performs \"publish stat/wemos-4/RESULT {\" POWER1 \":\" 0 \"}\" MQT : stat /wemos-4/ RESULT = { \"POWER1\" : \"0\" } RUL : SWITCH2 # STATE performs \"publish stat/wemos-4/RESULT {\" POWER2 \":\" 0 \"}\" MQT : stat /wemos-4/ RESULT = { \"POWER2\" : \"0\" } RUL : SWITCH1 # STATE performs \"publish stat/wemos-4/RESULT {\" POWER1 \":\" 1 \"}\" MQT : stat /wemos-4/ RESULT = { \"POWER1\" : \"1\" } RUL : SWITCH1 # STATE performs \"publish stat/wemos-4/RESULT {\" POWER1 \":\" 0 \"}\" MQT : stat /wemos-4/ RESULT = { \"POWER1\" : \"0\" } Receiving state of anything that triggers SWITCH more than one time ~ With analog intercom doorbells you can take out info about ringing from speaker voltage. You can connect GPIO to it via opto-isolator and resistor to take out state. But even with those speaker voltage is dropping so it switches the device multiple times. MQT : cmnd /doorbell/ POWER2 = OFF ( retained ) MQT : cmnd /doorbell/ POWER2 = ON ( retained ) MQT : cmnd /doorbell/ POWER2 = OFF ( retained ) MQT : cmnd /doorbell/ POWER2 = ON ( retained ) MQT : cmnd /doorbell/ POWER2 = OFF ( retained ) To solve it we can use rules. SwitchTopic 0 Rule1 on System#Boot var1 0 endon on Switch2#State do backlog add1 1; event START endon on event#START do event BELL=%var1% endon on event#BELL=1.000 do backlog publish cmnd/bell/power on; RuleTimer1 60 endon on event#BELL=0 do publish cmnd/bell/power off endon on Rules#Timer=1 do backlog var1 0; event BELL=0 endon Rule1 1 description: - turn off switchtopic as it is necessary to trigger Switch2#state - on system boot set var1 to 0 - on switch2 click (person pushing doorbell) - var1 += 1; trigger event START - on START - set event BELL equal to var1 - if event#BELL=1 (triggered first time) publish mqtt message ON and trigger RulesTimer1 for 60 seconds - if event#BELL=0 publish mqtt message OFF - on RulesTimer1 - reset var1 to 0, and call event#BELL. - enable rule 1 In this case we have lock for 60 seconds for multiple people calls or to be resistant for speaker voltage drops. Prevent Wemos D1 mini load overcurrent ~ As a WS2812 24 led ring draws approximately 24x3x20 mA = 1.44A and the Wemos D1 mini powered from a PC's USB port can only provide up to 0.5A it would be nice to have some kind of mechanism in place to limit the amount of current to the WS2812 LEDring to 0.1A. This is still enough to light all 24 leds up to color 202020. Hardware - Wemos D1 mini - INA219 I 2 C sensor - WS2812 LEDring with 24 LEDs powered by the Wemos D1 mini 5V thru the INA219 sensor Rule1 on INA219#Current>0.100 do Backlog Dimmer 10;Color 10,0,0 endon Rule1 on Result - When a user raises brightness to a level using more than 0.1A the rule kicks in and lowers the current by executing command Dimmer 10 and changes the color to Red with command Color 10,0,0 . Using dummy GPIO to send Serial codes to the MCU ~ By having a device (an Oil Diffusser ) that controls all its features through an MCU and reports the states in serial codes to the ESP8266 I had to create some rules to control it using the Web UI or standard Power commands. Rule2 on power1#state=1 do serialsend5 55AA00060005020400010213 endon on power1#state=0 do serialsend5 55AA00060005020400010011 endon on power2#state=1 do serialsend5 55AA00060005060400010217 endon on power2#state=0 do serialsend5 55AA00060005060400010015 endon Power1 controls the device, Power2 turn on and off the light on the device. Another rule was created to issued commands on boot so the serial interface works every time and to control the built in fan using Event triggers and have its state retained in an MQTT message for Home Assistant. Rule3 on system#boot do backlog baudrate 9600; seriallog 2; serialsend5 55aa000300010306 endon on event#high do backlog serialsend5 55AA00060005650400010175; publish2 stat/diffuser/FAN high endon on event#low do backlog serialsend5 55AA00060005650400010074; publish2 stat/diffuser/FAN low endon Arithmetic commands to be used with VARs ~ ADD ADD1 to ADD5 : Add a value to VARx Syntax: ADDx value Usage: ADD1 15 Result: VAR1 = VAR1 + 15 SUBTRACT SUB1 to SUB5 : Subtract a value from VARx Syntax: SUBx value Usage: SUB1 15 Result: VAR1 = VAR1 - 15 MULTIPLY MULT1 to MULT5 : Multiply a value to VARx Syntax: MULTx value Usage: MULT1 15 Result: VAR1 = VAR1 * 15 SCALE A VALUE SCALE1 to SCALE5 : Scale a value from a low and high limit to another low and high limit and store it in VARx (directly equivalent to MAP arduino command) Syntax: SCALEx value, fromLow, fromHigh, toLow, toHigh where, value : the number to scale fromLow : the lower bound of the value\u2019s current range fromHigh : the upper bound of the value\u2019s current range toLow : the lower bound of the value\u2019s target range toHigh : the upper bound of the value\u2019s target range (omitted values are taken as zero) Usage: SCALE1 15, 0, 100, 0, 1000 Result: VAR1 = 150 Transmit sensor value only when a delta is reached ~ Send only when the sensor value changes by a certain amount. Rule1 on SI7021#temperature>%var1% do backlog var1 %value%; publish stat/mqttTopic/temp %value%; var2 %value%; add1 2; sub2 2 endon on SI7021#temperature<%var2% do backlog var2 %value%; publish stat/mqttTopic/temp %value%; var1 %value%; add1 2; sub2 2 endon Adjust the value of a sensor and send it by MQTT ~ This example adds 2 degrees to the measured temperature and then sends that value to an MQTT topic. Rule1 on tele-SI7021#temperature do backlog var1 %value%; add1 2; event sendtemp endon on event#sendtemp do publish stat/mqttTopic/temp %var1% endon Switch relays via serial interface ~ This example switches a connected relays over the software serial on and off. Write the following rules: rule1 on SSerialReceived#Data=on do power1 1 endon on SSerialReceived#Data=off do power1 0 endon receiving on and off results in MQT : tele /mqttTopic/ RESULT = { \"SSerialReceived\" : \"on\" } RUL : SSERIALRECEIVED # DATA = ON performs \"power1 1\" MQT : stat /mqttTopic/ RESULT = { \"POWER\" : \"ON\" } MQT : stat /mqttTopic/ POWER = ON MQT : tele /mqttTopic/ RESULT = { \"SSerialReceived\" : \"off\" } RUL : SSERIALRECEIVED # DATA = OFF performs \"power1 0\" MQT : stat /mqttTopic/ RESULT = { \"POWER\" : \"OFF\" } MQT : stat /mqttTopic/ POWER = OFF Using BREAK to simulate IF..ELSEIF..ELSE..ENDIF ~ BREAK is an alternative to ENDON . BREAK will stop the execution for the triggers that follow. If a trigger that ends with BREAK fires, then the following triggers of that rule will not be executed. This allows to simulate IF..ELSEIF..ELSE..ENDIF Example: IF temp > 85 then VAR1 more85 ELSEIF temp > 83 then VAR1 more83 ELSEIF temp > 81 then VAR1 more81 ELSEIF temp = 81 then VAR1 equal81 ELSE VAR1 less81 ENDIF With the actual rules, if we use a set like the following: Rule1 on event#temp>85 do VAR1 more85 endon on event#temp>83 do VAR1 more83 endon on event#temp>81 do VAR1 more81 endon on event#temp=81 do VAR1 equal81 endon on event#temp<81 do VAR1 less81 endon This is the output in the console: CMD : rule MQT : stat /living/ RESULT = { \"Rule1\" : \"ON\" , \"Once\" : \"ON\" , \"StopOnError\" : \"OFF\" , \"Free\" : 322 , \"Rules\" : \"on event#temp>85 do VAR1 more85 endon on event#temp>83 do VAR1 more83 endon on event#temp>81 do VAR1 more81 endon on event#temp=81 do VAR1 equal81 endon on event#temp<81 do VAR1 less81 endon\" } CMD : event temp = 10 MQT : stat /living/ RESULT = { \"Event\" : \"Done\" } RUL : EVENT # TEMP < 81 performs \"VAR1 less81\" MQT : stat /living/ RESULT = { \"Var1\" : \"less81\" } CMD : event temp = 100 MQT : stat /living/ RESULT = { \"Event\" : \"Done\" } RUL : EVENT # TEMP > 85 performs \"VAR1 more85\" MQT : stat /living/ RESULT = { \"Var1\" : \"more85\" } RUL : EVENT # TEMP > 83 performs \"VAR1 more83\" MQT : stat /living/ RESULT = { \"Var1\" : \"more83\" } RUL : EVENT # TEMP > 81 performs \"VAR1 more81\" MQT : stat /living/ RESULT = { \"Var1\" : \"more81\" } So, all the triggers where TEMP>100, are firing. With the BREAK statement the rule set can be changed to: Rule on event#temp>85 do VAR1 more85 break on event#temp>83 do VAR1 more83 break on event#temp>81 do VAR1 more81 endon on event#temp=81 do VAR1 equal81 endon on event#temp<81 do VAR1 less81 endon Which will result in the following output: CMD : rule RSL : RESULT = { \"Rule1\" : \"ON\" , \"Once\" : \"OFF\" , \"StopOnError\" : \"OFF\" , \"Free\" : 321 , \"Rules\" : \"on event#temp>85 do VAR1 more85 break on event#temp>83 do VAR1 more83 break on event#temp>81 do VAR1 more81 endon on event#temp=81 do VAR1 equal81 endon on event#temp<81 do VAR1 less81 endon\" } CMD : event temp = 10 RSL : RESULT = { \"Event\" : \"Done\" } RUL : EVENT # TEMP < 81 performs \"VAR1 less81\" RSL : RESULT = { \"Var1\" : \"less81\" } CMD : event temp = 100 RSL : RESULT = { \"Event\" : \"Done\" } RUL : EVENT # TEMP > 85 performs \"VAR1 more85\" RSL : RESULT = { \"Var1\" : \"more85\" } CMD : event temp = 83 RSL : RESULT = { \"Event\" : \"Done\" } RUL : EVENT # TEMP > 81 performs \"VAR1 more81\" RSL : RESULT = { \"Var1\" : \"more81\" } Adjust PowerDelta according to current Power values ~ Power sensor reporting thresholds are set by a percentage change in the Power value by setting PowerDelta . Power changes from 10W to 11W (10%) may not be very interesting. But power changes from 1000W to 1100W (also 10%) could be very important. To avoid getting reports for small changes but ensuring that larger power swings are reported, a rule set can be used to create a gradient threshold based on the absolute power values. This rule also uses the one-shot feature of rules to avoid reporting of every small change within a threshold window. The rule (a ON/DO/ENDON rule in this the set) will trigger only once when a threshold is crossed. Backlog PowerDelta 0; Rule1 0; Rule1 5 Rule1 ON ENERGY#Power>=35 DO Backlog PowerDelta 10; Status 8 BREAK ON ENERGY#Power>=15 DO Backlog PowerDelta 25; Status 8 BREAK ON ENERGY#Power>5 DO Backlog PowerDelta 35; Status 8 BREAK ON ENERGY#Power<=5 DO Backlog PowerDelta 100 ENDON Rule1 1 Which translates to: Rule Pseudo Code IF ENERGY#Power>=35 // ENERGY#Power GE 35 DO Backlog PowerDelta 10; Status 8 ELSE IF ENERGY#Power>=15 // ENERGY#Power GE 15 and LT 35 DO Backlog PowerDelta 25; Status 8 ELSE IF ENERGY#Power>5 // ENERGY#Power GT 5 and LT 15 DO Backlog PowerDelta 35; Status 8 ELSE // ENERGY#Power changed (i.e. LE 5) DO PowerDelta 100 IR Forward ~ Using one IR receiver and one sender (or both extender) you can simply forward signals from one to another using the following rule rule1 on IRreceived#Data do publish cmnd/irsideboard/irsend {Protocol:NEC,Bits:32,Data:%value%} endon Garage Door Opener ~ ( #3942 ) // Set the relay on time to signal the opener PulseTime 7 // Send ON and OFF as the switch is ON or OFF Backlog SwitchMode1 1; SwitchMode2 1; SwitchMode3 1 //No need to save changes on power cycle SetOption0 0 //Don\u2019t blindly run the door on power up PowerOnState 0 //One shot Detection off Backlog Rule1 0; Rule1 4; Rule2 0; Rule2 4; Rule2 0; Rule2 4 //Set Counter to measure the period between on and off, check if its blinking because of an obstruction Backlog CounterType 1; CounterDebounce 100 //So the door doesn't close if you send it an Open when it's already Opened, etc. // var1=1 Only When OPEN // var2=1 Only When CLOSED // var3=1 Only When OPENING // var4=1 Only When CLOSING Rule1 on Switch1#Boot=1 do backlog delay 99; event Opened endon on Switch2#Boot=1 do backlog delay 99; event Closed endon on EVENT#OPEN do power1 %var2% endon on EVENT#CLOSE do power1 %var1% endon on EVENT#STOP do backlog power1 %var3%; power1 %var4%; event PState=STOP endon on Switch1#State=1 do event Opened endon on Switch2#State=1 do event Closed endon on Switch1#State=0 do event Closing endon on Switch2#State=0 do event Opening endon Rule2 on event#Opened do backlog var 1; var2 0; var3 0; var4 0; ruletimer1 0; event PState=OPEN endon on event#Closed do backlog var1 0; var2 1; var3 0; var4 0; ruletimer1 0; event PState=CLOSE endon on event#Opening do backlog var1 0; var2 0; var3 1; var4 0; ruletimer1 15; event PState=OPENING endon on event#Closing do backlog var1 0; var2 0; var3 0; var4 1; ruletimer1 15; event PState=CLOSING endon Rule3 on counter#c1>1000 do event PObstr=0 endon on counter#c1<1000 do event PObstr=1 endon on event#PObstr do publish stat/GarageDoor/OBSTR %value% endon on event#PState do publish stat/GarageDoor/STATE %value% endon on rules#timer=1 do event PState=STOP endon //Turn on Rules Backlog Rule1 1; Rule2 1; Rule3 1 Remote Control Button Multi-press ~ For example, a remote control with one button to change speed. This rules simulates pressing the button three times to set the receiving device to the third speed setting. //Specify the rule set //The <trigger> can be a a condition or an event sent from another device or home automation hub. // <topic> corresponds to the device transmitting the code (e.g., YTF IR Bridge ). This could also be modified to send an RF code from a Sonoff RF Bridge . // The Delay may not be necessary in your environment or may need to be adjusted according to your device characteristics. Rule 1 ON Event#tora DO Backlog Publish cmnd/<topic>/IRSend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF30CF\"}; Delay 10 ENDON ON <trigger> DO Backlog Event tora; Event tora; Event tora ENDON //Enable the Rule set Rule1 1 Two-way light switches without MQTT ~ Two Sonoff T1 3-gang light switches can be used at either end of a room by setting up one the master and the other as the slave. The master performs the switching of the power to the lights, while the slave just asks the master to toggle the power state. The master also turns the slave's relays on and off so that the LED indicators follow the master's state. Using the WebSend command, the two switches can talk to each other - no need for an MQTT broker. It remains to be seen how reliable this is. Starting with the slave, the rule to toggle the master is pretty simple: Rule1 ON Event sendPower DO WebSend [192.168.0.74] POWER%value% TOGGLE ENDON ON Button1#State DO Event sendPower=1 ENDON ON Button2#State DO Event sendPower=2 ENDON ON Button3#State DO Event sendPower=3 ENDON Rule1 1 Note that having a rule for the Button#State disables the power toggling of the slave's relay(s). This is desirable because we want the master to control the slave's relay state(s) according to its own as follows: Rule1 ON Event sendPower DO WebSend [192.168.0.144] POWER%Var1% %value% ENDON ON Power1#state DO Backlog Var1 1;Event sendPower=%value% ENDON ON Power2#state DO Backlog Var1 2;Event sendPower=%value% ENDON ON Power3#state DO Backlog Var1 3;Event sendPower=%value% ENDON Rule1 1 Roller shutter push-button toggle ~ With a two relay device (e.g., Shelly 2.5) configured for a roller shutter, you can also connect push-buttons (configured as switch components in this example) and set them for inverted toggle behavior. Pressing a push-button once makes the roller shutter move in one direction. Pressing it again stops it. These rules each use a variable to remember the shutter state where 0 == Stopped and 1 == Moving . Backlog SwitchTopic 0; SwitchMode1 4; SwitchMode2 4 Rule1 ON Switch1#State==1 DO Add1 1 ENDON ON Var1#State==0 DO ShutterStop1 ENDON ON Var1#State==1 DO ShutterClose1 ENDON ON Var1#State>=2 DO Var1 0 ENDON ON Shutter1#Close DO Var1 0 ENDON ON Switch2#State==1 DO Add2 1 ENDON ON Var2#State==0 DO ShutterStop1 ENDON ON Var2#State==1 DO ShutterOpen1 ENDON ON Var2#State>=2 DO Var2 0 ENDON ON Shutter1#Open DO Var2 0 ENDON Rule1 1 Control a dimmer with one switch ~ [!NOTE] This example is for GPIOs defined as switches not buttons Activate dimmer mode with Switchmode 11 and shorten long press time to 1 second ( Setoption32 10 ). A short press of the switch sends a TOGGLE message to toggle the dimmer. A long press sends repeated INC_DEC messages to increment the dimmer. If a second press of the switch follows the first press a INV message is sent to invert the function from increment to decrement and repeatet INC_DEC messages are sent to decrement the dimmer. After releasing the switch a timeout message CLEAR resets the automation Backlog SwitchMode 5; SetOption32 20 Rule1 on system#boot mem1 + endon on switch1#state=2 do publish light/cmnd/POWER TOGGLE endon on switch1#state=4 do publish light/cmnd/DIMMER %mem1% endon on switch1#state=5 do mem1 - endon on switch1#state=6 do mem1 + endon Rule1 1 Notice we use Rule which edits Rule1 rule set. They can be used interchangeably.","title":"Rules"},{"location":"Rules/#rule-syntax","text":"Rule definition statement ON <trigger> DO <command> [ENDON | BREAK] ON - marks the beginning of a rule definition <trigger> - what condition needs to occur for the rule to execute DO - what the rule is to perform if the <trigger> condition is met ENDON - marks the end of a rule. It can be followed by another rule. BREAK - marks the end of a rule. BREAK will stop the execution of the remaining rules that follow this rule within the rule set. If a rule that ends with BREAK is triggered, the following rules in that rule set will not be executed. This allows the rules to somewhat simulate an \"IF/ELSE\" statement. Rule sets are defined by using the Rule<x> command. After defining a rule set, you have to enable it (turn it on) using Rule<x> 1 . Similarly you can disable the rule set using Rule<x> 0 . There are three separate rule sets called Rule1 , Rule2 and Rule3 . Each rule set can contain as many rules as can fit within the 511 character limit. Whenever a rule set is enabled all the rules in it will be active. If the character count of the rules in the set exceed the limit, split the rules into another rule set. If you have a long list of rules, verify the rules have all fit by inspecting the resulting log. Rules inside a rule set Rule<x> are concatenated and entered as a single statement. Rule<x> ON <trigger1> DO <command> ENDON ON <trigger2> DO <command> ENDON ... Spaces after ON , around DO , and before ENDON or BREAK are mandatory. A rule is not case sensitive.","title":"Rule Syntax"},{"location":"Rules/#rule-trigger","text":"A rule trigger can consist of: [TriggerName]#[ValueName] [TriggerName]#[ValueName][comparison][value] [SensorName]#[ValueName] [SensorName]#[ValueName][comparison][value] Tele-[SensorName]#[ValueName] A trigger may be used in more than one rule. This may be required for some cases of using IF/ELSE since an IF statement cannot be used within a Backlog .","title":"Rule Trigger"},{"location":"Rules/#rule-command","text":"A rule command can be any command listed in the Commands list . The command's <parameter> can be replaced with %value% which will use the value of the trigger. ON Switch1#State DO Power %value% ENDON To accomplish a rule with one trigger but several commands, you need to use Backlog : ON <trigger> DO Backlog <command1>; <command2>; <command3> ENDON Appending new rule onto an existing rule set Use the + character to append a new rule to the rule set. For example: Existing Rule1: ON Rules#Timer=1 DO Mem2 %time% ENDON Rule to append: ON Button1#state DO POWER TOGGLE ENDON Command: Rule1 + ON button1#state DO POWER TOGGLE ENDON Resulting in Rule1 ON Rules # Timer = 1 DO Mem2 % time % ENDON ON Button1 # state DO POWER TOGGLE ENDON You can duplicate the same trigger on many lines. Rule on power2 # state = 1 do power1 1 endon on power2 # state = 1 do RuleTimer1 100 endon","title":"Rule Command"},{"location":"Rules/#rule-variables","text":"There are ten available variables (double precision reals) in Tasmota, Var1..Var5 and Mem1..Mem5 . All Var will be empty strings when the program starts. The value of all Mem persists after a reboot. They provide a means to store the trigger %value% to be used in any rule. The value of a Var<x> and Mem<x> can be: - any number - any text - %var1% to %var5% - %mem1% to %mem5% - %time% - %timestamp% - %uptime% - %sunrise% - %sunset% - %utctime% - %topic% To set the value for Var<x> and Mem<x> use the command - Var<x> <value> - Mem<x> <value> The <value> can also be the value of the trigger of the rule. - Set Var2 to the temperature of the AM2301 sensor - ON AM2301#Temperature DO Var2 %value% ENDON - Set Var4 to Var2's value - ON Event#temp DO Var4 %Var2% ENDON - Set Mem2 to the current time (minutes elapsed since midnight) - ON Rules#Timer=1 DO Mem2 %time% ENDON - After a Wi-Fi reconnect event, publish a payload containing timestamps of when Wi-Fi was disconnected in From: and when Wi-Fi re-connected in To: to stat/topic/BLACKOUT . haskell Rule1 ON wifi#disconnected DO Var1 %timestamp% ENDON ON wifi#connected DO Var2 %timestamp% ENDON ON mqtt#connected DO Publish stat/topic/BLACKOUT {\"From\":\"%Var1%\",\"To\":\"%Var2%\"} ENDON","title":"Rule Variables"},{"location":"Rules/#conditional-rules","text":"This feature is not included in precompiled binaries. To use it you must compile your build . Add the following to user_config_override.h : #define USE_EXPRESSION // Add support for expression evaluation in rules (+3k2 code, +64 bytes mem) #define SUPPORT_IF_STATEMENT // Add support for IF statement in rules (+4k2 code, -332 bytes mem)","title":"Conditional Rules"},{"location":"Rules/#expressions-in-rules","text":"This feature is not included in precompiled binaries. To use it you must compile your build . Add the following to user_config_override.h : #define USE_EXPRESSION // Add support for expression evaluation in rules (+3k2 code, +64 bytes mem) #define SUPPORT_IF_STATEMENT // Add support for IF statement in rules (+4k2 code, -332 bytes mem) Beginning with Tasmota version 6.4.1.14, an optional feature for using mathematical expressions in rules was introduced.","title":"Expressions in Rules"},{"location":"Rules/#rule-cookbook","text":"","title":"Rule Cookbook"},{"location":"Rules/#use-long-press-action-on-a-switch","text":"[!NOTE] This example is for GPIOs defined as switches not buttons Activate long press action with Switchmode 5 and shorten long press time to 2 seconds ( Setoption32 20 ). Long pressing on switch1 sends POWER 2 (toggle action) command to the tasmota02 device Backlog SwitchMode 5; SetOption32 20 Rule on switch1#state=3 do publish cmnd/tasmota02/POWER 2 endon Rule 1 Notice we use Rule which edits Rule1 rule set. They can be used interchangeably.","title":"Use long press action on a switch"},{"location":"Rules/#execute-any-mqtt-message-when-a-button-is-pressed","text":"When a button is pressed the user has the possibility to send a MQTT message based on FullTopic and ButtonTopic. This MQTT message is going to be received by the MQTT Broker and if there is any other device(s) subscripted to that Topic, it will receive also that message. So this approach can be used for sending messages/commands to MQTT Broker to Home Automation System, and/or sending messages/commands to MQTT Broker to other device(s). A problem with this solution is that on a Sonoff 4CH all four buttons will be sending the same MQTT topic using only a different Power index number like cmnd/ButtonTopic/power3 toggle . By using a rule a single button can now send any MQTT message allowing much more flexibility. Hardware - Sonoff 4CH Software - Tasmota compiled with #define USE_RULES - Disable ButtonTopic as it overrides rules for buttons: ButtonTopic 0 Rule Rule1 on button1#state do publish cmnd/ring2/power %value% endon on button2#state do publish cmnd/strip1/power %value% endon (You will likely need to enable this rule if it's the first time you've used them) \"Rule1 on\". Result - When button 1 is pressed the rule kicks in and sends a MQTT message substituting variable %value% with the button state like cmnd/ring2/power 2 . When button 2 is pressed a MQTT message like cmnd/strip1/power 2 will be sent.","title":"Execute any MQTT message when a button is pressed"},{"location":"Rules/#execute-several-commands-when-a-timer-expires","text":"The default Timer1..16 functionality allows for controlling one output to either off, on, toggle or blink. When rules are enabled the blink option will be replaced by rule functionality allowing much more flexibility. Hardware - Sonoff 4CH Software - Tasmota compiled with #define USE_RULES - Configure timer5 for rule execution when activated: console Timer5 {\"Arm\":1,\"Mode\":0,\"Time\":\"16:00\",\"Days\":\"1111111\",\"Repeat\":1,\"Action\":3} - Rule console Rule1 on clock#Timer=5 do backlog power2 on;power1 off;power3 2 endon Result - When the timer expires the rule kicks in and set Power1 to OFF, Power2 to ON and Toggles Power3 If you want to have blink functionality define a rule like on clock#Timer=5 do power 3 endon","title":"Execute several commands when a Timer expires"},{"location":"Rules/#usage-of-one-shot-once","text":"The rule command once option provides the possibility to trigger only once on a slow change while the change is still within the bounds of the test. Rule on ENERGY#Current>0.100 do publish tool/tablesaw/power 1 endon on ENERGY#Current<0.100 do publish tool/tablesaw/power 0 endon This creates a rule to publish MQTT commands whenever a Sonoff POW has current passing through it. Used as is, it will publish MQTT commands repeatedly, over and over, while current is >0.100 ... but, executing another command: Rule 5 Now the MQTT message will be sent once, and only once, while the condition is met. This is perfect for thermostat on/off depending on temperature, bathroom extractor fan on/off depending on humidity, workshop dust collector on/off depending on whether some dust-producing machine is running. It meets the 'hard thermostat' requests that have been common.","title":"Usage of one-shot (once)"},{"location":"Rules/#use-of-variables-and-tele-","text":"Using variables allows for storing sensor results to be used in composing a single HA message like used with Domoticz. To prevent flooding Domoticz with messages we only want to send a message at TelePeriod time. This is achieved by prefixing the <SensorName> with the label tele- . This example will use a variable storing the temperature to be used together with humidity in one Domoticz MQTT message. Hardware - Sonoff TH or Wemos D1 mini - AM2301 Temperature and Humidity sensor Software - Tasmota compiled with #define USE_RULES - Home Automation tool Domoticz configured with a virtual sensor Temp+Hum using Idx 134 Rule Rule on tele-am2301-12#temperature do var1 %value% endon on tele-am2301-12#humidity do publish domoticz/in {\"idx\":134,\"svalue\":\"%var1%;%value%;1\"} endon Result - As a result of the tele- prefix the rules will be checked at TelePeriod time for sensor AM2301-12 Temperature and Humidity. The first rule will use the Temperature stored in %value% and save it in %var1% for future use. The second rule will use the Humidity stored in %value% and the Temperature stored in %var1% to compose a single MQTT message suitable for Domoticz. Clever Dickies now finally have a way to send Temperatures from multiple DS18B20 to Domoticz.","title":"Use of variables and tele-"},{"location":"Rules/#use-a-potentiometer","text":"Connecting a potentiometer to the Analog A0 input and a rule can be used to control the dimmer state of any device. Hardware - Wemos D1 mini - Potentiometer of 2k2 connected to Gnd, A0 and 3V3 - WS2812 LED Software - Tasmota compiled with #define USE_RULES Rule on analog#a0div10 do dimmer %value% endon Result - Turning the potentiometer the voltage on the analog input will change resulting in a value change of 0 (Off) to 100 for the trigger. Using this value to control the dimmer of the WS2812 will control the brightness of the led(s) Rule on analog#a0div10 do publish cmnd/grouplight/dimmer %value% endon Result - This time all lights configured with GroupTopic grouplight will change their brightness according to the potentiometer position. NOTE: You might want to execute command SaveData 2 to reduce flash writes ;-)","title":"Use a potentiometer"},{"location":"Rules/#setting-variables","text":"Demonstrate the use of variables. Make sure to execute commands Rule 4 (Disable one-shot detection) first when trying the following example. Set a variable Rule on event#setvar1 do var1 %value% endon Command: event setvar1=1 View a variable rule on event#getvar1 do var1 endon Command: event getvar1 Toggle a variable Rule on event#togglevar1 do event toggling1=%var1% endon on event#toggling1<1 do event setvar1=1 endon on event#toggling1>0 do event setvar1=0 endon on event#setvar1 do var1 %value% endon ``` Command: `event togglevar1` Show Messages: ```console Rule on event#message do publish stat/[topic]/log %value% endon Command: event message=INIT All event commands can be executed from: console: event anyname=number mqtt: cmnd/[topic]/event anyname=number Everything together: Rule1 on event#togglevar1 do event toggling1=%var1% endon on event#toggling1<1 do event setvar1=1 endon on event#toggling1>0 do event setvar1=0 endon on event#setvar1 do var1 %value% endon on event#getvar1 do var1 endon on event#message do publish stat/mqttTopic/log %value% endon [!NOTE] The following won't work: Rule1 on event#setvar1 do backlog var1 %value%; power1 %var1% endon At least not as you probably would expect. The var1 value used by the power1 command will be the value present before the backlog command is executed. This is so, because the rule will replace %var1% BEFORE the backlog commands are put in the backlog command stream.","title":"Setting variables"},{"location":"Rules/#control-device-leds-with-relays","text":"If a device has more than one relay and LEDs on different GPIOs (not connected to the relay) you need to use rules to display current relay status on LEDs. This example is a 3 gang wall switch. Instead of LEDs you need to assign 3 dummy relays that will be controlled when the real relays are switched to reflect their status. Backlog ledmask 0x0000; setoption13 1; seriallog 0 rule1 on power1#state do power4 %value% endon on power2#state do power5 %value% endon on power3#state do power6 %value% endon rule1 1 Note: This method doubles the number of flash writes. Link to the device","title":"Control device LEDs with Relays"},{"location":"Rules/#thermostat-example","text":"As example, to be used on a Sonoff TH10 with Sensor Si7021 This example turn on and off an output based on the temperature value and the upper set point and the lower set point. It waits until is enabled by pressing the button or by mqtt message 1 to mem1. This value is remembered. So if power cycle occurs, will resume operation. The set point values can be changed on the fly by mqtt or console commands If the Temperature sensor disconnects, the outputs will shutdown until the sensor is back again and will resume operation. When the device is power up, the thermostat also waits until the sensor value to resume operation. Initial Config: Available physical button as switch1 Relay1 will be used the controller Rules must be used to control Relay so the pushbutton must only control switch1 and not directly control the relay - For this we use SwitchMode1 3 as described below and create the necessary rules because the pushbutton control of the relay is only disabled when the rules are in place. Initial config on console: SwitchMode1 3 <- Use the switch1 as pushbutton (It will allow us to disable the link between the button and the relay by inserting a rule to dictate what the pushbutton will do - NOTE: Until rules are created the pushbutton will still control the relay! ) Rule1 1 <- turn on rules Rule1 4 <- turn off one-shot rule TelePeriod 60 <- check temp every minute SetOption26 1 <- use power1 on mqtt messages SetOption0 0 <- dont save relay status on eeprom PowerOnState 0 <- start all relays off Mem1 0 <- thermostat status: 0-off 1-enabled - View or set by MQTT cmnd/mqttTopic/mem1 Mem2 25 <- setpoint Temp upper limit - View or set by MQTT cmnd/mqttTopic/mem2 Mem3 23 <- setpoint Temp lower limit - View or set by MQTT cmnd/mqttTopic/mem3 Var1 0 <- thermostat actual status: 1-OK 0-NOT READY - View by MQTT cmnd/mqttTopic/var1 Rules: On boot start a watchdog timer to check temp sensor connection. Rule on system#boot do RuleTimer1 70 endon An available button is configured as switch to set thermostat ON or OFF Rule1 on switch1#state do backlog event toggling1=%mem1% endon on event#toggling1=0 do mem1 1 endon on event#toggling1=1 do mem1 0 endon Check temp sensor connection. If fails, set to off and turn off thermostat. Also continue checking Rule on Rules#Timer=1 do backlog var1 0; RuleTimer1 70; power1 0 endon Resets checking timer if temperature is connected Rule on tele-SI7021#temperature do backlog var1 1; RuleTimer1 30; event ctrl_ready=1; event temp_demand=%value% endon Thermostat control - upper limit and lower limit and enabled Rule1 on event#ctrl_ready>%mem1% do var1 0 endon on event#temp_demand>%mem2% do power1 0 endon on event#temp_demand<%mem3% do power1 %var1% endon Thermostat can be turned On by: * pushing button * by command on local console: mem1 1 * by command on any other console: publish cmnd/mqttTopic/mem1 1 * or MQTT at: cmnd/mqttTopic/mem1 1 Thermostat can be turned Off by: * pushing button * by command on local console: mem1 0 * by command on any other console: publish cmnd/mqttTopic/mem1 0 * or MQTT at: cmnd/mqttTopic/mem1 0 To get the status: * mem1 <- thermostat status: 0-off 1-enabled - View or set by MQTT cmnd/mqttTopic/mem1 * mem2 <- setpoint Temp upper limit - View or set by MQTT cmnd/mqttTopic/mem2 * mem3 <- setpoint Temp lower limit - View or set by MQTT cmnd/mqttTopic/mem3 * var1 <- thermostat actual status: 1-OK 0-NOT READY - View by MQTT cmnd/mqttTopic/var1 Everything together: INITIAL CONFIG: (Note: RuleTimer1 must be greater that TelePeriod for expected results) backlog SwitchMode1 3; Rule 1; Rule 4; TelePeriod 60; SetOption26 1; SetOption0 0; poweronstate 0; mem1 0; mem2 25; mem3 23; var1 0 RULES: Rule1 on system#boot do RuleTimer1 70 endon on Switch1#State do event toggling1=%mem1% endon on event#toggling1=0 do mem1 1 endon on event#toggling1=1 do mem1 0 endon on Rules#Timer=1 do backlog var1 0; RuleTimer1 70; power1 0 endon on tele-SI7021#temperature do backlog var1 1; RuleTimer1 70; event ctrl_ready=1; event temp_demand=%value% endon on event#ctrl_ready>%mem1% do var1 0 endon on event#temp_demand>%mem2% do power1 0 endon on event#temp_demand<%mem3% do power1 %var1% endon EXAMPLE RULES WITHOUT TEMP SENSOR TO TEST THE THERMOSTAT RULES Rule1 on system#boot do RuleTimer1 70 endon on Switch1#State do event toggling1=%mem1% endon on event#toggling1=0 do mem1 1 endon on event#toggling1=1 do mem1 0 endon on Rules#Timer=1 do backlog var1 0; RuleTimer1 70; power1 0 endon on event#temp do backlog var1 1; RuleTimer1 70; event ctrl_ready=1; event temp_demand=%value% endon on event#ctrl_ready>%mem1% do var1 0 endon on event#temp_demand>%mem2% do power1 0 endon on event#temp_demand<%mem3% do power1 %var1% endon TESTS: * Push the button1. The thermostat changes to ENABLED (mem1=1) * on console: event temp=20 (now the system receives like a tele message from temperature sensor) and will turn on the relay1 (to heat) * on console: event temp=26 (the thermostat turn off the heater) * on console: event temp=22 (the thermostat turn on the heater) * wait more than a minute without using the event temp and the thermostat will turn off as there is no temperature value (like a sensor error or disconnection) * will resume when using again the event temp * console mem1 0, DISABLED, console mem1 1, ENABLED TIMERS: * With the above the timers can be used to control mem1 and add a schedule to when the thermostat will be enabled Rule2 on Clock#Timer=1 do mem1 1 endon on Clock#Timer=2 do mem1 0 endon","title":"Thermostat Example"},{"location":"Rules/#solar-heater-control","text":"In a swimming pool, a filter pump and a solar panel is installed. When the sun is shining, the pump should push water through the solar panel, to heat the pool. When it's night or cloudy, the pump should be off, to avoid cooling the pool water through the solar panel. The pump is controlled by a Sonoff TH10 with 2x DS18B20 sensors connected. 3 rules: Pump should start when solar panel is more than 2 deg warmer than the pool water Pump should stop when solar panel is less than 1 deg warmer than the pool water Pump should not start if the solar panel is below 25 deg Celsius. t1 : pool temp t2 : panel temp var1 : in valid panel temp range? var2 : off threshold temp for panel var3 : on threshold temp for panel mem3 : lowest valid panel temp mem3 25 rule1 on DS18B20-1#temperature do event t1=%value% endon on DS18B20-2#temperature do event t2=%value% endon on event#t2>%mem3% do var1 1; endon on event#t2<=%mem3% do var1 0; endon on event#t1 do backlog var2 %value%; add2 1; endon on event#t1 do backlog var3 %value%; add3 2; endon on event#t2>%var3% do power1 %var1%; endon on event#t2<%var2% do power1 0; endon rule1 1 To test the rule without having the sensors in place, simply enter the events for t1 and t2 in the console: Backlog event t1=21;event t2=30 And watch the relay turn on and off based on the values. Please note that this example does not support manual override or handle missing sensor data. Take a look at Thermostat Example for examples.","title":"Solar heater control"},{"location":"Rules/#energy-saving-smart-switch","text":"Example of a switch controlling a light with a condition of a required amount of lux. When the switch is on, the light will turn on but only when you have less than 100 lux in that room. While if the switch is off the light will be off. Rule1 on switch1#state=1 do var1 100 endon on switch1#state=0 do backlog var1 0; power1 off endon on APDS9960#Ambient<%var1% do power1 on endon All together to work as a rule: Rule 1 Rule1 on switch1#state=1 do var1 100 endon on switch1#state=0 do backlog var1 0; power1 off endon on APDS9960#Ambient<%var1% do power1 on endon","title":"Energy Saving Smart Switch"},{"location":"Rules/#time-delayed-auto-off-switch","text":"Rule: Rule1 on button1#state do backlog power1 %value%; RuleTimer1 600 endon on Rules#Timer=1 do power1 off endon Result: on button1#state do backlog power1 %value%; On Button press the Light will toggle on/off RuleTimer1 600 endon Additionally RuleTimer1 will begin to countdown 10 minutes on Rules#Timer=1 do power1 off endon After the RuleTimer1 expires the light will be turned off (if you forgot to turn it off)","title":"Time-delayed Auto-off Switch"},{"location":"Rules/#time-delay-after-switch-off","text":"Rule1 on switch1#state=1 do backlog power1 on; ruletimer1 0 endon on switch1#state=0 do ruletimer1 300 endon on rules#timer=1 do power1 0 endon backlog switchmode1 1; rule1 1 Legend: ruletimer1 300 sets a 5 minute timer. After that time, fan will be switched off. If during the defined 5 minutes (or in general - when timer is counting) you the switch on, the timer will be canceled. switchmode1 1 sets the switch in follow mode (LOW=off, HIGH=on) If you have inverted switch (LOW=on, HIGH=off) then use switchmode1 2","title":"Time-delay After Switch Off"},{"location":"Rules/#auto-off-motion-sense-switch","text":"Example works fine on a Wemos D1 Mini. Used as night light with motion sensor or as ambient light on floor or kitchen. I connect an LED Strip WS2812 on D1 and the PIR on D2 and a LDR on A0 (voltage divider with 10k ohm resistor) PIR example: HR-SC501 The Settings are: 18 Generic D1 WS2812 D2 Switch1 LDR on Wemos A0 (activated in user_config_override.h) and type the following statements in the Console: Rules: SwitchMode1 1 Rule1 on analog#a0<400 do backlog Rule3 0; Rule2 1 endon on analog#a0>500 do backlog Rule2 0; Rule3 1 endon Rule2 on switch1#state do backlog power1 1; RuleTimer1 30 endon on Rules#Timer=1 do power1 off endon Rule3 on switch1#state do power1 off endon Activate Rule1 with one shot detection Backlog Rule1 1; Rule1 6 Optional Backlog Rule2 4; Rule3 4 Result: * on analog#a0>400 disable Rule3 and activate Rule2 * on analog#a0>500 disable Rule2 and activate Rule3 * Rule2 activates the LEDs for RuleTimer1 30 seconds on each trigger from PIR the RuleTimer start again. on Rules#Timer=1 do power1 off The LEDs turn off after the RuleTimer expires * Rule3 is active on daylight and pipe the PIR signal in a power1 off signal. The LEDs stay off.","title":"Auto-off Motion Sense Switch"},{"location":"Rules/#controlling-timers-enabled-from-a-switch","text":"Assuming that your switch is on GPIO00 and configured as Switch1 : SwitchMode1 1 Rule1 on Switch1#state=1 do Timers 0 endon on Switch1#state=0 do Timers 1 endon Rule1 1 Switchmode1 1 will make Switch1#state be 1 when ON and 0 when OFF If you don't set Switchmode1 or it is equal 0, it will only have Switch1#state=2 (toggle) and the previous rule will not work.","title":"Controlling Timers Enabled from a Switch"},{"location":"Rules/#toggle-a-relay-only-when-holding-the-button-for-2-seconds","text":"The following example is to explain how to catch and use the HOLD feature for buttons. Behavior: Disable Button1 Short Press and Toggle Relay1 only when holding button1 for 2 Seconds. Type in the console: Backlog ButtonTopic 0; SetOption1 1; SetOption32 20 Rule1 on button1#state=3 do power1 2 endon on button1#state=2 do delay endon Rule1 1 Commands Explanation ButtonTopic 0 : (default) To not use topics for buttons SetOption1 1 : Allow only single, double and hold press button actions SetOption32 20 : Set key hold time from 0.1 to 10 seconds (20 = 2 seconds) Rule on button1#state=3 do power1 2 endon : When holding the button1 for 2 seconds it will toggle relay 1 (state = 3 means HOLD) on button1#state=2 do delay endon : Do nothing when short pressing the button1 (state = 2 means TOGGLE) Rule1 1 : To enable rules NOTE: There is no state value for \"double press\" for Buttons. It is designed that double press will toggle the relay. See Multi-Press Functions for more information. In the case you do not want the double press feature you can configure your button as switch and also set SwitchMode that fits your use case (such as SwitchMode 5 to make the switch behave like a pushbutton) [SWITCH does not support double press] Another example but using switch instead of button: Backlog SwitchTopic1 0; SwitchMode1 5; SetOption32 20 Rule1 on switch1#state=3 do power1 2 endon on switch1#state=2 do delay endon Rule1 1","title":"Toggle a Relay only when holding the button for 2 seconds"},{"location":"Rules/#make-sure-light-is-on-at-night","text":"Using Timers, you can set a light to turn on and off to illuminate a street/patio by night. But if the device has no power at the trigger time, then, when it powers up, the light will be off all night. So, as a fail-safe, implement a conditional control to be checked at Tasmota Startup. Set Timers to turn on your light at Sunset and Turn off at sunrise. Use poweronstate 0 in order to start with lights off when powering up your device. Set the following rules: Rule1 on Time#Initialized do backlog event checksunrise=%time%; event checksunset=%time% endon on event#checksunset>%sunset% do power1 1 endon on event#checksunrise<%sunrise% do power1 1 endon The previous rules are conditionals that represent the following logic: IF %time%>%sunset DO power1 1 / IF %time%<%sunrise DO power1 1","title":"Make Sure Light is on at Night"},{"location":"Rules/#turn-on-light-before-dawn-and-at-dusk","text":"Turn on light at dusk until your nighttime and again in the morning before dawn. What if the sun sets after your nighttime, as in during the summer? Then the timer will turn off the light at \"night\", but then the Sunset timer will turn it on again, so it stays on all night. Rule1 on Time#Initialized do event chkSun endon on Time#Minute=%sunset% do event chkSun endon on Time#Minute=%mem2% do event chkSun endon on Time#Minute=%sunrise% do event chkSun endon on Time#Minute=%mem1% do event chkSun endon Rule2 on event#chkSun do backlog var1 0; event chkSunrise=%time%; event chkSunset=%time%; event chkmorn=%time%; event chknight=%time%; event setPower endon on event#chkSunrise<%sunrise% do var1 1 endon on event#chkSunset>=%sunset% do var1 1 endon on event#chkmorn<%mem1% do var1 0 endon on event#chknight>=%mem2% do var1 0 endon on event#setPower do power1 %var1% endon Backlog mem1 360; mem2 1350 Backlog Rule1 1; Rule2 1 Explanation: - When device restarts, calculate if the light should be on or off on Time#Initialized do event chkSun endon Calculate if the light should be on or off on Time#Minute=%sunset% do event chkSun endon on Time#Minute=%mem2% do event chkSun endon on Time#Minute=%sunrise% do event chkSun endon on Time#Minute=%mem1% do event chkSun endon Calculate if the light should be on or off on event#chkSun do backlog Assume off var1 0; Trigger each event with the current time event chkSunrise=%time%; event chkSunset=%time%; event chkmorn=%time%; event chknight=%time%; event setPower End rule endon If before sunrise, turn on on event#chkSunrise<%sunrise% do var1 1 endon If past sunset, turn on on event#chkSunset>=%sunset% do var1 1 endon But if before Morning time ( mem1 ), do not turn on on event#chkmorn<%mem1% do var1 0 endon Or if after Night time ( mem2 ), do not turn on on event#chknight>=%mem2% do var1 0 endon Perform on/off state on event#setPower do power1 %var1% endon Set variables for Morning (06h00) and Night (22h30) times Backlog mem1 360; mem2 1350 Turn on the rule sets Backlog Rule1 1; Rule2 1","title":"Turn On Light Before Dawn and At Dusk"},{"location":"Rules/#enable-a-pir-switch-only-at-night","text":"PreInfo: - PIR HC-SR501 - GPIO14 09 Switch1 (Sonoff Basic) - Jumper outside ( like this ) - Lat and Lng set in config Commands: SwitchMode1 1 Rule1 on Switch1#state=1 do backlog event checksunrise=%time%; event checksunset=%time% endon on event#checksunrise<%sunrise% do power1 1 endon on event#checksunset>%sunset% do power1 1 endon Rule1 1","title":"Enable a PIR Switch only at night"},{"location":"Rules/#using-clock-timer-to-control-a-luminance-triggered-switch-only-in-mornings","text":"Background: Tasmota powers a Sonoff Basic attached to a TS-2561 Luminance Sensor. This switch toggles a lamp ON or OFF. The switch should work as below: i) during daytime (sunrise-sunset): ON when it is too dark (<150 lx) and OFF when it gets brighter (>175 lx). ii) during evenings it ignores the sensor and turns on at sunset and turns off after about 5 hours Approach: Used a combination of Clock Timers and Rule to do this. Timer 1: Power ON switch at Sunset Powers on the switch at sunset with an offset of 20 minutes. Repeats every day. Timer1 {\"Arm\":1,\"Mode\":2,\"Time\":\"-00:20\",\"Window\":0,\"Days\":\"1111111\",\"Repeat\":1,\"Output\":1,\"Action\":1} Timer 2: Power OFF switch at Night. Turns power OFF at 23.00hrs. Repeats every day. Timer2 {\"Arm\":1,\"Mode\":0,\"Time\":\"23:00\",\"Window\":0,\"Days\":\"1111111\",\"Repeat\":1,\"Output\":1,\"Action\":0} Timer 3: Trigger Luminance Rule at Sunrise Start watching the Lux sensor 15 minutes after sunrise. Timer3 {\"Arm\":1,\"Mode\":1,\"Time\":\"00:15\",\"Window\":0,\"Days\":\"1111111\",\"Repeat\":1,\"Output\":1,\"Action\":3} Rule 1: Main Rule to check Luminance If Luminance is less than 150lx, power ON. If it goes beyond 175lx, power OFF. Rule1 on tele-TSL2561#Illuminance<150 do power1 1 endon on tele-TSL2561#Illuminance>175 do power1 0 endon Rule1 1 Rule 2: Trigger Rule1 only in the Mornings This ensures that Rule1 is triggered when Timer3 starts (in the morning) and stops when Timer1 starts (in the evenings). Rule2 on Clock#Timer=3 do Rule1 1 endon on Clock#Timer=4 do Rule1 0 endon Rule2 1","title":"Using Clock Timer to control a Luminance triggered switch (only in mornings)"},{"location":"Rules/#button-with-single-press-double-press-and-hold","text":"You can have all 3 actions but only if defining your GPIO as button. In this case the double press will toggle the relay. There is also an option to swap the actions of the single press and double press . BUTTON WITH 3 DIFFERENT ACTIONS As an example: [assuming Button1] single press : Turn relay 1 double press : send a mqtt message hold 2 secs : send another mqtt message ```console Backlog ButtonTopic 0; SetOption1 1; SetOption11 1; SetOption32 20 Rule1 on button1#state=3 do publish cmnd/topicHOLD/power 2 endon on button1#state=2 do publish cmnd/topicDOUBLEPRESS/power 2 endon Rule1 1 ``` Another example: [assuming Button1] single press : send a mqtt message double press : Turn relay 1 hold 2 secs : send another mqtt message ```console Backlog ButtonTopic 0; SetOption1 1; SetOption11 0; SetOption32 20 Rule1 on button1#state=3 do publish cmnd/topicHOLD/power 2 endon on button1#state=2 do publish cmnd/topicSINGLEPRESS/power 2 endon Rule1 1 ``` Note: SetOption11 0 SWITCHES WITH 2 DIFFERENT ACTIONS Switches do not have double press feature Example: [assuming a connected pushbutton configured as Switch1] single press : Do nothing hold 2 secs : Toggle relay 1 ```console Backlog SwitchTopic1 0; SwitchMode1 5; SetOption32 20 Rule1 on Switch1#State=3 do Power1 2 endon on Switch1#State=2 do Delay endon Rule1 1 ```","title":"Button with single press, double press, and hold"},{"location":"Rules/#perform-any-action-on-singledouble-press-for-switches-and-buttons","text":"SwitchMode 5 Rule1 on switch1#state==2 do add1 1 endon on switch1#state==2 do power1 2 endon on var1#state!=0 do backlog delay 6;var1 0 endon on var1#state==2 do publish cmnd/othertasmota/POWER toggle endon Rule1 on Explanation: - each toggle of the switch triggers first condition and adds 1 to our variable (var1 in the example), - each toggle of the switch toggles the associated relay ( Power1 2 - but can do anything else instead, Publish for example) - when var1 changes to non zero, we set it back to 0 but after a Delay (arbitrarily chosen 6 here - 0.6 seconds) - when var1 reaches 2 (i.e. the switch has been toggled twice within the last 0.6 seconds), desired action is triggered (here: Publish to othertasmota ) Result: Every time you press the switch, your light toggles state (as it should). If you do press the switch twice in a rapid succession (i.e., double-click), you can trigger a different action (e.g., on a remote device).","title":"Perform any action on single/double press (for switches AND buttons)"},{"location":"Rules/#external-switch-to-enable-or-disable-doorbell-relay-with-http-call","text":"When you want to send MQTT messages ( we use domoticz in this example ) and choose when you want the relay on or off, by simply sending HTTP commands to trigger an event. Initial Config: - PushButton Doorbell - (Sonoff Basic R1) GPIO14 - Switch4 (12) Connect the Switch to GND and the GPIO on your device. Be sure put a 4.7k resistor between VCC(3.3v) and the GPIO. This prevents ghost switching (capacitor is optional) See: YouTube Dont forget to change the IDX value Commands: Backlog SwitchTopic 0; SwitchMode4 2; SetOption0 0; PowerOnState 0 var1 1 Rule1 on event#doorbell do var1 %value% endon on switch4#state=1 do publish domoticz/in {\"idx\":11,\"nvalue\":1} endon on switch4#state=1 do power1 %var1% endon on switch4#state=0 do publish domoticz/in {\"idx\":11,\"nvalue\":0} endon on switch4#state=0 do power1 0 endon Rule1 1 Usage: Turn off the relay by calling the event using HTTP: http://<tasmotaIP>/cm?cmnd=event%20doorbell=0 Turn on the relay by calling the event using HTTP: http://<tasmotaIP>/cm?cmnd=event%20doorbell=1 If your Tasmota device is password protected, which is most common, then use the following HTTP commands instead. Make sure you change <tasmotaUsername> and <tasmotaPassword> Off: http://<tasmotaIP>/cm?&user=<tasmotaUsername>&password=<tasmotaPassword>&cmnd=event%20doorbell=0 On: http://<tasmotaIP>/cm?&user=<tasmotaUsername>&password=<tasmotaPassword>&cmnd=event%20doorbell=1","title":"External switch to enable or disable doorbell relay with HTTP call"},{"location":"Rules/#force-automatic-re-connection-to-mqtt-server-via-sd-dns","text":"In order to search for the MQTT server using SD-DNS service (a.k.a. Bonjour or Zero Network Configuration) the suggested configuration is to leave the MQTT Host field blank. The standard behavior of Tasmota is - searches for _mqtt._tcp service - resolve that to the proper IP address - connect to it - in case the connection is successful, retain the IP address and use that in the subsequent connections The above is not proper, though, in case you have a redundant MQTT (e.g., two MQTT server synchronized). In such case, when the active MQTT fails for any reason, the expected behavior is to achieve automatic re-connection to the other MQTT server. That can be easily configured defining the following rule on the device console: Rule1 on Mqtt#Disconnected do MqttHost 0 endon Rule1 1 If the MqttHost field already contains an IP, you have to delete it using the web interface or the following MQTT command: mosquitto_pub -h mqtt_server.local -t \"cmnd/mqttTopic/MqttHost\" -m ''","title":"Force automatic re-connection to MQTT server via SD DNS"},{"location":"Rules/#change-distance-to-percentage","text":"When measuring distance and you have the need to see it in percentage of distance. In the example 100% is everything below 69cm and 0% is everything above 128cm. This is used for showing fill percentage of a wood pellets storage. Rule1 on tele-SR04#distance do backlog var1 %value%; event checklimit=%value%; event senddistance endon on event#checklimit>128 do var1 128 endon on event#checklimit<69 do var1 68 endon on event#senddistance do backlog SCALE1 %var1%, 128, 69, 0, 100; event pubdata endon on event#pubdata do publish tele/pannrum-temp/SENSOR %var1% endon Rule1 1","title":"Change distance to percentage"},{"location":"Rules/#distinguish-switch1-and-switch2-without-the-use-of-relay1-and-relay2","text":"When two (or more) switches are defined as input and you want to distinguish these in the RESULT topic without the use of Relays, then consider the following rules. SwitchMode1 1 will make Switch1#state to be 1 when ON and 0 when OFF SwitchMode1 1 SwitchMode2 1 will make Switch2#state to be 1 when ON and 0 when OFF SwitchMode2 1 Publish json with key POWER1 and value %value% Rule1 on switch1#state do publish stat/wemos-4/RESULT {\"POWER1\":\"%value%\"} endon Publish json with key POWER2 and value %value% Rule2 on switch2#state do publish stat/wemos-4/RESULT {\"POWER2\":\"%value%\"} endon Enable Rule1 Rule1 1 Enable Rule2 Rule2 1 Output: RUL : SWITCH1 # STATE performs \"publish stat/wemos-4/RESULT {\" POWER1 \":\" 1 \"}\" MQT : stat /wemos-4/ RESULT = { \"POWER1\" : \"1\" } RUL : SWITCH2 # STATE performs \"publish stat/wemos-4/RESULT {\" POWER2 \":\" 1 \"}\" MQT : stat /wemos-4/ RESULT = { \"POWER2\" : \"1\" } RUL : SWITCH1 # STATE performs \"publish stat/wemos-4/RESULT {\" POWER1 \":\" 0 \"}\" MQT : stat /wemos-4/ RESULT = { \"POWER1\" : \"0\" } RUL : SWITCH2 # STATE performs \"publish stat/wemos-4/RESULT {\" POWER2 \":\" 0 \"}\" MQT : stat /wemos-4/ RESULT = { \"POWER2\" : \"0\" } RUL : SWITCH1 # STATE performs \"publish stat/wemos-4/RESULT {\" POWER1 \":\" 1 \"}\" MQT : stat /wemos-4/ RESULT = { \"POWER1\" : \"1\" } RUL : SWITCH1 # STATE performs \"publish stat/wemos-4/RESULT {\" POWER1 \":\" 0 \"}\" MQT : stat /wemos-4/ RESULT = { \"POWER1\" : \"0\" }","title":"Distinguish Switch1 and Switch2 (without the use of Relay1 and Relay2)"},{"location":"Rules/#receiving-state-of-anything-that-triggers-switch-more-than-one-time","text":"With analog intercom doorbells you can take out info about ringing from speaker voltage. You can connect GPIO to it via opto-isolator and resistor to take out state. But even with those speaker voltage is dropping so it switches the device multiple times. MQT : cmnd /doorbell/ POWER2 = OFF ( retained ) MQT : cmnd /doorbell/ POWER2 = ON ( retained ) MQT : cmnd /doorbell/ POWER2 = OFF ( retained ) MQT : cmnd /doorbell/ POWER2 = ON ( retained ) MQT : cmnd /doorbell/ POWER2 = OFF ( retained ) To solve it we can use rules. SwitchTopic 0 Rule1 on System#Boot var1 0 endon on Switch2#State do backlog add1 1; event START endon on event#START do event BELL=%var1% endon on event#BELL=1.000 do backlog publish cmnd/bell/power on; RuleTimer1 60 endon on event#BELL=0 do publish cmnd/bell/power off endon on Rules#Timer=1 do backlog var1 0; event BELL=0 endon Rule1 1 description: - turn off switchtopic as it is necessary to trigger Switch2#state - on system boot set var1 to 0 - on switch2 click (person pushing doorbell) - var1 += 1; trigger event START - on START - set event BELL equal to var1 - if event#BELL=1 (triggered first time) publish mqtt message ON and trigger RulesTimer1 for 60 seconds - if event#BELL=0 publish mqtt message OFF - on RulesTimer1 - reset var1 to 0, and call event#BELL. - enable rule 1 In this case we have lock for 60 seconds for multiple people calls or to be resistant for speaker voltage drops.","title":"Receiving state of anything that triggers SWITCH more than one time"},{"location":"Rules/#prevent-wemos-d1-mini-load-overcurrent","text":"As a WS2812 24 led ring draws approximately 24x3x20 mA = 1.44A and the Wemos D1 mini powered from a PC's USB port can only provide up to 0.5A it would be nice to have some kind of mechanism in place to limit the amount of current to the WS2812 LEDring to 0.1A. This is still enough to light all 24 leds up to color 202020. Hardware - Wemos D1 mini - INA219 I 2 C sensor - WS2812 LEDring with 24 LEDs powered by the Wemos D1 mini 5V thru the INA219 sensor Rule1 on INA219#Current>0.100 do Backlog Dimmer 10;Color 10,0,0 endon Rule1 on Result - When a user raises brightness to a level using more than 0.1A the rule kicks in and lowers the current by executing command Dimmer 10 and changes the color to Red with command Color 10,0,0 .","title":"Prevent Wemos D1 mini load overcurrent"},{"location":"Rules/#using-dummy-gpio-to-send-serial-codes-to-the-mcu","text":"By having a device (an Oil Diffusser ) that controls all its features through an MCU and reports the states in serial codes to the ESP8266 I had to create some rules to control it using the Web UI or standard Power commands. Rule2 on power1#state=1 do serialsend5 55AA00060005020400010213 endon on power1#state=0 do serialsend5 55AA00060005020400010011 endon on power2#state=1 do serialsend5 55AA00060005060400010217 endon on power2#state=0 do serialsend5 55AA00060005060400010015 endon Power1 controls the device, Power2 turn on and off the light on the device. Another rule was created to issued commands on boot so the serial interface works every time and to control the built in fan using Event triggers and have its state retained in an MQTT message for Home Assistant. Rule3 on system#boot do backlog baudrate 9600; seriallog 2; serialsend5 55aa000300010306 endon on event#high do backlog serialsend5 55AA00060005650400010175; publish2 stat/diffuser/FAN high endon on event#low do backlog serialsend5 55AA00060005650400010074; publish2 stat/diffuser/FAN low endon","title":"Using dummy GPIO to send Serial codes to the MCU"},{"location":"Rules/#arithmetic-commands-to-be-used-with-vars","text":"ADD ADD1 to ADD5 : Add a value to VARx Syntax: ADDx value Usage: ADD1 15 Result: VAR1 = VAR1 + 15 SUBTRACT SUB1 to SUB5 : Subtract a value from VARx Syntax: SUBx value Usage: SUB1 15 Result: VAR1 = VAR1 - 15 MULTIPLY MULT1 to MULT5 : Multiply a value to VARx Syntax: MULTx value Usage: MULT1 15 Result: VAR1 = VAR1 * 15 SCALE A VALUE SCALE1 to SCALE5 : Scale a value from a low and high limit to another low and high limit and store it in VARx (directly equivalent to MAP arduino command) Syntax: SCALEx value, fromLow, fromHigh, toLow, toHigh where, value : the number to scale fromLow : the lower bound of the value\u2019s current range fromHigh : the upper bound of the value\u2019s current range toLow : the lower bound of the value\u2019s target range toHigh : the upper bound of the value\u2019s target range (omitted values are taken as zero) Usage: SCALE1 15, 0, 100, 0, 1000 Result: VAR1 = 150","title":"Arithmetic commands to be used with VARs"},{"location":"Rules/#transmit-sensor-value-only-when-a-delta-is-reached","text":"Send only when the sensor value changes by a certain amount. Rule1 on SI7021#temperature>%var1% do backlog var1 %value%; publish stat/mqttTopic/temp %value%; var2 %value%; add1 2; sub2 2 endon on SI7021#temperature<%var2% do backlog var2 %value%; publish stat/mqttTopic/temp %value%; var1 %value%; add1 2; sub2 2 endon","title":"Transmit sensor value only when a delta is reached"},{"location":"Rules/#adjust-the-value-of-a-sensor-and-send-it-by-mqtt","text":"This example adds 2 degrees to the measured temperature and then sends that value to an MQTT topic. Rule1 on tele-SI7021#temperature do backlog var1 %value%; add1 2; event sendtemp endon on event#sendtemp do publish stat/mqttTopic/temp %var1% endon","title":"Adjust the value of a sensor and send it by MQTT"},{"location":"Rules/#switch-relays-via-serial-interface","text":"This example switches a connected relays over the software serial on and off. Write the following rules: rule1 on SSerialReceived#Data=on do power1 1 endon on SSerialReceived#Data=off do power1 0 endon receiving on and off results in MQT : tele /mqttTopic/ RESULT = { \"SSerialReceived\" : \"on\" } RUL : SSERIALRECEIVED # DATA = ON performs \"power1 1\" MQT : stat /mqttTopic/ RESULT = { \"POWER\" : \"ON\" } MQT : stat /mqttTopic/ POWER = ON MQT : tele /mqttTopic/ RESULT = { \"SSerialReceived\" : \"off\" } RUL : SSERIALRECEIVED # DATA = OFF performs \"power1 0\" MQT : stat /mqttTopic/ RESULT = { \"POWER\" : \"OFF\" } MQT : stat /mqttTopic/ POWER = OFF","title":"Switch relays via serial interface"},{"location":"Rules/#using-break-to-simulate-ifelseifelseendif","text":"BREAK is an alternative to ENDON . BREAK will stop the execution for the triggers that follow. If a trigger that ends with BREAK fires, then the following triggers of that rule will not be executed. This allows to simulate IF..ELSEIF..ELSE..ENDIF Example: IF temp > 85 then VAR1 more85 ELSEIF temp > 83 then VAR1 more83 ELSEIF temp > 81 then VAR1 more81 ELSEIF temp = 81 then VAR1 equal81 ELSE VAR1 less81 ENDIF With the actual rules, if we use a set like the following: Rule1 on event#temp>85 do VAR1 more85 endon on event#temp>83 do VAR1 more83 endon on event#temp>81 do VAR1 more81 endon on event#temp=81 do VAR1 equal81 endon on event#temp<81 do VAR1 less81 endon This is the output in the console: CMD : rule MQT : stat /living/ RESULT = { \"Rule1\" : \"ON\" , \"Once\" : \"ON\" , \"StopOnError\" : \"OFF\" , \"Free\" : 322 , \"Rules\" : \"on event#temp>85 do VAR1 more85 endon on event#temp>83 do VAR1 more83 endon on event#temp>81 do VAR1 more81 endon on event#temp=81 do VAR1 equal81 endon on event#temp<81 do VAR1 less81 endon\" } CMD : event temp = 10 MQT : stat /living/ RESULT = { \"Event\" : \"Done\" } RUL : EVENT # TEMP < 81 performs \"VAR1 less81\" MQT : stat /living/ RESULT = { \"Var1\" : \"less81\" } CMD : event temp = 100 MQT : stat /living/ RESULT = { \"Event\" : \"Done\" } RUL : EVENT # TEMP > 85 performs \"VAR1 more85\" MQT : stat /living/ RESULT = { \"Var1\" : \"more85\" } RUL : EVENT # TEMP > 83 performs \"VAR1 more83\" MQT : stat /living/ RESULT = { \"Var1\" : \"more83\" } RUL : EVENT # TEMP > 81 performs \"VAR1 more81\" MQT : stat /living/ RESULT = { \"Var1\" : \"more81\" } So, all the triggers where TEMP>100, are firing. With the BREAK statement the rule set can be changed to: Rule on event#temp>85 do VAR1 more85 break on event#temp>83 do VAR1 more83 break on event#temp>81 do VAR1 more81 endon on event#temp=81 do VAR1 equal81 endon on event#temp<81 do VAR1 less81 endon Which will result in the following output: CMD : rule RSL : RESULT = { \"Rule1\" : \"ON\" , \"Once\" : \"OFF\" , \"StopOnError\" : \"OFF\" , \"Free\" : 321 , \"Rules\" : \"on event#temp>85 do VAR1 more85 break on event#temp>83 do VAR1 more83 break on event#temp>81 do VAR1 more81 endon on event#temp=81 do VAR1 equal81 endon on event#temp<81 do VAR1 less81 endon\" } CMD : event temp = 10 RSL : RESULT = { \"Event\" : \"Done\" } RUL : EVENT # TEMP < 81 performs \"VAR1 less81\" RSL : RESULT = { \"Var1\" : \"less81\" } CMD : event temp = 100 RSL : RESULT = { \"Event\" : \"Done\" } RUL : EVENT # TEMP > 85 performs \"VAR1 more85\" RSL : RESULT = { \"Var1\" : \"more85\" } CMD : event temp = 83 RSL : RESULT = { \"Event\" : \"Done\" } RUL : EVENT # TEMP > 81 performs \"VAR1 more81\" RSL : RESULT = { \"Var1\" : \"more81\" }","title":"Using BREAK to simulate IF..ELSEIF..ELSE..ENDIF"},{"location":"Rules/#adjust-powerdelta-according-to-current-power-values","text":"Power sensor reporting thresholds are set by a percentage change in the Power value by setting PowerDelta . Power changes from 10W to 11W (10%) may not be very interesting. But power changes from 1000W to 1100W (also 10%) could be very important. To avoid getting reports for small changes but ensuring that larger power swings are reported, a rule set can be used to create a gradient threshold based on the absolute power values. This rule also uses the one-shot feature of rules to avoid reporting of every small change within a threshold window. The rule (a ON/DO/ENDON rule in this the set) will trigger only once when a threshold is crossed. Backlog PowerDelta 0; Rule1 0; Rule1 5 Rule1 ON ENERGY#Power>=35 DO Backlog PowerDelta 10; Status 8 BREAK ON ENERGY#Power>=15 DO Backlog PowerDelta 25; Status 8 BREAK ON ENERGY#Power>5 DO Backlog PowerDelta 35; Status 8 BREAK ON ENERGY#Power<=5 DO Backlog PowerDelta 100 ENDON Rule1 1 Which translates to: Rule Pseudo Code IF ENERGY#Power>=35 // ENERGY#Power GE 35 DO Backlog PowerDelta 10; Status 8 ELSE IF ENERGY#Power>=15 // ENERGY#Power GE 15 and LT 35 DO Backlog PowerDelta 25; Status 8 ELSE IF ENERGY#Power>5 // ENERGY#Power GT 5 and LT 15 DO Backlog PowerDelta 35; Status 8 ELSE // ENERGY#Power changed (i.e. LE 5) DO PowerDelta 100","title":"Adjust PowerDelta according to current Power values"},{"location":"Rules/#ir-forward","text":"Using one IR receiver and one sender (or both extender) you can simply forward signals from one to another using the following rule rule1 on IRreceived#Data do publish cmnd/irsideboard/irsend {Protocol:NEC,Bits:32,Data:%value%} endon","title":"IR Forward"},{"location":"Rules/#garage-door-opener","text":"( #3942 ) // Set the relay on time to signal the opener PulseTime 7 // Send ON and OFF as the switch is ON or OFF Backlog SwitchMode1 1; SwitchMode2 1; SwitchMode3 1 //No need to save changes on power cycle SetOption0 0 //Don\u2019t blindly run the door on power up PowerOnState 0 //One shot Detection off Backlog Rule1 0; Rule1 4; Rule2 0; Rule2 4; Rule2 0; Rule2 4 //Set Counter to measure the period between on and off, check if its blinking because of an obstruction Backlog CounterType 1; CounterDebounce 100 //So the door doesn't close if you send it an Open when it's already Opened, etc. // var1=1 Only When OPEN // var2=1 Only When CLOSED // var3=1 Only When OPENING // var4=1 Only When CLOSING Rule1 on Switch1#Boot=1 do backlog delay 99; event Opened endon on Switch2#Boot=1 do backlog delay 99; event Closed endon on EVENT#OPEN do power1 %var2% endon on EVENT#CLOSE do power1 %var1% endon on EVENT#STOP do backlog power1 %var3%; power1 %var4%; event PState=STOP endon on Switch1#State=1 do event Opened endon on Switch2#State=1 do event Closed endon on Switch1#State=0 do event Closing endon on Switch2#State=0 do event Opening endon Rule2 on event#Opened do backlog var 1; var2 0; var3 0; var4 0; ruletimer1 0; event PState=OPEN endon on event#Closed do backlog var1 0; var2 1; var3 0; var4 0; ruletimer1 0; event PState=CLOSE endon on event#Opening do backlog var1 0; var2 0; var3 1; var4 0; ruletimer1 15; event PState=OPENING endon on event#Closing do backlog var1 0; var2 0; var3 0; var4 1; ruletimer1 15; event PState=CLOSING endon Rule3 on counter#c1>1000 do event PObstr=0 endon on counter#c1<1000 do event PObstr=1 endon on event#PObstr do publish stat/GarageDoor/OBSTR %value% endon on event#PState do publish stat/GarageDoor/STATE %value% endon on rules#timer=1 do event PState=STOP endon //Turn on Rules Backlog Rule1 1; Rule2 1; Rule3 1","title":"Garage Door Opener"},{"location":"Rules/#remote-control-button-multi-press","text":"For example, a remote control with one button to change speed. This rules simulates pressing the button three times to set the receiving device to the third speed setting. //Specify the rule set //The <trigger> can be a a condition or an event sent from another device or home automation hub. // <topic> corresponds to the device transmitting the code (e.g., YTF IR Bridge ). This could also be modified to send an RF code from a Sonoff RF Bridge . // The Delay may not be necessary in your environment or may need to be adjusted according to your device characteristics. Rule 1 ON Event#tora DO Backlog Publish cmnd/<topic>/IRSend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x00FF30CF\"}; Delay 10 ENDON ON <trigger> DO Backlog Event tora; Event tora; Event tora ENDON //Enable the Rule set Rule1 1","title":"Remote Control Button Multi-press"},{"location":"Rules/#two-way-light-switches-without-mqtt","text":"Two Sonoff T1 3-gang light switches can be used at either end of a room by setting up one the master and the other as the slave. The master performs the switching of the power to the lights, while the slave just asks the master to toggle the power state. The master also turns the slave's relays on and off so that the LED indicators follow the master's state. Using the WebSend command, the two switches can talk to each other - no need for an MQTT broker. It remains to be seen how reliable this is. Starting with the slave, the rule to toggle the master is pretty simple: Rule1 ON Event sendPower DO WebSend [192.168.0.74] POWER%value% TOGGLE ENDON ON Button1#State DO Event sendPower=1 ENDON ON Button2#State DO Event sendPower=2 ENDON ON Button3#State DO Event sendPower=3 ENDON Rule1 1 Note that having a rule for the Button#State disables the power toggling of the slave's relay(s). This is desirable because we want the master to control the slave's relay state(s) according to its own as follows: Rule1 ON Event sendPower DO WebSend [192.168.0.144] POWER%Var1% %value% ENDON ON Power1#state DO Backlog Var1 1;Event sendPower=%value% ENDON ON Power2#state DO Backlog Var1 2;Event sendPower=%value% ENDON ON Power3#state DO Backlog Var1 3;Event sendPower=%value% ENDON Rule1 1","title":"Two-way light switches without MQTT"},{"location":"Rules/#roller-shutter-push-button-toggle","text":"With a two relay device (e.g., Shelly 2.5) configured for a roller shutter, you can also connect push-buttons (configured as switch components in this example) and set them for inverted toggle behavior. Pressing a push-button once makes the roller shutter move in one direction. Pressing it again stops it. These rules each use a variable to remember the shutter state where 0 == Stopped and 1 == Moving . Backlog SwitchTopic 0; SwitchMode1 4; SwitchMode2 4 Rule1 ON Switch1#State==1 DO Add1 1 ENDON ON Var1#State==0 DO ShutterStop1 ENDON ON Var1#State==1 DO ShutterClose1 ENDON ON Var1#State>=2 DO Var1 0 ENDON ON Shutter1#Close DO Var1 0 ENDON ON Switch2#State==1 DO Add2 1 ENDON ON Var2#State==0 DO ShutterStop1 ENDON ON Var2#State==1 DO ShutterOpen1 ENDON ON Var2#State>=2 DO Var2 0 ENDON ON Shutter1#Open DO Var2 0 ENDON Rule1 1","title":"Roller shutter push-button toggle"},{"location":"Rules/#control-a-dimmer-with-one-switch","text":"[!NOTE] This example is for GPIOs defined as switches not buttons Activate dimmer mode with Switchmode 11 and shorten long press time to 1 second ( Setoption32 10 ). A short press of the switch sends a TOGGLE message to toggle the dimmer. A long press sends repeated INC_DEC messages to increment the dimmer. If a second press of the switch follows the first press a INV message is sent to invert the function from increment to decrement and repeatet INC_DEC messages are sent to decrement the dimmer. After releasing the switch a timeout message CLEAR resets the automation Backlog SwitchMode 5; SetOption32 20 Rule1 on system#boot mem1 + endon on switch1#state=2 do publish light/cmnd/POWER TOGGLE endon on switch1#state=4 do publish light/cmnd/DIMMER %mem1% endon on switch1#state=5 do mem1 - endon on switch1#state=6 do mem1 + endon Rule1 1 Notice we use Rule which edits Rule1 rule set. They can be used interchangeably.","title":"Control a dimmer with one switch"},{"location":"SDS011/","text":"!> This feature is included only in tasmota-sensors.bin Nova PM Sensor SDS011 can measure the air quality very accurately by measuring air particles or dust based on laser detection. Specifications: Voltage: 4.7 - 5.3V DC (5V DC with <20mV ripple advised) Power consumption: 70mA \u00b110mA (in operation), <4mA (laser and fan sleep mode) Measuring range: 0.0-999.9 \u03bcg/m3 PM2.5 and PM10 output See manufacturer site for more information. Configuration ~ Wiring ~ SDS011 ESP8266 GND GND 5V 5V TX GPIO RX RX GPIO TX Tasmota Settings ~ In the Configuration -> Configure Module page assign: 1. GPIO RX to SDS0X1 Tx (101) 2. GPIO TX to SDS0X1 Rx (70) Tasmota Main ~ After reboot of the device the displays the SDS011 measurements. OpenHab ~ Number Dust_Sensor_2_5 \"PM 2.5 [%.2f \u00b5g/m\u00b3]\" <door> (Dust) {mqtt=\"<[mosquitto:tele/dust/SENSOR:state:JSONPATH($.SDS0X1['PM2.5'])]\"} Number Dust_Sensor_10 \"PM 10 [%.2f \u00b5g/m\u00b3]\" <door> (Dust) {mqtt=\"<[mosquitto:tele/dust/SENSOR:state:JSONPATH($.SDS0X1['PM10'])]\"}","title":"SDS011"},{"location":"SDS011/#configuration","text":"","title":"Configuration"},{"location":"SDS011/#wiring","text":"SDS011 ESP8266 GND GND 5V 5V TX GPIO RX RX GPIO TX","title":"Wiring"},{"location":"SDS011/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: 1. GPIO RX to SDS0X1 Tx (101) 2. GPIO TX to SDS0X1 Rx (70)","title":"Tasmota Settings"},{"location":"SDS011/#tasmota-main","text":"After reboot of the device the displays the SDS011 measurements.","title":"Tasmota Main"},{"location":"SDS011/#openhab","text":"Number Dust_Sensor_2_5 \"PM 2.5 [%.2f \u00b5g/m\u00b3]\" <door> (Dust) {mqtt=\"<[mosquitto:tele/dust/SENSOR:state:JSONPATH($.SDS0X1['PM2.5'])]\"} Number Dust_Sensor_10 \"PM 10 [%.2f \u00b5g/m\u00b3]\" <door> (Dust) {mqtt=\"<[mosquitto:tele/dust/SENSOR:state:JSONPATH($.SDS0X1['PM10'])]\"}","title":"OpenHab"},{"location":"SHT30/","text":"!> This feature is included only in tasmota-sensors.bin Wemos SHT30 Shield High Precision Humidity & Temperature (I 2 C) sensor From the Wemos SHT30 shield specs the SDA pin on the SHT30 shield is connected to D2 and the SCL pin to D1. Note: v1.0.0 is retired, but v2.0.0 has the same pinout. Configuration ~ As a default the SHT30 uses I 2 C address 0x45 and is user changeable by short-circuiting the two soldering pads at the lower left-side of the sensor (see image below marked green). Also if no other I 2 C devices are connected to the Wemos it might be wise to short-circuit the three soldering pads at the upper left-side of the sensor (see image below marked red). This connects the pull-up resistors for I 2 C and biases the SCL and SDA pins to VCC. This is to avoid possible false detections of other sensors like VEML6070. Tasmota Settings ~ In the Configuration -> Configure Module page assign: 1. D2 GPIO4 to I2C SDA (6) 2. D1 GPIO5 to I2C SCL (5) After reboot of the device the temperature and humidity are displayed. Breakout Boards ~","title":"SHT30"},{"location":"SHT30/#configuration","text":"As a default the SHT30 uses I 2 C address 0x45 and is user changeable by short-circuiting the two soldering pads at the lower left-side of the sensor (see image below marked green). Also if no other I 2 C devices are connected to the Wemos it might be wise to short-circuit the three soldering pads at the upper left-side of the sensor (see image below marked red). This connects the pull-up resistors for I 2 C and biases the SCL and SDA pins to VCC. This is to avoid possible false detections of other sensors like VEML6070.","title":"Configuration"},{"location":"SHT30/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: 1. D2 GPIO4 to I2C SDA (6) 2. D1 GPIO5 to I2C SCL (5) After reboot of the device the temperature and humidity are displayed.","title":"Tasmota Settings"},{"location":"SHT30/#breakout-boards","text":"","title":"Breakout Boards"},{"location":"Scripting-Cookbook/","text":"- Scripting Language Example - Sensor Logging - e-Paper 29 Display with SGP30 and BME280 - e-Paper 42 Display with SHT31 and BME280 - ILI 9488 Color LCD Display with BMP280 and VL5310X - LED Bar Display with WS2812 LED Chain - Multiple IR Receiver Synchronization - Fast Polling - Switching and Dimming By Recognizing Mains Power Frequency - Web UI - Hue Emulation - Alexa Controlled MCP230xx I 2 C GPIO Expander - Retrieve network gateway IP Address - Send e-mail Scripting Language Example Actually this code is too large . This is only meant to show some of the possibilities >D ; define all vars here p:mintmp=10 (p:means permanent) p:maxtmp=30 t:timer1=30 (t:means countdown timer) t:mt=0 i:count=0 (i:means auto counter) hello=\"hello world\" string=\"xxx\" url=\"[ IP ]\" hum=0 temp=0 timer=0 dimmer=0 sw=0 rssi=0 param=0 col=\"\" ocol=\"\" chan1=0 chan2=0 chan3=0 ahum=0 atemp=0 tcnt=0 hour=0 state=1 m:med5=0 M:movav=0 ; define array with 10 entries m:array=0 10 >B string=hello+\"how are you?\" =>print BOOT executed =>print %hello% =>mp3track 1 ; list gpio pin definitions for cnt 0 16 1 tmp=pd[cnt] =>print %cnt% = %tmp% next ; get gpio pin for relais 1 tmp=pn[21] =>print relais 1 is on pin %tmp% ; pulse relais over raw gpio spin(tmp 1) delay(100) spin(tmp 0) ; raw pin level =>print level of gpio1 %pin[1]% ; pulse over tasmota cmd =>power 1 delay(100) =>power 0 >T hum=BME280#Humidity temp=BME280#Temperature rssi=Wifi#RSSI string=SleepMode ; add to median filter median=temp ; add to moving average filter movav=hum ; show filtered results =>print %median% %movav% if chg[rssi]>0 then =>print rssi changed to %rssi% endif if temp>30 and hum>70 then =>print damn hot! endif >S ; every second but not completely reliable time here ; use upsecs and uptime or best t: for reliable timers ; arrays array[1]=4 array[2]=5 tmp=array[1]+array[2] ; call subrountines with parameters =#sub1(\"hallo\") =#sub2(999) ; stop timer after expired if timer1==0 then timer1=-1 =>print timer1 expired endif ; auto counter with restart if count>=10 then =>print 10 seconds over count=0 endif if upsecs%5==0 then =>print %upsecs% (every 5 seconds) endif ; not recommended for reliable timers timer+=1 if timer>=5 then =>print 5 seconds over (may be) timer=0 endif dimmer+=1 if dimmer>100 then dimmer=0 endif =>dimmer %dimmer% =>WebSend %url% dimmer %dimmer% ; show on display dp0 =>displaytext [c1l1f1s2p20] dimmer=%dimmer% =>print %upsecs% %uptime% %time% %sunrise% %sunset% %tstamp% if time>sunset and time< sunrise then ; night time if pwr[1]==0 then =>power1 1 endif else ; day time if pwr[1]>0 then =>power1 0 endif endif ; clr display on boot if boot>0 then =>displaytext [z] endif ; frost warning if temp<0 and mt<=0 then =#sendmail(\"frost alert\") ; alarm only every 5 minutes mt=300 =>mp3track 2 endif ; var has been updated if upd[hello]>0 then =>print %hello% endif ; send to Thingspeak every 60 seconds ; average data in between if upsecs%60==0 then ahum/=tcnt atemp/=tcnt =>WebSend [ IP ]/update?key= token &field1=%atemp%&field2=%ahum% tcnt=0 atemp=0 ahum=0 else ahum+=hum atemp+=temp tcnt+=1 endif hour=int(time/60) if chg[hour]>0 then ; exactly every hour =>print full hour reached endif if time>5 { =>print more then 5 minutes after midnight } else { =>print less then 5 minutes after midnight } ; publish abs hum every teleperiod time if mqtts>0 and upsecs%tper==0 then ; calc abs humidity tmp=pow(2.718281828 (17.67*temp)/(temp+243.5)) tmp=(6.112*tmp*hum*18.01534)/((273.15+temp)*8.31447215) ; publish median filtered value =>Publish tele/%topic%/SENSOR {\"Script\":{\"abshum\":%med(0 tmp)%}} endif ;switch case state machine switch state case 1 =>print state=%state% , start state+=1 case 2 =>print state=%state% state+=1 case 3 =>print state=%state% , reset state=1 ends ; subroutines #sub1(string) =>print sub1: %string% #sub2(param) =>print sub2: %param% #sendmail(string) =>sendmail [smtp.gmail.com:465:user:passwd: sender@gmail.de : rec@gmail.de :alarm] %string% >E =>print event executed! ; get HSBColor 1. component tmp=st(HSBColor , 1) ; check if switch changed state sw=sw[1] if chg[sw]>0 then =>power1 %sw% endif hello=\"event occured\" ; check for Color change (Color is a string) col=Color ; color change needs 2 string vars if col!=ocol then ocol=col =>print color changed %col% endif ; or check change of color channels chan1=Channel[1] chan2=Channel[2] chan3=Channel[3] if chg[chan1]>0 or chg[chan2]>0 or chg[chan3]>0 then => color has changed endif ; compose color string for red col=hn(255)+hn(0)+hn(0) =>color %col% >R =>print restarting now Sensor Logging ; define all vars here ; reserve large strings >D 48 hum=0 temp=0 fr=0 res=0 ; moving average for 60 seconds M:mhum=0 60 M:mtemp=0 60 str=\"\" >B ; set sensor file download link fl1(\"slog.txt\") ; delete file in case we want to start fresh ;fd(\"slog.txt\") ; list all files in root directory fr=fo(\"/\" 0) for cnt 1 20 1 res=fr(str fr) if res>0 then =>print %cnt% : %str% else break endif next fc(fr) >T ; get sensor values temp=BME280#Temperature hum=BME280#Humidity >S ; average sensor values every second mhum=hum mtemp=temp ; write average to sensor log every minute if upsecs%60==0 then ; open file for write fr=fo(\"slog.txt\" 1) ; compose string for tab delimited file entry str=s(upsecs)+\"\\t\"+s(mhum)+\"\\t\"+s(mtemp)+\"\\n\" ; write string to log file res=fw(str fr) ; close file fc(fr) endif >R e-Paper 29 Display with SGP30 and BME280 Some variables are set from ioBroker >D hum=0 temp=0 press=0 ahum=0 tvoc=0 eco2=0 zwz=0 wr1=0 wr2=0 wr3=0 otmp=0 pwl=0 tmp=0 ; DisplayText substituted to save script space DT=\"DisplayText\" ; preset units in case they are not available punit=\"hPa\" tunit=\"C\" >B ;reset auto draw =>%DT% [zD0] ;clr display and draw a frame =>%DT% [x0y20h296x0y40h296] >T ; get telemetry sensor values temp=BME280#Temperature hum=BME280#Humidity press=BME280#Pressure tvoc=SGP30#TVOC eco2=SGP30#eCO2 ahum=SGP30#aHumidity tunit=TempUnit punit=PressureUnit >S // update display every TelePeriod if upsecs%tper==0 then dp2 =>%DT% [f1p7x0y5]%temp% %tunit% =>%DT% [p5x70y5]%hum% %%[x250y5t] =>%DT% [p11x140y5]%press% %punit% =>%DT% [p10x30y25]TVOC: %tvoc% ppb =>%DT% [p10x160y25]eCO2: %eco2% ppm =>%DT% [p10c26l5]ahum: %ahum% g^m3 dp0 =>%DT% [p25c1l5]WR 1 (Dach) : %wr1% W =>%DT% [p25c1l6]WR 2 (Garage): %-wr3% W =>%DT% [p25c1l7]WR 3 (Garten): %-wr2% W =>%DT% [p25c1l8]Aussentemperatur: %otmp% C =>%DT% [x170y95r120:30f2p6x185y100] %pwl% %% ; now update screen =>%DT% [d] endif >E >R e-Paper 42 Display with SHT31 and BME280 This script shows 2 graphs on an 4.2 inch e-Paper display: 1. some local sensors, and 2. power statistics - The first graph is the battery level of a solar battery (Tesla PowerWall 2) - The second graph shows the solar yield of the roof panels in Watts - Another special feature is that this script displays daily and weekly averages (via moving average) of all power IO of the house. - Since the display is a full update panel it is updated only once a minute - Some values (like power meters) are set remotely from ioBroker >D hum=0 temp=0 press=0 zwz=0 wr1=0 wr2=0 wr3=0 otmp=0 pwl=0 ez1=0 sez1=0 M:mez1=0 7 ezh=0 sezh=0 M:mezh=0 7 vzh=0 svzh=0 M:mvzh=0 7 hr=0 t1=0 ; DisplayText substituted to save script space DT=\"DisplayText\" >B =>%DT% [IzD0] =>%DT% [zG10352:5:40:-350:80:10080:0:100f3x360y40]100 %%[x360y115]0 %% =>%DT% [f1x100y25]Powerwall - 7 Tage[f1x360y75] 0 %% =>%DT% [G10353:5:140:-350:80:10080:0:5000f3x360y140]+5000 W[x360y215]0 W =>%DT% [f1x70y125]Volleinspeisung - 7 Tage[f1x360y180] 0 W =>%DT% [p13x10y230]WR 1,2,3: =>%DT% [p13x10y245]H-Einsp.: =>%DT% [p13x10y260]H-Verbr.: =>%DT% [p13x10y275]D-Einsp.: =>%DT% [d] >T press=BMP280#Pressure temp=SHT3X_0x44#Temperature hum=SHT3X_0x44#Humidity >S if upsecs%60==0 then dp2 =>%DT% [f1p7x0y5]%temp% C =>%DT% [x0y20h400x250y5T][x350t][f1p10x70y5]%hum% %% =>%DT% [p10x140y5]%press% hPa dp0 =>%DT% [p5x360y75]%pwl% %% =>%DT% [p6x360y180]%wr1%W =>%DT% [g0:%pwl%g1:%wr1%] =>%DT% [p24x75y230] %wr1% W : %-wr2% W : %-wr3% W =>%DT% [p-10x75y245]%ezh% kWh =>%DT% [p-10x75y260]%vzh% kWh =>%DT% [p-10x75y275]%ez1% kWh t1=mezh 7 =>%DT% [p-10x150y245]: %t1% kWh t1=mvzh 7 =>%DT% [p-10x150y260]: %t1% kWh t1=mez1*7 =>%DT% [p-10x150y275]: %t1% kWh dp1 t1=ezh-sezh =>%DT% [p12x250y245]: %t1% kWh t1=vzh-svzh =>%DT% [p12x250y260]: %t1% kWh t1=ez1-sez1 =>%DT% [p12x250y275]: %t1% kWh dp0 =>%DT% [f2p5x320y250] %otmp%C =>%DT% [d] endif hr=hours if chg[hr]>0 and hr==0 then mez1=ez1-sez1 sez1=ez1 mezh=ezh-sezh sezh=ezh mvzh=vzh-svzh svzh=vzh endif if sezh==0 then sez1=ez1 sezh=ezh svzh=vzh endif ILI 9488 Color LCD Display with BMP280 and VL5310X Shows various BMP280 energy graphs Turn display on and off using VL5310X proximity sensor to prevent burn-in Some variables are set from ioBroker >D temp=0 press=0 zwz=0 wr1=0 wr2=0 wr3=0 otmp=0 pwl=0 tmp=0 dist=0 ; DisplayText substituted to save script space DT=\"DisplayText\" punit=\"hPa\" tunit=\"C\" hour=0 >B =>%DT% [z] // define 2 graphs, 2. has 3 tracks =>%DT% [zCi1G2656:5:20:400:80:1440:-5000:5000:3Ci7f3x410y20]+5000 W[x410y95]-5000 W [Ci7f1x70y3] Zweirichtungsz~80hler - 24 Stunden =>%DT% [Ci1G2657:5:120:400:80:1440:0:5000:3Ci7f3x410y120]+5000 W[x410y195]0 W [Ci7f1x70y103] Wechselrichter 1-3 - 24 Stunden =>%DT% [Ci1G2658:5:120:400:80:1440:0:5000:16][Ci1G2659:5:120:400:80:1440:0:5000:5] =>%DT% [f1s1b0:260:260:100\u200b:50:2:11:4:2:Rel 1:b1:370:260:100\u200b:50:2:11:4:2:Dsp off:] =>mp3volume 100 =>mp3track 4 >T ; get some telemetry values temp=BMP280#Temperature press=BMP280#Pressure tunit=TempUnit punit=PressureUnit dist=VL53L0X#Distance ; check proximity sensor to turn display on and off to prevent burn-in if dist>300 then if pwr[2]>0 then =>power2 0 endif else if pwr[2]==0 then =>power2 1 endif endif >S ; update graph every teleperiod if upsecs%tper==0 then dp2 =>%DT% [f1Ci3x40y260w30Ci1] =>%DT% [Ci7x120y220t] =>%DT% [Ci7x180y220T] =>%DT% [Ci7p8x120y240]%temp% %tunit% =>%DT% [Ci7x120y260]%press% %punit% =>%DT% [Ci7x120y280]%dist% mm dp0 =>%DT% [g0:%zwz%g1:%wr1%g2:%-wr2%g3:%-wr3%] if zwz>0 then =>%DT% [p-8x410y55Ci2Bi0]%zwz% W else =>%DT% [p-8x410y55Ci3Bi0]%zwz% W endif =>%DT% [p-8x410y140Ci3Bi0]%wr1% W =>%DT% [p-8x410y155Ci16Bi0]%-wr2% W =>%DT% [p-8x410y170Ci5Bi0]%-wr3% W endif ; chime every full hour hour=int(time/60) if chg[hour]>0 then =>mp3track 4 endif >E >R LED Bar Display with WS2812 LED Chain Used to display home's solar power input/output (+-5000 Watts) >D m:array=0 60 ;defines array for 60 led pixels cnt=0 val=0 ind=0 ; rgb values for grid colr1=0x050000 colr2=0x050100 colg1=0x000300 colg2=0x020300 ledbar=0 blue=64 pixels=60 steps=10 div=0 tog=0 max=5000 min=-5000 pos=0 >B div=pixels/steps =#prep ws2812(array) ; ledbar is set from broker >S if ledbar<min then ledbar=min endif if ledbar>max then ledbar=max endif pos=(ledbar/max)*(pixels/2) if ledbar>0 then pos+=(pixels/2) if pos>pixels-1 then pos=pixels endif else pos+=(pixels/2)+1 if pos>pixels-1 then pos=1 endif endif if pos<1 or pos>pixels then pos=1 endif =#prep if ledbar==0 then array[pos]=blue array[pos-1]=blue else array[pos]=blue endif ; only used if power is off ; so lets may be used normally if on if pwr[1]==0 then ws2812(array) endif ; subroutine for grid prep ~ for cnt 1 pixels 1 ind+=1 if ind>div then ind=1 tog^=1 endif if cnt<=pixels/2 then if tog>0 then val=colr1 else val=colr2 endif else if tog>0 then val=colg1 else val=colg2 endif endif array[cnt]=val next >R Multiple IR Receiver Synchronization Shows how a Magic Home with IR receiver works Synchronizes 2 Magic Home devices by also sending the commands to a second Magic Home via WebSend Script example using if then else ; expand default string length to be able to hold WebSend [xxx.xxx.xxx.xxx] >D 25 istr=\"\" ws=\"WebSend [ IP ]\" ; event section >E ; get ir data istr=IrReceived#Data ; on if istr==\"0x00F7C03F\" then =>wakeup =>%ws% wakeup endif ; off if istr==\"0x00F740BF\" then =>power1 0 =>%ws% power1 0 endif ;white if istr==\"0x00F7E01F\" then =>color 000000ff =>%ws% color 000000ff endif ;red if istr==\"0x00F720DF\" then =>color ff000000 =>%ws% color ff000000 endif ;green if istr==\"0x00F7A05F\" then =>color 00ff0000 =>%ws% color 00ff0000 endif ;blue if istr==\"0x00F7609F\" then =>color 0000ff00 =>%ws% color 0000ff00 endif ; dimmer up if istr==\"0x00F700FF\" then =>dimmer + =>%ws% dimmer + endif ;dimmer down if istr==\"0x00F7807F\" then =>dimmer - =>%ws% dimmer - endif istr=\"\" Script example using switch case ends ; expand default string length to be able to hold WebSend [xxx.xxx.xxx.xxx] >D 25 istr=\"\" ws=\"WebSend [ IP ]\" ; event section >E ; get ir data istr=IrReceived#Data switch istr ; on case \"0x00F7C03F\" =>wakeup =>%ws% wakeup ;off case \"0x00F740BF\" =>power1 0 =>%ws% power1 0 ;white case \"0x00F7E01F\" =>color 000000ff =>%ws% color 000000ff ;red case \"0x00F720DF\" =>color ff000000 =>%ws% color ff000000 ;green case \"0x00F7A05F\" =>color 00ff0000 =>%ws% color 00ff0000 ;blue case \"0x00F7609F\" =>color 0000ff00 =>%ws% color 0000ff00 ; dimmer up case \"0x00F700FF\" =>dimmer + =>%ws% dimmer + ; dimmer down case \"0x00F7807F\" =>dimmer - =>%ws% dimmer - ends istr=\"\" Fast Polling ; expand default string length to be able to hold WebSend [xxx.xxx.xxx.xxx] >D 25 sw=0 ws=\"WebSend [ IP ]\" timer=0 hold=0 toggle=0 >B ; gpio 5 button input spinm(5,0) ; fast section 100ms >F sw=pin[5] ; 100 ms timer timer+=1 ; 3 seconds long press ; below 0,5 short press if sw==0 and timer>5 and timer<30 then ; short press ;=>print short press toggle^=1 =>%ws% power1 %toggle% endif if sw>0 then ;pressed if timer>30 then ; hold hold=1 ;=>print hold=%timer% if toggle>0 then =>%ws% dimmer + else =>%ws% dimmer - endif endif else timer=0 hold=0 endif Switching and Dimming By Recognizing Mains Power Frequency Switching in Tasmota is usually done by High/Low (+3.3V/GND) changes on a GPIO. However, for devices like the Moes QS-WiFi-D01 Dimmer , this is achieved by a pulse frequency when connected to the GPIO, and these pulses are captured by Counter1 in Tasmota. When the light is OFF and there is a short period of pulses -> then turn the light ON at the previous dimmer level. When the light is ON and there is a short period of pulses -> then turn the light OFF . When there is a longer period of pulses (i.e., HOLD ) -> toggle dimming direction and then adjust the brightness level as long as the button is pressed or until the limits are reached. #6085 (comment) In the Data Section >D at the beginning of the Script the following initialization variables may be changed: - dim multiplier - 0..2.55 set the dimming increment value - dim lower limit - range for the dimmer value for push-button operation (set according to your bulb); min 0 - dim upper limit - range for the dimmer value for push-button operation (set according to your bulb); max 100 - start dim level - initial dimmer level after power-up or restart; max 100 >D sw=0 tmp=0 cnt=0 tmr=0 hold=0 powert=0 slider=0 dim=\"\" shortprl=2 ;short press lo limit shortpru=10;short press up limit dimdir=0 ;dim direction 0/1 dimstp=2 ;dim step/speed 1 to 5 dimmlp=2.2 ;dim multiplier dimll=15 ;dim lower limit dimul=95 ;dim upper limit dimval=70 ;start dim level >B =>print \"WiFi-Dimmer-Script-v0.2\" =>Counter1 0 =>Baudrate 9600 ; boot sequence =#senddim(dimval) delay(1000) =#senddim(0) >F cnt=pc[1] if chg[cnt]>0 ; sw pressed then sw=1 else sw=0 ; sw not pressed endif ; 100ms timer tmr+=1 ; short press if sw==0 and tmr>shortprl and tmr<shortpru then powert^=1 ; change light on/off if powert==1 then =#senddim(dimval) else =#senddim(0) endif endif ; long press if sw>0 then if hold==0 then ; change dim direction dimdir^=1 endif if tmr>shortpru then hold=1 if powert>0 ; dim when on & hold then if dimdir>0 then ; increase dim level dimval+=dimstp if dimval>dimul then ; upper limit dimval=dimul endif =#senddim(dimval) else ; decrease dim level dimval-=dimstp if dimval<dimll then ; lower limit dimval=dimll endif =#senddim(dimval) endif endif endif else tmr=0 hold=0 endif >E slider=Dimmer ; slider change if chg[slider]>0 then ; dim according slider if slider>0 then dimval=slider =#senddim(dimval) else powert=0 =#senddim(0) endif endif if pwr[1]==1 ; on/off webui then powert=1 =#senddim(dimval) else powert=0 =#senddim(0) endif ; subroutine dim senddim(tmp) ~ dim=\"FF55\"+hn(tmp*dimmlp)+\"05DC0A\" =>SerialSend5 %dim% =>Dimmer %tmp% # Web UI An example to show how to implement a web UI. This example controls a light via WebSend >D dimmer=0 sw=0 color=\"\" col1=\"\" red=0 green=0 blue=0 ww=0 >F color=hn(red)+hn(green)+hn(blue)+hn(ww) if color!=col1 then col1=color =>websend [192.168.178.75] color %color% endif if chg[dimmer]>0 then =>websend [192.168.178.75] dimmer %dimmer% endif if chg[sw]>0 then =>websend [192.168.178.75] power1 %sw% endif >W bu(sw \"Light on\" \"Light off\") ck(sw \"Light on/off \") sl(0 100 dimmer \"0\" \"Dimmer\" \"100\") sl(0 255 red \"0\" \"red\" \"255\") sl(0 255 green \"0\" \"green\" \"255\") sl(0 255 blue \"0\" \"blue\" \"255\") sl(0 255 ww \"0\" \"warm white\" \"255\") tx(color \"color: \") Hue Emulation An example to show how to respond to Alexa requests via Hue Emulation When Alexa sends on/off, dimmer, and color (via hsb), send commands to a MagicHome device >D pwr1=0 hue1=0 sat1=0 bri1=0 tmp=0 >E if upd[hue1]>0 or upd[sat1]>0 or upd[bri1]>0 then tmp=hue1/182 ->websend [192.168.178.84] hsbcolor %tmp%,%sat1%,%bri1% endif if upd[pwr1]>0 then ->websend [192.168.178.84] power1 %pwr1% endif >H ; on,hue,sat,bri,ct livingroom,E,on=pwr1,hue=hue1,sat=sat1,bri=bri1 Alexa Controlled MCP230xx I 2 C GPIO Expander Uses Tasmota's Hue Emulation capabilities for Alexa interface ; define vars >D p:p1=0 p:p2=0 p:p3=0 p:p4=0 ; init ports >B ->sensor29 0,5,0 ->sensor29 1,5,0 ->sensor29 2,5,0 ->sensor29 3,5,0 ->sensor29 0,%0p1% ->sensor29 1,%0p2% ->sensor29 2,%0p3% ->sensor29 3,%0p4% ; define Alexa virtual devices >H port1,S,on=p1 port2,S,on=p2 port3,S,on=p3 port4,S,on=p4 ; handle events >E print EVENT if upd[p1]>0 then ->sensor29 0,%0p1% endif if upd[p2]>0 then ->sensor29 1,%0p2% endif if upd[p3]>0 then ->sensor29 2,%0p3% endif if upd[p4]>0 then ->sensor29 3,%0p4% endif =#pub ; publish routine pub ~ =>publish stat/%topic%/RESULT {\"MCP23XX\":{\"p1\":%0p1%,\"p2\":%0p2%,\"p3\":%0p3%,\"p4\":%0p4%}} svars ; web interface >W bu(p1 \"p1 on\" \"p1 off\")bu(p2 \"p2 on\" \"p2 off\")bu(p3 \"p3 on\" \"p3 off\")bu(p4 \"p4 on\" \"p4 off\") Retrieve network gateway IP Address >D gw=\"\" ; Request Status information. The response will trigger the >U section >B +>status 5 ; Read the status JSON payload >U gw=StatusNET#Gateway print %gw% Send e-mail >D 25 day1=0 et=0 to=\"mrx@gmail.com\" >T et=ENERGY#Total >S ; send at midnight day1=day if chg[day1]>0 then =>sendmail [*:*:*:*:*:\\%to\\%:energy report]* endif >m email report at %tstamp% your power consumption today was %et% KWh #","title":"Scripting Cookbook"},{"location":"Scripting-Cookbook/#prep","text":"for cnt 1 pixels 1 ind+=1 if ind>div then ind=1 tog^=1 endif if cnt<=pixels/2 then if tog>0 then val=colr1 else val=colr2 endif else if tog>0 then val=colg1 else val=colg2 endif endif array[cnt]=val next >R","title":"prep"},{"location":"Scripting-Cookbook/#senddimtmp","text":"dim=\"FF55\"+hn(tmp*dimmlp)+\"05DC0A\" =>SerialSend5 %dim% =>Dimmer %tmp% #","title":"senddim(tmp)"},{"location":"Scripting-Cookbook/#pub","text":"=>publish stat/%topic%/RESULT {\"MCP23XX\":{\"p1\":%0p1%,\"p2\":%0p2%,\"p3\":%0p3%,\"p4\":%0p4%}} svars ; web interface >W bu(p1 \"p1 on\" \"p1 off\")bu(p2 \"p2 on\" \"p2 off\")bu(p3 \"p3 on\" \"p3 off\")bu(p4 \"p4 on\" \"p4 off\")","title":"pub"},{"location":"Scripting-Language/","text":"This feature is not included in precompiled binaries To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_SCRIPT #define USE_SCRIPT // adds about 17k flash size, variable ram size #endif #ifdef USE_RULES #undef USE_RULES #endif Optional Includes Additional features are enabled by adding the following #define compiler directive parameters and then compiling the firmware. These parameters are explained further below in the article. Feature Description USE_BUTTON_EVENT enable >b section (detect button state changes) USE_SCRIPT_JSON_EXPORT enable >J section (publish JSON payload on TelePeriod ) USE_SCRIPT_SUB_COMMAND enables invoking named script subroutines via the Console or MQTT USE_SCRIPT_HUE enable >H section (Alexa Hue emulation) USE_SCRIPT_STATUS enable >U section (receive JSON payloads) SCRIPT_POWER_SECTION enable >P section (execute on power changes) SUPPORT_MQTT_EVENT enables support for subscribe unsubscribe USE_SENDMAIL enable >m section and support for sending e-mail USE_SCRIPT_WEB_DISPLAY enable >W section (modify web UI) USE_TOUCH_BUTTONS enable virtual touch button support with touch displays USE_WEBSEND_RESPONSE enable receiving the response of a WebSend command (received in section E) SCRIPT_STRIP_COMMENTS enables stripping comments when attempting to paste a script that is too large to fit USE_ANGLE_FUNC add sin(x),acos(x) and sqrt(x) e.g. to allow calculation of horizontal cylinder volume USE_24C256 enables use of 24C256 I 2 C EEPROM to expand script buffer (defaults to 4k) USE_SCRIPT_FATFS enables SD card support (on SPI bus). Specify the CS pin number. Also enables 4k script buffer USE_SCRIPT_FATFS_EXT enables additional FS commands SDCARD_DIR enables support for web UI for SD card directory upload and download Features ~ Scripting Language for Tasmota is an alternative to Tasmota Rules . To enter a script, go to Configuration -> Edit script in the Tasmota web UI menu The maximum script size is 1535 bytes (uses rule set buffers). If the pasted script is larger than 1535 characters, comments will be stripped to attempt to make the script fit. To save code space almost no error messages are provided. However it is taken care of that at least it should not crash on syntax errors. Features - Up to 50 variables (45 numeric and 5 strings - this may be changed by setting a compilation #define directive) - Freely definable variable names (all variable names are intentionally case sensitive ) - Nested if,then,else up to a level of 8 - Math operators + , - , * , / , % , & , | , ^ - All operators may be used in the op= form, e.g., += - Comparison operators == , != , > , >= , < , <= - and , or support - Hexadecimal numbers with prefix 0x are supported - Strings support + and += operators - Support for \\n \\r regular expressions on strings - String comparison == , != - String size is 19 characters (default). This can be increased or decreased by the optional parameter on the >D section definition Script Interpreter - Execution is strictly sequential , line by line - Evaluation is left to right with optional brackets - All numbers are float , e.g., temp=hum*(100/37.5)+temp-(timer*hum%10) - No spaces are allowed between math operators - Comments start with ; Console Commands script <n> \\ : 0 = switch script off; 1 = switch script on script ><cmdline> execute \\ - Can be used to set variables, e.g., script >mintmp=15 - Multiple statements can be specified by separating each with a semicolon, e.g. script >mintmp=15;maxtemp=40 - The script itself can't be specified because the size would not fit the MQTT buffers Script Sections ~ Section descriptors (e.g., >E ) are case sensitive >D ssize ssize = optional max string size (default=19) define and init variables here, must be the first section, no other code allowed p:vname specifies permanent variables. The number of permanent variables is limited by Tasmota rules space (50 bytes) - numeric variables are 4 bytes; string variables are one byte longer than the length of string t:vname specifies countdown timers, if >0 they are decremented in seconds until zero is reached. see example below i:vname specifies auto increment counters if >=0 (in seconds) m:vname specifies a median filter variable with 5 entries (for elimination of outliers) M:vname specifies a moving average filter variable with 8 entries (for smoothing data) (max 5 filters in total m+M) optional another filter length (1..127) can be given after the definition. Filter vars can be accessed also in indexed mode vname[x] (x = 1..N , x = 0 returns current array index pointer) Using this filter, vars can be used as arrays [!TIP] Keep variable names as short as possible. The length of all variable names taken together may not exceed 256 characters. Memory is dynamically allocated as a result of the D section. Copying a string to a number or reverse is supported >B executed on BOOT time and on save script >E Executed when a Tasmota MQTT RESULT message is received, e.g., on POWER change >F Executed every 100 ms >S Executed every second >R Executed on restart. p vars are saved automatically after this call >T Executed on TelePeriod time ( SENSOR and STATE ), only put tele- vars in this section Remark: json variable names (like all others) may not contain math operators like - , you should set SetOption64 1 to replace - ( dash ) with _ ( underscore ) >H Alexa Hue interface (up to 32 virtual hue devices) ( example ) device , type , onVars Remark: hue values have a range from 0-65535. Divide by 182 to assign HSBcolors hue values. device device name type device type - E = extended color; S = switch onVars assign Hue \"on\" extended color parameters for hue, saturation, brightness, and color temperature (hue,sat,bri,ct) to scripter variables [!EXAMPLE] lamp1,E,on=pwr1,hue=hue1,sat=sat1,bri=bri1,ct=ct1 >U status JSON Messages arrive here >b (note lower case) executed on button state change bt[x] read button state (x = 1.. MAX_KEYS ) [!EXAMPLE] if bt[1]==0 then print falling edge of button1 endif if bt[1]==1 then print rising edge of button1 endif >J The lines in this section are published via MQTT in a JSON payload on TelePeriod . Requires compiling with #define USE_SCRIPT_JSON_EXPORT . >W The lines in this section are displayed in the web UI main page. Requires compiling with #define USE_SCRIPT_WEB_DISPLAY . You may put any html code here. - Variables may be substituted using %var% - HTML statements are displayed in the sensor section of the main page - HTML statements preceded with a @ are displayed at the top of the page - USER IO elements are displayed at the top of the page A web user interface may be generated containing any of the following elements: toggle button, check box, slider, or text and number input. - Button: bu(<vn> <txt1> <txt2>) (up to 4 buttons may be defined in one row) <vn> = name of variable to hold button state <txt1> = text of ON state of button <txt2> = text of OFF state of button - Checkbox: ck(<vn> <txt>) <vn> = name of variable to hold checkbox state <txt> = label text - Slider: sl(<min> <max> <vn> <ltxt> <mtxt> <rtxt>) <min> = slider minimum value <max> = slider maximum value <vn> = name of variable to hold slider value <ltxt> = label left of slider <mtxt> = label middle of slider <rtxt> = label right of slider - Text Input: tx(<vn> <txt>) <vn> = name of string variable to hold text state <txt> = label text - Number Input: nm(<min <max> <step> <vn> <txt>) <min> = number minimum value <max> = number maximum value <step> = number step value for up/down arrows <vn> = name of number variable to hold number <txt> = label text >M Smart Meter Interface If a variable does not exist, ??? is displayed for commands If a Tasmota SENSOR or STATUS or RESULT message is not generated or a Var does not exist the destination variable is NOT updated. Special Variables ~ (read only) upsecs = seconds since start uptime = minutes since start time = minutes since midnight sunrise = sunrise minutes since midnight sunset = sunset minutes since midnight tper = TelePeriod ( may be set also ) tstamp = timestamp (local date and time) topic = mqtt topic gtopic = mqtt group topic prefixn = prefix n = 1-3 pwr[x] = power state (x = 1..N) pc[x] = pulse counter value (x = 1..4) tbut[x] = touch screen button state (x = 1..N) sw[x] = switch state (x = 1..N) bt[x] = button state (x = 1..N) only valid in section >b (if defined USE_BUTTON_EVENT) pin[x] = GPIO pin level (x = 0..16) pn[x] = GPIO for sensor code x. 99 if none pd[x] = defined sensor for GPIO x. 999 if none sht[x] = shutter position (x = 1..N) (if defined USE_SHUTTER) gtmp = global temperature ghum = global humidity gprs = global pressure pow(x y) = calculates exponential powers x^y med(n x) = calculates a 5 value median filter of x (2 filters possible n=0,1) int(x) = gets the integer part of x (like floor) hn(x) = converts x (0..255) to a hex nibble string hx(x) = converts x (0..65535) to a hex string st(svar c n) = string token - retrieve the n th element of svar delimited by c sl(svar) = gets the length of a string sb(svar p n) = gets a substring from svar at position p (if p<0 counts from end) and length n sin(x) = calculates the sinus(x) (if defined USE_ANGLE_FUNC) acos(x) = calculates the acos(x) (if defined USE_ANGLE_FUNC) sqrt(x) = calculates the sqrt(x) (if defined USE_ANGLE_FUNC) s(x) = explicit conversion from number x to string mqtts = MQTT connection status: 0 = disconnected, >0 = connected wifis = Wi-Fi connection status: 0 = disconnected, >0 = connected hours = hours mins = mins secs = seconds day = day of month wday = day of week month = month year = year epoch = epoch time (from 2019-1-1 00:00) The following variables are cleared after reading true: chg[var] = true if a variables value was changed (numeric vars only) upd[var] = true if a variable was updated boot = true on BOOT tinit = true on time init tset = true on time set mqttc = true on mqtt connect mqttd = true on mqtt disconnect wific = true on wifi connect wifid = true on wifi disconnect System variables (for debugging) stack = stack size heap = heap size ram = used ram size slen = script length micros = running microseconds millis = running milliseconds loglvl = loglevel of script cmds ( may be set also ) Remarks: If you define a variable with the same name as a special variable that special variable is discarded Commands ~ => <command> Execute \\ recursion disabled +> <command> Execute \\ recursion enabled -> <command> Execute \\ - do not send MQTT or log messages (i.e., silent execute - useful to reduce traffic) Variable Substitution - A single percent sign must be given as %% - Variable replacement within commands is allowed using %varname% . Optionally, the decimal places precision for numeric values may be specified by placing a digit ( %Nvarname% , N = 0..9 ) in front of the substitution variable (e.g., Humidity: %3hum%%% will output Humidity: 43.271% ) - Linefeed and carriage return may be defined by \\n and \\r Special commands: print or => print prints to the log for debugging A Tasmota MQTT RESULT message invokes the script's >E section. Add => print statements to debug a script. [!EXAMPLE] ``` slider=Dimmer power=POWER if upd[slider]>0 then =>print slider updated %slider% endif if upd[power]>0 then =>print power updated %power% endif ``` break exits a section or terminates a for next loop dpx sets decimal precision to x (0-9) svars save permanent vars delay(x) pauses x milliseconds (should be as short as possible) spin(x b) set GPIO x (0..16) to value b (0,1). Only bit 0 of b is used - even values set the GPIO to 0 and uneven values set the GPIO to 1 spinm(x m) set GPIO x (0..16) to mode m (input=0, output=1, input with pullup=2) ws2812(array) copies an array (defined with m:vname ) to the WS2812 LED chain. The array length should be defined as long as the number of pixels. Color is coded as 24 bit RGB. hsvrgb(h s v) converts hue (0..360), saturation (0..100) and value (0..100) to RGB color #name names a subroutine. Subroutine is called with =#name #name(param) names a subroutine with a parameter. Subroutine is called with =#name(param) Subroutines end with the next # or > line or break. Subroutines may be nested Parameters can be numbers or strings and on type mismatch are converted If #define USE_SCRIPT_SUB_COMMAND is included in your user_config_override.h , a subroutine may be invoked via the Console or MQTT using the subroutine's name. For example, a declared subroutine #SETLED(num) may be invoked by typing SETLED 1 in the Console. The parameter 1 is passed into the num argument. This also works with string parameters. It is possible to \"replace\" internal Tasmota commands. For example, if a #POWER1(num) subroutine is declared, the command POWER1 is processed in the scripter instead of in the main Tasmota code. =(svar) executes a routine whose name is passed as a string in a variable (dynamic or self modifying code). The string has to start with => or =# for the routine to be executed. > D svar = \"=#subroutine\" > S = ( svar ) # subroutine => print subroutine was executed For loop (loop count must not be less than 1) for var <from> <to> <inc> next Switch selector (numeric or string) switch x case a case b ends Conditional Statements There are two syntax alternatives. You may NOT mix both formats. if a==b and x==y or k==i then => do this else => do that endif or if a==b and x==y or k==i { => do this } else { => do that } Remarks: The last closing bracket must be on a separate line Calculations are permitted in conditional expressions, e.g., if var1-var2==var3*var4 Conditional expressions may be enclosed in parentheses. The statement must be on a single line. e.g., if ((a==b) and ((c==d) or (c==e)) and (s!=\"x\")) E-mail #define USE_SENDMAIL Enabling this feature also enables Tasmota TLS as sendmail uses SSL. sendmail [server:port:user:passwd:from:to:subject] msg [!EXAMPLE] sendmail [smtp.gmail.com:465:user:passwd:sender@gmail.com:<rec@gmail.com>:alarm] %string% Remark: A number of e-mail servers (such as Gmail) require the receiver's e-mail address to be enclosed by < ... > as in example above. Most other e-mail servers also accept this format. The following parameters can be specified during compilation via #define directives in user_config_override.h : * EMAIL_SERVER * EMAIL_PORT * EMAIL_USER * EMAIL_PASSWORD * EMAIL_FROM To use any of these values, pass an * as its corresponding argument placeholder. [!EXAMPLE] sendmail [*:*:*:*:*:<rec@gmail.com>:theSubject] theMessage Instead of passing the msg as a string constant, the body of the e-mail message may also be composed using the script >m (note lower case) section. The specified text in this script section must end with an # character. sendmail will use the >m section if * is passed as the msg parameter. See [Scripting Cookbook Example].(Scripting-Cookbook#Send-e-mail) Subscribe, Unsubscribe #define SUPPORT_MQTT_EVENT subscribe and unsubscribe commands are supported. In contrast to rules, no event is generated but the event name specifies a variable defined in >D section and this variable is automatically set on transmission of the subscribed item SD Card Support (+ 10k flash) #define USE_SCRIPT_FATFS CARD_CS CARD_CS = GPIO of card chip select SD card uses standard hardware SPI GPIO: mosi,miso,sclk A maximum of four files may be open at a time e.g., allows for logging sensors to a tab delimited file and then downloading the file ( see Sensor Logging example ) The downloading of files may be executed in a kind of \"multitasking\" when bit 7 of loglvl is set (128+loglevel) Without multitasking 150kb/s (all processes are stopped during downloading), with multitasking 50kb/s (other Tasmota processes are running) The script itself is also stored on the SD card with a default size of 4096 characters Enable SD card directory support (+ 1,2k flash) #define SDCARD_DIR Shows a web SD card directory (submenu of scripter) where you can upload and download files to/from sd card fr=fo(\"fname\" m) open file fname, mode 0=read, 1=write (returns file reference (0-3) or -1 for error) res=fw(\"text\" fr) writes text to (the end of) file fr, returns number of bytes written res=fr(svar fr) reads a string into svar, returns bytes read. String is read until delimiter (\\t \\n \\r) or eof fc(fr) close file ff(fr) flush file, writes cached data and updates directory fd(\"fname\") delete file fname flx(fname) create download link for file (x=1 or 2) fname = file name of file to download fsm return 1 if filesystem is mounted, (valid SD card found) Extended commands (+0,9k flash) #define USE_SCRIPT_FATFS_EXT fmd(\"fname\") make directory fname frd(\"fname\") remove directory fname fx(\"fname\") check if file fname exists fe(\"fname\") execute script fname (max 2048 bytes, script must start with the '>' character on the first line) Scripting Cookbook ~","title":"Scripting"},{"location":"Scripting-Language/#features","text":"Scripting Language for Tasmota is an alternative to Tasmota Rules . To enter a script, go to Configuration -> Edit script in the Tasmota web UI menu The maximum script size is 1535 bytes (uses rule set buffers). If the pasted script is larger than 1535 characters, comments will be stripped to attempt to make the script fit. To save code space almost no error messages are provided. However it is taken care of that at least it should not crash on syntax errors. Features - Up to 50 variables (45 numeric and 5 strings - this may be changed by setting a compilation #define directive) - Freely definable variable names (all variable names are intentionally case sensitive ) - Nested if,then,else up to a level of 8 - Math operators + , - , * , / , % , & , | , ^ - All operators may be used in the op= form, e.g., += - Comparison operators == , != , > , >= , < , <= - and , or support - Hexadecimal numbers with prefix 0x are supported - Strings support + and += operators - Support for \\n \\r regular expressions on strings - String comparison == , != - String size is 19 characters (default). This can be increased or decreased by the optional parameter on the >D section definition Script Interpreter - Execution is strictly sequential , line by line - Evaluation is left to right with optional brackets - All numbers are float , e.g., temp=hum*(100/37.5)+temp-(timer*hum%10) - No spaces are allowed between math operators - Comments start with ; Console Commands script <n> \\ : 0 = switch script off; 1 = switch script on script ><cmdline> execute \\ - Can be used to set variables, e.g., script >mintmp=15 - Multiple statements can be specified by separating each with a semicolon, e.g. script >mintmp=15;maxtemp=40 - The script itself can't be specified because the size would not fit the MQTT buffers","title":"Features"},{"location":"Scripting-Language/#script-sections","text":"Section descriptors (e.g., >E ) are case sensitive >D ssize ssize = optional max string size (default=19) define and init variables here, must be the first section, no other code allowed p:vname specifies permanent variables. The number of permanent variables is limited by Tasmota rules space (50 bytes) - numeric variables are 4 bytes; string variables are one byte longer than the length of string t:vname specifies countdown timers, if >0 they are decremented in seconds until zero is reached. see example below i:vname specifies auto increment counters if >=0 (in seconds) m:vname specifies a median filter variable with 5 entries (for elimination of outliers) M:vname specifies a moving average filter variable with 8 entries (for smoothing data) (max 5 filters in total m+M) optional another filter length (1..127) can be given after the definition. Filter vars can be accessed also in indexed mode vname[x] (x = 1..N , x = 0 returns current array index pointer) Using this filter, vars can be used as arrays [!TIP] Keep variable names as short as possible. The length of all variable names taken together may not exceed 256 characters. Memory is dynamically allocated as a result of the D section. Copying a string to a number or reverse is supported >B executed on BOOT time and on save script >E Executed when a Tasmota MQTT RESULT message is received, e.g., on POWER change >F Executed every 100 ms >S Executed every second >R Executed on restart. p vars are saved automatically after this call >T Executed on TelePeriod time ( SENSOR and STATE ), only put tele- vars in this section Remark: json variable names (like all others) may not contain math operators like - , you should set SetOption64 1 to replace - ( dash ) with _ ( underscore ) >H Alexa Hue interface (up to 32 virtual hue devices) ( example ) device , type , onVars Remark: hue values have a range from 0-65535. Divide by 182 to assign HSBcolors hue values. device device name type device type - E = extended color; S = switch onVars assign Hue \"on\" extended color parameters for hue, saturation, brightness, and color temperature (hue,sat,bri,ct) to scripter variables [!EXAMPLE] lamp1,E,on=pwr1,hue=hue1,sat=sat1,bri=bri1,ct=ct1 >U status JSON Messages arrive here >b (note lower case) executed on button state change bt[x] read button state (x = 1.. MAX_KEYS ) [!EXAMPLE] if bt[1]==0 then print falling edge of button1 endif if bt[1]==1 then print rising edge of button1 endif >J The lines in this section are published via MQTT in a JSON payload on TelePeriod . Requires compiling with #define USE_SCRIPT_JSON_EXPORT . >W The lines in this section are displayed in the web UI main page. Requires compiling with #define USE_SCRIPT_WEB_DISPLAY . You may put any html code here. - Variables may be substituted using %var% - HTML statements are displayed in the sensor section of the main page - HTML statements preceded with a @ are displayed at the top of the page - USER IO elements are displayed at the top of the page A web user interface may be generated containing any of the following elements: toggle button, check box, slider, or text and number input. - Button: bu(<vn> <txt1> <txt2>) (up to 4 buttons may be defined in one row) <vn> = name of variable to hold button state <txt1> = text of ON state of button <txt2> = text of OFF state of button - Checkbox: ck(<vn> <txt>) <vn> = name of variable to hold checkbox state <txt> = label text - Slider: sl(<min> <max> <vn> <ltxt> <mtxt> <rtxt>) <min> = slider minimum value <max> = slider maximum value <vn> = name of variable to hold slider value <ltxt> = label left of slider <mtxt> = label middle of slider <rtxt> = label right of slider - Text Input: tx(<vn> <txt>) <vn> = name of string variable to hold text state <txt> = label text - Number Input: nm(<min <max> <step> <vn> <txt>) <min> = number minimum value <max> = number maximum value <step> = number step value for up/down arrows <vn> = name of number variable to hold number <txt> = label text >M Smart Meter Interface If a variable does not exist, ??? is displayed for commands If a Tasmota SENSOR or STATUS or RESULT message is not generated or a Var does not exist the destination variable is NOT updated.","title":"Script Sections"},{"location":"Scripting-Language/#special-variables","text":"(read only) upsecs = seconds since start uptime = minutes since start time = minutes since midnight sunrise = sunrise minutes since midnight sunset = sunset minutes since midnight tper = TelePeriod ( may be set also ) tstamp = timestamp (local date and time) topic = mqtt topic gtopic = mqtt group topic prefixn = prefix n = 1-3 pwr[x] = power state (x = 1..N) pc[x] = pulse counter value (x = 1..4) tbut[x] = touch screen button state (x = 1..N) sw[x] = switch state (x = 1..N) bt[x] = button state (x = 1..N) only valid in section >b (if defined USE_BUTTON_EVENT) pin[x] = GPIO pin level (x = 0..16) pn[x] = GPIO for sensor code x. 99 if none pd[x] = defined sensor for GPIO x. 999 if none sht[x] = shutter position (x = 1..N) (if defined USE_SHUTTER) gtmp = global temperature ghum = global humidity gprs = global pressure pow(x y) = calculates exponential powers x^y med(n x) = calculates a 5 value median filter of x (2 filters possible n=0,1) int(x) = gets the integer part of x (like floor) hn(x) = converts x (0..255) to a hex nibble string hx(x) = converts x (0..65535) to a hex string st(svar c n) = string token - retrieve the n th element of svar delimited by c sl(svar) = gets the length of a string sb(svar p n) = gets a substring from svar at position p (if p<0 counts from end) and length n sin(x) = calculates the sinus(x) (if defined USE_ANGLE_FUNC) acos(x) = calculates the acos(x) (if defined USE_ANGLE_FUNC) sqrt(x) = calculates the sqrt(x) (if defined USE_ANGLE_FUNC) s(x) = explicit conversion from number x to string mqtts = MQTT connection status: 0 = disconnected, >0 = connected wifis = Wi-Fi connection status: 0 = disconnected, >0 = connected hours = hours mins = mins secs = seconds day = day of month wday = day of week month = month year = year epoch = epoch time (from 2019-1-1 00:00) The following variables are cleared after reading true: chg[var] = true if a variables value was changed (numeric vars only) upd[var] = true if a variable was updated boot = true on BOOT tinit = true on time init tset = true on time set mqttc = true on mqtt connect mqttd = true on mqtt disconnect wific = true on wifi connect wifid = true on wifi disconnect System variables (for debugging) stack = stack size heap = heap size ram = used ram size slen = script length micros = running microseconds millis = running milliseconds loglvl = loglevel of script cmds ( may be set also ) Remarks: If you define a variable with the same name as a special variable that special variable is discarded","title":"Special Variables"},{"location":"Scripting-Language/#commands","text":"=> <command> Execute \\ recursion disabled +> <command> Execute \\ recursion enabled -> <command> Execute \\ - do not send MQTT or log messages (i.e., silent execute - useful to reduce traffic) Variable Substitution - A single percent sign must be given as %% - Variable replacement within commands is allowed using %varname% . Optionally, the decimal places precision for numeric values may be specified by placing a digit ( %Nvarname% , N = 0..9 ) in front of the substitution variable (e.g., Humidity: %3hum%%% will output Humidity: 43.271% ) - Linefeed and carriage return may be defined by \\n and \\r Special commands: print or => print prints to the log for debugging A Tasmota MQTT RESULT message invokes the script's >E section. Add => print statements to debug a script. [!EXAMPLE] ``` slider=Dimmer power=POWER if upd[slider]>0 then =>print slider updated %slider% endif if upd[power]>0 then =>print power updated %power% endif ``` break exits a section or terminates a for next loop dpx sets decimal precision to x (0-9) svars save permanent vars delay(x) pauses x milliseconds (should be as short as possible) spin(x b) set GPIO x (0..16) to value b (0,1). Only bit 0 of b is used - even values set the GPIO to 0 and uneven values set the GPIO to 1 spinm(x m) set GPIO x (0..16) to mode m (input=0, output=1, input with pullup=2) ws2812(array) copies an array (defined with m:vname ) to the WS2812 LED chain. The array length should be defined as long as the number of pixels. Color is coded as 24 bit RGB. hsvrgb(h s v) converts hue (0..360), saturation (0..100) and value (0..100) to RGB color #name names a subroutine. Subroutine is called with =#name #name(param) names a subroutine with a parameter. Subroutine is called with =#name(param) Subroutines end with the next # or > line or break. Subroutines may be nested Parameters can be numbers or strings and on type mismatch are converted If #define USE_SCRIPT_SUB_COMMAND is included in your user_config_override.h , a subroutine may be invoked via the Console or MQTT using the subroutine's name. For example, a declared subroutine #SETLED(num) may be invoked by typing SETLED 1 in the Console. The parameter 1 is passed into the num argument. This also works with string parameters. It is possible to \"replace\" internal Tasmota commands. For example, if a #POWER1(num) subroutine is declared, the command POWER1 is processed in the scripter instead of in the main Tasmota code. =(svar) executes a routine whose name is passed as a string in a variable (dynamic or self modifying code). The string has to start with => or =# for the routine to be executed. > D svar = \"=#subroutine\" > S = ( svar ) # subroutine => print subroutine was executed For loop (loop count must not be less than 1) for var <from> <to> <inc> next Switch selector (numeric or string) switch x case a case b ends Conditional Statements There are two syntax alternatives. You may NOT mix both formats. if a==b and x==y or k==i then => do this else => do that endif or if a==b and x==y or k==i { => do this } else { => do that } Remarks: The last closing bracket must be on a separate line Calculations are permitted in conditional expressions, e.g., if var1-var2==var3*var4 Conditional expressions may be enclosed in parentheses. The statement must be on a single line. e.g., if ((a==b) and ((c==d) or (c==e)) and (s!=\"x\")) E-mail #define USE_SENDMAIL Enabling this feature also enables Tasmota TLS as sendmail uses SSL. sendmail [server:port:user:passwd:from:to:subject] msg [!EXAMPLE] sendmail [smtp.gmail.com:465:user:passwd:sender@gmail.com:<rec@gmail.com>:alarm] %string% Remark: A number of e-mail servers (such as Gmail) require the receiver's e-mail address to be enclosed by < ... > as in example above. Most other e-mail servers also accept this format. The following parameters can be specified during compilation via #define directives in user_config_override.h : * EMAIL_SERVER * EMAIL_PORT * EMAIL_USER * EMAIL_PASSWORD * EMAIL_FROM To use any of these values, pass an * as its corresponding argument placeholder. [!EXAMPLE] sendmail [*:*:*:*:*:<rec@gmail.com>:theSubject] theMessage Instead of passing the msg as a string constant, the body of the e-mail message may also be composed using the script >m (note lower case) section. The specified text in this script section must end with an # character. sendmail will use the >m section if * is passed as the msg parameter. See [Scripting Cookbook Example].(Scripting-Cookbook#Send-e-mail) Subscribe, Unsubscribe #define SUPPORT_MQTT_EVENT subscribe and unsubscribe commands are supported. In contrast to rules, no event is generated but the event name specifies a variable defined in >D section and this variable is automatically set on transmission of the subscribed item SD Card Support (+ 10k flash) #define USE_SCRIPT_FATFS CARD_CS CARD_CS = GPIO of card chip select SD card uses standard hardware SPI GPIO: mosi,miso,sclk A maximum of four files may be open at a time e.g., allows for logging sensors to a tab delimited file and then downloading the file ( see Sensor Logging example ) The downloading of files may be executed in a kind of \"multitasking\" when bit 7 of loglvl is set (128+loglevel) Without multitasking 150kb/s (all processes are stopped during downloading), with multitasking 50kb/s (other Tasmota processes are running) The script itself is also stored on the SD card with a default size of 4096 characters Enable SD card directory support (+ 1,2k flash) #define SDCARD_DIR Shows a web SD card directory (submenu of scripter) where you can upload and download files to/from sd card fr=fo(\"fname\" m) open file fname, mode 0=read, 1=write (returns file reference (0-3) or -1 for error) res=fw(\"text\" fr) writes text to (the end of) file fr, returns number of bytes written res=fr(svar fr) reads a string into svar, returns bytes read. String is read until delimiter (\\t \\n \\r) or eof fc(fr) close file ff(fr) flush file, writes cached data and updates directory fd(\"fname\") delete file fname flx(fname) create download link for file (x=1 or 2) fname = file name of file to download fsm return 1 if filesystem is mounted, (valid SD card found) Extended commands (+0,9k flash) #define USE_SCRIPT_FATFS_EXT fmd(\"fname\") make directory fname frd(\"fname\") remove directory fname fx(\"fname\") check if file fname exists fe(\"fname\") execute script fname (max 2048 bytes, script must start with the '>' character on the first line)","title":"Commands"},{"location":"Scripting-Language/#scripting-cookbook","text":"","title":"Scripting Cookbook"},{"location":"Securing-your-IoT-from-hacking/","text":"General Weaknesses ~ Whenever you add devices to your network you generate additional points of potential intrusion. This is not only valid for your mobile phones and computers, but also for you Smart TV, you Alexa, or all of your SONOFF devices (ESP8266). There are following potential risks you have to mitigate: - Someone hacks your device and is able to log in into your WLAN. (why is this a problem? 1 ) - Someone hacks your device and is able to read and change any value on your MQTT server (why is this a problem? 2 ) - Someone hacks your network and can interact with your devices (why is this a problem? 3 ) - Someone hacks your device and use it for different things like mail bot or DOS (Denial of Service) device or WLAN jammer (why is this a problem? 4 ) Scenario 1 If someone is able to get your WLAN key, he can login into your network, if he is nearby and scan for any traffic and for any devices. Many communication is not encrypted in your WLAN by default. Therefore be part of your WLAN gives the attacker a great opportunity to screw-up the rest of your infrastructure. Also be part of your WLAN does mean, that the attacker can use your IP-Address and your traffic to do nasty things. Scenario 2 If you can hack an ESP82xx device, you might get access to the keys stored in the device. For example, the MQTT password allows you to read ALL of your devices and change any device at any time. With the information of the MQTT-Server user/password, it might be not required anymore to physically be in your WLAN. Maybe your MQTT Server is publicly accessible. Then the attacker can control your home from any place. Update: Beginning with version 6.0.0, passwords are not directly exposed through the serial connection or web interface in configuration mode. Therefore it is now less simple, however still possible to obtain the MQTT or WLAN password from a device. Such can be accomplished by downloading a configuration backup via the web UI of the device and decoding it using the decode-config.py script found in the Tasmota tools folder. Scenario 3 It might happen, that e.g. your Samsung SmartTV is not as secure as it should be and an attacker gets access to your network. Now he can listen to any traffic and maybe can make changes on all of your IoT devices. Scenario 4 If someone uses your device to spam mail or do a DOS attack the impact at your home is minimal. You might have more outbound traffic, but maybe you don't recognize this either. But thousands of hacked IoT devices can generate tremendous trouble even at the largest internet providers. I hope these four typical scenarios ( the list is not complete) give you some idea, why you should take care, even if you're not a terrorist and normally nobody is interested into hacking you personally. Securing your WLAN ~ That you should have a WLAN key and use WPA2 for encryption is a \"no brainer\". This is a minimum requirement. Now think about someone can extract the password from the device. E.g. because the device is in the garden and someone with a Laptop and some USB stuff can connect and extract information. The hacker will get the key. The ONLY possible preventive action to mitigate worst case scenario is to have a second WLAN, like the \"FritzBox Guest WLAN\". Many other routers offer similar things. This guest WLAN has no access to your private WLAN. Additionally, there are some interesting switched you can configure for the WLAN. At the FritzRouter you can configure \"network separation\" . At Fritz this is done by DISABLE \"The wireless devices connected with the guest access can communicate with each other\" . This does mean, that a device in the network can not interact with any other device in the WLAN. It can only communicate with the Internet. This simple configuration prevents any attacker to do nasty stuff on YOUR network. Now we have to take care, that the attacker is not creating a Bot-Net and sending e.g., Spam-Mails. Normally a device in the \"guest WLAN\" can use any internet service. For our IoT devices and for any new device we can create a Router rule, that ONLY MQTT is allowed to our server and any other traffic is blocked. This is a great configuration because it limits the options what a hacker can do. If you have a FritzBox following configuration has to be created to get this working: Create Profile to block all communication except MQTT and NTP Time services. Internet -> Filters -> List -> \"Add Network Application\" \"New Protocol\" (Add four rules, This will block all but UDP123 for Timeserver and 8883 for MQTT Server) - TCP from any to Port 1 to 8882 - TCP from any to Port 8884 to 65636 - UDP from any to Port 1 to 122 - UDP from any to Port 124 to 65636 Create a list of \"websites\" your IoT devices are allowed to access. Internet -> Filters -> List -> \"Permitted web sites\" -> EDIT yourserver 01.de.pool.ntp.org Replace with the full qualified name of your router in the Internet. NTP server - Use the one you have defined in Tasmota to be the timeserver. Create a profile you can attach to your IoT devices. Internet -> Filters -> Access profiles -> \"new Access profile\" \"Filter Web sites\" DISABLE \"Allow HTTPS queries\" SELECT \"Permit web sites (whitelist) Now you will probably ask two questions: 1. How can I communicate with my MQTT Server in my personal WLAN if only traffic into the internet is allowed? 2. How can I access the WebConsole of my devices to upload new Firmware and/or make investigations? The first topic will be solved by exposing your MQTT server to the Internet (no worries, can be done securely). The second topic has only a workaround. If you want access to your devices you need to change the configuration temporary on your router and ENABLE \"The wireless devices connected with the guest access can communicate with each other\" . Secondly, you must login with your Laptop into the GuestWLAN to be able to communicate. If the Webserver is running you should be able to connect and upload e.g. a new firmware. Securing your Communication ~ In the world of IoT devices and more and more devices in a network, it is essential to use encryption ALL the time. The Tasmota project is able to enable encryption for MQTT. This is great. But it cannot enable encryption on the WebServer. This is bad. As a conclusion, the Webserver must be switched OFF all the time and only be switched ON for administrative purpose. This also disables the feature to change the Relay Status with an HTTP REST call. But this option is insecure anyway and should be avoided. Now let's work on the MQTT configuration. Also here an attacker can get access to user and password. To minimize the impact EVERY and really EVERY device must have a unique USER and a unique password. If you don't follow this rule the attacker get one device he can control ALL devices. With the USER/PASSWORD he now can control the one device he already holds in his hands. ok, no big deal. How to configure Mosquitto? In general, Tasmota stores data in stat/ /+ and tele/ /+. or cmnd/ /+ to control something. If we use the as username we can make some quite nice and straight forward configuration. Example: Topic: ESP_123456 User: ESP_123456 (must be the same to Topic) password: 987654321 Configurationfile: /etc/mosquitte/conf.d/jp.acl user root topic read # topic write # pattern read cmnd /% u /# pattern write stat /% u /# pattern write tele /% u /# My user root is allowed to do everything. This is used in my home-automation to control all devices and listen to all devices. The \"pattern\" is used for ALL other users and the %u is a substitute. The great thing is that the device can read its configuration but cannot write to it. And the status information it posts to the /status/ but is not able to read it afterward. With this minimal configuration, Tasmota devices are running. To add the different user to Mosquitte the following two commands work fine. There is also a re-read available, but a restart works better for me. sudo mosquitto_passwd -b /etc/mosquitto/conf.d/jp.pw ESP_123456 987654321 sudo /etc/init.d/mosquitto restart If this is running we switch the Mosquitto to secure communication on Port 8883 and disable all insecure options. /etc/mosquitto/conf.d/user.conf # User Config password_file / etc / mosquitto / conf . d / jp . pw acl_file / etc / mosquitto / conf . d / jp . acl allow_anonymous false listener 8883 cafile / etc / mosquitto / certs / ca . crt certfile / etc / mosquitto / certs / server . crt keyfile / etc / mosquitto / certs / server . key require_certificate false How to generate the certificates in mosquitto please look at: - Mosquitto SSL Configuration - MQTT TLS Security - Adding TLS to connect to Mosquitto - Internet of Things messaging MQTT with TLS - Enable Secure Communication with TLS and the Mosquitto Broker SSL/TLS on Tasmota ~ TLS article explains how to set it up in Tasmota Disable unsecured fallback WiFi (WifiManager) ~ In case your Wifi SSID is not available (i.e. access point dies), the WiFiManager will jump into action and make your tasmota devices available using an unsecured access point. Type WifiConfig into the tasmota console. If this parameter is set to 2, you might want to change it after completing the setup of your device. Some less risky options would be: 0/4/5. (For details, see https://tasmota.github.io/docs/#/Commands?id=wi-fi)","title":"Securing your IoT from hacking"},{"location":"Securing-your-IoT-from-hacking/#general-weaknesses","text":"Whenever you add devices to your network you generate additional points of potential intrusion. This is not only valid for your mobile phones and computers, but also for you Smart TV, you Alexa, or all of your SONOFF devices (ESP8266). There are following potential risks you have to mitigate: - Someone hacks your device and is able to log in into your WLAN. (why is this a problem? 1 ) - Someone hacks your device and is able to read and change any value on your MQTT server (why is this a problem? 2 ) - Someone hacks your network and can interact with your devices (why is this a problem? 3 ) - Someone hacks your device and use it for different things like mail bot or DOS (Denial of Service) device or WLAN jammer (why is this a problem? 4 )","title":"General Weaknesses"},{"location":"Securing-your-IoT-from-hacking/#securing-your-wlan","text":"That you should have a WLAN key and use WPA2 for encryption is a \"no brainer\". This is a minimum requirement. Now think about someone can extract the password from the device. E.g. because the device is in the garden and someone with a Laptop and some USB stuff can connect and extract information. The hacker will get the key. The ONLY possible preventive action to mitigate worst case scenario is to have a second WLAN, like the \"FritzBox Guest WLAN\". Many other routers offer similar things. This guest WLAN has no access to your private WLAN. Additionally, there are some interesting switched you can configure for the WLAN. At the FritzRouter you can configure \"network separation\" . At Fritz this is done by DISABLE \"The wireless devices connected with the guest access can communicate with each other\" . This does mean, that a device in the network can not interact with any other device in the WLAN. It can only communicate with the Internet. This simple configuration prevents any attacker to do nasty stuff on YOUR network. Now we have to take care, that the attacker is not creating a Bot-Net and sending e.g., Spam-Mails. Normally a device in the \"guest WLAN\" can use any internet service. For our IoT devices and for any new device we can create a Router rule, that ONLY MQTT is allowed to our server and any other traffic is blocked. This is a great configuration because it limits the options what a hacker can do. If you have a FritzBox following configuration has to be created to get this working: Create Profile to block all communication except MQTT and NTP Time services. Internet -> Filters -> List -> \"Add Network Application\" \"New Protocol\" (Add four rules, This will block all but UDP123 for Timeserver and 8883 for MQTT Server) - TCP from any to Port 1 to 8882 - TCP from any to Port 8884 to 65636 - UDP from any to Port 1 to 122 - UDP from any to Port 124 to 65636 Create a list of \"websites\" your IoT devices are allowed to access. Internet -> Filters -> List -> \"Permitted web sites\" -> EDIT yourserver 01.de.pool.ntp.org Replace with the full qualified name of your router in the Internet. NTP server - Use the one you have defined in Tasmota to be the timeserver. Create a profile you can attach to your IoT devices. Internet -> Filters -> Access profiles -> \"new Access profile\" \"Filter Web sites\" DISABLE \"Allow HTTPS queries\" SELECT \"Permit web sites (whitelist) Now you will probably ask two questions: 1. How can I communicate with my MQTT Server in my personal WLAN if only traffic into the internet is allowed? 2. How can I access the WebConsole of my devices to upload new Firmware and/or make investigations? The first topic will be solved by exposing your MQTT server to the Internet (no worries, can be done securely). The second topic has only a workaround. If you want access to your devices you need to change the configuration temporary on your router and ENABLE \"The wireless devices connected with the guest access can communicate with each other\" . Secondly, you must login with your Laptop into the GuestWLAN to be able to communicate. If the Webserver is running you should be able to connect and upload e.g. a new firmware.","title":"Securing your WLAN"},{"location":"Securing-your-IoT-from-hacking/#securing-your-communication","text":"In the world of IoT devices and more and more devices in a network, it is essential to use encryption ALL the time. The Tasmota project is able to enable encryption for MQTT. This is great. But it cannot enable encryption on the WebServer. This is bad. As a conclusion, the Webserver must be switched OFF all the time and only be switched ON for administrative purpose. This also disables the feature to change the Relay Status with an HTTP REST call. But this option is insecure anyway and should be avoided. Now let's work on the MQTT configuration. Also here an attacker can get access to user and password. To minimize the impact EVERY and really EVERY device must have a unique USER and a unique password. If you don't follow this rule the attacker get one device he can control ALL devices. With the USER/PASSWORD he now can control the one device he already holds in his hands. ok, no big deal. How to configure Mosquitto? In general, Tasmota stores data in stat/ /+ and tele/ /+. or cmnd/ /+ to control something. If we use the as username we can make some quite nice and straight forward configuration. Example: Topic: ESP_123456 User: ESP_123456 (must be the same to Topic) password: 987654321 Configurationfile: /etc/mosquitte/conf.d/jp.acl user root topic read # topic write # pattern read cmnd /% u /# pattern write stat /% u /# pattern write tele /% u /# My user root is allowed to do everything. This is used in my home-automation to control all devices and listen to all devices. The \"pattern\" is used for ALL other users and the %u is a substitute. The great thing is that the device can read its configuration but cannot write to it. And the status information it posts to the /status/ but is not able to read it afterward. With this minimal configuration, Tasmota devices are running. To add the different user to Mosquitte the following two commands work fine. There is also a re-read available, but a restart works better for me. sudo mosquitto_passwd -b /etc/mosquitto/conf.d/jp.pw ESP_123456 987654321 sudo /etc/init.d/mosquitto restart If this is running we switch the Mosquitto to secure communication on Port 8883 and disable all insecure options. /etc/mosquitto/conf.d/user.conf # User Config password_file / etc / mosquitto / conf . d / jp . pw acl_file / etc / mosquitto / conf . d / jp . acl allow_anonymous false listener 8883 cafile / etc / mosquitto / certs / ca . crt certfile / etc / mosquitto / certs / server . crt keyfile / etc / mosquitto / certs / server . key require_certificate false How to generate the certificates in mosquitto please look at: - Mosquitto SSL Configuration - MQTT TLS Security - Adding TLS to connect to Mosquitto - Internet of Things messaging MQTT with TLS - Enable Secure Communication with TLS and the Mosquitto Broker","title":"Securing your Communication"},{"location":"Securing-your-IoT-from-hacking/#ssltls-on-tasmota","text":"TLS article explains how to set it up in Tasmota","title":"SSL/TLS on Tasmota"},{"location":"Securing-your-IoT-from-hacking/#disable-unsecured-fallback-wifi-wifimanager","text":"In case your Wifi SSID is not available (i.e. access point dies), the WiFiManager will jump into action and make your tasmota devices available using an unsecured access point. Type WifiConfig into the tasmota console. If this parameter is set to 2, you might want to change it after completing the setup of your device. Some less risky options would be: 0/4/5. (For details, see https://tasmota.github.io/docs/#/Commands?id=wi-fi)","title":"Disable unsecured fallback WiFi (WifiManager)"},{"location":"Sensor-API/","text":"Tasmota sensor API documentation for sensor driver development. Important things to consider API Structure Keeping ESP8266 code compact Important things to consider ~ There are several I 2 C sensor examples you can take from the development codebase when writing your own and you are encouraged to do this as it is a quick and easy way to see how things fit together. The Tasmota firmware is essentially intended for ESP8266/ESP8285 Wi-Fi SoC based devices and commits to the main development branch will be subject to review based on whether or not what you intend to develop or add to the existing code is relevant to the general ESP device users. That being said, there is a lot of development going into the firmware which extends the functionality of standard off the shelf Sonoff devices. The firmware in itself is also useful for boards such as the WeMos ESP82xx boards. More technically inclined individuals who use generic ESP82xx modules in their own circuits to provide more access to pins and the ability to add more sensors and hardware external to the device or the generic ESP82xx module circuits can also take advantage of Tasmota. The resources on the ESP82xx are finite. Most devices ship with 1MByte SPI flash which means for the generic device users, the code generally needs to be less than 502KBytes to ensure that OTA (Over The Air) flash functionality (which is the main reason why people use this firmware) remains available. RAM is also limited to an absolute maximum of 80KBytes. This memory is divided into heap (used by global variables and Strings) and stack (used by local variables) where stack space is just 4KBytes. Given the above resource constraints its important to keep your code as small as possible, as fast running as possible, and use as little RAM as possible. You need to think about these resource constraints all the time whilst doing any development you wish to add to the firmware functionality - Face the fact that microcontroller development isn't as close a relative to standard computer programming as you'd expect. You will be adding code to an existing framework which requires you to adhere to some simple but strict rules such as not having any infinite loops like you would have in your generic Arduino code and try to avoid using the delay() functions when writing your code as this will cause the entire firmware to be subjected to the delays you have added - Infinite loops will cause the firmware to lock up completely! If your sensor has configuration options please make these available by using the SensorXX framework which is already incorporated in the base code - This may not stop you from using a web-based configuration interface but since web-based configuration takes up a lot of code space in flash it is very important to make this optional by means of a compiler directive or a #define in the configuration file and as such something you need to keep in mind during your development and debugging - The more progressively optional additional features are in your driver the smaller the basic codebase can be for minimalist implementations. Whilst developing drivers for devices that use the I 2 C bus always consider other devices already supported in the codebase which may use the same address range. This could mean you need to find a unique way of differentiating your device detection from other devices on the same address range (e.g. querying a model-specific register) and/or disabling by #undef existing devices if yours is selected with a #define statement and in such cases always provide a warning to the user during compile time using the #warning pragma such as including #warning **** Turned off conflicting drivers SHT and VEML6070 **** in your code. DO NOT ADD WEB INTERFACE FOR SENSOR CONFIGURATION if your sensor requires additional user configuration. The reason for this is the additional program memory required but most importantly the amount of RAM required to even create minimal user interfaces. Running out of RAM during runtime will lead to abnormal behaviour of your driver and/or other drivers or the entire firmware! See sensors such as the MCP23008/MCP23017 driver on more information on how to implement SensorXX commands instead! While developing you might want to enable additional debugging provided by file xdrv_95_debug.ino using #define USE_DEBUG_DRIVER which provides some commands for managing configuration settings and CPU timing. In addition you can enable define PROFILE_XSNS_SENSOR_EVERY_SECOND to profile your drivers duration. Do not assume others will know immediately how to use your addition and know that you will need to write a Wiki for it in the end. Managing a Forked Branch ~ If you plan to submit a PR bigger than a simple change in one file, here is a short intro about how to do a clean PR. fork the Tasmota repository in Github git clone https://github.com/<github_user>/Tasmota.git and work on your local copy git remote add upstream https://github.com/arendst/Tasmota.git git checkout development git checkout -b <temp_branch> to create a working branch where you can push commits git push --set-upstream origin <temp_branch> work on your local version and push as many commits as you want When you think it is ready to merge and submit a PR: - git checkout development to go back to the main branch - git pull upstream development to update all the latest changes - git push to update your fork - git checkout -b <pr_branch> to create a new branch for the final PR - git push --set-upstream origin <pr_branch> - Merge the edits but be sure to remove the history of your local commits - git merge --squash <temp_branch> - git commit -m \"Message\" Now you have a clean single commit from which you can create the PR on the Tasmota Github. Directory/file structure ~ Sensor libraries are located in the lib/ directory. Sensor drivers are located in the tasmota/ directory. The filename of the sensor driver is xsns_<driver_ID>_<driver_name>.ino , e.g. xsns_05_ds18b20.ino where <driver_ID> is a unique number between 01 and 90 and <driver_name> is a human-readable name of the driver. Using generic libraries from external sources for sensors should be avoided as far as possible as they usually include code for other platforms and are not always written in an optimized way. API structure ~ Pre-processor directives ~ Conditional compiling of a sensor driver is achieved by adding a pre-processor directive of the scheme USE_<driver_name> in my_user_config.h . Accordingly the driver code has to be wrapped in #ifdef USE_<driver_name> ... #endif // USE_<driver_name> . Any Sensor driver must contain a pre-processor directive defining the driver ID by the scheme #define XSNS_<driver_ID> . Callback function ~ Any sensor driver needs a callback function following the scheme // Conditional compilation of driver #ifdef USE_<driver_name> // Define driver ID #define XSNS_<driver_ID> <driver_ID> /** * The callback function Xsns<driver_ID>() interfaces Tasmota with the sensor driver. * * It provides the Tasmota callback IDs. * * @param byte callback_id Tasmota function ID. * @return boolean Return value. * @pre None. * @post None. * */ boolean Xsns < driverID > ( byte callback_id ) { // Set return value to `false` boolean result = false ; // Check if I2C interface mode // if(i2c_flg) { // Check which callback ID is called by Tasmota switch ( callback_id ) { case FUNC_INIT : break ; case FUNC_EVERY_50_MSECOND : break ; case FUNC_EVERY_SECOND : break ; case FUNC_JSON_APPEND : break ; #ifdef USE_WEBSERVER case FUNC_WEB_APPEND : break ; #endif // USE_WEBSERVER case FUNC_SAVE_BEFORE_RESTART : break ; case FUNC_COMMAND : break ; } // } // if(i2c_flg) // Return boolean result return result ; } #endif // USE_<driver_name> Callback IDs ~ FUNC_INIT This callback ID is called when sensor drivers should be initialized. FUNC_EVERY_50_MSECOND This callback ID is called every 50 milliseconds, e.g. for near real-time operation FUNC_EVERY_SECOND This callback ID is called every second. It can be useful for anything that you need to do on a per second basis and is commonly used as an entry point to detect a driver or initialize an externally driven device such as a sensor, relay board or other forms of input/output required by your driver. You would normally want to make sure you've detected and initialised before it is used by JSON_APPEND , etc. so that its ready to serve data. The generally accepted way to use this would be to detect your sensor and once this is done set a sensor value accordingly so that the function does not use unnecessary resources during future calls, for example: void MySensorDetect () { if ( MySensorDetected ) { return ; } /* * Perform the code which needs to be completed to * detect your sensor and then set MySensorDetected to * a non-zero value which will prevent this section * of your code to re-run every time the function is * called. * * Under normal circumstances you'd not need to do * re-detect or initialise your sensor once it has been * done */ } Setting a flag that the driver was successful in detecting the attached chip/board via I 2 C or SPI will prevent it from continuously trying to initialize an already initialized device. When writing your function responsible for detecting an externally connected I 2 C device try to create a method by which you read or write to specific registers that would be applicable to that specific I 2 C device only as to confirm a positive detect for the device. If this is not done extensively it will lead to some drivers getting false detects for a different device type simply because it shares the same I 2 C address. Unless your driver is specifically going to use the entire array of addresses provisioned by the manufacturer please consider using a #define USE_MYCHIPNAME_ADDR in the my_user_config.h so that the user may specify the address on which to expect the device. This is of course only applicable to drivers that are not enabled by default in any of the pre-built binaries. I 2 C address auto-detection example #define MPR121_I2C_ADDR_1ST 0x5A /** 1st I2C address of sensor model **/ #define MPR121_I2C_ADDR_NUM 4 /** Number of sensors/I2C addresses **/ #define MPR121_I2C_ID_REG 0x5D /** Sensor model specific ID register **/ #define MPR121_I2C_ID_VAL 0x24 /** Sensor model specific ID register value **/ /* Sensor data struct type declaration/default definition */ typedef struct { bool connected = false ; /** Status if sensor is connected at I2C address */ bool running = false ; /** Running state of sensor */ . . . } mpr121 ; // Declare array of sensor data structs mpr121 mpr121 [ MPR121_I2C_ADDR_NUM ]; // Sensor specific init function void mpr121_init () { // Loop through I2C addresses for ( uint8_t i = 0 ; i < MPR121_I2C_ADDR_NUM ); i ++ ) { // Check if sensor is connected on I2C address mpr121 [ i ]. connected = ( MPR121_I2C_ID_VAL == I2cRead8 ( MPR121_I2C_ADDR_1ST + i , MPR121_I2C_ID_REG ); if ( mpr121 [ i ]. connected ) { // Log sensor found snprintf_P ( log_data , sizeof ( log_data ), PSTR ( D_LOG_I2C \"MPR121-%d \" D_FOUND_AT \" 0x%X\" ), i , MPR121_I2C_ADDR_1ST + i ); AddLog ( LOG_LEVEL_INFO ); // Initialize sensor . . . // Set running to true mpr121 [ i ]. running = true ; } } if ( ! ( mpr121 [ 0 ]. connected || mpr121 [ 1 ]. connected || mpr121 [ 2 ]. connected || mpr121 [ 3 ]. connected )){ snprintf_P ( log_data , sizeof ( log_data ), PSTR ( D_LOG_I2C \"MPR121: No sensors found\" )); AddLog ( LOG_LEVEL_INFO ); } } Four advanced methods to use FUNC_EVERY_SECOND (Food for thought) : * If a sensor needs an action which takes a long time, like more than 100mS, the action will be started here for a future follow-up. Using the uptime variable for testing like (uptime &1) will happen every 2 seconds. An example is the DS18B20 driver where readings (conversions they call it) can take up to 800mS from the initial request. * If a sensor needed the previous action it is now time to gather the information and store it in a safe place to be used by FUNC_JSON_APPEND and/or FUNC_WEB_APPEND . Using the else function of the previous test (uptime &1) will happen every 2 seconds too but just 1 second later than the previous action. * If a sensor does not respond for 10 times the sensor detection flag could be reset which will stop further processing until the sensor is re-detected. This is currently not being used actively as some users complain about disappearing sensors for whatever reason - Could be hardware related but easier to make Tasmota a little more flexible. * Making re-detection of a sensor possible by executing this once every 100 seconds (94 == (uptime %100)) a re-attached sensor can be detected without a restart of Tasmota. The 94 given in this example should be different for every sensor driver to make sure not all sensors start detection at the same time. Using the drivers index number should be a good starting point. FUNC_PREP_BEFORE_TELEPERIOD NOTE: This callback ID is deprecated as sensors should prepare for more regular updates due to \"realtime\" rule execution. Use FUNC_EVERY_SECOND instead. See examples used in xsns_05_ds18x20.ino and xsns_09_bmp.ino where updated sensor data is stored in preparation to calls to FUNC_JSON_APPEND and FUNC_WEB_APPEND. FUNC_JSON_APPEND This callback ID is called when TelePeriod is due to append telemetry data to the MQTT JSON string or at approximately every 2 seconds when a rule is checked, e.g. snprintf_P ( mqtt_data , sizeof ( mqtt_data ), PSTR ( \"{ \\\" MPR121%c \\\" :{ \\\" Button%i \\\" :%i}}\" ), pS -> id [ i ], j , BITC ( i , j )); FUNC_WEB_APPEND This callback ID is called every millisecond when HTML code should be added to the Tasmota web-interface main page, e.g., snprintf_P ( mqtt_data , sizeof ( mqtt_data ), PSTR ( \"%s{s}MPR121%c Button%d{m}%d{e}\" ), mqtt_data , pS -> id [ i ], j , BITC ( i , j )); It should be wrapped in #ifdef USE_WEBSERVER ... #endif // USE_WEBSERVER FUNC_SAVE_BEFORE_RESTART This callback ID is called to allow a sensor to prepare for saving configuration changes. To be used to save volatile data just before a restart. Variables can be appended to struct SYSCFG {} Settings in file tasmota/settings.h . FUNC_COMMAND This callback ID is called when a sensor specific command Sensor<xx> or Driver<xx> is executed where xx is the sensor index. case FUNC_COMMAND : if ( XSNS_ < driver_ID > == XdrvMailbox . index ) { result = < driver_name > Command () { ... }; // Return true on success } break ; // Data struct of FUNC_COMMAND ID struct XDRVMAILBOX { uint16_t valid ; // ??? uint16_t index ; // Sensor index uint16_t data_len ; // Length of command string uint16_t payload16 ; // 16 bit unsigned int of payload if it could be converted, otherwise 0 int16_t payload ; // 16 bit signed int of payload if it could be converted, otherwise 0 uint8_t grpflg ; // ??? uint8_t notused ; // ??? char * topic ; // Command topic char * data ; // Command string/value - length of which is defined by data_len } XdrvMailbox ; If your driver needs to accept multiple parameters for SensorXX and/or DriverXX please consider using comma delimited formatting and use the already written subStr() function declared in support.ino to parse through the parameters you need. An example of those could be SensorXX reset // The reset parameter may be intercepted using: if ( ! strcmp ( subStr ( sub_string , XdrvMailbox . data , \",\" , 1 ), \"RESET\" )) { // Note 1 used for param number MyDriverName_Reset (); return serviced ; } Or in the case of multiple parameters SensorXX mode , 1 if ( ! strcmp ( subStr ( sub_string , XdrvMailbox . data , \",\" , 1 ), \"MODE\" )) { // Note 1 used for param number uint8_t mode = atoi ( subStr ( sub_string , XdrvMailbox . data , \",\" , 2 ); // Note 2 used for param number } Useful functions ~ MQTT ~ void MqttPublishPrefixTopic_P ( uint8_t prefix , const char * subtopic , boolean retained ) This function publishes MQTT messages immediately, e.g., snprintf_P ( mqtt_data , sizeof ( mqtt_data ), PSTR ( \"{ \\\" MPR121%c \\\" :{ \\\" Button%i \\\" :%i}}\" ), pS -> id [ i ], j , BITC ( i , j )); MqttPublishPrefixTopic_P ( RESULT_OR_STAT , mqtt_data ); Logging ~ void AddLog ( byte loglevel ) This function adds log messages stored in log_data to the local logging system, e.g. snprintf_P ( log_data , sizeof ( log_data ), PSTR ( D_LOG_I2C \"MPR121(%c) \" D_FOUND_AT \" 0x%X\" ), pS -> id [ i ], pS -> i2c_addr [ i ]); AddLog ( LOG_LEVEL_INFO ); void AddLogSerial ( byte loglevel ) This function adds a log message to the local logging system dumping the serial buffer as hex information, e.g. AddLogSerial ( LOG_LEVEL_INFO ); void AddLogMissed ( char * sensor , uint8_t misses ) This function adds a log message to the local logging system about missed sensor reads. I 2 C Interface ~ bool I2cValidRead8 ( uint8_t * data , uint8_t addr , uint8_t reg ) bool I2cValidRead16 ( uint16_t * data , uint8_t addr , uint8_t reg ) bool I2cValidReadS16 ( int16_t * data , uint8_t addr , uint8_t reg ) bool I2cValidRead16LE ( uint16_t * data , uint8_t addr , uint8_t reg ) bool I2cValidReadS16_LE ( int16_t * data , uint8_t addr , uint8_t reg ) bool I2cValidRead24 ( int32_t * data , uint8_t addr , uint8_t reg ) bool I2cValidRead ( uint8_t addr , uint8_t reg , uint8_t size ) These functions return true if 1, 2, 3 or size bytes can be read from the I 2 C address addr and register reg into *data . Functions with a S read signed data types while functions without a S read unsigned data types. Functions with LE read little-endian byte order while functions without LE read machine byte order. uint8_t I2cRead8 ( uint8_t addr , uint8_t reg ) uint16_t I2cRead16 ( uint8_t addr , uint8_t reg ) int16_t I2cReadS16 ( uint8_t addr , uint8_t reg ) uint16_t I2cRead16LE ( uint8_t addr , uint8_t reg ) int16_t I2cReadS16_LE ( uint8_t addr , uint8_t reg ) int32_t I2cRead24 ( uint8_t addr , uint8_t reg ) These functions return 1, 2 or 3 bytes from the I 2 C address addr and register reg . Functions with a S read signed data types while functions without a S read unsigned data types. Functions with LE read little endian byte order while functions without LE read machine byte order. bool I2cWrite8 ( uint8_t addr , uint8_t reg , uint8_t val ) bool I2cWrite16 ( uint8_t addr , uint8_t reg , uint16_t val ) bool I2cWrite ( uint8_t addr , uint8_t reg , uint32_t val , uint8_t size ) These functions return true after successfully writing 1, 2 or size bytes to the I 2 C address addr and register reg . int8_t I2cReadBuffer ( uint8_t addr , uint8_t reg , uint8_t * reg_data , uint16_t len ) int8_t I2cWriteBuffer ( uint8_t addr , uint8_t reg , uint8_t * reg_data , uint16_t len ) These functions copy len bytes from/to *reg_data starting at I 2 C address addr and register reg . void I2cScan ( char * devs , unsigned int devs_len ) This functions writes a list of I 2 C addresses in use into the string *dev with maximum length devs_len . bool I2cDevice ( byte addr ) This functions checks if the I 2 C address addr is in use. Useful pre-processor directives ~ PSTR(\"string\") This pre-processor directive saves RAM by storing strings in flash instead of RAM. const char MyTextStaticVariable [] PROGMEM = \"string\" ; This pre-processor directive saves RAM by storing strings in flash instead of RAM. You may then reference them directly (if the type matches the parameter required) or force it to 4 byte alignment by using the variable as FPSTR(MyTextStaticVariable) Keeping ESP8266 code compact ~ Below are various tips and tricks to keep ESP8266 code compact and save both Flash and Memory. Flash code is limited to 1024k but keep in mind that to allow OTA upgrade, you need Flash memory to contain two firmwares at the same time. To go beyond 512k, you typically use tasmota-minimal as an intermediate firmware. tasmota-minimal takes roughly 360k, so it's safe not to go uint32_t beyond 620k of Flash. Memory is even more limited: 80k. With Arduino Core and basic Tasmota, there are 25k-30k left of heap space. Heap memory is very precious, running out of memory will generally cause a crash. About ESP8266 ~ ESP8266 is based on Xtensa instruction set . Xtensa is a 32 bits RISC processor core, containing 16 x 32 bits registers. ESP8266 supports integer operations, including 32x32 multiplication. It does not contain an FPU for floating point operations, nor integer divisions. Contrary to classical RISC processors, all instructions are 24 bits wide instead of 32 bits. To increase code compactness, some instructions have a 16 bits version used whenever possible by gcc. If you want to see what assembly is generated by gcc, in file platform.ini , at the section used to compile (ex: [core_2_6_1] ) in section build_flags add: -save-temps=obj -fverbose-asm Gcc will store <file>.s in the same folder as the .o file, typically in .pioenvs/ . First example ~ Let's take a basic function: uint32_t Example ( uint32_t a , uint32_t b ) { return a + b ; } Below is the generated assembly. Function names are mangled using standard C++, i.e. their name derive from their arguments and return types: _Z7Examplejj: add.n a2 , a2 , a3 #, a, b ret.n As you can see, this is the simplest function we can think of. Register A2 holds the first argument and is used for return value. A3 holds the second argument. uint8_t or uint32_t ? ~ uint32_t Example ( uint32_t a , uint32_t b ) { uint8_t c = a + b ; return c ; } Assembly: _Z7Examplejj: add.n a2 , a2 , a3 # tmp52, a, b extui a2 , a2 , 0 , 8 #, tmp52 ret.n Whenever gcc needs to convert from uin32_t to uint8_t , it uses an extra instruction extui <reg>, <reg>, 0, 8 . Whenever you allocate uint8_t as a local variable, it will anyways allocate 32 bits on the stack. In conclusion you can easily use uint32_t in many places in the code. The main reason to force uint8_t are: in structures, to save memory. This is the only place where uint8_t will take 1 byte and the compiler will try to pack as much as 4 uint8_t in 32 bits when you want to ensure that the value can never exceed 255. Beware though that the compiler will just chunk the last 8 bits of a 32 bits value and will not report any overflow. Loops Should you use uint8_t or uint32_t for loops? Let's try: uint32_t Example ( uint32_t a , uint32_t b ) { for ( uint8_t i = 0 ; i < 10 ; i ++ ) { a += b ; } for ( uint32_t j = 0 ; j < 10 ; j ++ ) { a += b ; } return a ; } Assembly: _Z7Examplejj: movi.n a3 , 0 # ivtmp$7334, <- loop 1 .L2031: add.n a2 , a2 , a3 # a, a, ivtmp$7334 addi.n a3 , a3 , 1 # ivtmp$7334, ivtmp$7334, bnei a3 , 10 , .L2031 # ivtmp$7334,, movi.n a3 , 0 # j, <- loop 2 .L2033: add.n a2 , a2 , a3 # a, a, j addi.n a3 , a3 , 1 # j, j, bnei a3 , 10 , .L2033 # j,, ret.n As you can see here, both loops generate the same assembly for fixed size loops. Let's now see for variable size loops. uint32_t Example ( uint32_t a , uint32_t b ) { for ( uint8_t i = 0 ; i < b ; i ++ ) { a += i ; } for ( uint32_t j = 0 ; j < b ; j ++ ) { a += j ; } return a ; } Assembly: _Z7Examplejj: movi.n a4 , 0 # i, <- loop 1 j .L2030 # .L2031: add.n a2 , a2 , a4 # a, a, i addi.n a4 , a4 , 1 # tmp48, i, extui a4 , a4 , 0 , 8 # i, tmp48 <- extra 32 to 8 bits conversion .L2030: bltu a4 , a3 , .L2031 # i, b, movi.n a4 , 0 # j, <- loop 2 j .L2032 # .L2033: add.n a2 , a2 , a4 # a, a, j addi.n a4 , a4 , 1 # j, j, .L2032: bne a4 , a3 , .L2033 # j, b, ret.n In the first loop, the register a4 needs to be converted from 32 bits to 8 bits in each iteration. Again, there is no definitive rule, but keep in mind that using uint8_t can sometimes increase code size compared to uint32_t . Floats, not doubles! ~ ESP8266 does not have a FPU (Floating Point Unit), all floating point operations are emulated in software and provided in libm.a . The linker removes any unused functions, so we need to limit the number of floating point function calls. Rule 1 : use ints where you can, avoid floating point operations. Rule 2 : if you really need floating point, always use float , never ever use double . Let's now see why. float fits in 32 bits, with a mantissa of 20 bits, exponent of TODO. The mantissa is 20 bits wide, which provides enough precision for most of our needs. float is 32 bits wide and fits in a single register, whereas double is 64 bits and requires 2 registers. float Examplef ( float a , float b ) { return sinf ( a ) * ( b + 0.4f ) - 3.5f ; } Assembly: .literal .LC1012 , 0x3ecccccd < - 0 .4f .literal .LC1013 , 0x40600000 < - 3 .5f _Z8Examplefff: addi sp , sp , - 16 #,, <- reserve 16 bytes on stack s32i.n a0 , sp , 12 #, <- save a0 (return address) on stack s32i.n a12 , sp , 8 #, <- save a12 on stack, to free for local var s32i.n a13 , sp , 4 #, <- save a13 on stack, to free for local var mov.n a13 , a3 # b, b <- a3 holds 'b', save to a13 call0 sinf # <- calc sin of a2 (a) l32r a3 , .LC1012 #, <- load 0.4f in a3 mov.n a12 , a2 # D.171139, <- save result 'sin(a)' to a12 mov.n a2 , a13 #, b <- move a13 (second arg: b) to a2 call0 __addsf3 # <- add floats a2 and a3, result to a2 mov.n a3 , a2 # D.171139, <- copy result to a3 mov.n a2 , a12 #, D.171139 <- load a2 with a12: sin(a) call0 __mulsf3 # <- multiply 'sin(a)*(b+0.4f)' l32r a3 , .LC1013 #, <- load a3 with 3.5f call0 __subsf3 # <- substract l32i.n a0 , sp , 12 #, <- restore a0 (return address) l32i.n a12 , sp , 8 #, <- restore a12 l32i.n a13 , sp , 4 #, <- restore a13 addi sp , sp , 16 #,, <- free stack ret.n < - return Now with double : double Exampled ( double a , double b ) { return sin ( a ) * ( b + 0.4 ) - 3.5 ; } Assembly: .literal .LC1014 , 0x9999999a , 0x3fd99999 < - 0 .4 .literal .LC1015 , 0x00000000 , 0x400c0000 < - 3 .5 _Z8Exampleddd: addi sp , sp , - 32 #,, s32i.n a0 , sp , 28 #, s32i.n a12 , sp , 24 #, s32i.n a13 , sp , 20 #, s32i.n a14 , sp , 16 #, s32i.n a15 , sp , 12 #, mov.n a14 , a4 #, mov.n a15 , a5 #, call0 sin # l32r a4 , .LC1014 #, l32r a5 , .LC1014 + 4 #, mov.n a12 , a2 #, mov.n a13 , a3 #, mov.n a2 , a14 #, mov.n a3 , a15 #, call0 __adddf3 # mov.n a4 , a2 #, mov.n a5 , a3 #, mov.n a2 , a12 #, mov.n a3 , a13 #, call0 __muldf3 # l32r a4 , .LC1015 #, l32r a5 , .LC1015 + 4 #, call0 __subdf3 # l32i.n a0 , sp , 28 #, l32i.n a12 , sp , 24 #, l32i.n a13 , sp , 20 #, l32i.n a14 , sp , 16 #, l32i.n a15 , sp , 12 #, addi sp , sp , 32 #,, ret.n As you can see the double needs to move many more registers around. Examplef (float) is 84 bytes, Exampled (double) is 119 bytes (+42% code size). Actually it's even worse, sin is larger than float version sinf . Also, never forget to explicitly tag literals as float: always put 1.5f and not 1.5 . Let's see the impact: float Examplef2 ( float a , float b ) { return sinf ( a ) * ( b + 0.4 ) - 3.5 ; // same as above with double literals } Assembly: .literal .LC1014 , 0x9999999a , 0x3fd99999 .literal .LC1015 , 0x00000000 , 0x400c0000 .align 4 .global _Z9Examplef2ff .type _Z9Examplef2ff , @function _Z9Examplef2ff: addi sp , sp , - 16 #,, s32i.n a0 , sp , 12 #, s32i.n a12 , sp , 8 #, s32i.n a13 , sp , 4 #, s32i.n a14 , sp , 0 #, mov.n a14 , a3 # b, b call0 sinf # call0 __extendsfdf2 # <- extend float to double mov.n a12 , a2 #, mov.n a2 , a14 #, b mov.n a13 , a3 #, call0 __extendsfdf2 # <- extend float to double l32r a4 , .LC1014 #, l32r a5 , .LC1014 + 4 #, call0 __adddf3 # <- add double mov.n a4 , a2 #, mov.n a5 , a3 #, mov.n a2 , a12 #, mov.n a3 , a13 #, call0 __muldf3 # <- multiply double l32r a4 , .LC1015 #, l32r a5 , .LC1015 + 4 #, call0 __subdf3 # <- substract double call0 __truncdfsf2 # <- truncate double to float l32i.n a0 , sp , 12 #, l32i.n a12 , sp , 8 #, l32i.n a13 , sp , 4 #, l32i.n a14 , sp , 0 #, addi sp , sp , 16 #,, ret.n The last example takes 143 bytes, which is even worse than the double version, because of conversions from float to double and back. Internally, if you don't force float literals, gcc will make all intermediate compute in double and convert to float in the end. This is usually what is wanted: compute with maximum precision and truncate at the last moment. But for ESP8266 we want the opposite: most compact code. String concatenation ~ Let's start with an easy example: void ExampleStringConcat ( String & s ) { s += \"suffix\" ; } Assembly (25 bytes): .LC1024: .string \"suffix\" .literal .LC1025 , .LC1024 _Z19ExampleStringConcatR6String: l32r a3 , .LC1025 #, addi sp , sp , - 16 #,, s32i.n a0 , sp , 12 #, call0 _ZN6String6concatEPKc # l32i.n a0 , sp , 12 #, addi sp , sp , 16 #,, ret.n If you need to add more complex strings, do not concatenate using native c++ concat: void ExampleStringConcat2 ( String & s , uint8_t a , uint8_t b ) { s += \"[\" + String ( a ) + \",\" + String ( b ) + \"]\" ; } Assembly (122 bytes!): .LC231: .string \",\" .LC1026: .string \"[\" .LC1029: .string \"]\" .literal .LC1027 , .LC1026 .literal .LC1028 , .LC231 .literal .LC1030 , .LC1029 _Z20ExampleStringConcat2R6Stringhh: addi sp , sp , - 64 #,, s32i.n a13 , sp , 52 #, extui a13 , a3 , 0 , 8 # a, a l32r a3 , .LC1027 #, s32i.n a12 , sp , 56 #, mov.n a12 , a2 # s, s addi.n a2 , sp , 12 #,, s32i.n a0 , sp , 60 #, s32i.n a14 , sp , 48 #, extui a14 , a4 , 0 , 8 # b, b call0 _ZN6StringC2EPKc # . <- allocate String movi.n a4 , 0xa #, addi a2 , sp , 24 #,, mov.n a3 , a13 #, a call0 _ZN6StringC1Ehh # <- allocate String addi a3 , sp , 24 #,, addi.n a2 , sp , 12 #,, call0 _ZplRK15StringSumHelperRK6String # l32r a3 , .LC1028 #, call0 _ZplRK15StringSumHelperPKc # movi.n a4 , 0xa #, mov.n a13 , a2 # D.171315, mov.n a3 , a14 #, b mov.n a2 , sp #, call0 _ZN6StringC1Ehh # <- allocate String mov.n a3 , sp #, mov.n a2 , a13 #, D.171315 call0 _ZplRK15StringSumHelperRK6String # l32r a3 , .LC1030 #, call0 _ZplRK15StringSumHelperPKc # mov.n a3 , a2 # D.171315, mov.n a2 , a12 #, s call0 _ZN6String6concatERKS_ # mov.n a2 , sp #, call0 _ZN6StringD1Ev # <- destructor addi a2 , sp , 24 #,, call0 _ZN6StringD1Ev # <- destructor addi.n a2 , sp , 12 #,, call0 _ZN6StringD2Ev # <- destructor l32i.n a0 , sp , 60 #, l32i.n a12 , sp , 56 #, l32i.n a13 , sp , 52 #, l32i.n a14 , sp , 48 #, addi sp , sp , 64 #,, ret.n Instead use native String concat: void ExampleStringConcat3 ( String & s , uint8_t a , uint8_t b ) { s += \"[\" ; s += a ; s += \",\" ; s += b ; s += \"]\" ; } Assembly (69 bytes, -43%): .LC231: .string \",\" .LC1026: .string \"[\" .LC1029: .string \"]\" .literal .LC1031 , .LC1026 .literal .LC1032 , .LC231 .literal .LC1033 , .LC1029 _Z20ExampleStringConcat3R6Stringhh: addi sp , sp , - 16 #,, s32i.n a13 , sp , 4 #, extui a13 , a3 , 0 , 8 # a, a l32r a3 , .LC1031 #, s32i.n a0 , sp , 12 #, s32i.n a12 , sp , 8 #, s32i.n a14 , sp , 0 #, mov.n a12 , a2 # s, s extui a14 , a4 , 0 , 8 # b, b call0 _ZN6String6concatEPKc # <- native char* add mov.n a3 , a13 #, a mov.n a2 , a12 #, s call0 _ZN6String6concatEh # <- native int add l32r a3 , .LC1032 #, mov.n a2 , a12 #, s call0 _ZN6String6concatEPKc # <- native char* add mov.n a3 , a14 #, b mov.n a2 , a12 #, s call0 _ZN6String6concatEh # <- native int add l32r a3 , .LC1033 #, mov.n a2 , a12 #, s call0 _ZN6String6concatEPKc # <- native char* add l32i.n a0 , sp , 12 #, l32i.n a12 , sp , 8 #, l32i.n a13 , sp , 4 #, l32i.n a14 , sp , 0 #, addi sp , sp , 16 #,, ret.n","title":"Sensor API"},{"location":"Sensor-API/#important-things-to-consider","text":"There are several I 2 C sensor examples you can take from the development codebase when writing your own and you are encouraged to do this as it is a quick and easy way to see how things fit together. The Tasmota firmware is essentially intended for ESP8266/ESP8285 Wi-Fi SoC based devices and commits to the main development branch will be subject to review based on whether or not what you intend to develop or add to the existing code is relevant to the general ESP device users. That being said, there is a lot of development going into the firmware which extends the functionality of standard off the shelf Sonoff devices. The firmware in itself is also useful for boards such as the WeMos ESP82xx boards. More technically inclined individuals who use generic ESP82xx modules in their own circuits to provide more access to pins and the ability to add more sensors and hardware external to the device or the generic ESP82xx module circuits can also take advantage of Tasmota. The resources on the ESP82xx are finite. Most devices ship with 1MByte SPI flash which means for the generic device users, the code generally needs to be less than 502KBytes to ensure that OTA (Over The Air) flash functionality (which is the main reason why people use this firmware) remains available. RAM is also limited to an absolute maximum of 80KBytes. This memory is divided into heap (used by global variables and Strings) and stack (used by local variables) where stack space is just 4KBytes. Given the above resource constraints its important to keep your code as small as possible, as fast running as possible, and use as little RAM as possible. You need to think about these resource constraints all the time whilst doing any development you wish to add to the firmware functionality - Face the fact that microcontroller development isn't as close a relative to standard computer programming as you'd expect. You will be adding code to an existing framework which requires you to adhere to some simple but strict rules such as not having any infinite loops like you would have in your generic Arduino code and try to avoid using the delay() functions when writing your code as this will cause the entire firmware to be subjected to the delays you have added - Infinite loops will cause the firmware to lock up completely! If your sensor has configuration options please make these available by using the SensorXX framework which is already incorporated in the base code - This may not stop you from using a web-based configuration interface but since web-based configuration takes up a lot of code space in flash it is very important to make this optional by means of a compiler directive or a #define in the configuration file and as such something you need to keep in mind during your development and debugging - The more progressively optional additional features are in your driver the smaller the basic codebase can be for minimalist implementations. Whilst developing drivers for devices that use the I 2 C bus always consider other devices already supported in the codebase which may use the same address range. This could mean you need to find a unique way of differentiating your device detection from other devices on the same address range (e.g. querying a model-specific register) and/or disabling by #undef existing devices if yours is selected with a #define statement and in such cases always provide a warning to the user during compile time using the #warning pragma such as including #warning **** Turned off conflicting drivers SHT and VEML6070 **** in your code. DO NOT ADD WEB INTERFACE FOR SENSOR CONFIGURATION if your sensor requires additional user configuration. The reason for this is the additional program memory required but most importantly the amount of RAM required to even create minimal user interfaces. Running out of RAM during runtime will lead to abnormal behaviour of your driver and/or other drivers or the entire firmware! See sensors such as the MCP23008/MCP23017 driver on more information on how to implement SensorXX commands instead! While developing you might want to enable additional debugging provided by file xdrv_95_debug.ino using #define USE_DEBUG_DRIVER which provides some commands for managing configuration settings and CPU timing. In addition you can enable define PROFILE_XSNS_SENSOR_EVERY_SECOND to profile your drivers duration. Do not assume others will know immediately how to use your addition and know that you will need to write a Wiki for it in the end.","title":"Important things to consider"},{"location":"Sensor-API/#managing-a-forked-branch","text":"If you plan to submit a PR bigger than a simple change in one file, here is a short intro about how to do a clean PR. fork the Tasmota repository in Github git clone https://github.com/<github_user>/Tasmota.git and work on your local copy git remote add upstream https://github.com/arendst/Tasmota.git git checkout development git checkout -b <temp_branch> to create a working branch where you can push commits git push --set-upstream origin <temp_branch> work on your local version and push as many commits as you want When you think it is ready to merge and submit a PR: - git checkout development to go back to the main branch - git pull upstream development to update all the latest changes - git push to update your fork - git checkout -b <pr_branch> to create a new branch for the final PR - git push --set-upstream origin <pr_branch> - Merge the edits but be sure to remove the history of your local commits - git merge --squash <temp_branch> - git commit -m \"Message\" Now you have a clean single commit from which you can create the PR on the Tasmota Github.","title":"Managing a Forked Branch"},{"location":"Sensor-API/#directoryfile-structure","text":"Sensor libraries are located in the lib/ directory. Sensor drivers are located in the tasmota/ directory. The filename of the sensor driver is xsns_<driver_ID>_<driver_name>.ino , e.g. xsns_05_ds18b20.ino where <driver_ID> is a unique number between 01 and 90 and <driver_name> is a human-readable name of the driver. Using generic libraries from external sources for sensors should be avoided as far as possible as they usually include code for other platforms and are not always written in an optimized way.","title":"Directory/file structure"},{"location":"Sensor-API/#api-structure","text":"","title":"API structure"},{"location":"Sensor-API/#pre-processor-directives","text":"Conditional compiling of a sensor driver is achieved by adding a pre-processor directive of the scheme USE_<driver_name> in my_user_config.h . Accordingly the driver code has to be wrapped in #ifdef USE_<driver_name> ... #endif // USE_<driver_name> . Any Sensor driver must contain a pre-processor directive defining the driver ID by the scheme #define XSNS_<driver_ID> .","title":"Pre-processor directives"},{"location":"Sensor-API/#callback-function","text":"Any sensor driver needs a callback function following the scheme // Conditional compilation of driver #ifdef USE_<driver_name> // Define driver ID #define XSNS_<driver_ID> <driver_ID> /** * The callback function Xsns<driver_ID>() interfaces Tasmota with the sensor driver. * * It provides the Tasmota callback IDs. * * @param byte callback_id Tasmota function ID. * @return boolean Return value. * @pre None. * @post None. * */ boolean Xsns < driverID > ( byte callback_id ) { // Set return value to `false` boolean result = false ; // Check if I2C interface mode // if(i2c_flg) { // Check which callback ID is called by Tasmota switch ( callback_id ) { case FUNC_INIT : break ; case FUNC_EVERY_50_MSECOND : break ; case FUNC_EVERY_SECOND : break ; case FUNC_JSON_APPEND : break ; #ifdef USE_WEBSERVER case FUNC_WEB_APPEND : break ; #endif // USE_WEBSERVER case FUNC_SAVE_BEFORE_RESTART : break ; case FUNC_COMMAND : break ; } // } // if(i2c_flg) // Return boolean result return result ; } #endif // USE_<driver_name>","title":"Callback function"},{"location":"Sensor-API/#callback-ids","text":"FUNC_INIT This callback ID is called when sensor drivers should be initialized. FUNC_EVERY_50_MSECOND This callback ID is called every 50 milliseconds, e.g. for near real-time operation FUNC_EVERY_SECOND This callback ID is called every second. It can be useful for anything that you need to do on a per second basis and is commonly used as an entry point to detect a driver or initialize an externally driven device such as a sensor, relay board or other forms of input/output required by your driver. You would normally want to make sure you've detected and initialised before it is used by JSON_APPEND , etc. so that its ready to serve data. The generally accepted way to use this would be to detect your sensor and once this is done set a sensor value accordingly so that the function does not use unnecessary resources during future calls, for example: void MySensorDetect () { if ( MySensorDetected ) { return ; } /* * Perform the code which needs to be completed to * detect your sensor and then set MySensorDetected to * a non-zero value which will prevent this section * of your code to re-run every time the function is * called. * * Under normal circumstances you'd not need to do * re-detect or initialise your sensor once it has been * done */ } Setting a flag that the driver was successful in detecting the attached chip/board via I 2 C or SPI will prevent it from continuously trying to initialize an already initialized device. When writing your function responsible for detecting an externally connected I 2 C device try to create a method by which you read or write to specific registers that would be applicable to that specific I 2 C device only as to confirm a positive detect for the device. If this is not done extensively it will lead to some drivers getting false detects for a different device type simply because it shares the same I 2 C address. Unless your driver is specifically going to use the entire array of addresses provisioned by the manufacturer please consider using a #define USE_MYCHIPNAME_ADDR in the my_user_config.h so that the user may specify the address on which to expect the device. This is of course only applicable to drivers that are not enabled by default in any of the pre-built binaries. I 2 C address auto-detection example #define MPR121_I2C_ADDR_1ST 0x5A /** 1st I2C address of sensor model **/ #define MPR121_I2C_ADDR_NUM 4 /** Number of sensors/I2C addresses **/ #define MPR121_I2C_ID_REG 0x5D /** Sensor model specific ID register **/ #define MPR121_I2C_ID_VAL 0x24 /** Sensor model specific ID register value **/ /* Sensor data struct type declaration/default definition */ typedef struct { bool connected = false ; /** Status if sensor is connected at I2C address */ bool running = false ; /** Running state of sensor */ . . . } mpr121 ; // Declare array of sensor data structs mpr121 mpr121 [ MPR121_I2C_ADDR_NUM ]; // Sensor specific init function void mpr121_init () { // Loop through I2C addresses for ( uint8_t i = 0 ; i < MPR121_I2C_ADDR_NUM ); i ++ ) { // Check if sensor is connected on I2C address mpr121 [ i ]. connected = ( MPR121_I2C_ID_VAL == I2cRead8 ( MPR121_I2C_ADDR_1ST + i , MPR121_I2C_ID_REG ); if ( mpr121 [ i ]. connected ) { // Log sensor found snprintf_P ( log_data , sizeof ( log_data ), PSTR ( D_LOG_I2C \"MPR121-%d \" D_FOUND_AT \" 0x%X\" ), i , MPR121_I2C_ADDR_1ST + i ); AddLog ( LOG_LEVEL_INFO ); // Initialize sensor . . . // Set running to true mpr121 [ i ]. running = true ; } } if ( ! ( mpr121 [ 0 ]. connected || mpr121 [ 1 ]. connected || mpr121 [ 2 ]. connected || mpr121 [ 3 ]. connected )){ snprintf_P ( log_data , sizeof ( log_data ), PSTR ( D_LOG_I2C \"MPR121: No sensors found\" )); AddLog ( LOG_LEVEL_INFO ); } } Four advanced methods to use FUNC_EVERY_SECOND (Food for thought) : * If a sensor needs an action which takes a long time, like more than 100mS, the action will be started here for a future follow-up. Using the uptime variable for testing like (uptime &1) will happen every 2 seconds. An example is the DS18B20 driver where readings (conversions they call it) can take up to 800mS from the initial request. * If a sensor needed the previous action it is now time to gather the information and store it in a safe place to be used by FUNC_JSON_APPEND and/or FUNC_WEB_APPEND . Using the else function of the previous test (uptime &1) will happen every 2 seconds too but just 1 second later than the previous action. * If a sensor does not respond for 10 times the sensor detection flag could be reset which will stop further processing until the sensor is re-detected. This is currently not being used actively as some users complain about disappearing sensors for whatever reason - Could be hardware related but easier to make Tasmota a little more flexible. * Making re-detection of a sensor possible by executing this once every 100 seconds (94 == (uptime %100)) a re-attached sensor can be detected without a restart of Tasmota. The 94 given in this example should be different for every sensor driver to make sure not all sensors start detection at the same time. Using the drivers index number should be a good starting point. FUNC_PREP_BEFORE_TELEPERIOD NOTE: This callback ID is deprecated as sensors should prepare for more regular updates due to \"realtime\" rule execution. Use FUNC_EVERY_SECOND instead. See examples used in xsns_05_ds18x20.ino and xsns_09_bmp.ino where updated sensor data is stored in preparation to calls to FUNC_JSON_APPEND and FUNC_WEB_APPEND. FUNC_JSON_APPEND This callback ID is called when TelePeriod is due to append telemetry data to the MQTT JSON string or at approximately every 2 seconds when a rule is checked, e.g. snprintf_P ( mqtt_data , sizeof ( mqtt_data ), PSTR ( \"{ \\\" MPR121%c \\\" :{ \\\" Button%i \\\" :%i}}\" ), pS -> id [ i ], j , BITC ( i , j )); FUNC_WEB_APPEND This callback ID is called every millisecond when HTML code should be added to the Tasmota web-interface main page, e.g., snprintf_P ( mqtt_data , sizeof ( mqtt_data ), PSTR ( \"%s{s}MPR121%c Button%d{m}%d{e}\" ), mqtt_data , pS -> id [ i ], j , BITC ( i , j )); It should be wrapped in #ifdef USE_WEBSERVER ... #endif // USE_WEBSERVER FUNC_SAVE_BEFORE_RESTART This callback ID is called to allow a sensor to prepare for saving configuration changes. To be used to save volatile data just before a restart. Variables can be appended to struct SYSCFG {} Settings in file tasmota/settings.h . FUNC_COMMAND This callback ID is called when a sensor specific command Sensor<xx> or Driver<xx> is executed where xx is the sensor index. case FUNC_COMMAND : if ( XSNS_ < driver_ID > == XdrvMailbox . index ) { result = < driver_name > Command () { ... }; // Return true on success } break ; // Data struct of FUNC_COMMAND ID struct XDRVMAILBOX { uint16_t valid ; // ??? uint16_t index ; // Sensor index uint16_t data_len ; // Length of command string uint16_t payload16 ; // 16 bit unsigned int of payload if it could be converted, otherwise 0 int16_t payload ; // 16 bit signed int of payload if it could be converted, otherwise 0 uint8_t grpflg ; // ??? uint8_t notused ; // ??? char * topic ; // Command topic char * data ; // Command string/value - length of which is defined by data_len } XdrvMailbox ; If your driver needs to accept multiple parameters for SensorXX and/or DriverXX please consider using comma delimited formatting and use the already written subStr() function declared in support.ino to parse through the parameters you need. An example of those could be SensorXX reset // The reset parameter may be intercepted using: if ( ! strcmp ( subStr ( sub_string , XdrvMailbox . data , \",\" , 1 ), \"RESET\" )) { // Note 1 used for param number MyDriverName_Reset (); return serviced ; } Or in the case of multiple parameters SensorXX mode , 1 if ( ! strcmp ( subStr ( sub_string , XdrvMailbox . data , \",\" , 1 ), \"MODE\" )) { // Note 1 used for param number uint8_t mode = atoi ( subStr ( sub_string , XdrvMailbox . data , \",\" , 2 ); // Note 2 used for param number }","title":"Callback IDs"},{"location":"Sensor-API/#useful-functions","text":"","title":"Useful functions"},{"location":"Sensor-API/#mqtt","text":"void MqttPublishPrefixTopic_P ( uint8_t prefix , const char * subtopic , boolean retained ) This function publishes MQTT messages immediately, e.g., snprintf_P ( mqtt_data , sizeof ( mqtt_data ), PSTR ( \"{ \\\" MPR121%c \\\" :{ \\\" Button%i \\\" :%i}}\" ), pS -> id [ i ], j , BITC ( i , j )); MqttPublishPrefixTopic_P ( RESULT_OR_STAT , mqtt_data );","title":"MQTT"},{"location":"Sensor-API/#logging","text":"void AddLog ( byte loglevel ) This function adds log messages stored in log_data to the local logging system, e.g. snprintf_P ( log_data , sizeof ( log_data ), PSTR ( D_LOG_I2C \"MPR121(%c) \" D_FOUND_AT \" 0x%X\" ), pS -> id [ i ], pS -> i2c_addr [ i ]); AddLog ( LOG_LEVEL_INFO ); void AddLogSerial ( byte loglevel ) This function adds a log message to the local logging system dumping the serial buffer as hex information, e.g. AddLogSerial ( LOG_LEVEL_INFO ); void AddLogMissed ( char * sensor , uint8_t misses ) This function adds a log message to the local logging system about missed sensor reads.","title":"Logging"},{"location":"Sensor-API/#i2c-interface","text":"bool I2cValidRead8 ( uint8_t * data , uint8_t addr , uint8_t reg ) bool I2cValidRead16 ( uint16_t * data , uint8_t addr , uint8_t reg ) bool I2cValidReadS16 ( int16_t * data , uint8_t addr , uint8_t reg ) bool I2cValidRead16LE ( uint16_t * data , uint8_t addr , uint8_t reg ) bool I2cValidReadS16_LE ( int16_t * data , uint8_t addr , uint8_t reg ) bool I2cValidRead24 ( int32_t * data , uint8_t addr , uint8_t reg ) bool I2cValidRead ( uint8_t addr , uint8_t reg , uint8_t size ) These functions return true if 1, 2, 3 or size bytes can be read from the I 2 C address addr and register reg into *data . Functions with a S read signed data types while functions without a S read unsigned data types. Functions with LE read little-endian byte order while functions without LE read machine byte order. uint8_t I2cRead8 ( uint8_t addr , uint8_t reg ) uint16_t I2cRead16 ( uint8_t addr , uint8_t reg ) int16_t I2cReadS16 ( uint8_t addr , uint8_t reg ) uint16_t I2cRead16LE ( uint8_t addr , uint8_t reg ) int16_t I2cReadS16_LE ( uint8_t addr , uint8_t reg ) int32_t I2cRead24 ( uint8_t addr , uint8_t reg ) These functions return 1, 2 or 3 bytes from the I 2 C address addr and register reg . Functions with a S read signed data types while functions without a S read unsigned data types. Functions with LE read little endian byte order while functions without LE read machine byte order. bool I2cWrite8 ( uint8_t addr , uint8_t reg , uint8_t val ) bool I2cWrite16 ( uint8_t addr , uint8_t reg , uint16_t val ) bool I2cWrite ( uint8_t addr , uint8_t reg , uint32_t val , uint8_t size ) These functions return true after successfully writing 1, 2 or size bytes to the I 2 C address addr and register reg . int8_t I2cReadBuffer ( uint8_t addr , uint8_t reg , uint8_t * reg_data , uint16_t len ) int8_t I2cWriteBuffer ( uint8_t addr , uint8_t reg , uint8_t * reg_data , uint16_t len ) These functions copy len bytes from/to *reg_data starting at I 2 C address addr and register reg . void I2cScan ( char * devs , unsigned int devs_len ) This functions writes a list of I 2 C addresses in use into the string *dev with maximum length devs_len . bool I2cDevice ( byte addr ) This functions checks if the I 2 C address addr is in use.","title":"I2C Interface"},{"location":"Sensor-API/#useful-pre-processor-directives","text":"PSTR(\"string\") This pre-processor directive saves RAM by storing strings in flash instead of RAM. const char MyTextStaticVariable [] PROGMEM = \"string\" ; This pre-processor directive saves RAM by storing strings in flash instead of RAM. You may then reference them directly (if the type matches the parameter required) or force it to 4 byte alignment by using the variable as FPSTR(MyTextStaticVariable)","title":"Useful pre-processor directives"},{"location":"Sensor-API/#keeping-esp8266-code-compact","text":"Below are various tips and tricks to keep ESP8266 code compact and save both Flash and Memory. Flash code is limited to 1024k but keep in mind that to allow OTA upgrade, you need Flash memory to contain two firmwares at the same time. To go beyond 512k, you typically use tasmota-minimal as an intermediate firmware. tasmota-minimal takes roughly 360k, so it's safe not to go uint32_t beyond 620k of Flash. Memory is even more limited: 80k. With Arduino Core and basic Tasmota, there are 25k-30k left of heap space. Heap memory is very precious, running out of memory will generally cause a crash.","title":"Keeping ESP8266 code compact"},{"location":"Sensor-API/#about-esp8266","text":"ESP8266 is based on Xtensa instruction set . Xtensa is a 32 bits RISC processor core, containing 16 x 32 bits registers. ESP8266 supports integer operations, including 32x32 multiplication. It does not contain an FPU for floating point operations, nor integer divisions. Contrary to classical RISC processors, all instructions are 24 bits wide instead of 32 bits. To increase code compactness, some instructions have a 16 bits version used whenever possible by gcc. If you want to see what assembly is generated by gcc, in file platform.ini , at the section used to compile (ex: [core_2_6_1] ) in section build_flags add: -save-temps=obj -fverbose-asm Gcc will store <file>.s in the same folder as the .o file, typically in .pioenvs/ .","title":"About ESP8266"},{"location":"Sensor-API/#first-example","text":"Let's take a basic function: uint32_t Example ( uint32_t a , uint32_t b ) { return a + b ; } Below is the generated assembly. Function names are mangled using standard C++, i.e. their name derive from their arguments and return types: _Z7Examplejj: add.n a2 , a2 , a3 #, a, b ret.n As you can see, this is the simplest function we can think of. Register A2 holds the first argument and is used for return value. A3 holds the second argument.","title":"First example"},{"location":"Sensor-API/#uint8_t-or-uint32_t","text":"uint32_t Example ( uint32_t a , uint32_t b ) { uint8_t c = a + b ; return c ; } Assembly: _Z7Examplejj: add.n a2 , a2 , a3 # tmp52, a, b extui a2 , a2 , 0 , 8 #, tmp52 ret.n Whenever gcc needs to convert from uin32_t to uint8_t , it uses an extra instruction extui <reg>, <reg>, 0, 8 . Whenever you allocate uint8_t as a local variable, it will anyways allocate 32 bits on the stack. In conclusion you can easily use uint32_t in many places in the code. The main reason to force uint8_t are: in structures, to save memory. This is the only place where uint8_t will take 1 byte and the compiler will try to pack as much as 4 uint8_t in 32 bits when you want to ensure that the value can never exceed 255. Beware though that the compiler will just chunk the last 8 bits of a 32 bits value and will not report any overflow.","title":"uint8_t or uint32_t ?"},{"location":"Sensor-API/#floats-not-doubles","text":"ESP8266 does not have a FPU (Floating Point Unit), all floating point operations are emulated in software and provided in libm.a . The linker removes any unused functions, so we need to limit the number of floating point function calls. Rule 1 : use ints where you can, avoid floating point operations. Rule 2 : if you really need floating point, always use float , never ever use double . Let's now see why. float fits in 32 bits, with a mantissa of 20 bits, exponent of TODO. The mantissa is 20 bits wide, which provides enough precision for most of our needs. float is 32 bits wide and fits in a single register, whereas double is 64 bits and requires 2 registers. float Examplef ( float a , float b ) { return sinf ( a ) * ( b + 0.4f ) - 3.5f ; } Assembly: .literal .LC1012 , 0x3ecccccd < - 0 .4f .literal .LC1013 , 0x40600000 < - 3 .5f _Z8Examplefff: addi sp , sp , - 16 #,, <- reserve 16 bytes on stack s32i.n a0 , sp , 12 #, <- save a0 (return address) on stack s32i.n a12 , sp , 8 #, <- save a12 on stack, to free for local var s32i.n a13 , sp , 4 #, <- save a13 on stack, to free for local var mov.n a13 , a3 # b, b <- a3 holds 'b', save to a13 call0 sinf # <- calc sin of a2 (a) l32r a3 , .LC1012 #, <- load 0.4f in a3 mov.n a12 , a2 # D.171139, <- save result 'sin(a)' to a12 mov.n a2 , a13 #, b <- move a13 (second arg: b) to a2 call0 __addsf3 # <- add floats a2 and a3, result to a2 mov.n a3 , a2 # D.171139, <- copy result to a3 mov.n a2 , a12 #, D.171139 <- load a2 with a12: sin(a) call0 __mulsf3 # <- multiply 'sin(a)*(b+0.4f)' l32r a3 , .LC1013 #, <- load a3 with 3.5f call0 __subsf3 # <- substract l32i.n a0 , sp , 12 #, <- restore a0 (return address) l32i.n a12 , sp , 8 #, <- restore a12 l32i.n a13 , sp , 4 #, <- restore a13 addi sp , sp , 16 #,, <- free stack ret.n < - return Now with double : double Exampled ( double a , double b ) { return sin ( a ) * ( b + 0.4 ) - 3.5 ; } Assembly: .literal .LC1014 , 0x9999999a , 0x3fd99999 < - 0 .4 .literal .LC1015 , 0x00000000 , 0x400c0000 < - 3 .5 _Z8Exampleddd: addi sp , sp , - 32 #,, s32i.n a0 , sp , 28 #, s32i.n a12 , sp , 24 #, s32i.n a13 , sp , 20 #, s32i.n a14 , sp , 16 #, s32i.n a15 , sp , 12 #, mov.n a14 , a4 #, mov.n a15 , a5 #, call0 sin # l32r a4 , .LC1014 #, l32r a5 , .LC1014 + 4 #, mov.n a12 , a2 #, mov.n a13 , a3 #, mov.n a2 , a14 #, mov.n a3 , a15 #, call0 __adddf3 # mov.n a4 , a2 #, mov.n a5 , a3 #, mov.n a2 , a12 #, mov.n a3 , a13 #, call0 __muldf3 # l32r a4 , .LC1015 #, l32r a5 , .LC1015 + 4 #, call0 __subdf3 # l32i.n a0 , sp , 28 #, l32i.n a12 , sp , 24 #, l32i.n a13 , sp , 20 #, l32i.n a14 , sp , 16 #, l32i.n a15 , sp , 12 #, addi sp , sp , 32 #,, ret.n As you can see the double needs to move many more registers around. Examplef (float) is 84 bytes, Exampled (double) is 119 bytes (+42% code size). Actually it's even worse, sin is larger than float version sinf . Also, never forget to explicitly tag literals as float: always put 1.5f and not 1.5 . Let's see the impact: float Examplef2 ( float a , float b ) { return sinf ( a ) * ( b + 0.4 ) - 3.5 ; // same as above with double literals } Assembly: .literal .LC1014 , 0x9999999a , 0x3fd99999 .literal .LC1015 , 0x00000000 , 0x400c0000 .align 4 .global _Z9Examplef2ff .type _Z9Examplef2ff , @function _Z9Examplef2ff: addi sp , sp , - 16 #,, s32i.n a0 , sp , 12 #, s32i.n a12 , sp , 8 #, s32i.n a13 , sp , 4 #, s32i.n a14 , sp , 0 #, mov.n a14 , a3 # b, b call0 sinf # call0 __extendsfdf2 # <- extend float to double mov.n a12 , a2 #, mov.n a2 , a14 #, b mov.n a13 , a3 #, call0 __extendsfdf2 # <- extend float to double l32r a4 , .LC1014 #, l32r a5 , .LC1014 + 4 #, call0 __adddf3 # <- add double mov.n a4 , a2 #, mov.n a5 , a3 #, mov.n a2 , a12 #, mov.n a3 , a13 #, call0 __muldf3 # <- multiply double l32r a4 , .LC1015 #, l32r a5 , .LC1015 + 4 #, call0 __subdf3 # <- substract double call0 __truncdfsf2 # <- truncate double to float l32i.n a0 , sp , 12 #, l32i.n a12 , sp , 8 #, l32i.n a13 , sp , 4 #, l32i.n a14 , sp , 0 #, addi sp , sp , 16 #,, ret.n The last example takes 143 bytes, which is even worse than the double version, because of conversions from float to double and back. Internally, if you don't force float literals, gcc will make all intermediate compute in double and convert to float in the end. This is usually what is wanted: compute with maximum precision and truncate at the last moment. But for ESP8266 we want the opposite: most compact code.","title":"Floats, not doubles!"},{"location":"Sensor-API/#string-concatenation","text":"Let's start with an easy example: void ExampleStringConcat ( String & s ) { s += \"suffix\" ; } Assembly (25 bytes): .LC1024: .string \"suffix\" .literal .LC1025 , .LC1024 _Z19ExampleStringConcatR6String: l32r a3 , .LC1025 #, addi sp , sp , - 16 #,, s32i.n a0 , sp , 12 #, call0 _ZN6String6concatEPKc # l32i.n a0 , sp , 12 #, addi sp , sp , 16 #,, ret.n If you need to add more complex strings, do not concatenate using native c++ concat: void ExampleStringConcat2 ( String & s , uint8_t a , uint8_t b ) { s += \"[\" + String ( a ) + \",\" + String ( b ) + \"]\" ; } Assembly (122 bytes!): .LC231: .string \",\" .LC1026: .string \"[\" .LC1029: .string \"]\" .literal .LC1027 , .LC1026 .literal .LC1028 , .LC231 .literal .LC1030 , .LC1029 _Z20ExampleStringConcat2R6Stringhh: addi sp , sp , - 64 #,, s32i.n a13 , sp , 52 #, extui a13 , a3 , 0 , 8 # a, a l32r a3 , .LC1027 #, s32i.n a12 , sp , 56 #, mov.n a12 , a2 # s, s addi.n a2 , sp , 12 #,, s32i.n a0 , sp , 60 #, s32i.n a14 , sp , 48 #, extui a14 , a4 , 0 , 8 # b, b call0 _ZN6StringC2EPKc # . <- allocate String movi.n a4 , 0xa #, addi a2 , sp , 24 #,, mov.n a3 , a13 #, a call0 _ZN6StringC1Ehh # <- allocate String addi a3 , sp , 24 #,, addi.n a2 , sp , 12 #,, call0 _ZplRK15StringSumHelperRK6String # l32r a3 , .LC1028 #, call0 _ZplRK15StringSumHelperPKc # movi.n a4 , 0xa #, mov.n a13 , a2 # D.171315, mov.n a3 , a14 #, b mov.n a2 , sp #, call0 _ZN6StringC1Ehh # <- allocate String mov.n a3 , sp #, mov.n a2 , a13 #, D.171315 call0 _ZplRK15StringSumHelperRK6String # l32r a3 , .LC1030 #, call0 _ZplRK15StringSumHelperPKc # mov.n a3 , a2 # D.171315, mov.n a2 , a12 #, s call0 _ZN6String6concatERKS_ # mov.n a2 , sp #, call0 _ZN6StringD1Ev # <- destructor addi a2 , sp , 24 #,, call0 _ZN6StringD1Ev # <- destructor addi.n a2 , sp , 12 #,, call0 _ZN6StringD2Ev # <- destructor l32i.n a0 , sp , 60 #, l32i.n a12 , sp , 56 #, l32i.n a13 , sp , 52 #, l32i.n a14 , sp , 48 #, addi sp , sp , 64 #,, ret.n Instead use native String concat: void ExampleStringConcat3 ( String & s , uint8_t a , uint8_t b ) { s += \"[\" ; s += a ; s += \",\" ; s += b ; s += \"]\" ; } Assembly (69 bytes, -43%): .LC231: .string \",\" .LC1026: .string \"[\" .LC1029: .string \"]\" .literal .LC1031 , .LC1026 .literal .LC1032 , .LC231 .literal .LC1033 , .LC1029 _Z20ExampleStringConcat3R6Stringhh: addi sp , sp , - 16 #,, s32i.n a13 , sp , 4 #, extui a13 , a3 , 0 , 8 # a, a l32r a3 , .LC1031 #, s32i.n a0 , sp , 12 #, s32i.n a12 , sp , 8 #, s32i.n a14 , sp , 0 #, mov.n a12 , a2 # s, s extui a14 , a4 , 0 , 8 # b, b call0 _ZN6String6concatEPKc # <- native char* add mov.n a3 , a13 #, a mov.n a2 , a12 #, s call0 _ZN6String6concatEh # <- native int add l32r a3 , .LC1032 #, mov.n a2 , a12 #, s call0 _ZN6String6concatEPKc # <- native char* add mov.n a3 , a14 #, b mov.n a2 , a12 #, s call0 _ZN6String6concatEh # <- native int add l32r a3 , .LC1033 #, mov.n a2 , a12 #, s call0 _ZN6String6concatEPKc # <- native char* add l32i.n a0 , sp , 12 #, l32i.n a12 , sp , 8 #, l32i.n a13 , sp , 4 #, l32i.n a14 , sp , 0 #, addi sp , sp , 16 #,, ret.n","title":"String concatenation"},{"location":"Sensor-Configuration/","text":"?> Read before continuing: \u2003- Components \u2003- Expanding Tasmota [!WARNING] A peripheral must have correctly wired power, GND and data pins to the device prior to booting in order for Tasmota to detect it and initialize it properly. Tasmota Settings ~ Tasmota allows for easy selection of peripherals (sensors, switches, etc) and assignment to GPIO pins. Configuration is possible in the webUI Configuration - Configure Module page or by using commands: Module and GPIO , or Template . Module First select desired module for the device (Wait for the restart). Depending on the type of Module , only certain GPIO pins are user configurable. Module Generic (18) has all the GPIOs configurable. Modules shows supported modules GPIO Assign a component to a GPIO. gpio14 2 configures sensor AM2301 to GPIO14_ Backlog gpio14 5; gpio4 6 sets I 2 C SCL to GPIO14 and I 2 C SDA to GPIO4 Tasmota will auto-detect all connected and supported I 2 C devices. If you have conflicting I 2 C addresses see I2CDevices Gpios All shows list of all available components by name and index For a peripheral to show up you may need to power cycle your device instead of a soft restart. Template Instead of using Module and GPIO you can define all using Template Read more... Additional Options ~ Measurement Units ~ Temperature units can be set to Celsius or Fahrenheit with SetOption8 command. Pressure units can be set to hPa or mmHg with SetOption24 command. Update Interval ~ To change the update interval (teleperiod) of MQTT messages change the TelePeriod . Default interval is 300 seconds but can be set between 10 and 3600 seconds. TelePeriod 10 will set the update interval to 10 seconds, so the sensor will update 6 times a minute. Peripheral Specific ~ Some peripherals offer, or even require, additional commands. See Commands page for peripheral specific commands.","title":"Sensor Configuration"},{"location":"Sensor-Configuration/#tasmota-settings","text":"Tasmota allows for easy selection of peripherals (sensors, switches, etc) and assignment to GPIO pins. Configuration is possible in the webUI Configuration - Configure Module page or by using commands: Module and GPIO , or Template . Module First select desired module for the device (Wait for the restart). Depending on the type of Module , only certain GPIO pins are user configurable. Module Generic (18) has all the GPIOs configurable. Modules shows supported modules GPIO Assign a component to a GPIO. gpio14 2 configures sensor AM2301 to GPIO14_ Backlog gpio14 5; gpio4 6 sets I 2 C SCL to GPIO14 and I 2 C SDA to GPIO4 Tasmota will auto-detect all connected and supported I 2 C devices. If you have conflicting I 2 C addresses see I2CDevices Gpios All shows list of all available components by name and index For a peripheral to show up you may need to power cycle your device instead of a soft restart. Template Instead of using Module and GPIO you can define all using Template Read more...","title":"Tasmota Settings"},{"location":"Sensor-Configuration/#additional-options","text":"","title":"Additional Options"},{"location":"Sensor-Configuration/#measurement-units","text":"Temperature units can be set to Celsius or Fahrenheit with SetOption8 command. Pressure units can be set to hPa or mmHg with SetOption24 command.","title":"Measurement Units"},{"location":"Sensor-Configuration/#update-interval","text":"To change the update interval (teleperiod) of MQTT messages change the TelePeriod . Default interval is 300 seconds but can be set between 10 and 3600 seconds. TelePeriod 10 will set the update interval to 10 seconds, so the sensor will update 6 times a minute.","title":"Update Interval"},{"location":"Sensor-Configuration/#peripheral-specific","text":"Some peripherals offer, or even require, additional commands. See Commands page for peripheral specific commands.","title":"Peripheral Specific"},{"location":"SetOption36/","text":"SetOption36 is deprecated in favour of using the sleep command to use either Dynamic or Normal sleep as from Tasmota version 6.3.0.15. Click here to see the updated Wiki for Dynamic Sleep","title":"SetOption36"},{"location":"SetOption37/","text":"SetOption37 is used for re-mapping the RGBW c W w channels. This transformation happens right before the hardware-specific output, so all the advanced features (schemes, hsb setting, etc.) works with the original, un-mapped values. The main reason for this option is to provide support for bulbs whose physical wiring is almost the usual/standard one, but the channels are arranged in a different way. For technical reasons this transformation isn't a full N-to-N mapping, it can only the re-arrange the channels, which is equivalent to map the (R,G,B,W c ,W w ) channels to one of their permutations. The required permutation can be configured via SetOption37 n , where n is the systematic index of the permutation, a number from the [0 .. 119] interval, from 0=(R,G,B,W c ,W w ) to 119=(W w ,W c ,B,G,R): Idx Perm. Idx Perm. Idx Perm. Idx Perm. 0 R,G,B,W c ,W w 1 R,G,B,W w ,W c 2 R,G,W c ,B,W w 3 R,G,W c ,W w ,B 4 R,G,W w ,B,W c 5 R,G,W w ,W c ,B 6 R,B,G,W c ,W w 7 R,B,G,W w ,W c 8 R,B,W c ,G,W w 9 R,B,W c ,W w ,G 10 R,B,W w ,G,W c 11 R,B,W w ,W c ,G 12 R,W c ,G,B,W w 13 R,W c ,G,W w ,B 14 R,W c ,B,G,W w 15 R,W c ,B,W w ,G 16 R,W c ,W w ,G,B 17 R,W c ,W w ,B,G 18 R,W w ,G,B,W c 19 R,W w ,G,W c ,B 20 R,W w ,B,G,W c 21 R,W w ,B,W c ,G 22 R,W w ,W c ,G,B 23 R,W w ,W c ,B,G 24 G,R,B,W c ,W w 25 G,R,B,W w ,W c 26 G,R,W c ,B,W w 27 G,R,W c ,W w ,B 28 G,R,W w ,B,W c 29 G,R,W w ,W c ,B 30 G,B,R,W c ,W w 31 G,B,R,W w ,W c 32 G,B,W c ,R,W w 33 G,B,W c ,W w ,R 34 G,B,W w ,R,W c 35 G,B,W w ,W c ,R 36 G,W c ,R,B,W w 37 G,W c ,R,W w ,B 38 G,W c ,B,R,W w 39 G,W c ,B,W w ,R 40 G,W c ,W w ,R,B 41 G,W c ,W w ,B,R 42 G,W w ,R,B,W c 43 G,W w ,R,W c ,B 44 G,W w ,B,R,W c 45 G,W w ,B,W c ,R 46 G,W w ,W c ,R,B 47 G,W w ,W c ,B,R 48 B,R,G,W c ,W w 49 B,R,G,W w ,W c 50 B,R,W c ,G,W w 51 B,R,W c ,W w ,G 52 B,R,W w ,G,W c 53 B,R,W w ,W c ,G 54 B,G,R,W c ,W w 55 B,G,R,W w ,W c 56 B,G,W c ,R,W w 57 B,G,W c ,W w ,R 58 B,G,W w ,R,W c 59 B,G,W w ,W c ,R 60 B,W c ,R,G,W w 61 B,W c ,R,W w ,G 62 B,W c ,G,R,W w 63 B,W c ,G,W w ,R 64 B,W c ,W w ,R,G 65 B,W c ,W w ,G,R 66 B,W w ,R,G,W c 67 B,W w ,R,W c ,G 68 B,W w ,G,R,W c 69 B,W w ,G,W c ,R 70 B,W w ,W c ,R,G 71 B,W w ,W c ,G,R 72 W c ,R,G,B,W w 73 W c ,R,G,W w ,B 74 W c ,R,B,G,W w 75 W c ,R,B,W w ,G 76 W c ,R,W w ,G,B 77 W c ,R,W w ,B,G 78 W c ,G,R,B,W w 79 W c ,G,R,W w ,B 80 W c ,G,B,R,W w 81 W c ,G,B,W w ,R 82 W c ,G,W w ,R,B 83 W c ,G,W w ,B,R 84 W c ,B,R,G,W w 85 W c ,B,R,W w ,G 86 W c ,B,G,R,W w 87 W c ,B,G,W w ,R 88 W c ,B,W w ,R,G 89 W c ,B,W w ,G,R 90 W c ,W w ,R,G,B 91 W c ,W w ,R,B,G 92 W c ,W w ,G,R,B 93 W c ,W w ,G,B,R 94 W c ,W w ,B,R,G 95 W c ,W w ,B,G,R 96 W w ,R,G,B,W c 97 W w ,R,G,W c ,B 98 W w ,R,B,G,W c 99 W w ,R,B,W c ,G 100 W w ,R,W c ,G,B 101 W w ,R,W c ,B,G 102 W w ,G,R,B,W c 103 W w ,G,R,W c ,B 104 W w ,G,B,R,W c 105 W w ,G,B,W c ,R 106 W w ,G,W c ,R,B 107 W w ,G,W c ,B,R 108 W w ,B,R,G,W c 109 W w ,B,R,W c ,G 110 W w ,B,G,R,W c 111 W w ,B,G,W c ,R 112 W w ,B,W c ,R,G 113 W w ,B,W c ,G,R 114 W w ,W c ,R,G,B 115 W w ,W c ,R,B,G 116 W w ,W c ,G,R,B 117 W w ,W c ,G,B,R 118 W w ,W c ,B,R,G 119 W w ,W c ,B,G,R Source: this spreadsheet","title":"SetOption37"},{"location":"Shutter-and-Steppers/","text":"!> This feature is not included in precompiled binaries. To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_SHUTTER #define USE_SHUTTER // Add Shutter support (+6k code) #endif Stepper motors can be used to operate shutters and blinds. The configuration is very similar to the Circuit Safe (Shuttermode 1) configuration. To operate a stepper motor requires driver module such as the A4988 and uses EN (enable), DIR (direction), STP (Stepper) for controls. If everything is defined correctly the shuttermode 3 will be reported at boot time. Tasmota supports a maximum of four shutters with one stepper motor per shutter simultanously. In very rare conditions where two or more shutters simoultanously move the last mm it can happen than one shutter moves to far. Full description of Blinds and Shutters Complete list of Blinds, Shutters and Roller Shades Commands Stepper motor and Stepper drivers wiring diagrams Stepper drivers configuration tutorials: A4988 DRV8825 TMC2208 Modifying a 28BYJ-48 12V stepper motor from unipolar to bipolar tutorial Bill of Materials Example configuration ~ EN and DIR are on Relay1i and Relay2 respectively. Please be aware to use the inverse relay for the enable signal. The STP signal is assigned as a PWM<x> component where <x> matches the number of the shutter (e.g., PWM1 for Shutter1 ). The shutter feature adjusts the PWM frequency to operate the motor for proper shutter operation. The stepper motor frequency setting is a global setting all PWM components on the device. This means that all shutters on the device will operate at the same speed. Therefore no PWM devices other than shutters can be connected to the same Tasmota device. The frequency of the PWM can be changed from 1000Hz to any value up to 10,000Hz. The command ShutterFrequency globally changes this. Be aware that most 12V operated motors cannot work faster than 2,000Hz. 5,000Hz.10,000Hz is possible by increasing the supplied voltage to 24V and use ShutterMotorDelay to allow a slow speed up/speed down. The maximum voltage of the A4988 is 36V. The TMC2208 is much more silent than the others but also significant slower and does not like high frequencies. For example, the speed at 24V is half o A4988 Finally a GPIO must be assigned as Counter1 . This counter is used to keep track of the steps and send the stepper to the correct position. The Counter1 GPIO must be connected to the PWM1 GPIO. Otherwise the stepper and your shutter will run continually or freeze up randomly. Only bipolar stepper motors may be used (see above). You must properly configure the stepper motor driver (see above). ShutterOpenDuration and ShutterCloseDuration can be different. Shutter with Stepper motors always match positions exact. There is no need to vary ShutterOpenDuration and ShutterCloseDuration . Anyhow, if you decrease ShutterCloseDuration the Shutter will close with a higher speed on a virtual higher ShutterFrequency if possible. Same vice versa. You can define a soft start/stop by defining a ShutterMotorDelay . This causes the driver to ramp the speed up and down during the defined duration. The change of the ShutterMotorDelay does NOT change the distance the shutter makes. This is very convinent to trim the accelerate and decelerate rate without changeing the distance. Wemos Pin GPIO Component Stepper Signal D1 5 Relay1i EN D2 4 Relay2 DIR D3 0 PWM1 STP D4 2 Counter1 STP a) Set ShutterMode 3 Backlog PulseTime1 0; PulseTime2 0 // for relay Relay1i and Relay2 Interlock OFF // this is a global variable for all Relays or at least the RELAYS NOT in the Interlock group PWM1 and COUNTER1 defined b) Enable Shutters SetOption80 1 // this is a global variable for all Shutters c) Configure Shutter 1 and test ShutterMode 1 is working ShutterRelay1 1 // for relay Relay1i and Relay2 d) Set the stepper motor speed (optional setting) ShutterFrequency 1500 // this is a global variable for all steppers (1000rpm by default) e) Set at least a small ramp-up/ramp down period 1.0 second (optional) ShutterMotorDelay1 1.0 // Stepper do not like infinite momentum. Ramp up/down speed allow much higher frequencies. f) Restart Tasmota Restart 1 g) Test the shutter ShutterOpen1 ShutterStop1 // to stop the STEPPER1 ShutterClose1 ShutterInvert1 // to change the direction of rotation of the STEPPER1 h) Perform the shutter calibration Configuration for additional shutters ~ You must first set up the first shutter and only then the next. Wemos Pin GPIO Component Stepper Signal D5 14 Relay3i EN D6 12 Relay4 DIR D7 13 PWM2 STP D8 15 Counter2 STP a) Set ShutterMode 3 Backlog PulseTime3 0; PulseTime4 0 // for relay Relay3i and Relay4 PWM2 and COUNTER2 defined c) Configure Shutter 2 and test ShutterMode 1 is working ShutterRelay2 3 // for relay Relay3i and Relay4 b) Restart Tasmota Restart 1 d) Test the shutter ShutterOpen2 ShutterStop2 // to stop the STEPPER2 ShutterClose2 ShutterInvert2 // to change the direction of rotation of the STEPPER2 e) Perform the shutter calibration Wiring Diagrams ~ One Shutter ~ - Diagram v412: simple universal setup. For example, the control of horizontal curtain or vertical shutters, blinds adjuster or window opener, pet feeders, opening of a water tap for watering the lawn, rotating table for subject photography, opening the ventilation flap, PTZ camera, 3D Scanner Table, linear Actuator. - Diagram v414: parallel setup is to run two parallel steppers motors from the same controller. For example, to control a large and heavy hanging screen for an LCD projector, or two curtains at once on one large window. - Diagram v416: minimum setup size. For example, for small curtains located in a limited space. 2 Shutters ~ - Diagram v422: parallel setup is to run two shutters and independent control of two stepper motors from one controller. For example, to control two independent curtains. - Diagram v424: big parallel setup is to run two shutters and independent control of two pairs of stepper motors from one controller. For example, to control four curtains on one very large window. Bill of Materials ~ ESP8266 Boards: Wemos D1 mini NodeMCU ESP-01S Stepper motors (NEMA 17): Standard 5:1 Planetary Gearbox Stepper motors (28BYJ-48): Standard Stepper Drivers: A4988 DRV8825 TMC 2208 Stepper Motor Control Development Boards: x1 board x2 board DC-DC Step Down Power Supply Module: MP1584EN LM2596 XL4015 Power Supplies (AC-DC): DC 12V 2.5A DC 12V 4A DC 24v 4A Aluminum Capacitors: 35V 100UF 35V 10UF Motor Testing PWM Signal Generator: 1 type 2 type","title":"Shutter and Steppers"},{"location":"Shutter-and-Steppers/#example-configuration","text":"EN and DIR are on Relay1i and Relay2 respectively. Please be aware to use the inverse relay for the enable signal. The STP signal is assigned as a PWM<x> component where <x> matches the number of the shutter (e.g., PWM1 for Shutter1 ). The shutter feature adjusts the PWM frequency to operate the motor for proper shutter operation. The stepper motor frequency setting is a global setting all PWM components on the device. This means that all shutters on the device will operate at the same speed. Therefore no PWM devices other than shutters can be connected to the same Tasmota device. The frequency of the PWM can be changed from 1000Hz to any value up to 10,000Hz. The command ShutterFrequency globally changes this. Be aware that most 12V operated motors cannot work faster than 2,000Hz. 5,000Hz.10,000Hz is possible by increasing the supplied voltage to 24V and use ShutterMotorDelay to allow a slow speed up/speed down. The maximum voltage of the A4988 is 36V. The TMC2208 is much more silent than the others but also significant slower and does not like high frequencies. For example, the speed at 24V is half o A4988 Finally a GPIO must be assigned as Counter1 . This counter is used to keep track of the steps and send the stepper to the correct position. The Counter1 GPIO must be connected to the PWM1 GPIO. Otherwise the stepper and your shutter will run continually or freeze up randomly. Only bipolar stepper motors may be used (see above). You must properly configure the stepper motor driver (see above). ShutterOpenDuration and ShutterCloseDuration can be different. Shutter with Stepper motors always match positions exact. There is no need to vary ShutterOpenDuration and ShutterCloseDuration . Anyhow, if you decrease ShutterCloseDuration the Shutter will close with a higher speed on a virtual higher ShutterFrequency if possible. Same vice versa. You can define a soft start/stop by defining a ShutterMotorDelay . This causes the driver to ramp the speed up and down during the defined duration. The change of the ShutterMotorDelay does NOT change the distance the shutter makes. This is very convinent to trim the accelerate and decelerate rate without changeing the distance. Wemos Pin GPIO Component Stepper Signal D1 5 Relay1i EN D2 4 Relay2 DIR D3 0 PWM1 STP D4 2 Counter1 STP a) Set ShutterMode 3 Backlog PulseTime1 0; PulseTime2 0 // for relay Relay1i and Relay2 Interlock OFF // this is a global variable for all Relays or at least the RELAYS NOT in the Interlock group PWM1 and COUNTER1 defined b) Enable Shutters SetOption80 1 // this is a global variable for all Shutters c) Configure Shutter 1 and test ShutterMode 1 is working ShutterRelay1 1 // for relay Relay1i and Relay2 d) Set the stepper motor speed (optional setting) ShutterFrequency 1500 // this is a global variable for all steppers (1000rpm by default) e) Set at least a small ramp-up/ramp down period 1.0 second (optional) ShutterMotorDelay1 1.0 // Stepper do not like infinite momentum. Ramp up/down speed allow much higher frequencies. f) Restart Tasmota Restart 1 g) Test the shutter ShutterOpen1 ShutterStop1 // to stop the STEPPER1 ShutterClose1 ShutterInvert1 // to change the direction of rotation of the STEPPER1 h) Perform the shutter calibration","title":"Example configuration"},{"location":"Shutter-and-Steppers/#configuration-for-additional-shutters","text":"You must first set up the first shutter and only then the next. Wemos Pin GPIO Component Stepper Signal D5 14 Relay3i EN D6 12 Relay4 DIR D7 13 PWM2 STP D8 15 Counter2 STP a) Set ShutterMode 3 Backlog PulseTime3 0; PulseTime4 0 // for relay Relay3i and Relay4 PWM2 and COUNTER2 defined c) Configure Shutter 2 and test ShutterMode 1 is working ShutterRelay2 3 // for relay Relay3i and Relay4 b) Restart Tasmota Restart 1 d) Test the shutter ShutterOpen2 ShutterStop2 // to stop the STEPPER2 ShutterClose2 ShutterInvert2 // to change the direction of rotation of the STEPPER2 e) Perform the shutter calibration","title":"Configuration for additional shutters"},{"location":"Shutter-and-Steppers/#wiring-diagrams","text":"","title":"Wiring Diagrams"},{"location":"Shutter-and-Steppers/#one-shutter","text":"- Diagram v412: simple universal setup. For example, the control of horizontal curtain or vertical shutters, blinds adjuster or window opener, pet feeders, opening of a water tap for watering the lawn, rotating table for subject photography, opening the ventilation flap, PTZ camera, 3D Scanner Table, linear Actuator. - Diagram v414: parallel setup is to run two parallel steppers motors from the same controller. For example, to control a large and heavy hanging screen for an LCD projector, or two curtains at once on one large window. - Diagram v416: minimum setup size. For example, for small curtains located in a limited space.","title":"One Shutter"},{"location":"Shutter-and-Steppers/#2-shutters","text":"- Diagram v422: parallel setup is to run two shutters and independent control of two stepper motors from one controller. For example, to control two independent curtains. - Diagram v424: big parallel setup is to run two shutters and independent control of two pairs of stepper motors from one controller. For example, to control four curtains on one very large window.","title":"2 Shutters"},{"location":"Shutter-and-Steppers/#bill-of-materials","text":"ESP8266 Boards: Wemos D1 mini NodeMCU ESP-01S Stepper motors (NEMA 17): Standard 5:1 Planetary Gearbox Stepper motors (28BYJ-48): Standard Stepper Drivers: A4988 DRV8825 TMC 2208 Stepper Motor Control Development Boards: x1 board x2 board DC-DC Step Down Power Supply Module: MP1584EN LM2596 XL4015 Power Supplies (AC-DC): DC 12V 2.5A DC 12V 4A DC 24v 4A Aluminum Capacitors: 35V 100UF 35V 10UF Motor Testing PWM Signal Generator: 1 type 2 type","title":"Bill of Materials"},{"location":"Smart-Meter-Interface/","text":"!> This feature is not included in precompiled binaries. To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_SCRIPT #define USE_SCRIPT # adds about 17k flash size, variable ram size #endif #ifndef USE_SML_M #define USE_SML_M #endif #ifdef USE_RULES #undef USE_RULES #endif // see bellow instructions to set the value N accordingly #define SML_MAX_VARS N Driver for various meters , heating devices, and reed like contacts To use this interface, connect the meter to available GPIO pins. These GPIOs must be set as None (0) components in Tasmota. If the interface detects that a meter descriptor GPIO conflicts with a Tasmota GPIO setting, the interface will generate a \"duplicate GPIO defined\" error in the log and the meter descriptor will be ignored. The Smart Meter Interface provides a means to connect many kinds of meters to Tasmota. The following types of meter protocols are supported: - ASCII OBIS telegrams emitted from many smart meters and also from P1 meter interface - Binary SML OBIS telegram emitted from many smart meters - Binary EBUS telegram emitted by many heaters and heat pumps (e.g., Vaillant, Wolf) - Binary MODBUS telegram used by many power meters - Binary RAW telegram decodes all kinds of binary data eg EMS heater bus - Counter interface (uses Tasmota counter storage) for e.g., reed contacts either in polling or IRQ mode There are many different meters that use the same protocol. There are multitudes of variants and use cases. A meter can be defined by using compilation time #define pragmas. This requires recompiling the firmware to make modifications. This interface provides a means of specifying these definitions through meter descriptors . This method uses the scripting language editor to define the descriptors. In this way, only one firmware binary version is required and a modification can be made easily \"on the fly\". Note If no >M section is found in the script or if the scripting language is not compiled, the driver reverts to the default #define definition(s). [!NOTE]Additional hardware is required to read certain measuring devices. For example: RS485toTTL Adaper for Modbus, IR transistor for electricity meters. Sometimes an additional IR diode and resistors. Descriptor Syntax ~ This section must be present, but empty. In most cases, there is no need to define variables for this driver. >D Declare a script >B (boot) section to inform the interface to read the meter descriptor(s) >B => sensor53 r Declare a script >M section with the number of connected meters (n = 1..5 ) >M <n> Meter Declaration ~ +<M>,<rxGPIO>,<type>,<flag>,<parameter>,<jsonPrefix>{,<txGPIO>,<txPeriod>,<cmdTelegram>} [!EXAMPLE] +1,3,o,0,9600,OBIS1,1,2,2F3F210D0A +1,3,s,16,9600,SML1 +1,12,c,1,-10,H20_Cnt +1,3,m,0,9600,MODBUS,1,1,01040000,01040002,01040004,01040006,01040008,0104000a,0104000c,0104000e,01040010 +<M>,<rxGPIO>,<type>,<flag>,<parameter>,<jsonPrefix>{,<txGPIO>,<txPeriod>,<cmdTelegram>} - <M> - meter number. The number must be increased with each additional Meter. (1...5) - <rxGPIO> - meter data receive GPIO - <type> - meter type of meter: - o = OBIS ASCII type of coding - s = SML binary smart message coding - c = Counter type - e = EBus binary coding - m = MODBus binary coding with serial mode 8N1 - M = MODBus binary coding with serial mode 8E1 - r = Raw binary coding (any binary telegram) - <flag> - options flag: - 0 = counter without pullup - 1 = counter with pullup - 16 = enable median filter for that meter. Can help with sporadic dropouts eg. reading errors. (not available for counters) - <parameter> - parameters according to meter type: - for o,s,e,m,r : serial baud rate eg. 9600 - for c : - positive value >0 = counter poll interval - negative value <=0 = debounce time (milliseconds) for irq driven counters - <jsonPrefix> - prefix for Web UI and MQTT JSON payload. Up to 7 characters - <txGPIO> - meter command transmit GPIO (optional) - <txPeriod> - number of 250ms increments (n * 250ms). Period to repeat the transmission of commands to the meter (optional) - <cmdTelegram> - comma separated hex coded byte blocks to send to meter device. For modbus each comma separated block is a command to retrieve a certain register from the meter (Optional, only required for measuring devices that have to be triggered with a certain character string.) Modbus: [!EXAMPLE] +1,3,m,0,9600,MODBUS,1,1,01040000,01040002,01040004,01040006,01040008,0104000a,0104000c,0104000e,01040010 Components of the character string: ...01040000,01040002,... 01 = Modbus slave device ID 04 = Instruction to read an Input Register (alternatively, 03 = Instruction to read an Holding Register) 0000 / 0002 = Register # (as Hexadecimal codification, without the prefix 0x . Example: 0x0079 -> 0079 ) Note ID , Instruction to read the Register value (Input vs Holding) and Register # may differ depending on the measuring device. Meter Metrics ~ Each meter typically provides multiple metrics (voltage, power, current, humidity etc.) which it measures. An entry for each metric to be collected as #define SML_MAX_VARS N (n = 1..16 ) must be specified, in user_config_override.h file (see the code at the page top). An entry defines how to decode the data and put it into variables. [!EXAMPLE] (OBIS/SML/MODBus): 1,1-0:1.8.1\\*255(@1,Total consumption,KWh,Total_in,4 1,77070100010801ff@1000,W1,kWh,w1,4 1,010304UUuuxxxxxxxx@i0:1,Spannung L1,V,Voltage_L1,0 <M>,<decoder>@<scale>,<label>,<UoM>,<var>,<precision> - <M> - meter number to which this decoder belongs - <decoder> - decoding specification. Decode OBIS as ASCII; SML, EBUS, MODBus, RAW as HEX ASCII - OBIS: ASCII OBIS code terminated with ( character which indicates the start of the meter value - SML: SML binary OBIS as hex terminated with 0xFF indicating start of SML encoded value - EBUS, MODBus, RAW: hex values of EBUS, MODBus, RAW block to compare - xx means ignore value (1 byte) - ss = extract a signed byte - uu = extract an unsigned byte - UUuu = extract an unsigned word (high order byte first) - uuUU = extract an unsigned word (low order byte first) - UUuuUUuu = extract an unsigned long word (high order byte first) - SSss = extract a signed word (high order byte first) - ssSS = extract a signed word (low order byte first) - SSssSSss = extract an signed long word (high order byte first) - ffffffff = extract a float value - FFffFFff = extract a reverse float value - @ decoding definition termination character - decoding a 0/1 bit is indicated by a @ character followed by bx: (x = 0..7 ) extracting the corresponding bit from a byte. e.g.: 1,xxxx5017xxuu@b0:1,Solarpump,,Solarpump,0 - in the case of MODBus , ix: designates the index (x = 0..n ) referring to the requested block in the transmit section of the meter definition > [!EXAMPLE] +1,3,M,1,9600,SBC,1,2,01030023,01030028... 1,010304UUuuxxxxxxxx@i0:1,Voltage L1,V,Voltage_L1,0 < the i0:1 refers to: 01030023 with a scaling factor ( :1 ) of 1 1,010304UUuuxxxxxxxx@i1:10,Current L1,V,Current_L1,2 < the i1:10 refers to: 01030028 with a scaling factor ( :10 ) of 10 <scale> - scaling factor (divisor) This can be a fraction (e.g., 0.1 => result * 10), or a negative value When decoding a string result (e.g., a serial meter), use # character for this parameter (only in one line per meter). For OBIS, you need a ) termination character after the # character Example: OBIS: 1,1-0:0.0.0\\*255(@#),Meter Nr,, Meter_number,0 SML: 1,77078181c78203ff@#,Service ID,,Meter_id,0 <label> - web UI label (max 23 chars) <UoM> - unit of measure (max 7 chars) <var> - MQTT variable name (max 23 chars) <precision> - number of decimal places Add 16 to transmit the data immediately. Otherwise it is transmitted on TelePeriod [!EXAMPLE] 1,1-0:1.8.0*255(@1,consumption,KWh,Total_in,4 > Transmitted on TelePeriod 1,1-0:1.8.0*255(@1,consumption,KWh,Total_in,20 > Precision of 4. 4 + 16 = 20 >transmit its value immediately # character terminates the list Special Commands with the '=' char at the beginning of a line you may do some special decoding M,=m perform arithmetic ( +,-,*,/ ) on the metric. Use # before a number to designate a constant value [!EXAMPLE] 1,=m 3+4+5/#3 @100,Voltage L1+L2+L3/3,V,Volt_avg,2 1,=m 3+4+5/#3 add result of decoder entry 3,4,5 and divided by 3 (i.e., average) M,=d calculate difference between metric values decoded at time intervals [!EXAMPLE] 1,=d 3 10 calculate 10 second interval difference of decoder entry 3 M,=h html text (up to 30 chars) inserts a html line between entries (these lines do not count as decoder entry) [!EXAMPLE] 1,=h================== insert a separator line Tip Use: sensor53 dM to output the received data in the console. M = the number of the defined meter in the script. [!NOTE]During the output of the data in the console, the data in the WEB UI are not updated. To return write: sensor53 d0 [!WARNING] With a few meters, it is necessary to request the meter to send its data using a specific character string. This string has to be send at a very low baudrate. (300Baud) If you reply the meter with an acknowledge and ask the it for a new baudrate of 9600 baud, the baudrate of the SML driver has to be changed, too. To change the baudrate: sml( METERNUMBER 0 BAUDRATE ) For sending a specific character string: sml( METERNUMBER 1 STRING ) That works like this: [!EXAMPLE] >D res=0 scnt=0 ;For this Example in the >F section > >F ;count 100ms scnt+=1 switch scnt case 6 ;set sml driver to 300 baud and send /?! as HEX to trigger the Meter res=sml(1 0 300) res=sml(1 1 \"2F3F210D0A\") >;1800ms later > Send ACK and ask for switching to 9600 baud case 18 res=sml(1 1 \"063035300D0A\") >;2000ms later > Switching sml driver to 9600 baud case 20 res=sml(1 0 9600) >;Restart sequence after 50x100ms case 50 ; 5000ms later > restart sequence scnt=0 ends > >M 1 +1,3,o,0,9600, ,1 ...etc. You can find the example here. !>Attention, this procedure is only necessary, if the meter explicitly asks for 300 baud. The most meters work directly with 9600 baud. Therefore it is easier to give this method a try: [!EXAMPLE] Meter#,GPIO# Input,TYPE,FLAG,Baudrate,JSONNAME,GPIO# Output,TX Period,Character string + 1,3, o, 0,9600, energy, 1,4,2F3F210D0A Example: here. Smart Meter Descriptors ~ EMH ED300L (SML) Hager EHZ363 (SML) Hager EHZ161 (OBIS) Landis + Gyr ZMR120AR (OBIS) COMBO Meter (Water,Gas,SML) WOLF CSZ 11/300 Heater SDM530 (MODBUS) Janitza B23 (MODBUS) Hager EHZ363 (SML) with daily values Iskra MT 174 SBC ALE3 (MODBUS) 2 * SBC ALE3 (MODBUS) EMH ED300L (SML) ~ >D >B =>sensor53 r >M 2 +1,13,s,0,9600,Haus +2,12,s,0,9600,Heizung 1,770701000F0700FF@1,Aktuell,W,Power_curr,0 1,77070100010800FF@1000,Z\u00e4hlerstand Verb.,kWh,Tariflos,2 1,77070100020800FF@1000,Z\u00e4hlerstand Einsp.,kWh,Tariflos,2 2,=h================== 2,770701000F0700FF@1,Aktuell,W,Power_curr,0 2,77070100010800FF@1000,Z\u00e4hlerstand Verb.,kWh,Tariflos,2 2,77070100020800FF@1000,Z\u00e4hlerstand Einsp.,kWh,Tariflos,2 # Hager EHZ363 (SML) ~ >D >B =>sensor53 r >M 1 +1,3,s,0,9600,SML 1,77070100010800ff@1000,Total consumption,KWh,Total_in,4 1,77070100020800ff@1000,Total Feed,KWh,Total_out,4 1,77070100100700ff@1,Current consumption,W,Power_curr,0 1,77070100000009ff@#,Meter Nr,,Meter_number,0 # Hager EHZ161 (OBIS) ~ >D >B =>sensor53 r >M 1 +1,3,o,0,9600,OBIS 1,1-0:1.8.1*255(@1,Total consumption,KWh,Total_in,4 1,1-0:2.8.1*255(@1,Total Feed,KWh,Total_out,4 1,=d 2 10 @1,Current consumption,W,Power_curr,0 1,1-0:0.0.0*255(@#),Meter Nr,, Meter_number,0 # Landis + Gyr ZMR120AReS2R2sfCS (OBIS) ~ ?> Example: Changing the baud rate during operation. >D ;Var Power consumption total HT+NT v1=0 ;HT Main electricity tariff consumption total v2=0 ;NT Night electricity tariff consumption total v3=0 ; Energie L1+L2+L3 v4=0 ;recent Energie L1 v5=0 ;recent Energie L2 v6=0 ;recent Energie L3 v7=0 ;Var minute min=0 ;Var hour hr=0 ;Var begin of the month 01.xx.20xx 0:00 Uhr md=0 ;Var begin of the year 01.01. 0:00 Uhr yr=0 ;Var for counter see >F=ms scnt=0 ;Var for baudrate changeing res=0 ;Permanent Var Meter1 0:00 p:sm=0 p:HT_sm=0 p:NT_sm=0 ;Var for daily =0 sd=0 HT_sd=0 NT_sd=0 ;Permanent Var for month begin p:sma=0 p:HT_sma=0 p:NT_sma=0 ;Var for monthly =0 smn=0 HT_smn=0 NT_smn=0 ;Permanent Var for year begin p:sya=0 p:HT_sya=0 p:NT_sya=0 ;Var for yearly =0 syn=0 HT_syn=0 NT_syn=0 ;Fill vars with content on teleperiod >T v1=#Total_in v2=#HT_Total_in v3=#NT_Total_in v4=#kW_L1+L2+L3 v5=#kw_L1 v6=#kw_L2 v7=#kw_L3 >B ;Restart driver =>sensor53 r ;Set teleperiod to 20sec tper=20 >F ; count 100ms scnt+=1 switch scnt case 6 ;set sml driver to 300 baud and send /?! as HEX to trigger the Meter res=sml(1 0 300) res=sml(1 1 \"2F3F210D0A\") ;1800ms later > Ack and ask for switching to 9600 baud case 18 res=sml(1 1 \"063035300D0A\") ;2000ms later > Switching sml driver to 9600 baud case 20 res=sml(1 0 9600) ;Restart sequence after 50x100ms case 50 ; 5000ms later > restart sequence scnt=0 ends >S ;daily usage hr=hours if chg[hr]>0 and hr==0 and v1>0 then sm=v1 HT_sm=v2 NT_sm=v3 svars endif if upsecs%tper==0{ sd=v1-sm HT_sd=v2-HT_sm NT_sd=v3-NT_sm } ;Monthly usage md=day if chg[md]>0 and md==1 and v1>0 then sma=v1 HT_sma=v2 NT_sma=v3 svars endif if upsecs%tper==0{ smn=v1-sma HT_smn=v2-HT_sma NT_smn=v3-NT_sma } ;Yearly usage yr=year if chg[yr]>0 and v1>0 then sya=v1 HT_sya=v2 NT_sya=v3 svars endif if upsecs%tper==0{ syn=v1-sya HT_syn=v2-HT_sya NT_syn=v3-NT_sya ; Json payload > send on teleperiod >J ,\"Strom_Vb_Tag\":%3sd% ,\"HT_Strom_Vb_Tag\":%3HT_sd% ,\"NT_Strom_Vb_Tag\":%3NT_sd% ,\"Strom_Vb_M\":%1smn% ,\"HT_Strom_Vb_M\":%1HT_smn% ,\"NT_Strom_Vb_M\":%1NT_smn% ,\"Strom_Vb_Jahr\":%0syn% ,\"HT_Strom_Vb_Jahr\":%0HT_syn% ,\"NT_Strom_Vb_Jahr\":%0NT_syn% ,\"Strom_0:00 _Uhr\":%1sm% ,\"HT_Strom_0:00 _Uhr\":%1HT_sm% ,\"NT_Strom_0:00 _Uhr\":%1NT_sm% ,\"Strom_Ma\":%3sma% ,\"HT_Strom_Ma\":%3HT_sma% ,\"NT_Strom_Ma\":%3NT_sma% ,\"Strom_Ja\":%3sya% ,\"HT_Strom_Ja\":%3HT_sya% ,\"NT_Strom_Ja\":%3NT_sya% ;Webdisplay stuff >W ---------------------- 0:00 Uhr \u03a3 HT+NT: {m} %0sm% KWh HT: {m} %0HT_sm% KWh NT: {m} %0NT_sm% KWh ---------------------- Monatsanfang: {m} %1sma% KWh HT: {m} %1HT_sma% KWh NT: {m} %1NT_sma% KWh ---------------------- Jahresanfang: {m} %0sya% KWh HT: {m} %0HT_sya% KWh NT: {m} %0NT_sya% KWh ............................. Tagesverbrauch: {m} %1sd% KWh HT: {m} %1HT_sd% KWh NT: {m} %1NT_sd% KWh ---------------------- Monatsverbrauch: {m} %0smn% KWh HT: {m} %0HT_smn% KWh NT: {m} %0NT_smn% KWh --------------------- Jahresverbrauch: {m} %0syn% KWh HT: {m} %0HT_syn% KWh 0:00 Uhr \u03a3 HT+NT: {m} %0sm% KWh HT: {m} %0HT_sm% KWh NT: {m} %0NT_sm% KWh ---------------------- Monatsanfang: {m} %1sma% KWh HT: {m} %1HT_sma% KWh NT: {m} %1NT_sma% KWh ---------------------- Jahresanfang: {m} %0sya% KWh HT: {m} %0HT_sya% KWh NT: {m} %0NT_sya% KWh ............................. Tagesverbrauch: {m} %1sd% KWh HT: {m} %1HT_sd% KWh NT: {m} %1NT_sd% KWh ---------------------- Monatsverbrauch: {m} %0smn% KWh HT: {m} %0HT_smn% KWh NT: {m} %0NT_smn% KWh --------------------- Jahresverbrauch: {m} %0syn% KWh HT: {m} %0HT_syn% KWh NT: {m} %0NT_syn% KWhNT: {m} %0NT_syn% KWh >M 1 +1,3,o,0,9600,,1 1,0.0.1(@1,Z\u00e4hlernummer,,Meter_number,0 1,0.9.1(@#),Zeitstempel,Uhr,time-stamp,0 1,=h=================== 1,1.8.0(@1,HT+NT Z\u00e4hlerstand,KWh,Total_in,3 1,1.8.1(@1,HT,KWh,HT_Total_in,3 1,1.8.2(@1,NT,KWh,NT_Total_in,3 1,=h=================== 1,36.7.0(@1,Power_L1,kW,kW_L1,2 1,56.7.0(@1,Power_L2,kW,kW_L2,2 1,76.7.0(@1,Power_L3,kW,kW_L3,2 1,16.7.0(@1,\u03a3_L1+L2+L3,kW,kW_L1+L2+L3,2 1,=h=================== 1,31.7.0(@1,Strom_L1,A,I_L1,2 1,51.7.0(@1,Strom_L2,A,I_L2,2 1,71.7.0(@1,Strom_L3,A,I_L3,2 # COMBO Meter (Water,Gas,SML) ~ >D >B =>sensor53 r >M 3 +1,1,c,0,10,H20 +2,4,c,0,50,GAS +3,3,s,0,9600,SML 1,1-0:1.8.0*255(@10000,Water reading,cbm,Count,4 2,=h================== 2,1-0:1.8.0*255(@100,Gas reading,cbm,Count,3 3,77070100010800ff@1000,Total consumption,KWh,Total_in,3 3,=h================== 3,77070100100700ff@1,Current consumption,W,Power_curr,2 3,=h ------------------------------- 3,=m 10+11+12 @100,Currents L1+L2+L3,A,Curr_summ,2 3,=m 13+14+15/#3 @100,Voltage L1+L2+L3/3,V,Volt_avg,2 3,=h================== 3,77070100240700ff@1,Consumption P1,W,Power_p1,2 3,77070100380700ff@1,Consumption P2,W,Power_p2,2 3,770701004c0700ff@1,Consumption P3,W,Power_p3,2 3,=h ------------------------------- 3,770701001f0700ff@100,Current L1,A,Curr_p1,2 3,77070100330700ff@100,Current L2,A,Curr_p2,2 3,77070100470700ff@100,Current L3,A,Curr_p3,2 3,=h ------------------------------- 3,77070100200700ff@100,Voltage L1,V,Volt_p1,2 3,77070100340700ff@100,Voltage L2,V,Volt_p2,2 3,77070100480700ff@100,Voltage L3,V,Volt_p3,2 3,=h================== 3,77070100000009ff@#,Service ID,,Meter_id,0 3,=h-------------------------------- # WOLF CSZ 11/300 Heater ~ >D >B =>sensor53 r >M 1 +1,3,e,0,2400,EBUS 1,xxxx0503xxxxxxxxxxxxxxxxss@1,Outside temperature,C,Outsidetemp,0 1,xxxx5014xxxxxxxxxxuu@1,Romm temperature,C,Roomtemp,0 1,xxxx0503xxxxxxxxxxxxxxuu@1,Warmwater,C,Warmwater,0 1,xxxx0503xxxxxxxxxxuu@1,Boiler,C,Boiler,0 1,03fe0503xxxxxxxxxxxxuu@1,Returns,C,Returns,0 1,03fe0503xxxxuu@1,Status,,Status,0 1,03fe0503xxxxxxuu@b3:1,Burner on,,Burner,0 1,xxxx5017xxxxxxuuuu@16,Solar collektor,C,Collector,1 1,xxxx5017xxxxxxxxxxuuuu@16,Solar storage,C,Solarstorage,1 1,xxxx5017xxuu@b0:1,Solar pump on,,Solarpump,0 # MODBUS Devices ~ SDM530 ~ >D >B =>sensor53 r >M 1 +1,3,m,0,9600,MODBUS,1,1,01040000,01040002,01040004,01040006,01040008,0104000a,0104000c,0104000e,01040010 1,010404ffffffffxxxx@i0:1,Voltage P1,V,Voltage_P1,2 1,010404ffffffffxxxx@i1:1,Voltage P2,V,Voltage_P2,2 1,010404ffffffffxxxx@i2:1,Voltage P3,V,Voltage_P3,2 1,010404ffffffffxxxx@i3:1,Current P1,A,Current_P1,2 1,010404ffffffffxxxx@i4:1,Current P2,A,Current_P2,2 1,010404ffffffffxxxx@i5:1,Current P3,A,Current_P3,2 1,010404ffffffffxxxx@i6:1,Active Power P1,W,Power_P1,2 1,010404ffffffffxxxx@i7:1,Active Power P2,W,Power_P2,2 1,010404ffffffffxxxx@i8:1,Active Power P3,W,Power_P3,2 # Janitza B23 ~ >D >B =>sensor53 r >M 1 +1,3,m,0,9600,Janiza,1,1,01034A38,01034A3A,01034A3C,01034A4C,01034A4E,01034A50,01034A72,01034A7A,01034A82 1,010304ffffffffxxxx@i0:1,Voltage L1-N,V,Voltage_L1-N,2 1,010304ffffffffxxxx@i1:1,Voltage L2-N,V,Voltage_L2-N,2 1,010304ffffffffxxxx@i2:1,Voltage L3-N,V,Voltage_L3-N,2 1,010304ffffffffxxxx@i3:1,Real power L1-N,W,Real_power_L1-N,2 1,010304ffffffffxxxx@i4:1,Real power L2-N,W,Real_power_L2-N,2 1,010304ffffffffxxxx@i5:1,Real power L3-N,W,Real_power_L3-N,2 1,010304ffffffffxxxx@i6:1,Real energy L3,Wh,Real_energy_L3,2 1,010304ffffffffxxxx@i7:1,Real energy L3-consumed,Wh,Real_energy_L3_consumed,2 1,010304ffffffffxxxx@i8:1,Real energy L3-delivered,Wh,Real_energy_L3_delivered,2 # Hager EHZ363 (SML) with daily values ~ >D pin=0 pout=0 pi_d=0 po_d=0 hr=0 ; permanent midnight values p:pi_m=0 p:po_m=0 >B =>sensor53 r >T ; get total consumption and total feed pin=SML#Total_in pout=SML#Total_out >S ; at midnight, save meter total values hr=hours if chg[hr]>0 and hr==0 then pi_m=pin po_m=pout svars endif ; on teleperiod calculate current daily values from midnight if upsecs%tper==0 then pi_d=pin-pi_m po_d=pout-po_m endif ; show these values on WEB UI >W Tagesverbrauch: {m} %pi_d% kWh Tageseinspeisung: {m} %po_d% kWh ; transmit these values with MQTT >J ,\"daily_consumption\":%pi_d%,\"daily_feed\":%po_d% ; meter definition >M 1 +1,3,s,0,9600,SML 1,77070100010800ff@1000,Total Consumed,KWh,Total_in,4 1,77070100020800ff@1000,Total Delivered,KWh,Total_out,4 1,77070100100700ff@1,Current Consumption,W,Power_curr,0 1,77070100000009ff@#,Meter Number,,Meter_number,0 # Iskra MT 174 (OBIS) ~ >D >B =>sensor53 r >M 1 +1,3,o,0,300,STROM,1,100,2F3F210D0A 1,1-0:1.8.1 255(@1,Total Consumed,KWh,Total_in,3 1,1-0:2.8.1 255(@1,Total Delivered,KWh,Total_out,3 1,1-0:0.0.0*255(@#),Meter Number,,Meter_number,0 # SBC ALE3 MODBUS ~ >D >B =>sensor53 r >M 1 +1,3,M,1,9600,SBC,1,1,02030023,02030028,0203002d,02030025,0203002a,0203002f,02030032,02030027,0203002c,02030031,02030021,02030015,02030018 1,020304UUuuxxxxxxxx@i0:1,Spannung L1,V,Voltage_L1,0 1,020304UUuuxxxxxxxx@i1:1,Spannung L2,V,Voltage_L2,0 1,020304UUuuxxxxxxxx@i2:1,Spannung L3,V,Voltage_L3,0 1,020304xxxxUUuuxxxx@i0:10,Strom L1,A,Current_L1,2 1,020304xxxxUUuuxxxx@i1:10,Strom L2,A,Current_L2,2 1,020304xxxxUUuuxxxx@i2:10,Strom L3,A,Current_L3,2 1,=h= 1,020304UUuuxxxxxxxx@i3:100,Leistung L1,kW,Power_L1,3 1,020304UUuuxxxxxxxx@i4:100,Leistung L2,kW,Power_L2,3 1,020304UUuuxxxxxxxx@i5:100,Leistung L3,kW,Power_L3,3 1,020304UUuuxxxxxxxx@i6:100,Leistung Total,kW,Power_Total,3 1,020304xxxxSSssxxxx@i3:100,BlindLeistung L1,kVAr,ReaktivePower_L1,3 1,020304xxxxSSssxxxx@i4:100,BlindLeistung L2,kVAr,ReaktivePower_L2,3 1,020304xxxxSSssxxxx@i5:100,BlindLeistung L3,kVAr,ReaktivePower_L3,3 1,020304xxxxSSssxxxx@i6:100,BLeistung Total,kVAr,ReaktivePower_Total,3 1,=h= 1,020304UUuuxxxxxxxx@i7:100,CosPhi L1,,CosPhi_L1,2 1,020304UUuuxxxxxxxx@i8:100,CosPhi L2,,CosPhi_L2,2 1,020304UUuuxxxxxxxx@i9:100,CosPhi L3,,CosPhi_L3,2 1,=h= 1,020304UUuuUUuuxxxx@i10:100,T2 Wert,kWh,T2_Value,2 # 2 * SBC ALE3 MODBUS ~ >D >B =>sensor53 r >M 1 +1,3,M,1,9600,Meter,1,1,01030023,01030028,0103002d,01030025,0103002a,0103002f,01030032,01030027,0103002c,01030031,0103001B,0103001d,03030023,03030028,0303002d,03030025,0303002a,0303002f,03030032,03030027,0303002c,03030031,0303001B,0303001d 1,=h Domestic Electricity: 1,010304UUuuUUuuxxxx@i10:100,1 Tariff 1 total,kWh,M1_T1_total,2 1,010304UUuuUUuuxxxx@i11:100,1 Tariff 1 partial,kWh,M1_T1_par,2 1,=h Readings: 1,010304UUuuxxxxxxxx@i0:1,1 Voltage L1,V,M1_Voltage_L1,0 1,010304UUuuxxxxxxxx@i1:1,1 Voltage L2,V,M1_Voltage_L2,0 1,010304UUuuxxxxxxxx@i2:1,1 Voltage L3,V,M1_Voltage_L3,0 1,010304xxxxUUuuxxxx@i0:10,1 Current L1,A,M1_Current_L1,2 1,010304xxxxUUuuxxxx@i1:10,1 Current L2,A,M1_Current_L2,2 1,010304xxxxUUuuxxxx@i2:10,1 Current L3,A,M1_Current_L3,2 1,010304UUuuxxxxxxxx@i3:100,1 Active Power L1,kW,M1_PRMS_L1,3 1,010304UUuuxxxxxxxx@i4:100,1 Active Power L2,kW,M1_PRMS_L2,3 1,010304UUuuxxxxxxxx@i5:100,1 Active Power L3,kW,M1_PRMS_L3,3 1,010304UUuuxxxxxxxx@i6:100,1 Active Power total,kW,M1_PRMS_total,3 1,010304xxxxSSssxxxx@i3:100,1 Reactive Power L1,kVAr,M1_QRMS_L1,3 1,010304xxxxSSssxxxx@i4:100,1 Reactive Power L2,kVAr,M1_QRMS_L2,3 1,010304xxxxSSssxxxx@i5:100,1 Reactive Power L3,kVAr,M1_QRMS_L3,3 1,010304xxxxSSssxxxx@i6:100,1 Reactive Power total,kVAr,M1_QRMS_total,3 1,010304UUuuxxxxxxxx@i7:100,1 CosPhi L1,,M1_CosPhi_L1,2 1,010304UUuuxxxxxxxx@i8:100,1 CosPhi L2,,M1_CosPhi_L2,2 1,010304UUuuxxxxxxxx@i9:100,1 CosPhi L3,,M1_CosPhi_L3,2 1,=h________________________________________________ ; meter 2 +12 offset 1,=h Heat Pump 1,030304UUuuUUuuxxxx@i22:100,2 Tariff 1 total,kWh,M2_T1_total,2 1,030304UUuuUUuuxxxx@i23:100,2 Tariff 1 partial,kWh,M2_T1_par,2 1,=h Readings: 1,030304UUuuxxxxxxxx@i12:1,2 Voltage L1,V,M2_Voltage_L1,0 1,030304UUuuxxxxxxxx@i13:1,2 Voltage L2,V,M2_Voltage_L2,0 1,030304UUuuxxxxxxxx@i14:1,2 Voltage L3,V,M2_Voltage_L3,0 1,030304xxxxUUuuxxxx@i12:10,2 Current L1,A,M2_Current_L1,2 1,030304xxxxUUuuxxxx@i13:10,2 Current L2,A,M2_Current_L2,2 1,030304xxxxUUuuxxxx@i14:10,2 Current L3,A,M2_Current_L3,2 1,030304UUuuxxxxxxxx@i15:100,2 Active Power L1,kW,M2_PRMS_L1,3 1,030304UUuuxxxxxxxx@i16:100,2 Active Power L2,kW,M2_PRMS_L2,3 1,030304UUuuxxxxxxxx@i17:100,2 Active Power L3,kW,M2_PRMS_L3,3 1,030304UUuuxxxxxxxx@i18:100,2 Active Power total,kW,M2_PRMS_total,3 1,030304xxxxSSssxxxx@i15:100,2 Reactive Power L1,kVAr,M2_QRMS_L1,3 1,030304xxxxSSssxxxx@i16:100,2 Reactive Power L2,kVAr,M2_QRMS_L2,3 1,030304xxxxSSssxxxx@i16:100,2 Reactive Power L3,kVAr,M2_QRMS_L3,3 1,030304xxxxSSssxxxx@i18:100,2 Reactive Power total,kVAr,M2_QRMS_total,3 1,030304UUuuxxxxxxxx@i19:100,2 CosPhi L1,,M2_CosPhi_L1,2 1,030304UUuuxxxxxxxx@i20:100,2 CosPhi L2,,M2_CosPhi_L2,2 1,030304UUuuxxxxxxxx@i21:100,2 CosPhi L3,,M2_CosPhi_L3,2 #","title":"Smart Meter Interface"},{"location":"Smart-Meter-Interface/#descriptor-syntax","text":"This section must be present, but empty. In most cases, there is no need to define variables for this driver. >D Declare a script >B (boot) section to inform the interface to read the meter descriptor(s) >B => sensor53 r Declare a script >M section with the number of connected meters (n = 1..5 ) >M <n>","title":"Descriptor Syntax"},{"location":"Smart-Meter-Interface/#meter-declaration","text":"+<M>,<rxGPIO>,<type>,<flag>,<parameter>,<jsonPrefix>{,<txGPIO>,<txPeriod>,<cmdTelegram>} [!EXAMPLE] +1,3,o,0,9600,OBIS1,1,2,2F3F210D0A +1,3,s,16,9600,SML1 +1,12,c,1,-10,H20_Cnt +1,3,m,0,9600,MODBUS,1,1,01040000,01040002,01040004,01040006,01040008,0104000a,0104000c,0104000e,01040010 +<M>,<rxGPIO>,<type>,<flag>,<parameter>,<jsonPrefix>{,<txGPIO>,<txPeriod>,<cmdTelegram>} - <M> - meter number. The number must be increased with each additional Meter. (1...5) - <rxGPIO> - meter data receive GPIO - <type> - meter type of meter: - o = OBIS ASCII type of coding - s = SML binary smart message coding - c = Counter type - e = EBus binary coding - m = MODBus binary coding with serial mode 8N1 - M = MODBus binary coding with serial mode 8E1 - r = Raw binary coding (any binary telegram) - <flag> - options flag: - 0 = counter without pullup - 1 = counter with pullup - 16 = enable median filter for that meter. Can help with sporadic dropouts eg. reading errors. (not available for counters) - <parameter> - parameters according to meter type: - for o,s,e,m,r : serial baud rate eg. 9600 - for c : - positive value >0 = counter poll interval - negative value <=0 = debounce time (milliseconds) for irq driven counters - <jsonPrefix> - prefix for Web UI and MQTT JSON payload. Up to 7 characters - <txGPIO> - meter command transmit GPIO (optional) - <txPeriod> - number of 250ms increments (n * 250ms). Period to repeat the transmission of commands to the meter (optional) - <cmdTelegram> - comma separated hex coded byte blocks to send to meter device. For modbus each comma separated block is a command to retrieve a certain register from the meter (Optional, only required for measuring devices that have to be triggered with a certain character string.) Modbus: [!EXAMPLE] +1,3,m,0,9600,MODBUS,1,1,01040000,01040002,01040004,01040006,01040008,0104000a,0104000c,0104000e,01040010 Components of the character string: ...01040000,01040002,... 01 = Modbus slave device ID 04 = Instruction to read an Input Register (alternatively, 03 = Instruction to read an Holding Register) 0000 / 0002 = Register # (as Hexadecimal codification, without the prefix 0x . Example: 0x0079 -> 0079 ) Note ID , Instruction to read the Register value (Input vs Holding) and Register # may differ depending on the measuring device.","title":"Meter Declaration"},{"location":"Smart-Meter-Interface/#meter-metrics","text":"Each meter typically provides multiple metrics (voltage, power, current, humidity etc.) which it measures. An entry for each metric to be collected as #define SML_MAX_VARS N (n = 1..16 ) must be specified, in user_config_override.h file (see the code at the page top). An entry defines how to decode the data and put it into variables. [!EXAMPLE] (OBIS/SML/MODBus): 1,1-0:1.8.1\\*255(@1,Total consumption,KWh,Total_in,4 1,77070100010801ff@1000,W1,kWh,w1,4 1,010304UUuuxxxxxxxx@i0:1,Spannung L1,V,Voltage_L1,0 <M>,<decoder>@<scale>,<label>,<UoM>,<var>,<precision> - <M> - meter number to which this decoder belongs - <decoder> - decoding specification. Decode OBIS as ASCII; SML, EBUS, MODBus, RAW as HEX ASCII - OBIS: ASCII OBIS code terminated with ( character which indicates the start of the meter value - SML: SML binary OBIS as hex terminated with 0xFF indicating start of SML encoded value - EBUS, MODBus, RAW: hex values of EBUS, MODBus, RAW block to compare - xx means ignore value (1 byte) - ss = extract a signed byte - uu = extract an unsigned byte - UUuu = extract an unsigned word (high order byte first) - uuUU = extract an unsigned word (low order byte first) - UUuuUUuu = extract an unsigned long word (high order byte first) - SSss = extract a signed word (high order byte first) - ssSS = extract a signed word (low order byte first) - SSssSSss = extract an signed long word (high order byte first) - ffffffff = extract a float value - FFffFFff = extract a reverse float value - @ decoding definition termination character - decoding a 0/1 bit is indicated by a @ character followed by bx: (x = 0..7 ) extracting the corresponding bit from a byte. e.g.: 1,xxxx5017xxuu@b0:1,Solarpump,,Solarpump,0 - in the case of MODBus , ix: designates the index (x = 0..n ) referring to the requested block in the transmit section of the meter definition > [!EXAMPLE] +1,3,M,1,9600,SBC,1,2,01030023,01030028... 1,010304UUuuxxxxxxxx@i0:1,Voltage L1,V,Voltage_L1,0 < the i0:1 refers to: 01030023 with a scaling factor ( :1 ) of 1 1,010304UUuuxxxxxxxx@i1:10,Current L1,V,Current_L1,2 < the i1:10 refers to: 01030028 with a scaling factor ( :10 ) of 10 <scale> - scaling factor (divisor) This can be a fraction (e.g., 0.1 => result * 10), or a negative value When decoding a string result (e.g., a serial meter), use # character for this parameter (only in one line per meter). For OBIS, you need a ) termination character after the # character Example: OBIS: 1,1-0:0.0.0\\*255(@#),Meter Nr,, Meter_number,0 SML: 1,77078181c78203ff@#,Service ID,,Meter_id,0 <label> - web UI label (max 23 chars) <UoM> - unit of measure (max 7 chars) <var> - MQTT variable name (max 23 chars) <precision> - number of decimal places Add 16 to transmit the data immediately. Otherwise it is transmitted on TelePeriod [!EXAMPLE] 1,1-0:1.8.0*255(@1,consumption,KWh,Total_in,4 > Transmitted on TelePeriod 1,1-0:1.8.0*255(@1,consumption,KWh,Total_in,20 > Precision of 4. 4 + 16 = 20 >transmit its value immediately # character terminates the list Special Commands with the '=' char at the beginning of a line you may do some special decoding M,=m perform arithmetic ( +,-,*,/ ) on the metric. Use # before a number to designate a constant value [!EXAMPLE] 1,=m 3+4+5/#3 @100,Voltage L1+L2+L3/3,V,Volt_avg,2 1,=m 3+4+5/#3 add result of decoder entry 3,4,5 and divided by 3 (i.e., average) M,=d calculate difference between metric values decoded at time intervals [!EXAMPLE] 1,=d 3 10 calculate 10 second interval difference of decoder entry 3 M,=h html text (up to 30 chars) inserts a html line between entries (these lines do not count as decoder entry) [!EXAMPLE] 1,=h================== insert a separator line Tip Use: sensor53 dM to output the received data in the console. M = the number of the defined meter in the script. [!NOTE]During the output of the data in the console, the data in the WEB UI are not updated. To return write: sensor53 d0 [!WARNING] With a few meters, it is necessary to request the meter to send its data using a specific character string. This string has to be send at a very low baudrate. (300Baud) If you reply the meter with an acknowledge and ask the it for a new baudrate of 9600 baud, the baudrate of the SML driver has to be changed, too. To change the baudrate: sml( METERNUMBER 0 BAUDRATE ) For sending a specific character string: sml( METERNUMBER 1 STRING ) That works like this: [!EXAMPLE] >D res=0 scnt=0 ;For this Example in the >F section > >F ;count 100ms scnt+=1 switch scnt case 6 ;set sml driver to 300 baud and send /?! as HEX to trigger the Meter res=sml(1 0 300) res=sml(1 1 \"2F3F210D0A\") >;1800ms later > Send ACK and ask for switching to 9600 baud case 18 res=sml(1 1 \"063035300D0A\") >;2000ms later > Switching sml driver to 9600 baud case 20 res=sml(1 0 9600) >;Restart sequence after 50x100ms case 50 ; 5000ms later > restart sequence scnt=0 ends > >M 1 +1,3,o,0,9600, ,1 ...etc. You can find the example here. !>Attention, this procedure is only necessary, if the meter explicitly asks for 300 baud. The most meters work directly with 9600 baud. Therefore it is easier to give this method a try: [!EXAMPLE] Meter#,GPIO# Input,TYPE,FLAG,Baudrate,JSONNAME,GPIO# Output,TX Period,Character string + 1,3, o, 0,9600, energy, 1,4,2F3F210D0A Example: here.","title":"Meter Metrics"},{"location":"Smart-Meter-Interface/#smart-meter-descriptors","text":"EMH ED300L (SML) Hager EHZ363 (SML) Hager EHZ161 (OBIS) Landis + Gyr ZMR120AR (OBIS) COMBO Meter (Water,Gas,SML) WOLF CSZ 11/300 Heater SDM530 (MODBUS) Janitza B23 (MODBUS) Hager EHZ363 (SML) with daily values Iskra MT 174 SBC ALE3 (MODBUS) 2 * SBC ALE3 (MODBUS)","title":"Smart Meter Descriptors"},{"location":"Smart-Meter-Interface/#emh-ed300l-sml","text":">D >B =>sensor53 r >M 2 +1,13,s,0,9600,Haus +2,12,s,0,9600,Heizung 1,770701000F0700FF@1,Aktuell,W,Power_curr,0 1,77070100010800FF@1000,Z\u00e4hlerstand Verb.,kWh,Tariflos,2 1,77070100020800FF@1000,Z\u00e4hlerstand Einsp.,kWh,Tariflos,2 2,=h================== 2,770701000F0700FF@1,Aktuell,W,Power_curr,0 2,77070100010800FF@1000,Z\u00e4hlerstand Verb.,kWh,Tariflos,2 2,77070100020800FF@1000,Z\u00e4hlerstand Einsp.,kWh,Tariflos,2 #","title":"EMH ED300L (SML)"},{"location":"Smart-Meter-Interface/#hager-ehz363-sml","text":">D >B =>sensor53 r >M 1 +1,3,s,0,9600,SML 1,77070100010800ff@1000,Total consumption,KWh,Total_in,4 1,77070100020800ff@1000,Total Feed,KWh,Total_out,4 1,77070100100700ff@1,Current consumption,W,Power_curr,0 1,77070100000009ff@#,Meter Nr,,Meter_number,0 #","title":"Hager EHZ363 (SML)"},{"location":"Smart-Meter-Interface/#hager-ehz161-obis","text":">D >B =>sensor53 r >M 1 +1,3,o,0,9600,OBIS 1,1-0:1.8.1*255(@1,Total consumption,KWh,Total_in,4 1,1-0:2.8.1*255(@1,Total Feed,KWh,Total_out,4 1,=d 2 10 @1,Current consumption,W,Power_curr,0 1,1-0:0.0.0*255(@#),Meter Nr,, Meter_number,0 #","title":"Hager EHZ161 (OBIS)"},{"location":"Smart-Meter-Interface/#landis-gyr-zmr120ares2r2sfcs-obis","text":"?> Example: Changing the baud rate during operation. >D ;Var Power consumption total HT+NT v1=0 ;HT Main electricity tariff consumption total v2=0 ;NT Night electricity tariff consumption total v3=0 ; Energie L1+L2+L3 v4=0 ;recent Energie L1 v5=0 ;recent Energie L2 v6=0 ;recent Energie L3 v7=0 ;Var minute min=0 ;Var hour hr=0 ;Var begin of the month 01.xx.20xx 0:00 Uhr md=0 ;Var begin of the year 01.01. 0:00 Uhr yr=0 ;Var for counter see >F=ms scnt=0 ;Var for baudrate changeing res=0 ;Permanent Var Meter1 0:00 p:sm=0 p:HT_sm=0 p:NT_sm=0 ;Var for daily =0 sd=0 HT_sd=0 NT_sd=0 ;Permanent Var for month begin p:sma=0 p:HT_sma=0 p:NT_sma=0 ;Var for monthly =0 smn=0 HT_smn=0 NT_smn=0 ;Permanent Var for year begin p:sya=0 p:HT_sya=0 p:NT_sya=0 ;Var for yearly =0 syn=0 HT_syn=0 NT_syn=0 ;Fill vars with content on teleperiod >T v1=#Total_in v2=#HT_Total_in v3=#NT_Total_in v4=#kW_L1+L2+L3 v5=#kw_L1 v6=#kw_L2 v7=#kw_L3 >B ;Restart driver =>sensor53 r ;Set teleperiod to 20sec tper=20 >F ; count 100ms scnt+=1 switch scnt case 6 ;set sml driver to 300 baud and send /?! as HEX to trigger the Meter res=sml(1 0 300) res=sml(1 1 \"2F3F210D0A\") ;1800ms later > Ack and ask for switching to 9600 baud case 18 res=sml(1 1 \"063035300D0A\") ;2000ms later > Switching sml driver to 9600 baud case 20 res=sml(1 0 9600) ;Restart sequence after 50x100ms case 50 ; 5000ms later > restart sequence scnt=0 ends >S ;daily usage hr=hours if chg[hr]>0 and hr==0 and v1>0 then sm=v1 HT_sm=v2 NT_sm=v3 svars endif if upsecs%tper==0{ sd=v1-sm HT_sd=v2-HT_sm NT_sd=v3-NT_sm } ;Monthly usage md=day if chg[md]>0 and md==1 and v1>0 then sma=v1 HT_sma=v2 NT_sma=v3 svars endif if upsecs%tper==0{ smn=v1-sma HT_smn=v2-HT_sma NT_smn=v3-NT_sma } ;Yearly usage yr=year if chg[yr]>0 and v1>0 then sya=v1 HT_sya=v2 NT_sya=v3 svars endif if upsecs%tper==0{ syn=v1-sya HT_syn=v2-HT_sya NT_syn=v3-NT_sya ; Json payload > send on teleperiod >J ,\"Strom_Vb_Tag\":%3sd% ,\"HT_Strom_Vb_Tag\":%3HT_sd% ,\"NT_Strom_Vb_Tag\":%3NT_sd% ,\"Strom_Vb_M\":%1smn% ,\"HT_Strom_Vb_M\":%1HT_smn% ,\"NT_Strom_Vb_M\":%1NT_smn% ,\"Strom_Vb_Jahr\":%0syn% ,\"HT_Strom_Vb_Jahr\":%0HT_syn% ,\"NT_Strom_Vb_Jahr\":%0NT_syn% ,\"Strom_0:00 _Uhr\":%1sm% ,\"HT_Strom_0:00 _Uhr\":%1HT_sm% ,\"NT_Strom_0:00 _Uhr\":%1NT_sm% ,\"Strom_Ma\":%3sma% ,\"HT_Strom_Ma\":%3HT_sma% ,\"NT_Strom_Ma\":%3NT_sma% ,\"Strom_Ja\":%3sya% ,\"HT_Strom_Ja\":%3HT_sya% ,\"NT_Strom_Ja\":%3NT_sya% ;Webdisplay stuff >W ---------------------- 0:00 Uhr \u03a3 HT+NT: {m} %0sm% KWh HT: {m} %0HT_sm% KWh NT: {m} %0NT_sm% KWh ---------------------- Monatsanfang: {m} %1sma% KWh HT: {m} %1HT_sma% KWh NT: {m} %1NT_sma% KWh ---------------------- Jahresanfang: {m} %0sya% KWh HT: {m} %0HT_sya% KWh NT: {m} %0NT_sya% KWh ............................. Tagesverbrauch: {m} %1sd% KWh HT: {m} %1HT_sd% KWh NT: {m} %1NT_sd% KWh ---------------------- Monatsverbrauch: {m} %0smn% KWh HT: {m} %0HT_smn% KWh NT: {m} %0NT_smn% KWh --------------------- Jahresverbrauch: {m} %0syn% KWh HT: {m} %0HT_syn% KWh 0:00 Uhr \u03a3 HT+NT: {m} %0sm% KWh HT: {m} %0HT_sm% KWh NT: {m} %0NT_sm% KWh ---------------------- Monatsanfang: {m} %1sma% KWh HT: {m} %1HT_sma% KWh NT: {m} %1NT_sma% KWh ---------------------- Jahresanfang: {m} %0sya% KWh HT: {m} %0HT_sya% KWh NT: {m} %0NT_sya% KWh ............................. Tagesverbrauch: {m} %1sd% KWh HT: {m} %1HT_sd% KWh NT: {m} %1NT_sd% KWh ---------------------- Monatsverbrauch: {m} %0smn% KWh HT: {m} %0HT_smn% KWh NT: {m} %0NT_smn% KWh --------------------- Jahresverbrauch: {m} %0syn% KWh HT: {m} %0HT_syn% KWh NT: {m} %0NT_syn% KWhNT: {m} %0NT_syn% KWh >M 1 +1,3,o,0,9600,,1 1,0.0.1(@1,Z\u00e4hlernummer,,Meter_number,0 1,0.9.1(@#),Zeitstempel,Uhr,time-stamp,0 1,=h=================== 1,1.8.0(@1,HT+NT Z\u00e4hlerstand,KWh,Total_in,3 1,1.8.1(@1,HT,KWh,HT_Total_in,3 1,1.8.2(@1,NT,KWh,NT_Total_in,3 1,=h=================== 1,36.7.0(@1,Power_L1,kW,kW_L1,2 1,56.7.0(@1,Power_L2,kW,kW_L2,2 1,76.7.0(@1,Power_L3,kW,kW_L3,2 1,16.7.0(@1,\u03a3_L1+L2+L3,kW,kW_L1+L2+L3,2 1,=h=================== 1,31.7.0(@1,Strom_L1,A,I_L1,2 1,51.7.0(@1,Strom_L2,A,I_L2,2 1,71.7.0(@1,Strom_L3,A,I_L3,2 #","title":"Landis + Gyr ZMR120AReS2R2sfCS (OBIS)"},{"location":"Smart-Meter-Interface/#combo-meter-watergassml","text":">D >B =>sensor53 r >M 3 +1,1,c,0,10,H20 +2,4,c,0,50,GAS +3,3,s,0,9600,SML 1,1-0:1.8.0*255(@10000,Water reading,cbm,Count,4 2,=h================== 2,1-0:1.8.0*255(@100,Gas reading,cbm,Count,3 3,77070100010800ff@1000,Total consumption,KWh,Total_in,3 3,=h================== 3,77070100100700ff@1,Current consumption,W,Power_curr,2 3,=h ------------------------------- 3,=m 10+11+12 @100,Currents L1+L2+L3,A,Curr_summ,2 3,=m 13+14+15/#3 @100,Voltage L1+L2+L3/3,V,Volt_avg,2 3,=h================== 3,77070100240700ff@1,Consumption P1,W,Power_p1,2 3,77070100380700ff@1,Consumption P2,W,Power_p2,2 3,770701004c0700ff@1,Consumption P3,W,Power_p3,2 3,=h ------------------------------- 3,770701001f0700ff@100,Current L1,A,Curr_p1,2 3,77070100330700ff@100,Current L2,A,Curr_p2,2 3,77070100470700ff@100,Current L3,A,Curr_p3,2 3,=h ------------------------------- 3,77070100200700ff@100,Voltage L1,V,Volt_p1,2 3,77070100340700ff@100,Voltage L2,V,Volt_p2,2 3,77070100480700ff@100,Voltage L3,V,Volt_p3,2 3,=h================== 3,77070100000009ff@#,Service ID,,Meter_id,0 3,=h-------------------------------- #","title":"COMBO Meter (Water,Gas,SML)"},{"location":"Smart-Meter-Interface/#wolf-csz-11300-heater","text":">D >B =>sensor53 r >M 1 +1,3,e,0,2400,EBUS 1,xxxx0503xxxxxxxxxxxxxxxxss@1,Outside temperature,C,Outsidetemp,0 1,xxxx5014xxxxxxxxxxuu@1,Romm temperature,C,Roomtemp,0 1,xxxx0503xxxxxxxxxxxxxxuu@1,Warmwater,C,Warmwater,0 1,xxxx0503xxxxxxxxxxuu@1,Boiler,C,Boiler,0 1,03fe0503xxxxxxxxxxxxuu@1,Returns,C,Returns,0 1,03fe0503xxxxuu@1,Status,,Status,0 1,03fe0503xxxxxxuu@b3:1,Burner on,,Burner,0 1,xxxx5017xxxxxxuuuu@16,Solar collektor,C,Collector,1 1,xxxx5017xxxxxxxxxxuuuu@16,Solar storage,C,Solarstorage,1 1,xxxx5017xxuu@b0:1,Solar pump on,,Solarpump,0 #","title":"WOLF CSZ 11/300 Heater"},{"location":"Smart-Meter-Interface/#modbus-devices","text":"","title":"MODBUS Devices"},{"location":"Smart-Meter-Interface/#sdm530","text":">D >B =>sensor53 r >M 1 +1,3,m,0,9600,MODBUS,1,1,01040000,01040002,01040004,01040006,01040008,0104000a,0104000c,0104000e,01040010 1,010404ffffffffxxxx@i0:1,Voltage P1,V,Voltage_P1,2 1,010404ffffffffxxxx@i1:1,Voltage P2,V,Voltage_P2,2 1,010404ffffffffxxxx@i2:1,Voltage P3,V,Voltage_P3,2 1,010404ffffffffxxxx@i3:1,Current P1,A,Current_P1,2 1,010404ffffffffxxxx@i4:1,Current P2,A,Current_P2,2 1,010404ffffffffxxxx@i5:1,Current P3,A,Current_P3,2 1,010404ffffffffxxxx@i6:1,Active Power P1,W,Power_P1,2 1,010404ffffffffxxxx@i7:1,Active Power P2,W,Power_P2,2 1,010404ffffffffxxxx@i8:1,Active Power P3,W,Power_P3,2 #","title":"SDM530"},{"location":"Smart-Meter-Interface/#janitza-b23","text":">D >B =>sensor53 r >M 1 +1,3,m,0,9600,Janiza,1,1,01034A38,01034A3A,01034A3C,01034A4C,01034A4E,01034A50,01034A72,01034A7A,01034A82 1,010304ffffffffxxxx@i0:1,Voltage L1-N,V,Voltage_L1-N,2 1,010304ffffffffxxxx@i1:1,Voltage L2-N,V,Voltage_L2-N,2 1,010304ffffffffxxxx@i2:1,Voltage L3-N,V,Voltage_L3-N,2 1,010304ffffffffxxxx@i3:1,Real power L1-N,W,Real_power_L1-N,2 1,010304ffffffffxxxx@i4:1,Real power L2-N,W,Real_power_L2-N,2 1,010304ffffffffxxxx@i5:1,Real power L3-N,W,Real_power_L3-N,2 1,010304ffffffffxxxx@i6:1,Real energy L3,Wh,Real_energy_L3,2 1,010304ffffffffxxxx@i7:1,Real energy L3-consumed,Wh,Real_energy_L3_consumed,2 1,010304ffffffffxxxx@i8:1,Real energy L3-delivered,Wh,Real_energy_L3_delivered,2 #","title":"Janitza B23"},{"location":"Smart-Meter-Interface/#hager-ehz363-sml-with-daily-values","text":">D pin=0 pout=0 pi_d=0 po_d=0 hr=0 ; permanent midnight values p:pi_m=0 p:po_m=0 >B =>sensor53 r >T ; get total consumption and total feed pin=SML#Total_in pout=SML#Total_out >S ; at midnight, save meter total values hr=hours if chg[hr]>0 and hr==0 then pi_m=pin po_m=pout svars endif ; on teleperiod calculate current daily values from midnight if upsecs%tper==0 then pi_d=pin-pi_m po_d=pout-po_m endif ; show these values on WEB UI >W Tagesverbrauch: {m} %pi_d% kWh Tageseinspeisung: {m} %po_d% kWh ; transmit these values with MQTT >J ,\"daily_consumption\":%pi_d%,\"daily_feed\":%po_d% ; meter definition >M 1 +1,3,s,0,9600,SML 1,77070100010800ff@1000,Total Consumed,KWh,Total_in,4 1,77070100020800ff@1000,Total Delivered,KWh,Total_out,4 1,77070100100700ff@1,Current Consumption,W,Power_curr,0 1,77070100000009ff@#,Meter Number,,Meter_number,0 #","title":"Hager EHZ363 (SML) with daily values"},{"location":"Smart-Meter-Interface/#iskra-mt-174-obis","text":">D >B =>sensor53 r >M 1 +1,3,o,0,300,STROM,1,100,2F3F210D0A 1,1-0:1.8.1 255(@1,Total Consumed,KWh,Total_in,3 1,1-0:2.8.1 255(@1,Total Delivered,KWh,Total_out,3 1,1-0:0.0.0*255(@#),Meter Number,,Meter_number,0 #","title":"Iskra MT 174 (OBIS)"},{"location":"Smart-Meter-Interface/#sbc-ale3-modbus","text":">D >B =>sensor53 r >M 1 +1,3,M,1,9600,SBC,1,1,02030023,02030028,0203002d,02030025,0203002a,0203002f,02030032,02030027,0203002c,02030031,02030021,02030015,02030018 1,020304UUuuxxxxxxxx@i0:1,Spannung L1,V,Voltage_L1,0 1,020304UUuuxxxxxxxx@i1:1,Spannung L2,V,Voltage_L2,0 1,020304UUuuxxxxxxxx@i2:1,Spannung L3,V,Voltage_L3,0 1,020304xxxxUUuuxxxx@i0:10,Strom L1,A,Current_L1,2 1,020304xxxxUUuuxxxx@i1:10,Strom L2,A,Current_L2,2 1,020304xxxxUUuuxxxx@i2:10,Strom L3,A,Current_L3,2 1,=h= 1,020304UUuuxxxxxxxx@i3:100,Leistung L1,kW,Power_L1,3 1,020304UUuuxxxxxxxx@i4:100,Leistung L2,kW,Power_L2,3 1,020304UUuuxxxxxxxx@i5:100,Leistung L3,kW,Power_L3,3 1,020304UUuuxxxxxxxx@i6:100,Leistung Total,kW,Power_Total,3 1,020304xxxxSSssxxxx@i3:100,BlindLeistung L1,kVAr,ReaktivePower_L1,3 1,020304xxxxSSssxxxx@i4:100,BlindLeistung L2,kVAr,ReaktivePower_L2,3 1,020304xxxxSSssxxxx@i5:100,BlindLeistung L3,kVAr,ReaktivePower_L3,3 1,020304xxxxSSssxxxx@i6:100,BLeistung Total,kVAr,ReaktivePower_Total,3 1,=h= 1,020304UUuuxxxxxxxx@i7:100,CosPhi L1,,CosPhi_L1,2 1,020304UUuuxxxxxxxx@i8:100,CosPhi L2,,CosPhi_L2,2 1,020304UUuuxxxxxxxx@i9:100,CosPhi L3,,CosPhi_L3,2 1,=h= 1,020304UUuuUUuuxxxx@i10:100,T2 Wert,kWh,T2_Value,2 #","title":"SBC ALE3 MODBUS"},{"location":"Smart-Meter-Interface/#2-sbc-ale3-modbus","text":">D >B =>sensor53 r >M 1 +1,3,M,1,9600,Meter,1,1,01030023,01030028,0103002d,01030025,0103002a,0103002f,01030032,01030027,0103002c,01030031,0103001B,0103001d,03030023,03030028,0303002d,03030025,0303002a,0303002f,03030032,03030027,0303002c,03030031,0303001B,0303001d 1,=h Domestic Electricity: 1,010304UUuuUUuuxxxx@i10:100,1 Tariff 1 total,kWh,M1_T1_total,2 1,010304UUuuUUuuxxxx@i11:100,1 Tariff 1 partial,kWh,M1_T1_par,2 1,=h Readings: 1,010304UUuuxxxxxxxx@i0:1,1 Voltage L1,V,M1_Voltage_L1,0 1,010304UUuuxxxxxxxx@i1:1,1 Voltage L2,V,M1_Voltage_L2,0 1,010304UUuuxxxxxxxx@i2:1,1 Voltage L3,V,M1_Voltage_L3,0 1,010304xxxxUUuuxxxx@i0:10,1 Current L1,A,M1_Current_L1,2 1,010304xxxxUUuuxxxx@i1:10,1 Current L2,A,M1_Current_L2,2 1,010304xxxxUUuuxxxx@i2:10,1 Current L3,A,M1_Current_L3,2 1,010304UUuuxxxxxxxx@i3:100,1 Active Power L1,kW,M1_PRMS_L1,3 1,010304UUuuxxxxxxxx@i4:100,1 Active Power L2,kW,M1_PRMS_L2,3 1,010304UUuuxxxxxxxx@i5:100,1 Active Power L3,kW,M1_PRMS_L3,3 1,010304UUuuxxxxxxxx@i6:100,1 Active Power total,kW,M1_PRMS_total,3 1,010304xxxxSSssxxxx@i3:100,1 Reactive Power L1,kVAr,M1_QRMS_L1,3 1,010304xxxxSSssxxxx@i4:100,1 Reactive Power L2,kVAr,M1_QRMS_L2,3 1,010304xxxxSSssxxxx@i5:100,1 Reactive Power L3,kVAr,M1_QRMS_L3,3 1,010304xxxxSSssxxxx@i6:100,1 Reactive Power total,kVAr,M1_QRMS_total,3 1,010304UUuuxxxxxxxx@i7:100,1 CosPhi L1,,M1_CosPhi_L1,2 1,010304UUuuxxxxxxxx@i8:100,1 CosPhi L2,,M1_CosPhi_L2,2 1,010304UUuuxxxxxxxx@i9:100,1 CosPhi L3,,M1_CosPhi_L3,2 1,=h________________________________________________ ; meter 2 +12 offset 1,=h Heat Pump 1,030304UUuuUUuuxxxx@i22:100,2 Tariff 1 total,kWh,M2_T1_total,2 1,030304UUuuUUuuxxxx@i23:100,2 Tariff 1 partial,kWh,M2_T1_par,2 1,=h Readings: 1,030304UUuuxxxxxxxx@i12:1,2 Voltage L1,V,M2_Voltage_L1,0 1,030304UUuuxxxxxxxx@i13:1,2 Voltage L2,V,M2_Voltage_L2,0 1,030304UUuuxxxxxxxx@i14:1,2 Voltage L3,V,M2_Voltage_L3,0 1,030304xxxxUUuuxxxx@i12:10,2 Current L1,A,M2_Current_L1,2 1,030304xxxxUUuuxxxx@i13:10,2 Current L2,A,M2_Current_L2,2 1,030304xxxxUUuuxxxx@i14:10,2 Current L3,A,M2_Current_L3,2 1,030304UUuuxxxxxxxx@i15:100,2 Active Power L1,kW,M2_PRMS_L1,3 1,030304UUuuxxxxxxxx@i16:100,2 Active Power L2,kW,M2_PRMS_L2,3 1,030304UUuuxxxxxxxx@i17:100,2 Active Power L3,kW,M2_PRMS_L3,3 1,030304UUuuxxxxxxxx@i18:100,2 Active Power total,kW,M2_PRMS_total,3 1,030304xxxxSSssxxxx@i15:100,2 Reactive Power L1,kVAr,M2_QRMS_L1,3 1,030304xxxxSSssxxxx@i16:100,2 Reactive Power L2,kVAr,M2_QRMS_L2,3 1,030304xxxxSSssxxxx@i16:100,2 Reactive Power L3,kVAr,M2_QRMS_L3,3 1,030304xxxxSSssxxxx@i18:100,2 Reactive Power total,kVAr,M2_QRMS_total,3 1,030304UUuuxxxxxxxx@i19:100,2 CosPhi L1,,M2_CosPhi_L1,2 1,030304UUuuxxxxxxxx@i20:100,2 CosPhi L2,,M2_CosPhi_L2,2 1,030304UUuuxxxxxxxx@i21:100,2 CosPhi L3,,M2_CosPhi_L3,2 #","title":"2 * SBC ALE3 MODBUS"},{"location":"Sonoff-DIY/","text":"Some new Sonoff devices support the new Itead DIY architecture which allows OTA firmware upload. With Sonoff DIY , a user has more control over the hardware features of the device and also allows for upgrading the firmware without additional hardware. The following procedure upgrades Sonoff eWelink firmware to Tasmota. IMPORTANT: There are some reports suggesting that the Windows version of Sonoff DIY Tool contains a trojan. It is not clear if it actually contains the malicious code or these are just false positives due to the way Python code was converted to native executables. Nevertheless, proceed with care. Compatible devices ~ Currently the following devices officially support Sonoff DIY: - Sonoff Basic R3 - Sonoff RF R3 - Sonoff Mini As Sonoff DIY is enabled by connecting GPIO16 to GND it may well be possible that other Sonoff devices running eWelink 3.1 or higher will also support it. [!ATTENTION] The OTA process Sonoff provides through the Sonoff DIY procedure does not create a backup of the Itead firmware on the device. If you use this OTA method to flash Tasmota on the Sonoff device, you will not be able to revert to the original factory firmware. Flash procedure ~ Using the Itead DIY tool ~ Verify and/or update eWelink firmware version ~ - Open the device and remove the jumper labeled OTA if present - Power on device and connect to eWelink - eWelink firmware updated to at least 3.1 Flash Tasmota ~ Download the Sonoff DIY tool_01DIY85 from Github: ./tool .exe (Microsoft Windows) ./code .py ( not yet tested ) Power off the Sonoff DIY device and install the DIY OTA jumper Modify your PC configuration to provide a Mobile hotspot: SSID: sonoffDiy ( case sensitive! ) Password: 20170618sn Power on the Sonoff device and verify that it shows up on the Mobile hotspot Settings page Start the tool_01DIY85 utility The utility should discover the device Select the device and toggle it ON and OFF to verify you are connected to the right device Select Firmware flash ( Brush machine on newer versions of the tool) Select a Tasmota binary (e.g., tasmota-wifiman.bin ) or your own self-compiled binary. It must fit in the available free program space. Do NOT use the tasmota-minimal pre-compiled binary as it does not allow you to change any settings. [!NOTE] You may wish to compile your own firmware with all the features you require and disabling the features you do not. This will usually result in a \"full\" binary that is under 500k. You can use the resulting firmware file instead of the pre-compiled tasmota-wifiman.bin . - Select the device in the flash pop-up and then select OK - Tasmota will be uploaded and started If the firmware update gets stuck at 0%, the Sonoff device could not reach the manufacturer server because your mobile hotspot does not share the Internet connection. If this happens, use the DIY tool to set the SSID and password of your Wi-Fi network on the Sonoff device. The device will connect to your network. Disable the hotspot and use your Wi-Fi for DIY tool laptop as well. Now start Brush machine again, flash Tasmota. Then continue with this guide. Clean up ~ Quit DIY mode tool Stop mobile hotspot Power off the device and remove DIY jumper as it is no longer needed and might interfere with future Tasmota features that use GPIO16 Manual Flash ~ This procedure is recommended for MacOS, but also works for Linux. Requirements ~ eWelink firmware updated to at least 3.1 OS with curl and a network services discovery tool (e.g., mDNS for MacOS or avahi-browse for Linux) sonoffDiy SSID on your local network. Use a router/access point or configure your laptop/smartphone as a hotspot with the proper SSID and password. A <webServer> available on the same local network. Very simple web servers like SimpleHTTPServer will not work. For Mac, the OSX built-in web server is recommended. A Tasmota binary (e.g., tasmota-wifiman.bin ) or your own self-compiled binary. It must fit in the available free program space. You can use the 2.3.0 Core for this initial flash since it has the smallest program memory footprint. Do NOT use the tasmota-minimal pre-compiled binary as it does not allow you to change any settings. You may wish to compile your own firmware with all the features you require and disabling the features you do not. This will usually result in a \"full\" binary that is under 500k. You can use the resulting firmware file instead of the pre-compiled tasmota-wifiman.bin . This way you will not have to perform the secondary OTA firmware update. Nevertheless, it is still recommended that you perform a Reset 5 immediately after the Sonoff DIY flash completes. Upload the firmware file to the <webServer> available on the same local network. - SHA256 <SHAsum> of firmware binary file $ shasum -a 256 tasmota-wifiman.bin 1da0e89be4c01df033fa6da9d0c1db58c3deea354d7ad194f607d1f518db48f9 Verify and/or update eWelink firmware version ~ Open the device and remove the jumper labeled OTA if present Power on device and connect to eWelink Update eWelink firmware to at least 3.1 Discover the device ID ~ Power off the Sonoff DIY device and install the DIY OTA jumper Create a new SSID on your router: SSID: sonoffDiy ( case sensitive! ) Password: 20170618sn Wait for the Sonoff device to connect Obtain the <deviceIP> address (search on the router or perform an IP scan) Discover the Zeroconf details. In this example, the <deviceID> is 1000988699 MacOS $ dns-sd -B _ewelink._tcp Browsing for _ewelink._tcp DATE: ---Mon 12 Aug 2019--- 20:19:31.956 ...STARTING... Timestamp A/R Flags if Domain Service Type Instance Name 20:19:31.957 Add 2 5 local. _ewelink._tcp. eWeLink_1000988699 Linux $ avahi-browse -t _ewelink._tcp --resolve + wlp3s0 IPv4 eWeLink_1000988699 _ ewelink . _ tcp local = wlp3s0 IPv4 eWeLink_1000988699 _ ewelink . _ tcp local hostname = [ eWeLink_1000988699 . local ] address = [ 192.168.1.109 ] port = [ 8081 ] txt = [ \"data1={\" switch \":\" off \",\" startup \":\" off \",\" pulse \":\" off \",\" pulseWidth \":500,\" rssi \":-47}\" \"seq=1\" \"apivers=1\" \"type=diy_plug\" \"id=1000988699\" \"txtvers=1\" ] Flash the firmware and confirm ~ Test with /zeroconf/info POST $ curl http://<deviceIP>:8081/zeroconf/info -XPOST --data '{\"deviceid\":\"<deviceID>\",\"data\":{} }' {\"seq\":2,\"error\":0,\"data\":\"{\"switch\":\"off\",\"startup\":\"off\",\"pulse\":\"off\",\"pulseWidth\":500,\"ssid\":\"sonoffDiy\",\"otaUnlock\":false}\"} - Unlock OTA updates at /zeroconf/ota_unlock $ curl http://<deviceIP>:8081/zeroconf/ota_unlock -XPOST --data '{\"deviceid\":\"<deviceID>\",\"data\":{} }' {\"seq\":2,\"error\":0} If OTA unlocking gets stuck, the Sonoff device could not reach the manufacturer server because your mobile hotspot does not share the Internet connection. If this happens, POST a request on /zeroconf/wifi with '{\"deviceid\":\"<deviceID>\",\"data\":{ \"ssid\": \"yourssid\", \"password\": \"yourpasswd\" } }' to set the SSID and password of your Wi-Fi network on the Sonoff device. The device will connect to your network. Disable the hotspot and use your Wi-Fi as well, and restart /zeroconf/info and /zeroconf/ota_unlock . Flash firmware at /zeroconf/ota_flash $ curl http://<deviceIP>:8081/zeroconf/ota_flash -XPOST --data '{\"deviceid\":\"<deviceID>\",\"data\":{\"downloadUrl\": \"http://<webServer>/tasmota-wifiman.bin\", \"sha256sum\": \"<SHAsum>\"} }' {\"seq\":3,\"error\":0} - Ping the device for about 30 seconds until it has rebooted Post Installation ~ Once the firmware upload completes and the device restarts, the usual tasmota-xxxx SSID should now be available. 1. Set up Wi-Fi to connect your device to your network 2. Perform a Reset 5 to wipe any flash remnants BEFORE attempting a Tasmota OTA flash for the first time 3. If you flashed tasmota-wifiman.bin , it is recommended that you upgrade to the firmware and Core variant that is needed for your device and use case (e.g., tasmota.bin ). You must perform this update using the local File upload OTA. Do not use a web OTA for this step. Download the firmware file from the repository to your computer. Some users have reported that upgrading via web OTA from tasmota-wifiman.bin to another binary has resulted in an unresponsive device which has required a wired flash to recover. 4. Once the desired firmware is on the device, continue the regular Tasmota setup process. Use the the appropriate Template from the repository to assign the device components to the GPIO pins. For example, the Sonoff Mini template assigns these GPIO: GPIO Tasmota Component Device Function 0 Button1 (17) Button 4 Switch1 (9) S1/S2 12 Relay1 (21) L Out 13 LED1 (56) Link/Power Indicator Video tutorials ~ Andreas Spiess DrZzs Paul Hibbert More info: ~ Michel Deslierres","title":"Sonoff DIY"},{"location":"Sonoff-DIY/#compatible-devices","text":"Currently the following devices officially support Sonoff DIY: - Sonoff Basic R3 - Sonoff RF R3 - Sonoff Mini As Sonoff DIY is enabled by connecting GPIO16 to GND it may well be possible that other Sonoff devices running eWelink 3.1 or higher will also support it. [!ATTENTION] The OTA process Sonoff provides through the Sonoff DIY procedure does not create a backup of the Itead firmware on the device. If you use this OTA method to flash Tasmota on the Sonoff device, you will not be able to revert to the original factory firmware.","title":"Compatible devices"},{"location":"Sonoff-DIY/#flash-procedure","text":"","title":"Flash procedure"},{"location":"Sonoff-DIY/#using-the-itead-diy-tool","text":"","title":"Using the Itead DIY tool"},{"location":"Sonoff-DIY/#verify-andor-update-ewelink-firmware-version","text":"- Open the device and remove the jumper labeled OTA if present - Power on device and connect to eWelink - eWelink firmware updated to at least 3.1","title":"Verify and/or update eWelink firmware version"},{"location":"Sonoff-DIY/#flash-tasmota","text":"Download the Sonoff DIY tool_01DIY85 from Github: ./tool .exe (Microsoft Windows) ./code .py ( not yet tested ) Power off the Sonoff DIY device and install the DIY OTA jumper Modify your PC configuration to provide a Mobile hotspot: SSID: sonoffDiy ( case sensitive! ) Password: 20170618sn Power on the Sonoff device and verify that it shows up on the Mobile hotspot Settings page Start the tool_01DIY85 utility The utility should discover the device Select the device and toggle it ON and OFF to verify you are connected to the right device Select Firmware flash ( Brush machine on newer versions of the tool) Select a Tasmota binary (e.g., tasmota-wifiman.bin ) or your own self-compiled binary. It must fit in the available free program space. Do NOT use the tasmota-minimal pre-compiled binary as it does not allow you to change any settings. [!NOTE] You may wish to compile your own firmware with all the features you require and disabling the features you do not. This will usually result in a \"full\" binary that is under 500k. You can use the resulting firmware file instead of the pre-compiled tasmota-wifiman.bin . - Select the device in the flash pop-up and then select OK - Tasmota will be uploaded and started If the firmware update gets stuck at 0%, the Sonoff device could not reach the manufacturer server because your mobile hotspot does not share the Internet connection. If this happens, use the DIY tool to set the SSID and password of your Wi-Fi network on the Sonoff device. The device will connect to your network. Disable the hotspot and use your Wi-Fi for DIY tool laptop as well. Now start Brush machine again, flash Tasmota. Then continue with this guide.","title":"Flash Tasmota"},{"location":"Sonoff-DIY/#clean-up","text":"Quit DIY mode tool Stop mobile hotspot Power off the device and remove DIY jumper as it is no longer needed and might interfere with future Tasmota features that use GPIO16","title":"Clean up"},{"location":"Sonoff-DIY/#manual-flash","text":"This procedure is recommended for MacOS, but also works for Linux.","title":"Manual Flash"},{"location":"Sonoff-DIY/#requirements","text":"eWelink firmware updated to at least 3.1 OS with curl and a network services discovery tool (e.g., mDNS for MacOS or avahi-browse for Linux) sonoffDiy SSID on your local network. Use a router/access point or configure your laptop/smartphone as a hotspot with the proper SSID and password. A <webServer> available on the same local network. Very simple web servers like SimpleHTTPServer will not work. For Mac, the OSX built-in web server is recommended. A Tasmota binary (e.g., tasmota-wifiman.bin ) or your own self-compiled binary. It must fit in the available free program space. You can use the 2.3.0 Core for this initial flash since it has the smallest program memory footprint. Do NOT use the tasmota-minimal pre-compiled binary as it does not allow you to change any settings. You may wish to compile your own firmware with all the features you require and disabling the features you do not. This will usually result in a \"full\" binary that is under 500k. You can use the resulting firmware file instead of the pre-compiled tasmota-wifiman.bin . This way you will not have to perform the secondary OTA firmware update. Nevertheless, it is still recommended that you perform a Reset 5 immediately after the Sonoff DIY flash completes. Upload the firmware file to the <webServer> available on the same local network. - SHA256 <SHAsum> of firmware binary file $ shasum -a 256 tasmota-wifiman.bin 1da0e89be4c01df033fa6da9d0c1db58c3deea354d7ad194f607d1f518db48f9","title":"Requirements"},{"location":"Sonoff-DIY/#verify-andor-update-ewelink-firmware-version_1","text":"Open the device and remove the jumper labeled OTA if present Power on device and connect to eWelink Update eWelink firmware to at least 3.1","title":"Verify and/or update eWelink firmware version"},{"location":"Sonoff-DIY/#discover-the-device-id","text":"Power off the Sonoff DIY device and install the DIY OTA jumper Create a new SSID on your router: SSID: sonoffDiy ( case sensitive! ) Password: 20170618sn Wait for the Sonoff device to connect Obtain the <deviceIP> address (search on the router or perform an IP scan) Discover the Zeroconf details. In this example, the <deviceID> is 1000988699 MacOS $ dns-sd -B _ewelink._tcp Browsing for _ewelink._tcp DATE: ---Mon 12 Aug 2019--- 20:19:31.956 ...STARTING... Timestamp A/R Flags if Domain Service Type Instance Name 20:19:31.957 Add 2 5 local. _ewelink._tcp. eWeLink_1000988699 Linux $ avahi-browse -t _ewelink._tcp --resolve + wlp3s0 IPv4 eWeLink_1000988699 _ ewelink . _ tcp local = wlp3s0 IPv4 eWeLink_1000988699 _ ewelink . _ tcp local hostname = [ eWeLink_1000988699 . local ] address = [ 192.168.1.109 ] port = [ 8081 ] txt = [ \"data1={\" switch \":\" off \",\" startup \":\" off \",\" pulse \":\" off \",\" pulseWidth \":500,\" rssi \":-47}\" \"seq=1\" \"apivers=1\" \"type=diy_plug\" \"id=1000988699\" \"txtvers=1\" ]","title":"Discover the device ID"},{"location":"Sonoff-DIY/#flash-the-firmware-and-confirm","text":"Test with /zeroconf/info POST $ curl http://<deviceIP>:8081/zeroconf/info -XPOST --data '{\"deviceid\":\"<deviceID>\",\"data\":{} }' {\"seq\":2,\"error\":0,\"data\":\"{\"switch\":\"off\",\"startup\":\"off\",\"pulse\":\"off\",\"pulseWidth\":500,\"ssid\":\"sonoffDiy\",\"otaUnlock\":false}\"} - Unlock OTA updates at /zeroconf/ota_unlock $ curl http://<deviceIP>:8081/zeroconf/ota_unlock -XPOST --data '{\"deviceid\":\"<deviceID>\",\"data\":{} }' {\"seq\":2,\"error\":0} If OTA unlocking gets stuck, the Sonoff device could not reach the manufacturer server because your mobile hotspot does not share the Internet connection. If this happens, POST a request on /zeroconf/wifi with '{\"deviceid\":\"<deviceID>\",\"data\":{ \"ssid\": \"yourssid\", \"password\": \"yourpasswd\" } }' to set the SSID and password of your Wi-Fi network on the Sonoff device. The device will connect to your network. Disable the hotspot and use your Wi-Fi as well, and restart /zeroconf/info and /zeroconf/ota_unlock . Flash firmware at /zeroconf/ota_flash $ curl http://<deviceIP>:8081/zeroconf/ota_flash -XPOST --data '{\"deviceid\":\"<deviceID>\",\"data\":{\"downloadUrl\": \"http://<webServer>/tasmota-wifiman.bin\", \"sha256sum\": \"<SHAsum>\"} }' {\"seq\":3,\"error\":0} - Ping the device for about 30 seconds until it has rebooted","title":"Flash the firmware and confirm"},{"location":"Sonoff-DIY/#post-installation","text":"Once the firmware upload completes and the device restarts, the usual tasmota-xxxx SSID should now be available. 1. Set up Wi-Fi to connect your device to your network 2. Perform a Reset 5 to wipe any flash remnants BEFORE attempting a Tasmota OTA flash for the first time 3. If you flashed tasmota-wifiman.bin , it is recommended that you upgrade to the firmware and Core variant that is needed for your device and use case (e.g., tasmota.bin ). You must perform this update using the local File upload OTA. Do not use a web OTA for this step. Download the firmware file from the repository to your computer. Some users have reported that upgrading via web OTA from tasmota-wifiman.bin to another binary has resulted in an unresponsive device which has required a wired flash to recover. 4. Once the desired firmware is on the device, continue the regular Tasmota setup process. Use the the appropriate Template from the repository to assign the device components to the GPIO pins. For example, the Sonoff Mini template assigns these GPIO: GPIO Tasmota Component Device Function 0 Button1 (17) Button 4 Switch1 (9) S1/S2 12 Relay1 (21) L Out 13 LED1 (56) Link/Power Indicator","title":"Post Installation"},{"location":"Sonoff-DIY/#video-tutorials","text":"Andreas Spiess DrZzs Paul Hibbert","title":"Video tutorials"},{"location":"Sonoff-DIY/#more-info","text":"Michel Deslierres","title":"More info:"},{"location":"Status-LED/","text":"?> Status LEDs are the LEDs on the device used to display its state. Those LEDs are defined in a template or module using Led1 , Led2 , Led3 or Led4 (or Led1i , Led2i , Led3i or Led4i ) and additionally using LedLink or LedLinki ( LedLink was introduced in version 6.5.0.12). It is not recommended to assign Led<x> and Led<x>i with the same <x> number. Prior to version 6.5.0.12, Tasmota only supported up to two LED components to indicate the power state of the relay(s), and the Wi-Fi/MQTT connectivity status. [!NOTE] It is possible to wire in your own LED and assign it as any of the above mentioned but that's outside the scope of this article. If only one LED is configured, it serves both purposes; the link status LED and/or the LED that indicates the power state of the relay(s). If more than one LED component is defined, Led1 / Led1i will act as the Wi-Fi/MQTT status LED and the next defined LED (e.g., Led2 / Led2i ) will act as the LED that indicates the power state of the relay(s). This is the default behavior . Configuring a GPIO as an LEDLink / LEDLinki component changes this behavior. For example, on a Sonoff Basic the green LED is used as the link status LED. Once the device connects, the LED is used to indicate the relay's power status. Link status LED ~ Link status LED shows the network state, more specifically the Wi-Fi and MQTT connection status. It blinks if the device is not connected to your Wi-Fi AP and MQTT broker (if MQTT is enabled). You can change this behaviour with LedState or turn it off with SetOption31 . Power status LED ~ Power status LED shows the power status of relay component(s). LedMask determines which relay(s) are associated with the power status LED. This behavior can be modified with the LedState command. The LED is turned off by default when the relay is OFF and turned on when the relay switches ON. Note Depending on the device design, some LEDs are connected to the same GPIO as the relay. Those cannot be independently controlled since they have to follow the relay state. If you have more than one LED wired independently and you want it to show the power state of the relay, you must assign an LedLink GPIO. Using LedLink ~ LedLink / LedLinki was introduced with Tasmota version 6.5.0.12. It is used to assign the link status LED. If your device does not have an LED for link status (or you want to use that LED for a different purpose), you can assign LedLink to an available free GPIO. When LedLink(i) is assigned, other LEDs are automatically linked to their corresponding relay and serve as that relay's power status LED - i.e., Led<x>(i) links to Relay<x>(i) LedPower command ~ When you use LedPower you take over control of that particular LED and it stops being linked to its corresponding relay and being its power status LED.","title":"Status LED"},{"location":"Status-LED/#link-status-led","text":"Link status LED shows the network state, more specifically the Wi-Fi and MQTT connection status. It blinks if the device is not connected to your Wi-Fi AP and MQTT broker (if MQTT is enabled). You can change this behaviour with LedState or turn it off with SetOption31 .","title":"Link status LED"},{"location":"Status-LED/#power-status-led","text":"Power status LED shows the power status of relay component(s). LedMask determines which relay(s) are associated with the power status LED. This behavior can be modified with the LedState command. The LED is turned off by default when the relay is OFF and turned on when the relay switches ON. Note Depending on the device design, some LEDs are connected to the same GPIO as the relay. Those cannot be independently controlled since they have to follow the relay state. If you have more than one LED wired independently and you want it to show the power state of the relay, you must assign an LedLink GPIO.","title":"Power status LED"},{"location":"Status-LED/#using-ledlink","text":"LedLink / LedLinki was introduced with Tasmota version 6.5.0.12. It is used to assign the link status LED. If your device does not have an LED for link status (or you want to use that LED for a different purpose), you can assign LedLink to an available free GPIO. When LedLink(i) is assigned, other LEDs are automatically linked to their corresponding relay and serve as that relay's power status LED - i.e., Led<x>(i) links to Relay<x>(i)","title":"Using LedLink"},{"location":"Status-LED/#ledpower-command","text":"When you use LedPower you take over control of that particular LED and it stops being linked to its corresponding relay and being its power status LED.","title":"LedPower command"},{"location":"Subscribe-%26-Unsubscribe/","text":"!> This feature is not included in precompiled binaries. To use it you must compile your build . Add the following to user_config_override.h : #ifndef SUPPORT_MQTT_EVENT #define SUPPORT_MQTT_EVENT #endif Subscribe ~ Subscribes to an MQTT topic and assigns an Event name to it. Subscribe <eventName>, <mqttTopic> [, <key>] The <key> parameter is specified when you need to parse a key/value pair from a JSON payload in the MQTT message. In order to parse a value from a multi-level JSON pair, you can use one dot ( . ) syntax to split the key into sections. You subscribe to an MQTT topic and assign an event name. Once the subscribed MQTT message is received the configured event will be triggered. Command without any parameters will list all currently subscribed topics. You can set up a rule with ON EVENT#<event_name> DO ... ENDON to do what you want based on this MQTT message. The payload is passed as a parameter once the event has been triggered. If the payload is in JSON format, you are able to get the value of specified key as a parameter. For example, if you have a Tasmota based thermostat and multiple temperature sensors in different locations, usually you have to set up a home automation system like Domoticz to control the thermostat. Right now, with this new feature, you can write a rule to do this. Examples: Rule1 ON mqtt#connected DO Subscribe BkLight, stat/%topic%/POWER ENDON ON Event#BkLight=ON DO <command> ENDON Rule1 ON mqtt#connected DO Subscribe DnTemp, stat/%topic%/SENSOR, DS18B20.Temperature ENDON ON Event#DnTemp>=21 DO <command> ENDON where the MQTT message payload is `{\"Time\":\"2017-02-16T10:13:52\", \"DS18B20\":{\"Temperature\":20.6}}` Unsubscribe ~ Unsubscribe from topics which were subscribed to using the Subscribe command. Unsubscribe from a specific MQTT topic Unsubscribe <eventName> The command without a parameter will unsubscribe from all currently subscribed topics.","title":"Subscribe & Unsubscribe"},{"location":"Subscribe-%26-Unsubscribe/#subscribe","text":"Subscribes to an MQTT topic and assigns an Event name to it. Subscribe <eventName>, <mqttTopic> [, <key>] The <key> parameter is specified when you need to parse a key/value pair from a JSON payload in the MQTT message. In order to parse a value from a multi-level JSON pair, you can use one dot ( . ) syntax to split the key into sections. You subscribe to an MQTT topic and assign an event name. Once the subscribed MQTT message is received the configured event will be triggered. Command without any parameters will list all currently subscribed topics. You can set up a rule with ON EVENT#<event_name> DO ... ENDON to do what you want based on this MQTT message. The payload is passed as a parameter once the event has been triggered. If the payload is in JSON format, you are able to get the value of specified key as a parameter. For example, if you have a Tasmota based thermostat and multiple temperature sensors in different locations, usually you have to set up a home automation system like Domoticz to control the thermostat. Right now, with this new feature, you can write a rule to do this. Examples: Rule1 ON mqtt#connected DO Subscribe BkLight, stat/%topic%/POWER ENDON ON Event#BkLight=ON DO <command> ENDON Rule1 ON mqtt#connected DO Subscribe DnTemp, stat/%topic%/SENSOR, DS18B20.Temperature ENDON ON Event#DnTemp>=21 DO <command> ENDON where the MQTT message payload is `{\"Time\":\"2017-02-16T10:13:52\", \"DS18B20\":{\"Temperature\":20.6}}`","title":"Subscribe"},{"location":"Subscribe-%26-Unsubscribe/#unsubscribe","text":"Unsubscribe from topics which were subscribed to using the Subscribe command. Unsubscribe from a specific MQTT topic Unsubscribe <eventName> The command without a parameter will unsubscribe from all currently subscribed topics.","title":"Unsubscribe"},{"location":"Supported-Modules/","text":"Supported Modules ~ Sonoff 4CH Sonoff 4CH Pro Sonoff 4CH DIY Sonoff B1 / B1 R2 Sonoff Basic R1/R2/R3 Sonoff Dual Sonoff Dual R2 Sonoff iFan02 Sonoff iFan03 Sonoff Mini Sonoff Pow Sonoff Pow R2 Sonoff PSA Sonoff RF Sonoff RF R3 Sonoff RF Bridge 433 Sonoff S20 Smart Socket Sonoff S26 Smart Socket Sonoff S31 Sonoff SC Sonoff Slampher Sonoff SV Sonoff T1 Sonoff Touch Sonoff TH Arilux LC02 Armtronix Dimmers Blitzwolf BW-SHP2 Blitzwolf BW-SHP4 Blitzwolf BW-SHP6 Digoo DG-SP202 Geekcreit 2CH Gosund SP1 H801 LED Controller HuaFan Smart Socket Luminea LED Controller MagicHome LED Controller (ESP-12S/ESP-2M.md) MagicHome LED Controller (ESP8285.md) Mi Desk Lamp PS-16-DZ Dimmer OBI Socket OBI Socket 2 OBI Socket IP44 (Black.md) Shelly 1 Shelly 1PM Shelly 2 Shelly 2.5 SK03 Outdoor Smart Plug Teckin SP10 Smart Socket Teckin SP22 YTF IR Bridge WT003-EU 4 AC + 4 USB Outlet Tuya Power Strip EU Wemos D1 R1 & R2 Wemos D1 Mini Other Devices","title":"Supported Modules"},{"location":"Supported-Modules/#supported-modules","text":"Sonoff 4CH Sonoff 4CH Pro Sonoff 4CH DIY Sonoff B1 / B1 R2 Sonoff Basic R1/R2/R3 Sonoff Dual Sonoff Dual R2 Sonoff iFan02 Sonoff iFan03 Sonoff Mini Sonoff Pow Sonoff Pow R2 Sonoff PSA Sonoff RF Sonoff RF R3 Sonoff RF Bridge 433 Sonoff S20 Smart Socket Sonoff S26 Smart Socket Sonoff S31 Sonoff SC Sonoff Slampher Sonoff SV Sonoff T1 Sonoff Touch Sonoff TH Arilux LC02 Armtronix Dimmers Blitzwolf BW-SHP2 Blitzwolf BW-SHP4 Blitzwolf BW-SHP6 Digoo DG-SP202 Geekcreit 2CH Gosund SP1 H801 LED Controller HuaFan Smart Socket Luminea LED Controller MagicHome LED Controller (ESP-12S/ESP-2M.md) MagicHome LED Controller (ESP8285.md) Mi Desk Lamp PS-16-DZ Dimmer OBI Socket OBI Socket 2 OBI Socket IP44 (Black.md) Shelly 1 Shelly 1PM Shelly 2 Shelly 2.5 SK03 Outdoor Smart Plug Teckin SP10 Smart Socket Teckin SP22 YTF IR Bridge WT003-EU 4 AC + 4 USB Outlet Tuya Power Strip EU Wemos D1 R1 & R2 Wemos D1 Mini Other Devices","title":"Supported Modules"},{"location":"Supported-Peripherals/","text":"You can connect all kinds of peripherals (sensors, displays, switches, LED lights, ...) to available pins of your device or even create your own from a development board Tip A peripheral must have correctly wired power, GND and data pins to the device prior to booting in order for Tasmota to detect it and initialize it properly. Tasmota Settings ~ Tasmota allows for easy selection of peripherals (sensors, switches, etc) and assignment to GPIO pins. Configuration is possible in the webUI Configuration - Configure Module page or by using commands: Module and GPIO , or Template . Module First select desired module for the device (Wait for the restart). Depending on the type of Module , only certain GPIO pins are user configurable. Module Generic (18) has all the GPIOs configurable. Modules shows supported modules GPIO Assign a component to a GPIO. GPIO14 2 configures sensor AM2301 to GPIO14_ Backlog GPIO14 5; GPIO4 6 sets I 2 C SCL to GPIO14 and I 2 C SDA to GPIO4 Tasmota will auto-detect all connected and supported I 2 C devices. If you have conflicting I 2 C addresses see I2CDevices GPIOs All shows list of all available components by name and index For a peripheral to show up you may need to power cycle your device instead of a soft restart. Template Instead of using Module and GPIO you can define everything using Template . Read more... Additional Options ~ Measurement Units Temperature units can be set to Celsius or Fahrenheit with SetOption8 command. Pressure units can be set to hPa or mmHg with SetOption24 command. Update Interval To change the update interval (TelePeriod) of MQTT messages change the TelePeriod . Default interval is 300 seconds but can be set between 10 and 3600 seconds. TelePeriod 10 will set the update interval to 10 seconds, so the sensor will update 6 times a minute. Peripheral Specific Some peripherals offer, or even require, additional commands. See Commands page for peripheral specific commands. Tip To make a link between the different naming schemes the Pin Definition overview in the ESP8266 wiki is quite helpful. Examples ~ Connect switch If you take a Sonoff Basic and connect a switch between pin4 (GND) and pin5 (GPIO14) of the 5 pin programming header you now have a second switch connected to the device. You can set this through the module config page as option Switch1 (9) or from the command line with gpio14 9 . See Buttons and Switches for more information. Connect jack Instead of connecting a switch, you could connect a 4-pin 2.5mm jack, with the pins wired: Jack Pin ESP8266 tip 5 GPIO14 R1 no connection R2 1 GND R3 4 3.3V You can then plug a sensor into the jack like you would to a Sonoff TH and define what sensor you have connected to GPIO14. Restrictions ~ Danger If you can avoid it, don't use GPIOs: 0, 1, 2, 6-11, 15 and 16 . That leaves 4, 5, 12, 13, 14 as GPIOs without any constraints. 3 being RX is also good to avoid (PWM is not working on this GPIO). Others can be used but you have to mind the constraints outlined in this document . Danger The ESP8266 is a 3.3V microcontroller, so its I/O operates at 3.3V as well. The pins are not 5V tolerant, applying more than 3.6V on any pin will release the magic smoke (fry the chip). The maximum current that can be drawn from a single GPIO pin is 12mA. Power Supply ~ [!DANGER] The power supplied to the device is one of the most important elements** for stable device operation. Many devices on the market have barely adequate power supplies for normal operation. ** Connected peripherals may strain the ability of the power supply on the device to deliver appropriate power to all the components, both on-board as well as externally connected. Voltage regulation issues typically result in fatal exception fault code 1 . You must ensure that the device receives sufficient power (current and appropriate voltage level). Take into account the current that each wired component (f.e. sensor) will draw from the device itself. Electrical Considerations ~ When you switch a GPIO pin to an input and hang a long wire off of it, that wire can pick up stray signals and cause the voltage on the GPIO pin to vary. This can cause the system to think the switch has changed. To fix this, there are several things you can do. add a pull-up resistor add a bypass capacitor shielding on the wire use twisted pair wiring A pull-up resistor is a resistor connected between the GPIO pin and 3.3v. The exact value of this is not critical, 4.7k is a common value to use, as is 10k. This ensures that when the switch it open, the GPIO pin will go high. A bypass capacitor is a small (pF range) capacitor that is connected between the GPIO and ground. This provides a path for any radio signals that are picked up by the wire to go to ground and not confuse the system. Shielding or using twisted pair wiring are other ways to reduce the effect of radio signals on the system. Example for 10K Resistor (issue #2708 ) ESP8266 In Depth ~ Complete document available from https://tttapa.github.io/ESP8266/Chap04%20-%20Microcontroller.html Digital I/O ~ Just like a normal Arduino, the ESP8266 has digital input/output pins (I/O or GPIO, General Purpose Input/Output pins). As the name implies, they can be used as digital inputs to read a digital voltage, or as digital outputs to output either 0V (sink current) or 3.3V (source current). Usable Pins ~ The ESP8266 and ESP8285 have 17 GPIO pins (0-16) but several are reserved or have constraints . Do not use any of the reserved pins. If you do, you might crash your program. On the ESP8266, six pins (GPIO 6 - 11) are used to interface the flash memory (the small 8-legged chip usually right next to the ESP8266). The ESP8285 has its flash memory integrated into the chip which frees up GPIO 9 and 10. GPIO 1 and 3 are used as TX and RX of the hardware Serial port (UART), so in most cases, you can\u2019t use them as normal I/O while sending/receiving serial data. Boot Mode Pins Some I/O pins have a special function during boot: They select 1 of 3 boot modes: GPIO15 GPIO0 GPIO2 Mode 0V 0V 3.3V Uart Bootloader 0V 3.3V 3.3V Boot sketch (SPI flash) 3.3V x x SDIO mode (not used for Arduino) Note: you don\u2019t have to add an external pull-up resistor to GPIO2, the internal one is enabled at boot. We have to be sure that these conditions are met by adding external resistors, or the board manufacturer of your board has added them for you. This has some implications, however: GPIO15 is always pulled low, so you can\u2019t use the internal pull-up resistor. You have to keep this in mind when using GPIO15 as an input to read a switch or connect it to a device with an open-collector (or open-drain) output, like I\u00b2C. GPIO0 is pulled high during normal operation, so you can\u2019t use it as a Hi-Z input. GPIO2 can\u2019t be low at boot, so you can\u2019t connect a switch to it. Internal pull-up/-down resistors GPIO 0-15 all have a built-in pull-up resistor, just like in an Arduino. GPIO16 has a built-in pull-down resistor. PWM ~ Unlike most Atmel chips (Arduino), the ESP8266 doesn\u2019t support hardware PWM, however, software PWM is supported on all digital pins. The default PWM range is 10-bits @ 1kHz, but this can be changed (up to >14-bit@1kHz). Check Restrictions . Analog Input ~ The ESP8266 has a single analog input, with an input range of 0 - 1.0V. If you supply 3.3V, for example, you will damage the chip. Some boards like the NodeMCU have an on-board resistive voltage divider, to get an easier 0 - 3.3V range. You could also just use a trimpot as a voltage divider. The ADC (analog to digital converter) has a resolution of 10 bits. Communication ~ Serial ~ The ESP8266 has two hardware UARTS (Serial ports): UART0 on pins 1 and 3 (TX0 and RX0 resp.), and UART1 on pins 2 and 8 (TX1 and RX1 resp.), however, GPIO8 is used to connect the flash chip. This means that UART1 can only transmit data. UART0 also has hardware flow control on pins 15 and 13 (RTS0 and CTS0 resp.). These two pins can also be used as alternative TX0 and RX0 pins. I\u00b2C ~ ESP8266 doesn\u2019t have a hardware TWI (Two Wire Interface) but it is implemented in software. This means that you can use pretty much any two digital pins. By default, the I\u00b2C library uses pin 4 as SDA and pin 5 as SCL. (The data sheet specifies GPIO2 as SDA and GPIO14 as SCL.) The maximum speed is approximately 450kHz. SPI ~ The ESP8266 has one SPI connection available to the user, referred to as HSPI. It uses GPIO14 as CLK, 12 as MISO, 13 as MOSI and 15 as Slave Select (SS). It can be used in both Slave and Master mode (in software). GPIO Overview ~ NodeMCU Labelled Pin GPIO# Function State Restrictions D3 0 Boot mode select 3.3V No Hi-Z D10 1 TX0 - Not usable during Serial transmission D4 2 Boot mode select TX1 3.3V (boot only) Don\u2019t connect to ground at boot time Sends debug data at boot time D9 3 RX0 - Not usable during Serial transmission D2 4 SDA (I\u00b2C) - - D1 5 SCL (I\u00b2C) - - x 6 - 8 Flash connection x Not usable, and not broken out x 9, 10 Flash connection * Only available on the ESP8285 x 11 Flash connection x Not usable, and not broken out D6 12 MISO (SPI) - - D7 13 MOSI (SPI) - - D5 14 SCK (SPI) - - D8 15 SS (SPI) 0V Pull-up resistor not usable (extern pull down resistor) D0 16 Wake up from sleep - No pull-up resistor, but pull-down instead Should be connected to RST to wake up Supported Peripherals ~ Name Description Image A4988 Stepper Motor Controller ADC Analog input over A0 pin ADS1x15 A/D Converter AHT10/AHT15 Asair AHT10 / AHT15 Temperature and Humidity Sensor (I 2 C) AM2301 (DHT21), AM2302 (DHT22), AM2321 Temperature and Humidity Sensor (gpio) APDS-9960 Ambient Light, RGB Color and Proximity Sensor with Gesture Detection AZ 7798 CO 2 Meter Datalogger BH1750 Luminosity Sensor BMP280 (BMP085, BMP180) Pressure Sensor BME280 Temperature, Humidity and Pressure Sensor BME680 Temperature, Humidity, Pressure and Gas Sensor Buzzer Audio Signalling Device CC2530 TI CC2530 Zigbee Adapter (serial) CCS811 Gas and Air Quality sensor (I 2 C) Chirp! Soil Moisture Sensor Moisture Sensor (I 2 C) DHT11 Temperature and Humidity Sensor DHT12 DS18x20 Temperature sensor (1-Wire) DS1624/DS1621 Temperature sensor (1-Wire) DS3231 Real-Time-Clock (I 2 C) F&F LE-01MR F&F LE-01MR Single Phase Modbus Energy meter GPS-NTP-server GPS-NTP-server (serial) HDC1080 Texas Instruments HDC1080 Humidity and Temperature Sensor (I 2 C) HM-10 BLE Bluetooth gateway (serial) HM-17/HM-16 Bluetooth iBeacon reader (serial) HR-E Water Meter Encoder interface (serial) HRXL MaxBotix HRXL line of Sonar Ranging Sensors (gpio) HC-SR04 (HC-SR04P, JSN-SR04T) Ultrasonic Sensor Honeywell HIH Temperature and Humidity sensor (I 2 C) Honeywell HPMA115xx Particulate Matter Sensor (serial) HTU21 Temperature and Humidity sensor (I 2 C) HX711 Load Cell sensor (gpio) INA219 High-Side DC Current and Voltage sensor (I 2 C) IR Remote IR transmitter and receiver K30, K70, S8 CO 2 sensor (I 2 C) LM75AD Temperature Sensor (I 2 C) MAX31855 Thermocouple Sensor (SPI) MAX31865 RTD Temperature Sensor Amplifier (SPI) MAX44009 Ambient Light Sensor (I 2 C) MCP23008 / MCP23017 I/O Expander (I 2 C) MGC3130 3D Tracking and Gesture Controller MH-Z19B CO 2 Sensor MI-HM10 BLE-Bridge via HM-10 MLX90614 MLX9061X Infrared Thermometer (I 2 C) NRF24L01 NRF24L01 as BLE-bridge for Mijia BT sensors (SPI) MPR121 Proximity Capacitive Touch Sensor Controller (I 2 C) MPU6050 3-Axis Gyroscope and 3-Axis Accelerometer sensor (I 2 C) P1 Smart Meter Energy Meter (serial) PAJ7620 Gesture & Proximity Detection Sensor PIR Passive Infrared Sensor (gpio) PCA9685 16-channel, 12-bit PWM LED controller (I 2 C) PCF8574 8-port IO Expander (I 2 C) PMS3003-5003-7003 Particle Concentration sensor (serial) PN532 NFC/RFID controller PZEM-0XX Energy Monitor (serial) RCWL-0516 Microwave Radar Presence detection RDM6300 125Khz RFID Module RX-4M50RR30SF / RX-AM8SF RF Sensor receiver (gpio) SCD30 CO 2 sensor (I 2 C) Eastron SDM120 Modbus Energy Meter (serial) Eastron SDM630 Modbus Energy Meter (serial) SDS011 (SDS021) Laser Dust Sensor SGP30 Gas and Air Quality sensor (I 2 C) SHT1x Temperature and Humidity sensor (I 2 C) SHT30 Humidity & Temperature Sensor SI114x UV Index, IR and Visible Light sensor (I 2 C) Si7021 Humidity and Temperature Sensor (I 2 C) Smart Meter Interface (serial) SolaX X1 SolaX X1 inverter (serial) SPS30 Particulate Matter (PM) sensor (I 2 C) TM1638 8 Switch, LED and 7 Segment Unit sensor (gpio) TSL2561 Luminosity Sensor (I 2 C) TSL2591 Luminosity Sensor (I 2 C) TX2x La Crosse TX2x Series Anemometer sensor (gpio) VEML6070 UV Sensor (I 2 C) VL53L0x Time of flight sensor (I 2 C) WS2812B Wemos RGB LED Shield WS2812B/WS2813B LED Strip Xadow (Grove) Mutichannel Gas Sensor gas sensor (I 2 C) Google Sheet list of supported peripherals Sensor API Documentation Expanding Specific Devices ~ LEGO nightstand switch using Sonoff SV Add a physical button to Sonoff Basic Remote button for Sonoff Expand Sonoff S20 with a jack plug Expand Sonoff 4CH with a jack plug Modify KaKu to WKaKu Power Socket GPIO Locations","title":"Peripherals"},{"location":"Supported-Peripherals/#tasmota-settings","text":"Tasmota allows for easy selection of peripherals (sensors, switches, etc) and assignment to GPIO pins. Configuration is possible in the webUI Configuration - Configure Module page or by using commands: Module and GPIO , or Template .","title":"Tasmota Settings"},{"location":"Supported-Peripherals/#additional-options","text":"","title":"Additional Options"},{"location":"Supported-Peripherals/#examples","text":"","title":"Examples"},{"location":"Supported-Peripherals/#restrictions","text":"Danger If you can avoid it, don't use GPIOs: 0, 1, 2, 6-11, 15 and 16 . That leaves 4, 5, 12, 13, 14 as GPIOs without any constraints. 3 being RX is also good to avoid (PWM is not working on this GPIO). Others can be used but you have to mind the constraints outlined in this document . Danger The ESP8266 is a 3.3V microcontroller, so its I/O operates at 3.3V as well. The pins are not 5V tolerant, applying more than 3.6V on any pin will release the magic smoke (fry the chip). The maximum current that can be drawn from a single GPIO pin is 12mA.","title":"Restrictions"},{"location":"Supported-Peripherals/#power-supply","text":"[!DANGER] The power supplied to the device is one of the most important elements** for stable device operation. Many devices on the market have barely adequate power supplies for normal operation. ** Connected peripherals may strain the ability of the power supply on the device to deliver appropriate power to all the components, both on-board as well as externally connected. Voltage regulation issues typically result in fatal exception fault code 1 . You must ensure that the device receives sufficient power (current and appropriate voltage level). Take into account the current that each wired component (f.e. sensor) will draw from the device itself.","title":"Power Supply"},{"location":"Supported-Peripherals/#electrical-considerations","text":"When you switch a GPIO pin to an input and hang a long wire off of it, that wire can pick up stray signals and cause the voltage on the GPIO pin to vary. This can cause the system to think the switch has changed. To fix this, there are several things you can do. add a pull-up resistor add a bypass capacitor shielding on the wire use twisted pair wiring A pull-up resistor is a resistor connected between the GPIO pin and 3.3v. The exact value of this is not critical, 4.7k is a common value to use, as is 10k. This ensures that when the switch it open, the GPIO pin will go high. A bypass capacitor is a small (pF range) capacitor that is connected between the GPIO and ground. This provides a path for any radio signals that are picked up by the wire to go to ground and not confuse the system. Shielding or using twisted pair wiring are other ways to reduce the effect of radio signals on the system. Example for 10K Resistor (issue #2708 )","title":"Electrical Considerations"},{"location":"Supported-Peripherals/#esp8266-in-depth","text":"Complete document available from https://tttapa.github.io/ESP8266/Chap04%20-%20Microcontroller.html","title":"ESP8266 In Depth"},{"location":"Supported-Peripherals/#digital-io","text":"Just like a normal Arduino, the ESP8266 has digital input/output pins (I/O or GPIO, General Purpose Input/Output pins). As the name implies, they can be used as digital inputs to read a digital voltage, or as digital outputs to output either 0V (sink current) or 3.3V (source current).","title":"Digital I/O"},{"location":"Supported-Peripherals/#usable-pins","text":"The ESP8266 and ESP8285 have 17 GPIO pins (0-16) but several are reserved or have constraints . Do not use any of the reserved pins. If you do, you might crash your program. On the ESP8266, six pins (GPIO 6 - 11) are used to interface the flash memory (the small 8-legged chip usually right next to the ESP8266). The ESP8285 has its flash memory integrated into the chip which frees up GPIO 9 and 10. GPIO 1 and 3 are used as TX and RX of the hardware Serial port (UART), so in most cases, you can\u2019t use them as normal I/O while sending/receiving serial data.","title":"Usable Pins"},{"location":"Supported-Peripherals/#pwm","text":"Unlike most Atmel chips (Arduino), the ESP8266 doesn\u2019t support hardware PWM, however, software PWM is supported on all digital pins. The default PWM range is 10-bits @ 1kHz, but this can be changed (up to >14-bit@1kHz). Check Restrictions .","title":"PWM"},{"location":"Supported-Peripherals/#analog-input","text":"The ESP8266 has a single analog input, with an input range of 0 - 1.0V. If you supply 3.3V, for example, you will damage the chip. Some boards like the NodeMCU have an on-board resistive voltage divider, to get an easier 0 - 3.3V range. You could also just use a trimpot as a voltage divider. The ADC (analog to digital converter) has a resolution of 10 bits.","title":"Analog Input"},{"location":"Supported-Peripherals/#communication","text":"","title":"Communication"},{"location":"Supported-Peripherals/#serial","text":"The ESP8266 has two hardware UARTS (Serial ports): UART0 on pins 1 and 3 (TX0 and RX0 resp.), and UART1 on pins 2 and 8 (TX1 and RX1 resp.), however, GPIO8 is used to connect the flash chip. This means that UART1 can only transmit data. UART0 also has hardware flow control on pins 15 and 13 (RTS0 and CTS0 resp.). These two pins can also be used as alternative TX0 and RX0 pins.","title":"Serial"},{"location":"Supported-Peripherals/#i2c","text":"ESP8266 doesn\u2019t have a hardware TWI (Two Wire Interface) but it is implemented in software. This means that you can use pretty much any two digital pins. By default, the I\u00b2C library uses pin 4 as SDA and pin 5 as SCL. (The data sheet specifies GPIO2 as SDA and GPIO14 as SCL.) The maximum speed is approximately 450kHz.","title":"I\u00b2C"},{"location":"Supported-Peripherals/#spi","text":"The ESP8266 has one SPI connection available to the user, referred to as HSPI. It uses GPIO14 as CLK, 12 as MISO, 13 as MOSI and 15 as Slave Select (SS). It can be used in both Slave and Master mode (in software).","title":"SPI"},{"location":"Supported-Peripherals/#gpio-overview","text":"NodeMCU Labelled Pin GPIO# Function State Restrictions D3 0 Boot mode select 3.3V No Hi-Z D10 1 TX0 - Not usable during Serial transmission D4 2 Boot mode select TX1 3.3V (boot only) Don\u2019t connect to ground at boot time Sends debug data at boot time D9 3 RX0 - Not usable during Serial transmission D2 4 SDA (I\u00b2C) - - D1 5 SCL (I\u00b2C) - - x 6 - 8 Flash connection x Not usable, and not broken out x 9, 10 Flash connection * Only available on the ESP8285 x 11 Flash connection x Not usable, and not broken out D6 12 MISO (SPI) - - D7 13 MOSI (SPI) - - D5 14 SCK (SPI) - - D8 15 SS (SPI) 0V Pull-up resistor not usable (extern pull down resistor) D0 16 Wake up from sleep - No pull-up resistor, but pull-down instead Should be connected to RST to wake up","title":"GPIO Overview"},{"location":"Supported-Peripherals/#supported-peripherals","text":"Name Description Image A4988 Stepper Motor Controller ADC Analog input over A0 pin ADS1x15 A/D Converter AHT10/AHT15 Asair AHT10 / AHT15 Temperature and Humidity Sensor (I 2 C) AM2301 (DHT21), AM2302 (DHT22), AM2321 Temperature and Humidity Sensor (gpio) APDS-9960 Ambient Light, RGB Color and Proximity Sensor with Gesture Detection AZ 7798 CO 2 Meter Datalogger BH1750 Luminosity Sensor BMP280 (BMP085, BMP180) Pressure Sensor BME280 Temperature, Humidity and Pressure Sensor BME680 Temperature, Humidity, Pressure and Gas Sensor Buzzer Audio Signalling Device CC2530 TI CC2530 Zigbee Adapter (serial) CCS811 Gas and Air Quality sensor (I 2 C) Chirp! Soil Moisture Sensor Moisture Sensor (I 2 C) DHT11 Temperature and Humidity Sensor DHT12 DS18x20 Temperature sensor (1-Wire) DS1624/DS1621 Temperature sensor (1-Wire) DS3231 Real-Time-Clock (I 2 C) F&F LE-01MR F&F LE-01MR Single Phase Modbus Energy meter GPS-NTP-server GPS-NTP-server (serial) HDC1080 Texas Instruments HDC1080 Humidity and Temperature Sensor (I 2 C) HM-10 BLE Bluetooth gateway (serial) HM-17/HM-16 Bluetooth iBeacon reader (serial) HR-E Water Meter Encoder interface (serial) HRXL MaxBotix HRXL line of Sonar Ranging Sensors (gpio) HC-SR04 (HC-SR04P, JSN-SR04T) Ultrasonic Sensor Honeywell HIH Temperature and Humidity sensor (I 2 C) Honeywell HPMA115xx Particulate Matter Sensor (serial) HTU21 Temperature and Humidity sensor (I 2 C) HX711 Load Cell sensor (gpio) INA219 High-Side DC Current and Voltage sensor (I 2 C) IR Remote IR transmitter and receiver K30, K70, S8 CO 2 sensor (I 2 C) LM75AD Temperature Sensor (I 2 C) MAX31855 Thermocouple Sensor (SPI) MAX31865 RTD Temperature Sensor Amplifier (SPI) MAX44009 Ambient Light Sensor (I 2 C) MCP23008 / MCP23017 I/O Expander (I 2 C) MGC3130 3D Tracking and Gesture Controller MH-Z19B CO 2 Sensor MI-HM10 BLE-Bridge via HM-10 MLX90614 MLX9061X Infrared Thermometer (I 2 C) NRF24L01 NRF24L01 as BLE-bridge for Mijia BT sensors (SPI) MPR121 Proximity Capacitive Touch Sensor Controller (I 2 C) MPU6050 3-Axis Gyroscope and 3-Axis Accelerometer sensor (I 2 C) P1 Smart Meter Energy Meter (serial) PAJ7620 Gesture & Proximity Detection Sensor PIR Passive Infrared Sensor (gpio) PCA9685 16-channel, 12-bit PWM LED controller (I 2 C) PCF8574 8-port IO Expander (I 2 C) PMS3003-5003-7003 Particle Concentration sensor (serial) PN532 NFC/RFID controller PZEM-0XX Energy Monitor (serial) RCWL-0516 Microwave Radar Presence detection RDM6300 125Khz RFID Module RX-4M50RR30SF / RX-AM8SF RF Sensor receiver (gpio) SCD30 CO 2 sensor (I 2 C) Eastron SDM120 Modbus Energy Meter (serial) Eastron SDM630 Modbus Energy Meter (serial) SDS011 (SDS021) Laser Dust Sensor SGP30 Gas and Air Quality sensor (I 2 C) SHT1x Temperature and Humidity sensor (I 2 C) SHT30 Humidity & Temperature Sensor SI114x UV Index, IR and Visible Light sensor (I 2 C) Si7021 Humidity and Temperature Sensor (I 2 C) Smart Meter Interface (serial) SolaX X1 SolaX X1 inverter (serial) SPS30 Particulate Matter (PM) sensor (I 2 C) TM1638 8 Switch, LED and 7 Segment Unit sensor (gpio) TSL2561 Luminosity Sensor (I 2 C) TSL2591 Luminosity Sensor (I 2 C) TX2x La Crosse TX2x Series Anemometer sensor (gpio) VEML6070 UV Sensor (I 2 C) VL53L0x Time of flight sensor (I 2 C) WS2812B Wemos RGB LED Shield WS2812B/WS2813B LED Strip Xadow (Grove) Mutichannel Gas Sensor gas sensor (I 2 C) Google Sheet list of supported peripherals Sensor API Documentation","title":"Supported Peripherals"},{"location":"Supported-Peripherals/#expanding-specific-devices","text":"LEGO nightstand switch using Sonoff SV Add a physical button to Sonoff Basic Remote button for Sonoff Expand Sonoff S20 with a jack plug Expand Sonoff 4CH with a jack plug Modify KaKu to WKaKu Power Socket GPIO Locations","title":"Expanding Specific Devices"},{"location":"TLS/","text":"SSL/TLS on Tasmota ~ TLS offer increased security between your connected devices and your MQTT server, providing server authentication and encryption. Please refer to the general discussion in Securing-your-IoT-from-hacking Starting version 6.5.0.15, there are major changes to TLS to make it lighter in memory and easier to use. It has now reduced flash and memory requirements that makes it compatible with Web and Hue Emulation. Note: If you are upgrading from a previous TLS activated version, there are breaking changes in the way Fingerprints are calculated, read below. At the TASMOTA configuration, you need to enable to use the TLS Version. This is done by enable #define USE_MQTT_TLS in user_config_override.h and change the port number to 8883 . If you are using LetsEncrypt to generate your server certificates, you should activate #define USE_MQTT_TLS_CA_CERT . Tasmota will transparently check the server's certificate with LetsEncrypt CA. If you are generating self-signed certificates or prefer fingerprints, read below. Fingerprint validation ~ The fingerprint is now calculated on the server's Public Key and no longer on its Certificate. The good news is that Public Keys tend to change far less often than certificates, i.e. LetsEncrypt triggers a certificate renewal every 3 months, the Public Key fingerprint will not change after a certificate renewal. The bad news is that there is no openssl command to retrieve the server's Public Key fingerprint, although a tool exists to calculate it from your certificate. So to simplify your task, we have added two more options: 1/ auto-learning of the fingerprint, 2/ disabling of the fingerprint validation altogether. Option 1: Fingerprint auto-learn. If set, Tasmota will automatically learn the fingerprint during the first connection and will set the Fingerprint settings to the target fingerprint. To do so, use one of the following commands: MqttFingerprint1 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 or MqttFingerprint2 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 Option 2: Disable Fingerprint. You can completely disable server fingerprint validation, which means that Tasmota will not check the server's identity. This also means that your traffic can possibly be intercepted and read/changed, so this option should only be used on trusted networks, i.e. with an MQTT on your local network. YOU HAVE BEEN WARNED! To do so, set one of the Fingerprints to all 0xFF: MqttFingerprint2 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF Limitations: ~ Starting with 6.5.0.15, AxTLS has been replaced with BearSSL . This allows a much lighter use of memory - typically 6.0k constantly, and an additional 6.8k during TLS connection. This now makes TLS compatible with Web and Hue/Wemo emulation. The main limitations are: Your SSL/TLS server must support TLS 1.2 and the RSA_WITH_AES_128_GCM_SHA256 cipher - which is the case with the default Mosquitto configuration The server certificate must have an RSA private key (max 2048 bits) and the certificate must be signed with RSA and SHA256 hash. This is the case with default LetsEncrypt certificates. Your SSL/TLS should support TLS 1.2 MFLN to limit buffer to 1024 bytes. If MFLN is not supported, it will still work well, as long as the server does not send any message above 1024 bytes (which should be ok, since Tasmota cannot parse MQTT messages above 1024 bytes) Implementation notes ~ Arduino Core switched from AxTLS to BearSSL in 2.4.2, allowing further optimization of the TLS library footprint. BearSSL is designed for compactness, both in code size and memory requirements. Furthermore it is modular and allows for inclusion of only the code necessary for the subset of crypto-algorithms you want to support. Thanks to BearSSL's compactness and aggressive optimization, the minimal TLS configuration requires just 34.5k of Flash and 6.7k of Memory . The full-blown AWS IoT version with full certificate validation requires 48.3k of Flash and 9.4k of Memory. Here are the tips and tricks used to reduce Flash and Memory: MFLN (Maximum Fragment Length Negotiation): TLS normally uses 16k buffers for send and receive. 32k looks very small on a server, but immensely huge for ESP8266. TLS 1.2 introduced MFLN, which allows the TLS Client to reduce both buffers down to 512 bytes. MFLN is not widely supported yet, but it is by recent OpenSSL versions and by AWS IoT. This is a huge improvement in memory footprint. If your server does not support MFLN, it will still work as long as the messages sent by the server do not exceed the buffer length. In Tasmota the buffer length is 1024 bytes for send buffer and 1024 bytes for receive buffer. Going below creates message fragmentation and much longer TLS connection times (above 3s). If your server does not support MFLN, you'll see a message to that effect in the logs. Max Certificat size : BearSSL normally supports server certificates of up to RSA 4096 bits and EC 521 bits. These certificates are very uncommon currently. To save extra memory, the included BearSSL library is trimmed down to maximum RSA 2048 bit certificate and EC 256 bit certificate. This should not have any impact for you. EC private key : AWS IoT requires the client to authenticate with its own Private Key and Certificate. By default AWS IoT will generate an RSA 2048 bit private key. In Tasmota, we moved to an EC (Elliptic Curve) Private Key of 256 bits. EC keys are much smaller, and handshake is significantly faster. Note: the key being 256 bits does not mean it's less secure than RSA 2048, it's actually the opposite. Single Cipher : to reduce code size, we only support a single TLS cipher and embed only the code strictly necessary. When using TLS (e.g. LetsEncrypt on Mosquitto) the supported cipher is RSA_WITH_AES_128_GCM_SHA256 which is a very commonly supported cipher. For AWS IoT, the only supported cipher is ECDHE_RSA_WITH_AES_128_GCM_SHA256 which is one of the recommended ciphers. Additionally, ECDHE offers Perfect Forward Secrecy which means extra security. Adaptive Thunk Stack : BearSSL does not allocate memory on its own. It's either the caller's responsibility or memory is taken on the Stack. Stack usage can go above 5k, more than the ESP8266 stack. Arduino created a Thunk Stack , a secondary stack of 5.6k, allocated on Heap, and activated when a TLS connection is active. Actually the stack is mostly used during TLS handshake, and much less memory is required during TLS message processing. Tasmota only allocates the Thunk Stack during TLS handshake and switches back to the normal Stack afterwards. See below for details of actual memory usage. Keys and CA in PROGMEM : BearSSL was adapted from original source code to push most on the tables and static data into PROGMEM: https://github.com/earlephilhower/bearssl-esp8266. Additional work now allows us to put the Client Private Key, Certificate and CA in PROGMEM too, saving at least 3k of Memory. Memory usage ~ TLS on Tasmota has been aggressively optimized to use as little memory (heap) as possible. It was also optimized to limit code size. Memory consumption (nominal): BearSSL lib: 1424 bytes (or 1024 bytes with LetsEncrypt or regular TLS) BearSSL ClientContext: 3440 bytes Buffers (1024 bytes in + 1024 bytes out + overhead): 2528 bytes Total = 7.4k (or 7.0k with LetsEncrypt or regular TLS) Note: if you use USE_WEBSERVER , your impact is lowered by 2k since the Web log buffer is reduced from 4k to 2k. Overall, when activating USE_WEBSERVER , you just see a memory impact of 5.4k. Memory needed during connection (TLS handshake - fingerprint validation): ThunkStack = 5308 bytes (or 3608 bytes with LetsEncrypt or regular TLS) DecoderContext = 1152 bytes Total for connection = 6.5k (or 4.8k with LetsEncrypt or regular TLS) Memory needed during connection (TLS handshake - full CA validation): ThunkStack = 5308 bytes (or 3608 bytes with LetsEncrypt or regular TLS) DecoderContext = 3072 bytes Total for connection = 8.4k (or 6.7k with LetsEncrypt or regular TLS) Connection Time ~ The ESP8266 is quite slow compared to modern processors when it comes to SSL handshakes. Here are the observed performance times when connecting to an SSL/TLS server, depending on the CPU frequency (80MHz or 160MHz): AWS IoT Connection, with EC Private Key, simple fingerprint validation: 0.7s at 160MHz 1.3s at 80 MHz AWS IoT Connection, with EC Private Key, full CA validation (easier to configure than fingerprints): 1.0s at 160MHz 1.8s at 80 MHz LetsEncrypt based server (Mosquitto for ex), simple fingerprint validation: 0.3s at 160MHz 0.4s at 80MHz LetsEncrypt based server (Mosquitto for ex), with full CA validation (easier to configure than fingerprint): 0.4s at 160MHz 0.7s at 80MHz TLS Troubleshooting ~ Here are the most common TLS errors: Error code Description -1004 Missing CA -1003 Missing EC private key -1002 Cannot connect to TCP port -1001 Cannot resolve IP address -1000 Out of memory error 1 Bad fingerprint 2 BR_ERR_BAD_STATE 3 BR_ERR_UNSUPPORTED_VERSION 4 BR_ERR_BAD_VERSION 5 BR_ERR_BAD_LENGTH 6 BR_ERR_TOO_LARGE 7 BR_ERR_BAD_MAC 8 BR_ERR_NO_RANDOM 9 BR_ERR_UNKNOWN_TYPE 10 BR_ERR_UNEXPECTED 12 BR_ERR_BAD_CCS 13 BR_ERR_BAD_ALERT 14 BR_ERR_BAD_HANDSHAKE 15 BR_ERR_OVERSIZED_ID 16 BR_ERR_BAD_CIPHER_SUITE 17 BR_ERR_BAD_COMPRESSION 18 BR_ERR_BAD_FRAGLEN 19 BR_ERR_BAD_SECRENEG 20 BR_ERR_EXTRA_EXTENSION 21 BR_ERR_BAD_SNI 22 BR_ERR_BAD_HELLO_DONE 23 BR_ERR_LIMIT_EXCEEDED: the server's public key is too large. Tasmota TLS is limited to 2048 RSA keys 24 BR_ERR_BAD_FINISHED 25 BR_ERR_RESUME_MISMATCH 26 BR_ERR_INVALID_ALGORITHM 27 BR_ERR_BAD_SIGNATURE 28 BR_ERR_WRONG_KEY_USAGE 29 BR_ERR_NO_CLIENT_AUTH 31 BR_ERR_IO 62 X509 not trusted, the server certificate is not signed by the CA (AWS IoT or LetsEncrypt) 266 SSL3_ALERT_UNEXPECTED_MESSAGE 276 TLS1_ALERT_BAD_RECORD_MAC 277 TLS1_ALERT_DECRYPTION_FAILED 278 TLS1_ALERT_RECORD_OVERFLOW 286 SSL3_ALERT_DECOMPRESSION_FAIL 296 SSL3_ALERT_HANDSHAKE_FAILURE 298 TLS1_ALERT_BAD_CERTIFICATE: Missing or bad client private key 299 TLS1_ALERT_UNSUPPORTED_CERT 300 TLS1_ALERT_CERTIFICATE_REVOKED 301 TLS1_ALERT_CERTIFICATE_EXPIRED 302 TLS1_ALERT_CERTIFICATE_UNKNOWN 303 SSL3_ALERT_ILLEGAL_PARAMETER 304 TLS1_ALERT_UNKNOWN_CA 305 TLS1_ALERT_ACCESS_DENIED 306 TLS1_ALERT_DECODE_ERROR 307 TLS1_ALERT_DECRYPT_ERROR 316 TLS1_ALERT_EXPORT_RESTRICTION 326 TLS1_ALERT_PROTOCOL_VERSION 327 TLS1_ALERT_INSUFFIENT_SECURITY 336 TLS1_ALERT_INTERNAL_ERROR 346 TLS1_ALERT_USER_CANCELED 356 TLS1_ALERT_NO_RENEGOTIATION 366 TLS1_ALERT_UNSUPPORTED_EXT Additional BR_ERR* error codes Below are the instructions of pre-6.5.0.15 versions. ~ Before v 6.5.0.15: to the value you're getting from the Mosquitto server. To get the fingerprint you can use the following command on your MQTT server: openssl s_client -connect localhost:8883 < /dev/null 2>/dev/null | openssl x509 -fingerprint -noout -in /dev/stdin Note: The openssl output will most likely be a Colon separated fingerprint A5 : 02 : FF : 13 : 99 : 9 F : 8 B : 39 : 8 E : F1 : 83 : 4 F : 11 : 23 : 65 : 0 B : 32 : 36 : FC : 07 Tasmota requires the fingerprint expressed as 20 space separated bytes A5 02 FF 13 99 9F 8B 39 8E F1 83 4F 11 23 65 0B 32 36 FC 07 Note that when you create your certificate, you should make sure to set the CN field to the value of MQTT_HOST. Setting your CN to a domain name but your MQTT_HOST to an IP address will cause the signature verification on the Tasmota device to fail.","title":"SSL/TLS on Tasmota"},{"location":"TLS/#ssltls-on-tasmota","text":"TLS offer increased security between your connected devices and your MQTT server, providing server authentication and encryption. Please refer to the general discussion in Securing-your-IoT-from-hacking Starting version 6.5.0.15, there are major changes to TLS to make it lighter in memory and easier to use. It has now reduced flash and memory requirements that makes it compatible with Web and Hue Emulation. Note: If you are upgrading from a previous TLS activated version, there are breaking changes in the way Fingerprints are calculated, read below. At the TASMOTA configuration, you need to enable to use the TLS Version. This is done by enable #define USE_MQTT_TLS in user_config_override.h and change the port number to 8883 . If you are using LetsEncrypt to generate your server certificates, you should activate #define USE_MQTT_TLS_CA_CERT . Tasmota will transparently check the server's certificate with LetsEncrypt CA. If you are generating self-signed certificates or prefer fingerprints, read below.","title":"SSL/TLS on Tasmota"},{"location":"TLS/#fingerprint-validation","text":"The fingerprint is now calculated on the server's Public Key and no longer on its Certificate. The good news is that Public Keys tend to change far less often than certificates, i.e. LetsEncrypt triggers a certificate renewal every 3 months, the Public Key fingerprint will not change after a certificate renewal. The bad news is that there is no openssl command to retrieve the server's Public Key fingerprint, although a tool exists to calculate it from your certificate. So to simplify your task, we have added two more options: 1/ auto-learning of the fingerprint, 2/ disabling of the fingerprint validation altogether. Option 1: Fingerprint auto-learn. If set, Tasmota will automatically learn the fingerprint during the first connection and will set the Fingerprint settings to the target fingerprint. To do so, use one of the following commands: MqttFingerprint1 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 or MqttFingerprint2 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 Option 2: Disable Fingerprint. You can completely disable server fingerprint validation, which means that Tasmota will not check the server's identity. This also means that your traffic can possibly be intercepted and read/changed, so this option should only be used on trusted networks, i.e. with an MQTT on your local network. YOU HAVE BEEN WARNED! To do so, set one of the Fingerprints to all 0xFF: MqttFingerprint2 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF","title":"Fingerprint validation"},{"location":"TLS/#limitations","text":"Starting with 6.5.0.15, AxTLS has been replaced with BearSSL . This allows a much lighter use of memory - typically 6.0k constantly, and an additional 6.8k during TLS connection. This now makes TLS compatible with Web and Hue/Wemo emulation. The main limitations are: Your SSL/TLS server must support TLS 1.2 and the RSA_WITH_AES_128_GCM_SHA256 cipher - which is the case with the default Mosquitto configuration The server certificate must have an RSA private key (max 2048 bits) and the certificate must be signed with RSA and SHA256 hash. This is the case with default LetsEncrypt certificates. Your SSL/TLS should support TLS 1.2 MFLN to limit buffer to 1024 bytes. If MFLN is not supported, it will still work well, as long as the server does not send any message above 1024 bytes (which should be ok, since Tasmota cannot parse MQTT messages above 1024 bytes)","title":"Limitations:"},{"location":"TLS/#implementation-notes","text":"Arduino Core switched from AxTLS to BearSSL in 2.4.2, allowing further optimization of the TLS library footprint. BearSSL is designed for compactness, both in code size and memory requirements. Furthermore it is modular and allows for inclusion of only the code necessary for the subset of crypto-algorithms you want to support. Thanks to BearSSL's compactness and aggressive optimization, the minimal TLS configuration requires just 34.5k of Flash and 6.7k of Memory . The full-blown AWS IoT version with full certificate validation requires 48.3k of Flash and 9.4k of Memory. Here are the tips and tricks used to reduce Flash and Memory: MFLN (Maximum Fragment Length Negotiation): TLS normally uses 16k buffers for send and receive. 32k looks very small on a server, but immensely huge for ESP8266. TLS 1.2 introduced MFLN, which allows the TLS Client to reduce both buffers down to 512 bytes. MFLN is not widely supported yet, but it is by recent OpenSSL versions and by AWS IoT. This is a huge improvement in memory footprint. If your server does not support MFLN, it will still work as long as the messages sent by the server do not exceed the buffer length. In Tasmota the buffer length is 1024 bytes for send buffer and 1024 bytes for receive buffer. Going below creates message fragmentation and much longer TLS connection times (above 3s). If your server does not support MFLN, you'll see a message to that effect in the logs. Max Certificat size : BearSSL normally supports server certificates of up to RSA 4096 bits and EC 521 bits. These certificates are very uncommon currently. To save extra memory, the included BearSSL library is trimmed down to maximum RSA 2048 bit certificate and EC 256 bit certificate. This should not have any impact for you. EC private key : AWS IoT requires the client to authenticate with its own Private Key and Certificate. By default AWS IoT will generate an RSA 2048 bit private key. In Tasmota, we moved to an EC (Elliptic Curve) Private Key of 256 bits. EC keys are much smaller, and handshake is significantly faster. Note: the key being 256 bits does not mean it's less secure than RSA 2048, it's actually the opposite. Single Cipher : to reduce code size, we only support a single TLS cipher and embed only the code strictly necessary. When using TLS (e.g. LetsEncrypt on Mosquitto) the supported cipher is RSA_WITH_AES_128_GCM_SHA256 which is a very commonly supported cipher. For AWS IoT, the only supported cipher is ECDHE_RSA_WITH_AES_128_GCM_SHA256 which is one of the recommended ciphers. Additionally, ECDHE offers Perfect Forward Secrecy which means extra security. Adaptive Thunk Stack : BearSSL does not allocate memory on its own. It's either the caller's responsibility or memory is taken on the Stack. Stack usage can go above 5k, more than the ESP8266 stack. Arduino created a Thunk Stack , a secondary stack of 5.6k, allocated on Heap, and activated when a TLS connection is active. Actually the stack is mostly used during TLS handshake, and much less memory is required during TLS message processing. Tasmota only allocates the Thunk Stack during TLS handshake and switches back to the normal Stack afterwards. See below for details of actual memory usage. Keys and CA in PROGMEM : BearSSL was adapted from original source code to push most on the tables and static data into PROGMEM: https://github.com/earlephilhower/bearssl-esp8266. Additional work now allows us to put the Client Private Key, Certificate and CA in PROGMEM too, saving at least 3k of Memory.","title":"Implementation notes"},{"location":"TLS/#memory-usage","text":"TLS on Tasmota has been aggressively optimized to use as little memory (heap) as possible. It was also optimized to limit code size. Memory consumption (nominal): BearSSL lib: 1424 bytes (or 1024 bytes with LetsEncrypt or regular TLS) BearSSL ClientContext: 3440 bytes Buffers (1024 bytes in + 1024 bytes out + overhead): 2528 bytes Total = 7.4k (or 7.0k with LetsEncrypt or regular TLS) Note: if you use USE_WEBSERVER , your impact is lowered by 2k since the Web log buffer is reduced from 4k to 2k. Overall, when activating USE_WEBSERVER , you just see a memory impact of 5.4k. Memory needed during connection (TLS handshake - fingerprint validation): ThunkStack = 5308 bytes (or 3608 bytes with LetsEncrypt or regular TLS) DecoderContext = 1152 bytes Total for connection = 6.5k (or 4.8k with LetsEncrypt or regular TLS) Memory needed during connection (TLS handshake - full CA validation): ThunkStack = 5308 bytes (or 3608 bytes with LetsEncrypt or regular TLS) DecoderContext = 3072 bytes Total for connection = 8.4k (or 6.7k with LetsEncrypt or regular TLS)","title":"Memory usage"},{"location":"TLS/#connection-time","text":"The ESP8266 is quite slow compared to modern processors when it comes to SSL handshakes. Here are the observed performance times when connecting to an SSL/TLS server, depending on the CPU frequency (80MHz or 160MHz): AWS IoT Connection, with EC Private Key, simple fingerprint validation: 0.7s at 160MHz 1.3s at 80 MHz AWS IoT Connection, with EC Private Key, full CA validation (easier to configure than fingerprints): 1.0s at 160MHz 1.8s at 80 MHz LetsEncrypt based server (Mosquitto for ex), simple fingerprint validation: 0.3s at 160MHz 0.4s at 80MHz LetsEncrypt based server (Mosquitto for ex), with full CA validation (easier to configure than fingerprint): 0.4s at 160MHz 0.7s at 80MHz","title":"Connection Time"},{"location":"TLS/#tls-troubleshooting","text":"Here are the most common TLS errors: Error code Description -1004 Missing CA -1003 Missing EC private key -1002 Cannot connect to TCP port -1001 Cannot resolve IP address -1000 Out of memory error 1 Bad fingerprint 2 BR_ERR_BAD_STATE 3 BR_ERR_UNSUPPORTED_VERSION 4 BR_ERR_BAD_VERSION 5 BR_ERR_BAD_LENGTH 6 BR_ERR_TOO_LARGE 7 BR_ERR_BAD_MAC 8 BR_ERR_NO_RANDOM 9 BR_ERR_UNKNOWN_TYPE 10 BR_ERR_UNEXPECTED 12 BR_ERR_BAD_CCS 13 BR_ERR_BAD_ALERT 14 BR_ERR_BAD_HANDSHAKE 15 BR_ERR_OVERSIZED_ID 16 BR_ERR_BAD_CIPHER_SUITE 17 BR_ERR_BAD_COMPRESSION 18 BR_ERR_BAD_FRAGLEN 19 BR_ERR_BAD_SECRENEG 20 BR_ERR_EXTRA_EXTENSION 21 BR_ERR_BAD_SNI 22 BR_ERR_BAD_HELLO_DONE 23 BR_ERR_LIMIT_EXCEEDED: the server's public key is too large. Tasmota TLS is limited to 2048 RSA keys 24 BR_ERR_BAD_FINISHED 25 BR_ERR_RESUME_MISMATCH 26 BR_ERR_INVALID_ALGORITHM 27 BR_ERR_BAD_SIGNATURE 28 BR_ERR_WRONG_KEY_USAGE 29 BR_ERR_NO_CLIENT_AUTH 31 BR_ERR_IO 62 X509 not trusted, the server certificate is not signed by the CA (AWS IoT or LetsEncrypt) 266 SSL3_ALERT_UNEXPECTED_MESSAGE 276 TLS1_ALERT_BAD_RECORD_MAC 277 TLS1_ALERT_DECRYPTION_FAILED 278 TLS1_ALERT_RECORD_OVERFLOW 286 SSL3_ALERT_DECOMPRESSION_FAIL 296 SSL3_ALERT_HANDSHAKE_FAILURE 298 TLS1_ALERT_BAD_CERTIFICATE: Missing or bad client private key 299 TLS1_ALERT_UNSUPPORTED_CERT 300 TLS1_ALERT_CERTIFICATE_REVOKED 301 TLS1_ALERT_CERTIFICATE_EXPIRED 302 TLS1_ALERT_CERTIFICATE_UNKNOWN 303 SSL3_ALERT_ILLEGAL_PARAMETER 304 TLS1_ALERT_UNKNOWN_CA 305 TLS1_ALERT_ACCESS_DENIED 306 TLS1_ALERT_DECODE_ERROR 307 TLS1_ALERT_DECRYPT_ERROR 316 TLS1_ALERT_EXPORT_RESTRICTION 326 TLS1_ALERT_PROTOCOL_VERSION 327 TLS1_ALERT_INSUFFIENT_SECURITY 336 TLS1_ALERT_INTERNAL_ERROR 346 TLS1_ALERT_USER_CANCELED 356 TLS1_ALERT_NO_RENEGOTIATION 366 TLS1_ALERT_UNSUPPORTED_EXT Additional BR_ERR* error codes","title":"TLS Troubleshooting"},{"location":"TLS/#below-are-the-instructions-of-pre-65015-versions","text":"Before v 6.5.0.15: to the value you're getting from the Mosquitto server. To get the fingerprint you can use the following command on your MQTT server: openssl s_client -connect localhost:8883 < /dev/null 2>/dev/null | openssl x509 -fingerprint -noout -in /dev/stdin Note: The openssl output will most likely be a Colon separated fingerprint A5 : 02 : FF : 13 : 99 : 9 F : 8 B : 39 : 8 E : F1 : 83 : 4 F : 11 : 23 : 65 : 0 B : 32 : 36 : FC : 07 Tasmota requires the fingerprint expressed as 20 space separated bytes A5 02 FF 13 99 9F 8B 39 8E F1 83 4F 11 23 65 0B 32 36 FC 07 Note that when you create your certificate, you should make sure to set the CN field to the value of MQTT_HOST. Setting your CN to a domain name but your MQTT_HOST to an IP address will cause the signature verification on the Tasmota device to fail.","title":"Below are the instructions of pre-6.5.0.15 versions."},{"location":"TSL2561/","text":"!> This feature is included only in tasmota-sensors.bin Otherwise you must compile your build . Add the following to user_config_override.h : #ifndef USE_VEML6070 #define USE_TSL2561 // Enable TSL2561 sensor (I2C address 0x29, 0x39 or 0x49) (+2k3 code) #endif The TSL2561 luminosity sensor is an advanced digital light I 2 C sensor, ideal for use in a wide range of light situations. Configuration ~ Wiring ~ TSL2561 ESP8266 GND GND VCC 3.3V SCL GPIOy SDA GPIOx INT not used Tasmota Settings ~ In the Configuration -> Configure Module page assign: 1. GPIOx to I2C SDA (6) 2. GPIOy to I2C SCL (5) After a reboot the driver will detect TSL2561 automatically and display Illuminance. Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2019-11-03T21:04:05\" , \"TSL2561\" :{ \"Illuminance\" : 21.180 }} Breakout Boards ~","title":"TSL2561"},{"location":"TSL2561/#configuration","text":"","title":"Configuration"},{"location":"TSL2561/#wiring","text":"TSL2561 ESP8266 GND GND VCC 3.3V SCL GPIOy SDA GPIOx INT not used","title":"Wiring"},{"location":"TSL2561/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: 1. GPIOx to I2C SDA (6) 2. GPIOy to I2C SCL (5) After a reboot the driver will detect TSL2561 automatically and display Illuminance. Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2019-11-03T21:04:05\" , \"TSL2561\" :{ \"Illuminance\" : 21.180 }}","title":"Tasmota Settings"},{"location":"TSL2561/#breakout-boards","text":"","title":"Breakout Boards"},{"location":"TX2x/","text":"!> This feature is not included in precompiled binaries. To use it you must compile your build . Add the following to user_config_override.h : For TX20 sensor #ifndef USE_TX20_WIND_SENSOR #define USE_TX20_WIND_SENSOR // Add support for La Crosse TX20 anemometer (+2k6/0k8 code) #endif For TX23 sensor #ifndef USE_TX23_WIND_SENSOR #define USE_TX23_WIND_SENSOR // Add support for La Crosse TX20 anemometer (+2k6/0k8 code) #endif This setting compiles Tasmota with sensor statistical values (needs the higher value size of code), which are useful for the wind sensor, since the measured values naturally change very quickly. The values generated in addition to the wind speed and wind direction are: Wind speed min/max Wind speed average (\u2205) Wind direction average (\u2205) Wind direction range (\u2220) and min/max The average (\u2205) values are continuously calculated values. The range (\u2220) and min/max values are held for the time TelePeriod and reset after MQTT SENSOR message has been output. If you do not want the statistical calculation having speed and direction value only, use #ifndef USE_TX2X_WIND_SENSOR_NOSTATISTICS #define USE_TX2X_WIND_SENSOR_NOSTATISTICS #endif in your user_config_override.h . This will save approx. 1k8 bytes of code. The TX20 (retired) and TX23 sensor supplies the two measured values wind speed and wind direction. The TX23 sensor is still available under various brand names such as \"La Crosse\", \"Technoline\". Unfortunately, the TX20 (at least in Europe) is almost impossible to get. However, the two sensors differ only in the protocol used, but deliver the same measured values. Configuration ~ Wiring ~ TX20 Pin Color Description ESP8266 1 Brown/Black TxD GPIOx 2 Red 3.3V 3.3V 3 Green DTR GND 4 Yellow GND GND TX23 Pin Color Description ESP8266 1 Brown/Black TxD GPIOx 2 Red 3.3V 3.3V 3 Green - - 4 Yellow GND GND Tasmota Settings ~ In the Configuration -> Configure Module page assign: GPIOx to TX2x (104) The TX2 pin needs a pull-up resistor. The internal pull-up is activated for this so you can use any useful GPIO except GPIO15 and GPIO16 (GPIO15 is always pulled low, GPIO16 has a built-in pull-down resistor). To be on the save side you can add an additonal external 10k pull-up to TX2x GPIOx. After a reboot the driver will detect TX20/TX23 automatically and display the wind data: Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2020-03-03T00:00:00+00:00\" , \"TX23\" : { \"Speed\" : { \"Act\" : 14.8 , \"Avg\" : 8.5 , \"Min\" : 12.2 , \"Max\" : 14.8 }, \"Dir\" : { \"Card\" : \"WSW\" , \"Deg\" : 247.5 , \"Avg\" : 266.1 , \"AvgCard\" : \"W\" , \"Min\" : 247.5 , \"Max\" : 247.5 , \"Range\" : 0 } }, \"SpeedUnit\" : \"km/h\" } Commands ~ The wind speed unit is set to km/h as default. You can change the unit using the command SpeedUnit <x> where \\ = 1\u20266 : - 1 = m/s (meter per second) - 2 = km/h (kilometer per hour) - 3 = kn (knots) - 4 = mph (miles per hour) - 5 = ft/s (foot per second) - 6 = yd/s (yard per second) The changed unit will appear in the webUI and via MQTT SENSOR messages.","title":"TX2x"},{"location":"TX2x/#configuration","text":"","title":"Configuration"},{"location":"TX2x/#wiring","text":"","title":"Wiring"},{"location":"TX2x/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: GPIOx to TX2x (104) The TX2 pin needs a pull-up resistor. The internal pull-up is activated for this so you can use any useful GPIO except GPIO15 and GPIO16 (GPIO15 is always pulled low, GPIO16 has a built-in pull-down resistor). To be on the save side you can add an additonal external 10k pull-up to TX2x GPIOx. After a reboot the driver will detect TX20/TX23 automatically and display the wind data: Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2020-03-03T00:00:00+00:00\" , \"TX23\" : { \"Speed\" : { \"Act\" : 14.8 , \"Avg\" : 8.5 , \"Min\" : 12.2 , \"Max\" : 14.8 }, \"Dir\" : { \"Card\" : \"WSW\" , \"Deg\" : 247.5 , \"Avg\" : 266.1 , \"AvgCard\" : \"W\" , \"Min\" : 247.5 , \"Max\" : 247.5 , \"Range\" : 0 } }, \"SpeedUnit\" : \"km/h\" }","title":"Tasmota Settings"},{"location":"TX2x/#commands","text":"The wind speed unit is set to km/h as default. You can change the unit using the command SpeedUnit <x> where \\ = 1\u20266 : - 1 = m/s (meter per second) - 2 = km/h (kilometer per hour) - 3 = kn (knots) - 4 = mph (miles per hour) - 5 = ft/s (foot per second) - 6 = yd/s (yard per second) The changed unit will appear in the webUI and via MQTT SENSOR messages.","title":"Commands"},{"location":"TasUI/","text":"TasUI is a zero-install device management interface web application for all your Tasmota devices. It will discover your deployed devices and allow you to set up and configure every device from a single dashboard. This initial version includes multiple views (Control, Health, Firmware, Wi-Fi, & MQTT) to allow you to quickly assess the state of your devices. There is also a detailed view (e.g., SetOptions, Status, etc.) available. TasUI provides a syntax-aware command interface for every Tasmota command by category (e.g., Configuration, Timers, Sensors, Lights, etc.) as well as the \"familiar\" Console interface to enter commands directly. This is a beta version (i.e., we expect you to find some unexpected features). As these issues are fixed, it will not require you to reinstall any software to get these fixes. This also applies to new features as they are added to the app. Join us on Discord ! Docker ~ For those who prefer to have everything installed locally, a Docker image for linux amd64 , arm32v7 , arm64v8 and i386 is available for download . docker pull iotreboot / tasui : latest docker run - p [ PORT ] : 80 iotreboot / tasui : latest Home Assistant ~ The add-on can be installed on amd64 , arm32v7 , arm64v8 and i386 builds. Simply add the TasUI repository on your addons list: https://github.com/iotreboot/TasUI No configuration is required.","title":"TasUI"},{"location":"TasUI/#docker","text":"For those who prefer to have everything installed locally, a Docker image for linux amd64 , arm32v7 , arm64v8 and i386 is available for download . docker pull iotreboot / tasui : latest docker run - p [ PORT ] : 80 iotreboot / tasui : latest","title":"Docker"},{"location":"TasUI/#home-assistant","text":"The add-on can be installed on amd64 , arm32v7 , arm64v8 and i386 builds. Simply add the TasUI repository on your addons list: https://github.com/iotreboot/TasUI No configuration is required.","title":"Home Assistant"},{"location":"TasmoAdmin/","text":"TasmoAdmin is an administrative Website for Devices flashed with Tasmota . You can find it here: TasmoAdmin GitHub . It supports running on Windows, Linux and as Docker container. Features ~ Login protected Multi Update Process Select devices to update Automatic Modus downloads latest firmware bin from Tasmota GitHub Show device information Mobile Responsive (Bootstrap4) Config devices SelfUpdate function for TasmoAdmin (disabled for Docker) NightMode (Enable/Disable/Auto) in settings AutoScan to find Tasmota Devices Support for multiple sensors chat (beta) Installation ~ Windows ~ A ready to use TasmoAdmin-XAMP-Portable-*.zip is available on the release page and is based on XAMPP. Download the XAMPP Zip package from the releases page Extract the Zip (recommend to put the xamp folder on C:\\ Run once the xamp\\setup_xampp.bat Start xampp-control.exe Start Apache in the opened ControlCenter Get your local IP Address Now you can type in your browser http://YOURLOCALIP and TasmoAdmin shows up. Linux ~ Running TasmoAdmin on a Linux/Unix hosts requires the following: * A Webserver * apache2 recommended * php7 recommended (works with php5 too) * php-curl php-zip Modules installed You need to install a web server with php-zip and php-curl modules installed. Also mod_rewrite must be enabled. I suggest to look in the Guide for Ubuntu Server 16.04 and try to adjust it to your server OS. Docker ~ TasmoAdmin is available as a Docker image at Docker Hub . This is a Linux Alpine (3.7) based image with Apache2 and Php7 installed. It supports multiple architectures, amd64 (i.e. Synology DSM), arm (i.e. Raspberry PI3) and arm64 (i.e. Pine64). Check out the Wiki for running TasmoAdmin in a Docker Container for install instructions. Example Images ~ Login Page Start Page Devices Page Devices Add/Edit Page Config General Page Config Network Page Update Devices Page Settings Page Mobile","title":"TasmoAdmin"},{"location":"TasmoAdmin/#features","text":"Login protected Multi Update Process Select devices to update Automatic Modus downloads latest firmware bin from Tasmota GitHub Show device information Mobile Responsive (Bootstrap4) Config devices SelfUpdate function for TasmoAdmin (disabled for Docker) NightMode (Enable/Disable/Auto) in settings AutoScan to find Tasmota Devices Support for multiple sensors chat (beta)","title":"Features"},{"location":"TasmoAdmin/#installation","text":"","title":"Installation"},{"location":"TasmoAdmin/#windows","text":"A ready to use TasmoAdmin-XAMP-Portable-*.zip is available on the release page and is based on XAMPP. Download the XAMPP Zip package from the releases page Extract the Zip (recommend to put the xamp folder on C:\\ Run once the xamp\\setup_xampp.bat Start xampp-control.exe Start Apache in the opened ControlCenter Get your local IP Address Now you can type in your browser http://YOURLOCALIP and TasmoAdmin shows up.","title":"Windows"},{"location":"TasmoAdmin/#linux","text":"Running TasmoAdmin on a Linux/Unix hosts requires the following: * A Webserver * apache2 recommended * php7 recommended (works with php5 too) * php-curl php-zip Modules installed You need to install a web server with php-zip and php-curl modules installed. Also mod_rewrite must be enabled. I suggest to look in the Guide for Ubuntu Server 16.04 and try to adjust it to your server OS.","title":"Linux"},{"location":"TasmoAdmin/#docker","text":"TasmoAdmin is available as a Docker image at Docker Hub . This is a Linux Alpine (3.7) based image with Apache2 and Php7 installed. It supports multiple architectures, amd64 (i.e. Synology DSM), arm (i.e. Raspberry PI3) and arm64 (i.e. Pine64). Check out the Wiki for running TasmoAdmin in a Docker Container for install instructions.","title":"Docker"},{"location":"TasmoAdmin/#example-images","text":"","title":"Example Images"},{"location":"Tasmota-Device-Locator/","text":"Tasmota Device Locator ~ Locate Tasmota Devices on your network when you only know the subnet of the device. The search is done with JavaScript in a browser and no software installation is required. Only newer devices with HTTP Cross-Origin Resource Sharing (CORS) support will be found. CORS is disabled in Tasmota by default. Use SetOption73 to change this setting. Usage ~ Enter any IP address in the subnet and it will search for devices on the entire subnet. For example, specify 192.168.0.0 to locate all devices in the range 192.168.0.0 to 192.168.0.255. If the devices are password protected also enter the password. The password will be tried on all devices. If they have different passwords, multiple searches must be performed. Run the live version ~ The live version can be found here Local Deployment ~ If you want to run your own server, the Tasmota Device Locator can be served by any static http server (not https). - Checkout the branch gh-pages. - Copy the files to the root of the web server Development ~ Sources can be found on github, Tasmota Device Locator .","title":"Tasmota Device Locator"},{"location":"Tasmota-Device-Locator/#tasmota-device-locator","text":"Locate Tasmota Devices on your network when you only know the subnet of the device. The search is done with JavaScript in a browser and no software installation is required. Only newer devices with HTTP Cross-Origin Resource Sharing (CORS) support will be found. CORS is disabled in Tasmota by default. Use SetOption73 to change this setting.","title":"Tasmota Device Locator"},{"location":"Tasmota-Device-Locator/#usage","text":"Enter any IP address in the subnet and it will search for devices on the entire subnet. For example, specify 192.168.0.0 to locate all devices in the range 192.168.0.0 to 192.168.0.255. If the devices are password protected also enter the password. The password will be tried on all devices. If they have different passwords, multiple searches must be performed.","title":"Usage"},{"location":"Tasmota-Device-Locator/#run-the-live-version","text":"The live version can be found here","title":"Run the live version"},{"location":"Tasmota-Device-Locator/#local-deployment","text":"If you want to run your own server, the Tasmota Device Locator can be served by any static http server (not https). - Checkout the branch gh-pages. - Copy the files to the root of the web server","title":"Local Deployment"},{"location":"Tasmota-Device-Locator/#development","text":"Sources can be found on github, Tasmota Device Locator .","title":"Development"},{"location":"Tasmota-Device-Manager/","text":"Tasmota Device Manager or TDM is a GUI application written in Python for discovery and monitoring of Tasmota flashed devices. Features ~ clean, readable interface autodetection of devices following the default topic template for Tasmota (%prefix%/%topic%/) and for HomeAssistant Auto Discovery protocol (%topic%/%prefix%/) module and GPIO configuration rules editor devices with different syntax can be added manually clean retained MQTT topic messages toggleable active querying of telemetry passive monitoring of state and telemetry (currently supported sensors are listed in \"status8.json\") relay control via context menu on device list (all ON/OFF, or individual) MQTT console with payload preview (dbl-click an entry to display), sorting and filtering selectable detail columns in device list BSSID aliasing for larger deployments Installation ~ Python 3.6+ is required. Clone the repo or download zip and extract, install prerequisites and run tdm.py using Python binary. Prerequisites ~ PyQt5: pip install PyQt5 paho-mqtt: pip install paho-mqtt","title":"Tasmota Device Manager"},{"location":"Tasmota-Device-Manager/#features","text":"clean, readable interface autodetection of devices following the default topic template for Tasmota (%prefix%/%topic%/) and for HomeAssistant Auto Discovery protocol (%topic%/%prefix%/) module and GPIO configuration rules editor devices with different syntax can be added manually clean retained MQTT topic messages toggleable active querying of telemetry passive monitoring of state and telemetry (currently supported sensors are listed in \"status8.json\") relay control via context menu on device list (all ON/OFF, or individual) MQTT console with payload preview (dbl-click an entry to display), sorting and filtering selectable detail columns in device list BSSID aliasing for larger deployments","title":"Features"},{"location":"Tasmota-Device-Manager/#installation","text":"Python 3.6+ is required. Clone the repo or download zip and extract, install prerequisites and run tdm.py using Python binary.","title":"Installation"},{"location":"Tasmota-Device-Manager/#prerequisites","text":"PyQt5: pip install PyQt5 paho-mqtt: pip install paho-mqtt","title":"Prerequisites"},{"location":"Tasmota-IR/","text":"The default Tasmota firmware variants include support for IR send/receive for a limited set of protocols (see IR Remote ). Tasmota uses the IRremoteESP8266 library that supports numerous protocols. Each protocol consumes some memory, especially air conditioner protocols (up to 81k of flash size). Also, every protocol included increases the time to decode the IR signal. There are two additional Tasmota firmware variants that provide almost all IRremoteESP8266 protocols. This requires disabling some other features to keep code size manageable. - sonoff-ir is pre-packaged for IR blasters, like Eachen IR Bridge or YTF IR Bridge . Choose sonoff-ir if you are using an IR blaster. - sonoff-ircustom is used if you want to customize your features (additional sensors, language, etc.). This variant is required because it triggers a special compilation flag for IRremoteESP8266. Edit the IRremoteESP8266.h header in the IRremoteESP8266-x.x.x/src folder to disable (i.e., set to false ) any unneeded/unwanted protocols. Then compile your own firmware . You can flash the binary or upgrade your existing one. To test that you have the correct firmware on your device issue the following command in the web UI Console: IRhvac {\"Vendor\":\"xx\"} The output should be a list of the supported protocols/vendors. For example: RESULT = {\"IRHVAC\":\"Wrong Vendor (COOLIX|DAIKIN|KELVINATOR|MITSUBISHI_AC|GREE|ARGO|TROTEC|TOSHIBA_AC|FUJITSU_AC|MIDEA|HAIER_AC|HITACHI_AC|HAIER_AC_YRW02|WHIRLPOOL_AC|SAMSUNG_AC|ELECTRA_AC|PANASONIC_AC|DAIKIN2|VESTEL_AC|TECO|TCL112AC|MITSUBISHI_HEAVY_88|MITSUBISHI_HEAVY_152|DAIKIN216|SHARP_AC|GOODWEATHER|DAIKIN160|NEOCLIMA|DAIKIN176|DAIKIN128|AMCOR)\"} Sending IR Commands ~ Send an IR remote control code as a decimal or hexadecimal string in a JSON payload. In order to send IR data, you must configure one of the free device GPIO as IRsend (8) . Neither GPIO01 nor GPIO03 can be used. Command Parameters IRsend <x> <x> [ optional ] = number of times the IR message is sent. If not specified or 0..1 , the message is sent only once (i.e., not repeated) (default) >1 = emulate a long-press on the remote control, sending the message <x> times, or sending a repeat message for specific protocols (like NEC) {\"Protocol\":\"<value>\",\"Bits\":<value>,\"Data\":<value>,\"DataLSB\":<value>,\"Repeat\":<value>} \"Protocol\" or \"Vendor\" (select one of the following): RC5, RC6, NEC, SONY, PANASONIC, JVC, SAMSUNG, WHYNTER, AIWA_RC_T501, LG, MITSUBISHI, DISH, SHARP, DENON, SHERWOOD, RCMM, SANYO_LC7461, RC5X, NEC (non-strict), NIKAI, MAGIQUEST, LASERTAG, CARRIER_AC, MITSUBISHI2, HITACHI_AC1, HITACHI_AC2, GICABLE, LUTRON, PIONEER, LG2, SAMSUNG36, LEGOPF, INAX, DAIKIN152 \"Bits\":1..64 = required number of data bits for PANASONIC protocol this parameter is the the address, not the number of bits \"Data\":0x1..0xFFFFFFFFFFFFFFFF = data frame as 64 bit hexadecimal. e.g., IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":0x8166817E} Or \"DataLSB\":0x1..0xFFFFFFFFFFFFFFFF = data frame as 64 bit hexadecimal with LSB (each byte with bits reversed). e.g., IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":0x8166817E} DataLSB comes handy with LSB-first (Least Significant Bit First) protocols like NEC, and makes decoding/encoding easier. \"Repeat\":0..<x> if 0 send the frame once, if >0 simulates a long press; Note: \"Repeat\":1 sends the message twice. Alternatively, you can send IR remote control codes using RAW command encoding . See also Sending IRHVAC Commands ~ Command Parameters IRhvac Send HVAC IR remote control code as JSON payload IRhvac {\"Vendor\":\"Mitsubishi_Heavy_152\", \"Power\":\"On\",\"Mode\":\"Hot\",\"FanSpeed\":3,\"Temp\":22.5} \"Protocol\" or \"Vendor\" (select one of the following): COOLIX, DAIKIN, KELVINATOR, MITSUBISHI_AC, GREE, ARGO, TROTEC, TOSHIBA_AC, FUJITSU_AC, MIDEA, HAIER_AC, HITACHI_AC, HAIER_AC_YRW02, WHIRLPOOL_AC, SAMSUNG_AC, ELECTRA_AC, PANASONIC_AC, DAIKIN2, VESTEL_AC, TECO, TCL112AC, MITSUBISHI_HEAVY_88, MITSUBISHI_HEAVY_152, DAIKIN216, SHARP_AC, GOODWEATHER, DAIKIN160, NEOCLIMA, DAIKIN176, DAIKIN128 \"Model\": Some HVAC have variants in protocols, this field allows to specify the variant, see detailed list . Fujitsu_AC : ARRAH2E\\|ARDB1 Panasonic_AC : LKE\\|NKE\\|DKE\\|JKE\\|CKP\\|RKR Whirlpool_AC : DG11J13A\\|DG11J104\\|DG11J1-04\\|DG11J191 \"Power\" : On, Yes, True, 1 Off, No, False, 0 \"Mode\" : Off, Stop Auto, Automatic Cool, Cooling Heat, Heating Dry, Drying, Dehumidify Fan, Fanonly, Fan_Only \"FanSpeed\" : Auto, Automatic Min, Minimum, Lowest, 1 Low, 2 Med, Medium, Mid, 3 High, Hi, 4 Max, Maximum, Highest, 5 \"SwingV\" : vertical swing of Fan Auto, Automatic, On, Swing Off, Stop Min, Minimum, Lowest, Bottom, Down Low Mid, Middle, Med, Medium, Centre, Center High, Hi Highest, Max, Maximum, Top, Up \"SwingH\" : horizontal swing of Fan Auto, Automatic, On, Swing Off, Stop LeftMax, Left Max, MaxLeft, Max Left, FarLeft, Far Left Left Mid, Middle, Med, Medium, Centre, Center Right RightMax, Right Max, MaxRight, Max Right, FarRight, Far Right Wide \"Celsius\" : temperature is in Celsius ( \"On\" ) of Farenheit ( \"Off\" ) \"Temp\" : Temperature, can be float if supported by protocol \"Quiet\" : Quiet mode ( \"On\" / \"Off\" ) \"Turbo\" : Turbo mode ( \"On\" / \"Off\" ) \"Econo\" : Econo mode ( \"On\" / \"Off\" ) \"Light\" : Light ( \"On\" / \"Off\" ) \"Filter\" : Filter active ( \"On\" / \"Off\" ) \"Clean\" : Clean mode ( \"On\" / \"Off\" ) \"Beep\" : Beep active ( \"On\" / \"Off\" ) \"Sleep\" : Timer in seconds Receiving IR Commands ~ If you have an IR receiver, a message will be logged each time an IR message is seen. IR driver will try to decode the message against all supported protocols. If unrecognized, the \"Protocol\":\"UNKNOWN\" will be shown. In this case, the \"Data\" field contains a hash of the received message. The hash can't be used to send the a message, but the same hash will be produced by the same message. An inexpensive IR sensor such as a TSOP1838 can be connected to a device running Tasmota. Configure a free device GPIO as 'IRrecv (51)'. When Tasmota receives an IR message, the data portion of the payload has the same format as the IRsend parameter. {\"IrReceived\":{\"Protocol\":\"<value>\",\"Bits\":<value>,\"Data\":<value>}} This JSON payload data can be used in a rule such as: ON IrReceived#Data=<value> DO <command> ENDON If the data is received on an unknown protocol use SetOption58 1 . See here . Examples: Pioneer Vol+ MQT: tele/tasmota/IR1/RESULT = {\"IrReceived\":{\"Protocol\":\"PIONEER\",\"Bits\":64,\"Data\":\"0xA55A50AFA55A50AF\",\"DataLSB\":\"0xA55A0AF5A55A0AF5\",\"Repeat\":0}} Pioneer Vol- tele/tasmota/IR1/RESULT = {\"IrReceived\":{\"Protocol\":\"PIONEER\",\"Bits\":64,\"Data\":\"0xA55AD02FA55AD02F\",\"DataLSB\":\"0xA55A0BF4A55A0BF4\",\"Repeat\":0}} Toshiba (NEC): Channel 1 MQT: tele/tasmota/IR1/RESULT = {\"IrReceived\":{\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x02FD807F\",\"DataLSB\":\"0x40BF01FE\",\"Repeat\":0}} Toshiba (NEC): Channel 2 MQT: tele/tasmota/IR1/RESULT = {\"IrReceived\":{\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x02FD40BF\",\"DataLSB\":\"0x40BF02FD\",\"Repeat\":0}} Toshiba (NEC): Channel 3 MQT: tele/tasmota/IR1/RESULT = {\"IrReceived\":{\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x02FDC03F\",\"DataLSB\":\"0x40BF03FC\",\"Repeat\":0}} As you can see above, \"DataLSB\" are easier to decode than \"Data\" . The third byte contains the command, and the fourth byte is the third with all bits reversed. Example of HVAC message: MQT: tele/tasmota/IR1/RESULT = {\"IrReceived\":{\"Protocol\":\"MITSUBISHI_HEAVY_152\",\"Bits\":152,\"Data\":\"0xAD513CE51A08F705FA02FDC03F08F700FF807F\",\"Repeat\":0,\"IRHVAC\":{\"Vendor\":\"MITSUBISHI_HEAVY_152\",\"Model\":-1,\"Power\":\"on\",\"Mode\":\"auto\",\"Celsius\":\"on\",\"Temp\":22,\"FanSpeed\":\"medium\",\"SwingV\":\"off\",\"SwingH\":\"off\",\"Quiet\":\"off\",\"Turbo\":\"off\",\"Econo\":\"off\",\"Light\":\"off\",\"Filter\":\"off\",\"Clean\":\"off\",\"Beep\":\"off\",\"Sleep\":-1}}} MQT: tele/tasmota/IR1/RESULT = {\"IrReceived\":{\"Protocol\":\"COOLIX\",\"Bits\":24,\"Data\":\"0xB25F78\",\"DataLSB\":\"0x4DFA1E\",\"Repeat\":0,\"IRHVAC\":{\"Vendor\":\"COOLIX\",\"Model\":-1,\"Power\":\"on\",\"Mode\":\"auto\",\"Celsius\":\"on\",\"Temp\":22,\"FanSpeed\":\"medium\",\"SwingV\":\"off\",\"SwingH\":\"off\",\"Quiet\":\"off\",\"Turbo\":\"off\",\"Econo\":\"off\",\"Light\":\"on\",\"Filter\":\"off\",\"Clean\":\"on\",\"Beep\":\"off\",\"Sleep\":-1}}} RSL: RESULT = {\"Time\":\"2019-09-09T21:52:35\",\"IrReceived\":{\"Protocol\":\"PANASONIC_AC\",\"Bits\":216,\"Data\":\"0x0220E004000000060220E00400032C805F06000EE0000081000089\",\"Repeat\":0,\"IRHVAC\":{\"Vendor\":\"PANASONIC_AC\",\"Model\":2,\"Power\":\"on\",\"Mode\":\"auto\",\"Celsius\":\"on\",\"Temp\":22,\"FanSpeed\":\"medium\",\"SwingV\":\"auto\",\"SwingH\":\"middle\",\"Quiet\":\"off\",\"Turbo\":\"off\",\"Econo\":\"off\",\"Light\":\"off\",\"Filter\":\"off\",\"Clean\":\"off\",\"Beep\":\"off\",\"Sleep\":-1}}}","title":"IR Communication"},{"location":"Tasmota-IR/#sending-ir-commands","text":"Send an IR remote control code as a decimal or hexadecimal string in a JSON payload. In order to send IR data, you must configure one of the free device GPIO as IRsend (8) . Neither GPIO01 nor GPIO03 can be used. Command Parameters IRsend <x> <x> [ optional ] = number of times the IR message is sent. If not specified or 0..1 , the message is sent only once (i.e., not repeated) (default) >1 = emulate a long-press on the remote control, sending the message <x> times, or sending a repeat message for specific protocols (like NEC) {\"Protocol\":\"<value>\",\"Bits\":<value>,\"Data\":<value>,\"DataLSB\":<value>,\"Repeat\":<value>} \"Protocol\" or \"Vendor\" (select one of the following): RC5, RC6, NEC, SONY, PANASONIC, JVC, SAMSUNG, WHYNTER, AIWA_RC_T501, LG, MITSUBISHI, DISH, SHARP, DENON, SHERWOOD, RCMM, SANYO_LC7461, RC5X, NEC (non-strict), NIKAI, MAGIQUEST, LASERTAG, CARRIER_AC, MITSUBISHI2, HITACHI_AC1, HITACHI_AC2, GICABLE, LUTRON, PIONEER, LG2, SAMSUNG36, LEGOPF, INAX, DAIKIN152 \"Bits\":1..64 = required number of data bits for PANASONIC protocol this parameter is the the address, not the number of bits \"Data\":0x1..0xFFFFFFFFFFFFFFFF = data frame as 64 bit hexadecimal. e.g., IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":0x8166817E} Or \"DataLSB\":0x1..0xFFFFFFFFFFFFFFFF = data frame as 64 bit hexadecimal with LSB (each byte with bits reversed). e.g., IRsend {\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":0x8166817E} DataLSB comes handy with LSB-first (Least Significant Bit First) protocols like NEC, and makes decoding/encoding easier. \"Repeat\":0..<x> if 0 send the frame once, if >0 simulates a long press; Note: \"Repeat\":1 sends the message twice. Alternatively, you can send IR remote control codes using RAW command encoding . See also","title":"Sending IR Commands"},{"location":"Tasmota-IR/#sending-irhvac-commands","text":"Command Parameters IRhvac Send HVAC IR remote control code as JSON payload IRhvac {\"Vendor\":\"Mitsubishi_Heavy_152\", \"Power\":\"On\",\"Mode\":\"Hot\",\"FanSpeed\":3,\"Temp\":22.5} \"Protocol\" or \"Vendor\" (select one of the following): COOLIX, DAIKIN, KELVINATOR, MITSUBISHI_AC, GREE, ARGO, TROTEC, TOSHIBA_AC, FUJITSU_AC, MIDEA, HAIER_AC, HITACHI_AC, HAIER_AC_YRW02, WHIRLPOOL_AC, SAMSUNG_AC, ELECTRA_AC, PANASONIC_AC, DAIKIN2, VESTEL_AC, TECO, TCL112AC, MITSUBISHI_HEAVY_88, MITSUBISHI_HEAVY_152, DAIKIN216, SHARP_AC, GOODWEATHER, DAIKIN160, NEOCLIMA, DAIKIN176, DAIKIN128 \"Model\": Some HVAC have variants in protocols, this field allows to specify the variant, see detailed list . Fujitsu_AC : ARRAH2E\\|ARDB1 Panasonic_AC : LKE\\|NKE\\|DKE\\|JKE\\|CKP\\|RKR Whirlpool_AC : DG11J13A\\|DG11J104\\|DG11J1-04\\|DG11J191 \"Power\" : On, Yes, True, 1 Off, No, False, 0 \"Mode\" : Off, Stop Auto, Automatic Cool, Cooling Heat, Heating Dry, Drying, Dehumidify Fan, Fanonly, Fan_Only \"FanSpeed\" : Auto, Automatic Min, Minimum, Lowest, 1 Low, 2 Med, Medium, Mid, 3 High, Hi, 4 Max, Maximum, Highest, 5 \"SwingV\" : vertical swing of Fan Auto, Automatic, On, Swing Off, Stop Min, Minimum, Lowest, Bottom, Down Low Mid, Middle, Med, Medium, Centre, Center High, Hi Highest, Max, Maximum, Top, Up \"SwingH\" : horizontal swing of Fan Auto, Automatic, On, Swing Off, Stop LeftMax, Left Max, MaxLeft, Max Left, FarLeft, Far Left Left Mid, Middle, Med, Medium, Centre, Center Right RightMax, Right Max, MaxRight, Max Right, FarRight, Far Right Wide \"Celsius\" : temperature is in Celsius ( \"On\" ) of Farenheit ( \"Off\" ) \"Temp\" : Temperature, can be float if supported by protocol \"Quiet\" : Quiet mode ( \"On\" / \"Off\" ) \"Turbo\" : Turbo mode ( \"On\" / \"Off\" ) \"Econo\" : Econo mode ( \"On\" / \"Off\" ) \"Light\" : Light ( \"On\" / \"Off\" ) \"Filter\" : Filter active ( \"On\" / \"Off\" ) \"Clean\" : Clean mode ( \"On\" / \"Off\" ) \"Beep\" : Beep active ( \"On\" / \"Off\" ) \"Sleep\" : Timer in seconds","title":"Sending IRHVAC Commands"},{"location":"Tasmota-IR/#receiving-ir-commands","text":"If you have an IR receiver, a message will be logged each time an IR message is seen. IR driver will try to decode the message against all supported protocols. If unrecognized, the \"Protocol\":\"UNKNOWN\" will be shown. In this case, the \"Data\" field contains a hash of the received message. The hash can't be used to send the a message, but the same hash will be produced by the same message. An inexpensive IR sensor such as a TSOP1838 can be connected to a device running Tasmota. Configure a free device GPIO as 'IRrecv (51)'. When Tasmota receives an IR message, the data portion of the payload has the same format as the IRsend parameter. {\"IrReceived\":{\"Protocol\":\"<value>\",\"Bits\":<value>,\"Data\":<value>}} This JSON payload data can be used in a rule such as: ON IrReceived#Data=<value> DO <command> ENDON If the data is received on an unknown protocol use SetOption58 1 . See here . Examples: Pioneer Vol+ MQT: tele/tasmota/IR1/RESULT = {\"IrReceived\":{\"Protocol\":\"PIONEER\",\"Bits\":64,\"Data\":\"0xA55A50AFA55A50AF\",\"DataLSB\":\"0xA55A0AF5A55A0AF5\",\"Repeat\":0}} Pioneer Vol- tele/tasmota/IR1/RESULT = {\"IrReceived\":{\"Protocol\":\"PIONEER\",\"Bits\":64,\"Data\":\"0xA55AD02FA55AD02F\",\"DataLSB\":\"0xA55A0BF4A55A0BF4\",\"Repeat\":0}} Toshiba (NEC): Channel 1 MQT: tele/tasmota/IR1/RESULT = {\"IrReceived\":{\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x02FD807F\",\"DataLSB\":\"0x40BF01FE\",\"Repeat\":0}} Toshiba (NEC): Channel 2 MQT: tele/tasmota/IR1/RESULT = {\"IrReceived\":{\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x02FD40BF\",\"DataLSB\":\"0x40BF02FD\",\"Repeat\":0}} Toshiba (NEC): Channel 3 MQT: tele/tasmota/IR1/RESULT = {\"IrReceived\":{\"Protocol\":\"NEC\",\"Bits\":32,\"Data\":\"0x02FDC03F\",\"DataLSB\":\"0x40BF03FC\",\"Repeat\":0}} As you can see above, \"DataLSB\" are easier to decode than \"Data\" . The third byte contains the command, and the fourth byte is the third with all bits reversed. Example of HVAC message: MQT: tele/tasmota/IR1/RESULT = {\"IrReceived\":{\"Protocol\":\"MITSUBISHI_HEAVY_152\",\"Bits\":152,\"Data\":\"0xAD513CE51A08F705FA02FDC03F08F700FF807F\",\"Repeat\":0,\"IRHVAC\":{\"Vendor\":\"MITSUBISHI_HEAVY_152\",\"Model\":-1,\"Power\":\"on\",\"Mode\":\"auto\",\"Celsius\":\"on\",\"Temp\":22,\"FanSpeed\":\"medium\",\"SwingV\":\"off\",\"SwingH\":\"off\",\"Quiet\":\"off\",\"Turbo\":\"off\",\"Econo\":\"off\",\"Light\":\"off\",\"Filter\":\"off\",\"Clean\":\"off\",\"Beep\":\"off\",\"Sleep\":-1}}} MQT: tele/tasmota/IR1/RESULT = {\"IrReceived\":{\"Protocol\":\"COOLIX\",\"Bits\":24,\"Data\":\"0xB25F78\",\"DataLSB\":\"0x4DFA1E\",\"Repeat\":0,\"IRHVAC\":{\"Vendor\":\"COOLIX\",\"Model\":-1,\"Power\":\"on\",\"Mode\":\"auto\",\"Celsius\":\"on\",\"Temp\":22,\"FanSpeed\":\"medium\",\"SwingV\":\"off\",\"SwingH\":\"off\",\"Quiet\":\"off\",\"Turbo\":\"off\",\"Econo\":\"off\",\"Light\":\"on\",\"Filter\":\"off\",\"Clean\":\"on\",\"Beep\":\"off\",\"Sleep\":-1}}} RSL: RESULT = {\"Time\":\"2019-09-09T21:52:35\",\"IrReceived\":{\"Protocol\":\"PANASONIC_AC\",\"Bits\":216,\"Data\":\"0x0220E004000000060220E00400032C805F06000EE0000081000089\",\"Repeat\":0,\"IRHVAC\":{\"Vendor\":\"PANASONIC_AC\",\"Model\":2,\"Power\":\"on\",\"Mode\":\"auto\",\"Celsius\":\"on\",\"Temp\":22,\"FanSpeed\":\"medium\",\"SwingV\":\"auto\",\"SwingH\":\"middle\",\"Quiet\":\"off\",\"Turbo\":\"off\",\"Econo\":\"off\",\"Light\":\"off\",\"Filter\":\"off\",\"Clean\":\"off\",\"Beep\":\"off\",\"Sleep\":-1}}}","title":"Receiving IR Commands"},{"location":"TasmotaSlave/","text":"It is possible to amend your existing Arduino Uno / Mini / Nano project to interface with a Tasmota powered ESP8266/ESP8285 generic development boards such as the Wemos D1 or NodeMCU branded hardware boards. The creation of a slave driver interface implemented since Tasmota 7.0.0.2 enables this possibility. !> This feature is not included in precompiled binaries. To use it you must compile your build . Add the following to user_config_override.h : #ifndef USE_TASMOTA_SLAVE #define USE_TASMOTA_SLAVE // Enable the driver #endif #ifndef USE_TASMOTA_SLAVE_FLASH_SPEED #define USE_TASMOTA_SLAVE_FLASH_SPEED 57600 // Configure the baud rate of the bootloader #endif #ifndef USE_TASMOTA_SLAVE_SERIAL_SPEED 57600 #define USE_TASMOTA_SLAVE_SERIAL_SPEED 57600 // Configure the baud rate at which the slave microcontroller will be interfacing to Tasmota #endif Please note that the USE_TASMOTA_SLAVE_FLASH_SPEED will depend on the variant of Arduino Uno/Mini/Nano board you are using - The general observation is that the 3.3V devices usually run at 57600 whereas the 5V devices usually run on 115200 but this is provided for guidance only as it has been found that some boards will not necessarily adhere to this. The main driving factor behind the baud rate is the crystal oscillator on the board which is usually 8Mhz for 3.3V variants and 16Mhz for 5V variants - hence 57600 being 1/2 of 115200. It should also be noted that this option is only really applicable if you're actually using an Arduino UNO/Mini/Nano as a slave device and you want to be able to update the firmware on the Arduino OTA via the Tasmota Web UI. If you are using another type of microcontroller, obviously the OTA update functionality will not work (for now, until support is added for other microcontrollers). But if you are able to program the device manually there is no reason why you cannot use any microcontroller or development board as a slave to your Tasmota powered ESP8266/8285 hardware. Once you have compiled your own variant with the correct settings and flashed the self-compiled binary to your Tasmota device it is time to make the necessary configuration within Tasmota. Configuring Tasmota to use the TasmotaSlave functionality ~ The communication interface between Tasmota and your slave micro-controller will be over serial communication. To make this possible you will need to configure two of the GPIO pins to Slave TX and Slave RX respectively. In addition to this you also need to define the GPIO which will be used to pull the reset pin of your slave microcontroller down to GND or up to 3.3V, so either Slave RST for normal reset behaviour (active low) or Slave RSTi for inverted reset behaviour (active high) As mentioned above it is possible to connect any microcontroller of your choice but for the purpose of this article, only the implementation of an Arduino Pro Mini (3.3V) will be covered. Getting things wired up ~ With Tasmota GPIO configuration provided above you may now proceed to make the necessary electrical connections between the ESP8266/ESP8285 and your slave device, for example: ESP8266 Arduino Pro Mini (3.3V) VCC VCC GND GND D2 (GPIO4) RX (0) D1 (GPIO5) TX (1) D4 (GPIO2) Reset (RST) So to visualize the above: Please verify your specific board's pin naming as they are not always exactly the same depending on where they came from! Compiling a test sketch for the slave ~ The TasmotaSlave driver requires your slave to operate within specific parameters allowed by the driver itself so head over to the TasmotaSlave Library and install the library in your local Arduino development environment. Once installed you should be able to access the examples from the menu system: Make sure you have the correct board and speed selected: Now that everything is set, it's time to export the compiled binary by selecting it from the Arduino menu: Once completed head over to the known folder you chose in previous steps and locate the .hex file which should be in the same folder as where your sketch was originally saved to. You will most likely see a file listing like this: You are interested in Blink.ino.eightanaloginputs.hex and can ignore the one which has bootloader as part of the file name since the Arduino Pro Mini already has the bootloader flashed. Take note of the location and name of this file as you will need it in the next step to upload the compiled file to your slave device. Uploading a new hex file to your slave device ~ If you are using an Arduino Pro Mini as is the case in this example you would have created a .hex file in the previous step. This file can be flashed directly to the Arduino Pro Mini via the Tasmota Web UI. Navigate to the Firmware Upgrade page where you would normally upload a new binary file to upgrade Tasmota. The same method is used to upload a HEX file to the slave device. Tasmota will automatically decide where it will flash the upload based on whether you're uploading a .bin file or a .hex file. Tasmota will prompt you for the firmware file you wish to upload - You need to navigate to the previously known location folder you chose in earlier steps and select the .hex file previously identified: After selecting the hex file you may proceed to click the Start Upgrade button: The hex file will upload to Tasmota and Tasmota will flash the new slave firmware onto the Arduino Pro Mini and present you with the following web page: After the device completes a restart you should now have an Arduino Pro Mini running as a slave where the blink is controlled from Tasmota's internal one-second callback.","title":"TasmotaSlave"},{"location":"TasmotaSlave/#configuring-tasmota-to-use-the-tasmotaslave-functionality","text":"The communication interface between Tasmota and your slave micro-controller will be over serial communication. To make this possible you will need to configure two of the GPIO pins to Slave TX and Slave RX respectively. In addition to this you also need to define the GPIO which will be used to pull the reset pin of your slave microcontroller down to GND or up to 3.3V, so either Slave RST for normal reset behaviour (active low) or Slave RSTi for inverted reset behaviour (active high) As mentioned above it is possible to connect any microcontroller of your choice but for the purpose of this article, only the implementation of an Arduino Pro Mini (3.3V) will be covered.","title":"Configuring Tasmota to use the TasmotaSlave functionality"},{"location":"TasmotaSlave/#getting-things-wired-up","text":"With Tasmota GPIO configuration provided above you may now proceed to make the necessary electrical connections between the ESP8266/ESP8285 and your slave device, for example: ESP8266 Arduino Pro Mini (3.3V) VCC VCC GND GND D2 (GPIO4) RX (0) D1 (GPIO5) TX (1) D4 (GPIO2) Reset (RST) So to visualize the above: Please verify your specific board's pin naming as they are not always exactly the same depending on where they came from!","title":"Getting things wired up"},{"location":"TasmotaSlave/#compiling-a-test-sketch-for-the-slave","text":"The TasmotaSlave driver requires your slave to operate within specific parameters allowed by the driver itself so head over to the TasmotaSlave Library and install the library in your local Arduino development environment. Once installed you should be able to access the examples from the menu system: Make sure you have the correct board and speed selected: Now that everything is set, it's time to export the compiled binary by selecting it from the Arduino menu: Once completed head over to the known folder you chose in previous steps and locate the .hex file which should be in the same folder as where your sketch was originally saved to. You will most likely see a file listing like this: You are interested in Blink.ino.eightanaloginputs.hex and can ignore the one which has bootloader as part of the file name since the Arduino Pro Mini already has the bootloader flashed. Take note of the location and name of this file as you will need it in the next step to upload the compiled file to your slave device.","title":"Compiling a test sketch for the slave"},{"location":"TasmotaSlave/#uploading-a-new-hex-file-to-your-slave-device","text":"If you are using an Arduino Pro Mini as is the case in this example you would have created a .hex file in the previous step. This file can be flashed directly to the Arduino Pro Mini via the Tasmota Web UI. Navigate to the Firmware Upgrade page where you would normally upload a new binary file to upgrade Tasmota. The same method is used to upload a HEX file to the slave device. Tasmota will automatically decide where it will flash the upload based on whether you're uploading a .bin file or a .hex file. Tasmota will prompt you for the firmware file you wish to upload - You need to navigate to the previously known location folder you chose in earlier steps and select the .hex file previously identified: After selecting the hex file you may proceed to click the Start Upgrade button: The hex file will upload to Tasmota and Tasmota will flash the new slave firmware onto the Arduino Pro Mini and present you with the following web page: After the device completes a restart you should now have an Arduino Pro Mini running as a slave where the blink is controlled from Tasmota's internal one-second callback.","title":"Uploading a new hex file to your slave device"},{"location":"Templates/","text":"Template is a definition of a device and how its GPIOs are assigned. Templates provide an easy way for you to create, modify and share configurations for various devices that have features supported in Tasmota. To provide easy processing by Tasmota a template is written as a JSON string and could look like this: { \"NAME\" : \"UserModule1\" , \"GPIO\" :[ 17 , 148 , 29 , 149 , 7 , 255 , 255 , 255 , 138 , 255 , 139 , 255 , 255 ], \"FLAG\" : 0 , \"BASE\" : 18 } Tip Tasmota Device Templates Repository has a complete list of supported devices. We encourage everyone who creates a template for a new unknown device to submit it using Add New Template form . How to Use ~ Go to Configuration - Configure Template ... ... and you'll end up looking at this screen. Time to create your template. Creating Your Template ~ Change the template name (also defines the name for the module). Select a module to BASE your template on . If you're not sure, Module 18 is the best choice. In this example the device is based on Blitzwolf SHP (45) module. Configure the components assigned to the GPIOs to match your device. If you do not know what pins your device uses, read about the new device configuration procedure to determine the correct pin assignments. Any unused GPIO that has cannot have a peripheral connected should be set to None (0) . In our example the device has no exposed GPIO's so the unused ones are set to 0 compared to the original BlitzWolf module. GPIOs that can have peripherals connected to (exposed GPIOs) should be set to User (255) . This allows future configuration through the Configure Module dialog without the need to create a new template. [!EXAMPLE] Take Sonoff TH as one: It has a jack connected to GPIO4 that allows a user to plug in a sensor. Assigning GPIO4 as 255 allows a Template to have correct GPIOs for this device even if nothing is plugged in. But, when a user decides to connect a sensor using the jack, GPIO4 can be set to the type of sensor through the Configure Module page. Click on Save and you'll see this message Finally, the device will reboot with the new template name Exporting Your Template ~ Now that you've set up your previously unsupported device in Tasmota it is time to share the knowledge: Check that Module 0 is selected in the Configuration - Configure Module menu. Open up Console and issue command Template which will output a string with the configuration of your currently active template. Our example gives the following: MQT: stat/tasmota/RESULT = { \"NAME\" : \"RGB Smart Plug\" , \"GPIO\" :[ 37 , 0 , 39 , 0 , 38 , 134 , 0 , 0 , 131 , 17 , 132 , 21 , 0 ], \"FLAG\" : 0 , \"BASE\" : 45 } Copy the string {\"NAME\":\"RGB Smart Plug\",\"GPIO\":[37,0,39,0,38,134,0,0,131,17,132,21,0],\"FLAG\":0,\"BASE\":45} and share it on the Tasmota Device Templates Repository . Importing Templates ~ Go to Configuration - Configure Other When there: 1. Paste the template string into the Template field 2. Make sure you check Activate 3. Click on Save . The device will reboot with a name reflecting your template name and Module 0 selected which has your new template stored. Commands ~ A user provided template can be stored in Tasmota using the Template command. It has the following parameters. Parameter Description Show current Template 0 Create template from active module 1..71 Create template from a supported module { ... } Store template written in a JSON string Template {\"NAME\":\"UserModule1\",\"GPIO\":[17,148,29,149,7,255,255,255,138,255,139,255,255],\"FLAG\":0,\"BASE\":18} stores a complete template based on the Generic module Template {\"NAME\":\"AnotherModuleName\"} updates the name of a stored template Template {\"FLAG\":0} changes FLAG value Template {\"BASE\":18} updates the base of a stored template to Generic After setting a template in command line it is necessary to issue Module 0 command if the device doesn't reboot on its own. Merge Template with Module You can set up your device in module Configuration -> Configure Module and use command Template 255 to merge the settings of the Module with current template into a new Template named \"Merged\". Anatomy of a Template ~ Let's look again at our example template: {\"NAME\":\"UserModule1\",\"GPIO\":[17,148,29,149,7,255,255,255,138,255,139,255,255],\"FLAG\":0,\"BASE\":18} The four properties with UPPERCASE property names have the following functionality: Property name Property value description NAME Up to 14 characters for the Module name GPIO Up to 13 decimal numbers from 0 to 255 representing GPIO0 to GPIO5, GPIO09, GPIO10 and GPIO12 to GPIO16 FLAG 8 bit mask flag register BASE Module number of a hard-coded device to be used when device specific functionality is needed GPIO ~ GPIO order GPIO# |00| 01|02| 03|04| 05| 09| 10| 12| 13| 14| 15| 16| CODE [17,148,29,149,52,255,255,255,138,255,139,255,255] GPIO functionality The GPIO functionality numbers are the same as shown by command GPIOs . In addition code 255 is added to select a GPIO as user configurable via the GUI Configure Module menu. [!EXAMPLE] In our example the GPIO 00 data element is 17 which corresponds to the Button1 component, according to the following table. If you change that template element to 9 it would then be assigned as a Switch1 component instead. Components See Components for a complete list Google Sheet with the components by number or alphabetically. FLAG ~ Used to configure the ADC type. In most templates this should be set to 0 . FLAG Feature description 0 No features 1 Analog value 2 Temperature 3 Light 4 Button 5 Buttoni 15 User configured (same as GPIO 255 ) BASE ~ BASE is the starting module setup for the custom template. Some modules include special programming. If your device is similar to an existing built-in module it is best to use that as a starting point. When you're not sure which BASE module is suitable for your device use the Generic (18) module. A list of hard-coded devices can be found in Modules . [!EXAMPLE] In the RGB Smart Plug template we used the BlitzWolf SHP (45) module as BASE since the power monitoring circuitry is identical but GPIO00 and GPIO02 were changed and an unused GPIO04 was added to enable the RGB LED function. Using that specific module we took advantage of that module's calibrated power monitoring special programming which the Generic (18) module does not use.","title":"Templates"},{"location":"Templates/#how-to-use","text":"Go to Configuration - Configure Template ... ... and you'll end up looking at this screen. Time to create your template.","title":"How to Use"},{"location":"Templates/#creating-your-template","text":"Change the template name (also defines the name for the module). Select a module to BASE your template on . If you're not sure, Module 18 is the best choice. In this example the device is based on Blitzwolf SHP (45) module. Configure the components assigned to the GPIOs to match your device. If you do not know what pins your device uses, read about the new device configuration procedure to determine the correct pin assignments. Any unused GPIO that has cannot have a peripheral connected should be set to None (0) . In our example the device has no exposed GPIO's so the unused ones are set to 0 compared to the original BlitzWolf module. GPIOs that can have peripherals connected to (exposed GPIOs) should be set to User (255) . This allows future configuration through the Configure Module dialog without the need to create a new template. [!EXAMPLE] Take Sonoff TH as one: It has a jack connected to GPIO4 that allows a user to plug in a sensor. Assigning GPIO4 as 255 allows a Template to have correct GPIOs for this device even if nothing is plugged in. But, when a user decides to connect a sensor using the jack, GPIO4 can be set to the type of sensor through the Configure Module page. Click on Save and you'll see this message Finally, the device will reboot with the new template name","title":"Creating Your Template"},{"location":"Templates/#exporting-your-template","text":"Now that you've set up your previously unsupported device in Tasmota it is time to share the knowledge: Check that Module 0 is selected in the Configuration - Configure Module menu. Open up Console and issue command Template which will output a string with the configuration of your currently active template. Our example gives the following: MQT: stat/tasmota/RESULT = { \"NAME\" : \"RGB Smart Plug\" , \"GPIO\" :[ 37 , 0 , 39 , 0 , 38 , 134 , 0 , 0 , 131 , 17 , 132 , 21 , 0 ], \"FLAG\" : 0 , \"BASE\" : 45 } Copy the string {\"NAME\":\"RGB Smart Plug\",\"GPIO\":[37,0,39,0,38,134,0,0,131,17,132,21,0],\"FLAG\":0,\"BASE\":45} and share it on the Tasmota Device Templates Repository .","title":"Exporting Your Template"},{"location":"Templates/#importing-templates","text":"Go to Configuration - Configure Other When there: 1. Paste the template string into the Template field 2. Make sure you check Activate 3. Click on Save . The device will reboot with a name reflecting your template name and Module 0 selected which has your new template stored.","title":"Importing Templates"},{"location":"Templates/#commands","text":"A user provided template can be stored in Tasmota using the Template command. It has the following parameters. Parameter Description Show current Template 0 Create template from active module 1..71 Create template from a supported module { ... } Store template written in a JSON string Template {\"NAME\":\"UserModule1\",\"GPIO\":[17,148,29,149,7,255,255,255,138,255,139,255,255],\"FLAG\":0,\"BASE\":18} stores a complete template based on the Generic module Template {\"NAME\":\"AnotherModuleName\"} updates the name of a stored template Template {\"FLAG\":0} changes FLAG value Template {\"BASE\":18} updates the base of a stored template to Generic After setting a template in command line it is necessary to issue Module 0 command if the device doesn't reboot on its own.","title":"Commands"},{"location":"Templates/#anatomy-of-a-template","text":"Let's look again at our example template: {\"NAME\":\"UserModule1\",\"GPIO\":[17,148,29,149,7,255,255,255,138,255,139,255,255],\"FLAG\":0,\"BASE\":18} The four properties with UPPERCASE property names have the following functionality: Property name Property value description NAME Up to 14 characters for the Module name GPIO Up to 13 decimal numbers from 0 to 255 representing GPIO0 to GPIO5, GPIO09, GPIO10 and GPIO12 to GPIO16 FLAG 8 bit mask flag register BASE Module number of a hard-coded device to be used when device specific functionality is needed","title":"Anatomy of a Template"},{"location":"Templates/#gpio","text":"","title":"GPIO"},{"location":"Templates/#flag","text":"Used to configure the ADC type. In most templates this should be set to 0 . FLAG Feature description 0 No features 1 Analog value 2 Temperature 3 Light 4 Button 5 Buttoni 15 User configured (same as GPIO 255 )","title":"FLAG"},{"location":"Templates/#base","text":"BASE is the starting module setup for the custom template. Some modules include special programming. If your device is similar to an existing built-in module it is best to use that as a starting point. When you're not sure which BASE module is suitable for your device use the Generic (18) module. A list of hard-coded devices can be found in Modules . [!EXAMPLE] In the RGB Smart Plug template we used the BlitzWolf SHP (45) module as BASE since the power monitoring circuitry is identical but GPIO00 and GPIO02 were changed and an unused GPIO04 was added to enable the RGB LED function. Using that specific module we took advantage of that module's calibrated power monitoring special programming which the Generic (18) module does not use.","title":"BASE"},{"location":"Theo%27s-Tasmota-Tips/","text":"20180723 - Release binary corruption ~ I found a Travis compiler error which results in corrupt release binaries as many users have noticed when they tried to use the provided images until 20180723. It seems Travis compiles using platformio on Linux and their xtensa cross-compiler does not correctly byte align 8-bit, 16-bit and 32-bit values. The newly provided images for release 6.1.1 and 5.14.0 are xtensa cross-compiled on Windows and proven the work correctly. 20180110 - My preferred Tasmota development environment ~ After years of using the Arduino IDE I started using Visual Studio Code with integrated PlatformIO some months ago and I wonder what took me so long. It's great in editing as you may have noticed as changing global variables is a breeze. Using my latest OtaMagic integration makes it even more friendly. I only miss the Arduino IDE integrated ESP Exception Decoder used for yet another Exception analysis. 20180103 - Tasmota is ready for esp8266/Arduino version 2.4.0 ~ Tasmota is based on esp8266/Arduino. A few days ago esp8266/Arduino version 2.4.0 was released. Tasmota and it's supporting libraries as available in the lib folder will compile and run just fine. Among many fixes this version also uses more flash space which makes it almost impossible to easily OTA update Tasmota. A solution was developed months ago and involves an intermediate step using the tasmota-minimal.bin image available in all latest releases. Now that this step has almost become mandatory it opens up the possibility to add some more functionality to Tasmota in the future. NOTE : Selecting a different esp8266/Arduino version in (Visual Studio (Code)) PlatformIO is easy using the following defines in file platformio.ini: platform = espressif8266 @1.5.0 ; esp8266 / Arduino version 2.3.0 platform = espressif8266 @1.6.0 ; esp8266 / Arduino version 2.4.0 ( + 22 k code ) 20170714 - Tasmota needs compile Flash Mode option DOUT on all devices ~ An increasing number of devices are using the ESP8285. As this chip only supports a subset of hardware connections to its inbuilt 1MB flash the firmware needs to be compiled with Flash Mode option set for DOUT. This is documented in the Wiki and the platformio.ini file in the repository. As this compile option works for the ESP8266 \"legacy\" chip too, I only provide released firmware compiled with Flash Mode DOUT which runs fine on all released hardware like Sonoff, Wemos etc. See also #598 . Indications of selecting the wrong Flash Mode compile option (like DIO or QIO) on ESP8285 is a dead device while uploading just went fine #683 . 20170619 - Configuration settings save locations in flash ~ Configuration settings are saved in flash. Over time different areas of flash have been used as can be seen in the picture below. To reduce flash wear I started to use a number of rotating flash pages with version 5.2. To still be able to use maximum program size during OTA or webpage upgrades I copy the latest config to the EEPROM area just before the upgrade starts. 20170425 - Tasmota version 5.x and up need linker script 1M with No SPIFFS ~ Starting with version 5.x a new linker script is made available allowing for 32k more code space. See Wiki how to implement it in your Arduino or platformIO IDE. 20170403 - Tasmota supported libraries in repository ~ All Tasmota external libraries are available in the lib folder of the repository. To save as much code space as possible only these library versions are supported by Tasmota. See Wiki for individual library installation. 20170124 - Tasmota spin-off from Sonoff-MQTT-OTA-Arduino ~ The goal of Tasmota (Tasmota for short) is to provide one pre-compiled MQTT enabled, \"Over the Air\" firmware with support for as much (iTead Sonoff) devices as possible without the need to edit a user_config.h file. Configuration settings can be changed online without re-compilation. All this within the tight code space that 1MB flash allows.","title":"Theo's Tasmota Tips"},{"location":"Theo%27s-Tasmota-Tips/#20180723-release-binary-corruption","text":"I found a Travis compiler error which results in corrupt release binaries as many users have noticed when they tried to use the provided images until 20180723. It seems Travis compiles using platformio on Linux and their xtensa cross-compiler does not correctly byte align 8-bit, 16-bit and 32-bit values. The newly provided images for release 6.1.1 and 5.14.0 are xtensa cross-compiled on Windows and proven the work correctly.","title":"20180723 - Release binary corruption"},{"location":"Theo%27s-Tasmota-Tips/#20180110-my-preferred-tasmota-development-environment","text":"After years of using the Arduino IDE I started using Visual Studio Code with integrated PlatformIO some months ago and I wonder what took me so long. It's great in editing as you may have noticed as changing global variables is a breeze. Using my latest OtaMagic integration makes it even more friendly. I only miss the Arduino IDE integrated ESP Exception Decoder used for yet another Exception analysis.","title":"20180110 - My preferred Tasmota development environment"},{"location":"Theo%27s-Tasmota-Tips/#20180103-tasmota-is-ready-for-esp8266arduino-version-240","text":"Tasmota is based on esp8266/Arduino. A few days ago esp8266/Arduino version 2.4.0 was released. Tasmota and it's supporting libraries as available in the lib folder will compile and run just fine. Among many fixes this version also uses more flash space which makes it almost impossible to easily OTA update Tasmota. A solution was developed months ago and involves an intermediate step using the tasmota-minimal.bin image available in all latest releases. Now that this step has almost become mandatory it opens up the possibility to add some more functionality to Tasmota in the future. NOTE : Selecting a different esp8266/Arduino version in (Visual Studio (Code)) PlatformIO is easy using the following defines in file platformio.ini: platform = espressif8266 @1.5.0 ; esp8266 / Arduino version 2.3.0 platform = espressif8266 @1.6.0 ; esp8266 / Arduino version 2.4.0 ( + 22 k code )","title":"20180103 - Tasmota is ready for esp8266/Arduino version 2.4.0"},{"location":"Theo%27s-Tasmota-Tips/#20170714-tasmota-needs-compile-flash-mode-option-dout-on-all-devices","text":"An increasing number of devices are using the ESP8285. As this chip only supports a subset of hardware connections to its inbuilt 1MB flash the firmware needs to be compiled with Flash Mode option set for DOUT. This is documented in the Wiki and the platformio.ini file in the repository. As this compile option works for the ESP8266 \"legacy\" chip too, I only provide released firmware compiled with Flash Mode DOUT which runs fine on all released hardware like Sonoff, Wemos etc. See also #598 . Indications of selecting the wrong Flash Mode compile option (like DIO or QIO) on ESP8285 is a dead device while uploading just went fine #683 .","title":"20170714 - Tasmota needs compile Flash Mode option DOUT on all devices"},{"location":"Theo%27s-Tasmota-Tips/#20170619-configuration-settings-save-locations-in-flash","text":"Configuration settings are saved in flash. Over time different areas of flash have been used as can be seen in the picture below. To reduce flash wear I started to use a number of rotating flash pages with version 5.2. To still be able to use maximum program size during OTA or webpage upgrades I copy the latest config to the EEPROM area just before the upgrade starts.","title":"20170619 - Configuration settings save locations in flash"},{"location":"Theo%27s-Tasmota-Tips/#20170425-tasmota-version-5x-and-up-need-linker-script-1m-with-no-spiffs","text":"Starting with version 5.x a new linker script is made available allowing for 32k more code space. See Wiki how to implement it in your Arduino or platformIO IDE.","title":"20170425 - Tasmota version 5.x and up need linker script 1M with No SPIFFS"},{"location":"Theo%27s-Tasmota-Tips/#20170403-tasmota-supported-libraries-in-repository","text":"All Tasmota external libraries are available in the lib folder of the repository. To save as much code space as possible only these library versions are supported by Tasmota. See Wiki for individual library installation.","title":"20170403 - Tasmota supported libraries in repository"},{"location":"Theo%27s-Tasmota-Tips/#20170124-tasmota-spin-off-from-sonoff-mqtt-ota-arduino","text":"The goal of Tasmota (Tasmota for short) is to provide one pre-compiled MQTT enabled, \"Over the Air\" firmware with support for as much (iTead Sonoff) devices as possible without the need to edit a user_config.h file. Configuration settings can be changed online without re-compilation. All this within the tight code space that 1MB flash allows.","title":"20170124 - Tasmota spin-off from Sonoff-MQTT-OTA-Arduino"},{"location":"Thermal-considerations/","text":"Even though LEDs consume far less energy than incandescent bulbs, these devices contain more complex circuitries and sometimes they still produce more heat than they can handle. The produced heat is proportional to the LED intensities, and if it builds up faster than how it dissipates from the chassis, then the temperature will rise. The circuitries usually (but not necessarily ) contain some last-resort countermeasure that shuts down the device when it is critically overheated, but it shouldn't be relied upon. When testing the device for the first time, especially at higher light intensities, monitor its temperature for some time , like for at least half an hour, and if it rises rapidly, then please consider: Reducing the overall brightness Using only one of the light sources (i.e. either the color LEDs, or the high-power white ones) For such a test use an electrically safe lamp in which you can access the bulb, and which you can easily disconnect from the mains anytime. For measuring the temperature the best tool is an IR thermometer: aim it at the heatsink part of the chassis from a direction perpendicular to it, from such a distance that its cone of sensitivity is fully on the chassis. If you choose to test the temperature by hand, then be prepared that it may be hot , so approach it slowly, and if you already feel its heat, then don't touch it . During this check please also consider that a bulb standing on your desk in a test socket has considerably better cooling than one in a closed armature right below your ceiling, so try to 'model' the operating conditions in which you plan to use the device. If you have found a solution that keeps the temperature stable, don't forget to configure a limit in your home automation system so you (or anyone else) won't accidentally set the device to overheating when it'll be already installed. Some of the devices' original firmwares do contain such software throttling, but as the thermal behaviour differs from one model to another, there is no generic way to apply the right amount of throttling that would be both required and enough for everyone, so \"your mileage may vary\". Technical background ~ Light bulb circuitries consist of 3 main stages: A small power supply unit that converts the 230V or 110V mains to approx. 20V for the LEDs and 3.3V for the controller. This is a small switching-mode power supply, but usually of a parsimonius design, so it's usually barely adequate for the average power requirement, and sometimes not enough for the maximum . The main problem is not the transformer, but the voltage regulators: they produce heat proportionally to the current that's drawn through them, and they aren't connected to the heatsink , so all their heat goes just into the air within the bulb. The controller module, usually a SoC that contains the CPU, memory, flash and wifi. It is a logic circuit, its heat production is negligible compared to the other stages. The LED circuitry, meaning the LEDs themselves and their driver chips, usually on a separate board. They produce a lot of heat, but they are always connected to the chassis via either thermal grease or thermally conductive glue. So the problems are: - Voltage regulators produce heat proportional to light intensity - Their thermal coupling to the chassis is terrible: via a huge air gap - The chassis is not an effective heatsink (for aesthetic reasons it can't be) - The overall system is designed for the average conditions and not for the maximum. Thus our goal is to limit the power consumption to such a level that the heat produced can be dissipated by the chassis heatsink, and the way to achieve this is throttling down the light intensity and/or limiting the switched-on time. Measured values ~ SYF05 (Fcmila/Sunyesmart) ~ At start: 23\u00b0C After 10 minutes: 40\u00b0C (warm) After 20 minutes: 48\u00b0C (hot) After 30 minutes: 53\u00b0C (barely touchable) After 40 minutes: 55\u00b0C At this point the thermal protection has shut the device down, and the local temperatures were: - Chassis: 55\u00b0C - RGB LED driver chip: 73\u00b0C - White LED driver chip: 76\u00b0C - Controller module: 76\u00b0C - Transformer: 85\u00b0C - Area around the voltage regulator: 91\u00b0C Sonoff B1 ~ At start: 26\u00b0C After 10 minutes: 33\u00b0C After 20 minutes: 40\u00b0C After 30 minutes: 44\u00b0C After 40 minutes: 47\u00b0C After 50 minutes: 48\u00b0C After 1 hour: 50\u00b0C The bulb was operational at this point, but I considered this temperature too high for sustained use.","title":"Thermal considerations"},{"location":"Thermal-considerations/#technical-background","text":"Light bulb circuitries consist of 3 main stages: A small power supply unit that converts the 230V or 110V mains to approx. 20V for the LEDs and 3.3V for the controller. This is a small switching-mode power supply, but usually of a parsimonius design, so it's usually barely adequate for the average power requirement, and sometimes not enough for the maximum . The main problem is not the transformer, but the voltage regulators: they produce heat proportionally to the current that's drawn through them, and they aren't connected to the heatsink , so all their heat goes just into the air within the bulb. The controller module, usually a SoC that contains the CPU, memory, flash and wifi. It is a logic circuit, its heat production is negligible compared to the other stages. The LED circuitry, meaning the LEDs themselves and their driver chips, usually on a separate board. They produce a lot of heat, but they are always connected to the chassis via either thermal grease or thermally conductive glue. So the problems are: - Voltage regulators produce heat proportional to light intensity - Their thermal coupling to the chassis is terrible: via a huge air gap - The chassis is not an effective heatsink (for aesthetic reasons it can't be) - The overall system is designed for the average conditions and not for the maximum. Thus our goal is to limit the power consumption to such a level that the heat produced can be dissipated by the chassis heatsink, and the way to achieve this is throttling down the light intensity and/or limiting the switched-on time.","title":"Technical background"},{"location":"Thermal-considerations/#measured-values","text":"","title":"Measured values"},{"location":"Thermal-considerations/#syf05-fcmilasunyesmart","text":"At start: 23\u00b0C After 10 minutes: 40\u00b0C (warm) After 20 minutes: 48\u00b0C (hot) After 30 minutes: 53\u00b0C (barely touchable) After 40 minutes: 55\u00b0C At this point the thermal protection has shut the device down, and the local temperatures were: - Chassis: 55\u00b0C - RGB LED driver chip: 73\u00b0C - White LED driver chip: 76\u00b0C - Controller module: 76\u00b0C - Transformer: 85\u00b0C - Area around the voltage regulator: 91\u00b0C","title":"SYF05 (Fcmila/Sunyesmart)"},{"location":"Thermal-considerations/#sonoff-b1","text":"At start: 26\u00b0C After 10 minutes: 33\u00b0C After 20 minutes: 40\u00b0C After 30 minutes: 44\u00b0C After 40 minutes: 47\u00b0C After 50 minutes: 48\u00b0C After 1 hour: 50\u00b0C The bulb was operational at this point, but I considered this temperature too high for sustained use.","title":"Sonoff B1"},{"location":"Time-Proportioned-Output-support/","text":"This extension adds a Time Proportioned Digital Output feature into the Tasmota software. The relay output on a Sonoff device provides (obviously) just on/off control. Often it is desirable to be able to get a value between off and on, for example 25% power. The conventional way to achieve this with devices such as electrical heaters or hot water radiators is to switch the device on for a period and then off for a period. This extension allows a required power value between 0 and 1 to be specified via MQTT and the code will automatically cycle the relay on/off to achieve this power. The s/w is configured with a Cycle Time that specifies the period. So for example if a power value of 0.25 is specified with a cycle time of 12 minutes then the relay will be on for 3 minutes and off for 9 minutes every 12 minute period. The s/w includes a safety mechanism where the maximum time expected between MQTT power updates is specified. If this time is exceeded with no value being received then the power will revert to a specified fallback value. To add the feature into the standard Tasmotta s/w (at least version 5.12.0 is required) then have a look at the timeprop_branch of the tasmota fork at https://github.com/colinl/Sonoff-Tasmota/tree/timeprop_branch . Pick up the three files from there, lib/ProcessControl/Timeprop.cpp and Timeprop.h (which are from this process-control repository ) and sonoff/xdrv_91_timeprop.ino and add them into your Tasmota sources. Instructions for setting it up and using it are in xdrv_91_timeprop.ino . The feature adds about 1.2k to the compiled code. Currently all configuration parameters must be setup at build time. If anyone wanted to add these to the MQTT and/or web interfaces a PR would be gratefully received. For any issues please submit an issue to the Tasmota fork on gitub or ask on the sonoff mailing list .","title":"Time Proportioned Output support"},{"location":"Timers/","text":"?> Timers allow you to automate your device based on time triggers. To control a device locally 16 timers are programmable. They can be configured with the Timer<x> command followed by a JSON payload with optional parameters. For example: Timer 1 will ENABLE output of POWER1 at exactly 2:23 every Tue/Wed and Sat Timer1 { \"Arm\" : 1 , \"Time\" : \"02:23\" , \"Window\" : 0 , \"Days\" : \"--TW--S\" , \"Repeat\" : 1 , \"Output\" : 1 , \"Action\" : 1 } Timer 4 will TOGGLE output of POWER2 within a 30 minute window centered around 16:23 each Sunday, Monday, Thursday and Friday and will disable (disarm) after executing. Timer4 { \"Arm\" : 1 , \"Time\" : \"16:23\" , \"Window\" : 15 , \"Days\" : \"SM00TF0\" , \"Repeat\" : 0 , \"Output\" : 2 , \"Action\" : 2 } When Mode 1 or Mode 2 is used, Latitude and Longitude become available. In that case the Time value is always used as an offset so make sure to set it to 00:00 if no offset is wanted. Timer1 { \"Arm\" : 1 , \"Mode\" : 2 , \"Time\" : \"-2:23\" , \"Window\" : 0 , \"Days\" : \"11TW11S\" , \"Repeat\" : 1 , \"Output\" : 1 , \"Action\" : 1 } Commands ~ Command Parameters Latitude <value> = set latitude Longitude <value> = set longitude Timers Timers control 0 = disable all timers\u2003 \u00bb v6.2.0 1 = enable all timers 2 = toggle all timers Timer\\<x> Parameters for Timer\\<x> where x = 1..16 0 = clear parameters for Timer\\<x>\u2003 \u00bb v6.2.0 1..16 = copy Timer\\<y> parameters to Timer\\<x> { \"name\":value ; .. } = set all or individual parameters using JSON payload with names and values of data pairs from the table below JSON Payload Anatomy ~ JSON Name JSON Value Arm 0 = disarm or disable timer 1 = arm or enable timer Mode 0 = use clock time 1 = Use local sunrise time using Longitude , Latitude and Time offset 2 = use local sunset time using Longitude , Latitude and Time offset Time hh:mm = set time in hours 0 .. 23 and minutes 0 .. 59 -hh:mm = set time in offset hours -11 .. 12 and minutes 0 .. 59 (used with Mode 1 and Mode 2 ) Window 0..15 = add or subtract a random number of minutes to Time Days SMTWTFS = set day of weeks mask where 0 or - = OFF and any different character = ON Repeat 0 = allow timer only once 1 = repeat timer execution Output 1..16 = select an output to be used if no rule is enabled Action 0 = turn output OFF 1 = turn output ON 2 = TOGGLE output 3 = RULE/BLINK If the Tasmota Rules feature has been activated by compiling the code (activated by default in all pre-compiled Tasmota binaries), a rule with Clock#Timer=<timer> will be triggered if written and turned on by the user. If Rules are not compiled, BLINK output using BlinkCount parameters.","title":"Timers"},{"location":"Timers/#commands","text":"Command Parameters Latitude <value> = set latitude Longitude <value> = set longitude Timers Timers control 0 = disable all timers\u2003 \u00bb v6.2.0 1 = enable all timers 2 = toggle all timers Timer\\<x> Parameters for Timer\\<x> where x = 1..16 0 = clear parameters for Timer\\<x>\u2003 \u00bb v6.2.0 1..16 = copy Timer\\<y> parameters to Timer\\<x> { \"name\":value ; .. } = set all or individual parameters using JSON payload with names and values of data pairs from the table below","title":"Commands"},{"location":"Timers/#json-payload-anatomy","text":"JSON Name JSON Value Arm 0 = disarm or disable timer 1 = arm or enable timer Mode 0 = use clock time 1 = Use local sunrise time using Longitude , Latitude and Time offset 2 = use local sunset time using Longitude , Latitude and Time offset Time hh:mm = set time in hours 0 .. 23 and minutes 0 .. 59 -hh:mm = set time in offset hours -11 .. 12 and minutes 0 .. 59 (used with Mode 1 and Mode 2 ) Window 0..15 = add or subtract a random number of minutes to Time Days SMTWTFS = set day of weeks mask where 0 or - = OFF and any different character = ON Repeat 0 = allow timer only once 1 = repeat timer execution Output 1..16 = select an output to be used if no rule is enabled Action 0 = turn output OFF 1 = turn output ON 2 = TOGGLE output 3 = RULE/BLINK If the Tasmota Rules feature has been activated by compiling the code (activated by default in all pre-compiled Tasmota binaries), a rule with Clock#Timer=<timer> will be triggered if written and turned on by the user. If Rules are not compiled, BLINK output using BlinkCount parameters.","title":"JSON Payload Anatomy"},{"location":"Tips/","text":"Theo's Tasmota Tips ~ remoteMarkdownUrl Obtaining the IP address of a Tasmota device ~ The network name is be <MQTT_TOPIC>-<last 4 decimal chars of MAC address> . The default name is sonoff-xxxx . Use the Status 5 command Available Characters for HOSTNAME ~ 24 chars max only a..z A..Z 0..9 '-' no '-' as last char RFC952 ASSUMPTIONS 1. A \"name\" (Net, Host, Gateway, or Domain name) is a text string up to 24 characters drawn from the alphabet (A-Z), digits (0-9), minus sign (-), and period (.). Note that periods are only allowed when they serve to delimit components of \"domain style names\". (See RFC-921, \"Domain Name System Implementation Schedule\", for background). No blank or space characters are permitted as part of a name. No distinction is made between upper and lower case. The first character must be an alpha character. The last character must not be a minus sign or period. A host which serves as a GATEWAY should have \"-GATEWAY\" or \"-GW\" as part of its name. Hosts which do not serve as Internet gateways should not use \"-GATEWAY\" and \"-GW\" as part of their names. A host which is a TAC should have \"-TAC\" as the last part of its host name, if it is a DoD host. Single character names or nicknames are not allowed. Flash Memory Considerations ~ To stop saving parameter changes to Flash or Spiffs use command SaveData off . To stop saving power changes only to Flash or Spiffs use command SetOption0 off . This will disable the relay from returning to the same state after power on UNLESS you use the MQTT retain flag in which case the MQTT broker will send the last known MQTT state on restart or power on. The command ButtonRetain on will configure the button to send a MQTT command with Topic and the MQTT retain flag set. 3D Printed Cases ~ Don't have 3D printer? Depending on where you live, you may be able to find a third party to print the model for you. Some schools and public libraries provide printing services. Search for a printing service using 3D Hubs or send your design to a service like Shapeways . - Thingiverse - Yeggi","title":"Tips"},{"location":"Tips/#theos-tasmota-tips","text":"remoteMarkdownUrl","title":"Theo's Tasmota Tips"},{"location":"Tips/#obtaining-the-ip-address-of-a-tasmota-device","text":"The network name is be <MQTT_TOPIC>-<last 4 decimal chars of MAC address> . The default name is sonoff-xxxx . Use the Status 5 command","title":"Obtaining the IP address of a Tasmota device"},{"location":"Tips/#available-characters-for-hostname","text":"24 chars max only a..z A..Z 0..9 '-' no '-' as last char RFC952 ASSUMPTIONS 1. A \"name\" (Net, Host, Gateway, or Domain name) is a text string up to 24 characters drawn from the alphabet (A-Z), digits (0-9), minus sign (-), and period (.). Note that periods are only allowed when they serve to delimit components of \"domain style names\". (See RFC-921, \"Domain Name System Implementation Schedule\", for background). No blank or space characters are permitted as part of a name. No distinction is made between upper and lower case. The first character must be an alpha character. The last character must not be a minus sign or period. A host which serves as a GATEWAY should have \"-GATEWAY\" or \"-GW\" as part of its name. Hosts which do not serve as Internet gateways should not use \"-GATEWAY\" and \"-GW\" as part of their names. A host which is a TAC should have \"-TAC\" as the last part of its host name, if it is a DoD host. Single character names or nicknames are not allowed.","title":"Available Characters for HOSTNAME"},{"location":"Tips/#flash-memory-considerations","text":"To stop saving parameter changes to Flash or Spiffs use command SaveData off . To stop saving power changes only to Flash or Spiffs use command SetOption0 off . This will disable the relay from returning to the same state after power on UNLESS you use the MQTT retain flag in which case the MQTT broker will send the last known MQTT state on restart or power on. The command ButtonRetain on will configure the button to send a MQTT command with Topic and the MQTT retain flag set.","title":"Flash Memory Considerations"},{"location":"Tips/#3d-printed-cases","text":"Don't have 3D printer? Depending on where you live, you may be able to find a third party to print the model for you. Some schools and public libraries provide printing services. Search for a printing service using 3D Hubs or send your design to a service like Shapeways . - Thingiverse - Yeggi","title":"3D Printed Cases"},{"location":"Troubleshooting/","text":"Troubleshooting ~ Debugging ~ Logs ~ For debugging purposes you can use Level 4 or Level 5 logging to the MqttLog , WebLog , SerialLog , or remote SysLog . The logging level is set separately for each log destination. Log levels range from 0 to 5 . The higher the log level, the more information is logged. When troubleshooting your device its recommended to set the logging level to 4 . Web Logging These show up in the Web UI Console (http://deviceip/cs). The default logging level for WebLog logging is 2. Warning Never connect to serial while the device is connected to mains power. You can still collect the logs, but only when powering it via your serial connection. Some devices use the serial port to control the relays or an MCU, so serial logging might interfere with control and even switch relays or lights. The default logging level for SerialLog logging is 2. Unless explicitly set by a command (e.g., user input in the Console, a System#Boot triggered rule), SerialLog will be disabled automatically 10 minutes after the device reboots. Through a terminal program set the baud rate to 115200 (19200 for Sonoff Dual), both NL & CR, and disable hardware flow control. Debugging the Sonoff Pow is a bit tricky as the serial interface has a direct connection to one of the AC power lines . The schematic below uses two optocouplers separating the AC connection on the left from the low voltage connection on the right allowing for serial control at 115200 baud and uploading of firmware up to 57600 baud while AC is connected. Crashdumps If the ESP8266 crashes, it frequently dumps information about the crash out the serial port, so the process listed above to see serial logs can provide extremely useful information Syslog Logging If you have a Linux system, it is probably already running syslog . You just need to configure it to listen on the network. SysLog logging is disabled in Tasmota by default. On systems running rsyslog (most linux distros), edit the /etc/rsyslog.conf file. Adding (or uncommenting) the following lines will probably start making the logs show up in some file under /var/log $ModLoad imudp $UDPServerRun 514 If you do not have access to a Linux system, there are Microsoft Windows Syslog server options . MQTT Logging These log messages show up as MQTT messages. MqttLog logging is disabled by default. MQTT traffic ~ To check the flow of MQTT traffic you can use MQTT Explorer which shows your entire MQTT traffic in an organised and structured way. Tasmota Device Manager offers an overview of all your Tasmota devices using MQTT protocol. You can manage them, use device features and do basic troubleshooting with ease. It also cleanly displays if your device is dropping from the network often or reboots unexpectedly. Running out of RAM ~ This typically shows up in the device working when it first starts up (hitting the button toggles the relay), but some time later it either reboots or some function won't work. For example, you can't load the module configuration page. The only fix for this is to recompile the firmware and disable features you don't need. Known large features are web server and TLS, but other things to consider disabling if you don't need them are emulation support, Domoticz support and WS8212 support. Program Memory ~ A 512K firmware binary size is a good \"target\" and rule of thumb for allowing future OTA firmware updates. Flashing over the air (OTA) requires that there is enough free program memory available to upload the new firmware along with the existing copy before the old copy is deleted. If your firmware binary is larger than the available free program memory, you can replace the existing firmware with a minimal functionality version of Tasmota (roughly 375K). This leaves enough free in the 1024K program memory for the final copy of the firmware (i.e., larger than 512K). Flashing Tasmota makes it simpler to update to newer versions because it is built for OTA upgrades. In fact, if the new firmware is larger than the available free memory, Tasmota's OTA process will, automatically, first replace the existing firmware with \"minimal\" to then have enough space to put the new firmware in. If one is loading firmware only via the serial interface (i.e., wired), then theoretically you could load firmware as large at the program memory size. since you can erase the flash and then fill it to the rim with the new firmware. But then you'd be left with performing upgrades by having to have physical access to the device each time.","title":"Troubleshooting"},{"location":"Troubleshooting/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"Troubleshooting/#debugging","text":"","title":"Debugging"},{"location":"Troubleshooting/#logs","text":"For debugging purposes you can use Level 4 or Level 5 logging to the MqttLog , WebLog , SerialLog , or remote SysLog . The logging level is set separately for each log destination. Log levels range from 0 to 5 . The higher the log level, the more information is logged. When troubleshooting your device its recommended to set the logging level to 4 .","title":"Logs"},{"location":"Troubleshooting/#mqtt-traffic","text":"To check the flow of MQTT traffic you can use MQTT Explorer which shows your entire MQTT traffic in an organised and structured way. Tasmota Device Manager offers an overview of all your Tasmota devices using MQTT protocol. You can manage them, use device features and do basic troubleshooting with ease. It also cleanly displays if your device is dropping from the network often or reboots unexpectedly.","title":"MQTT traffic"},{"location":"Troubleshooting/#running-out-of-ram","text":"This typically shows up in the device working when it first starts up (hitting the button toggles the relay), but some time later it either reboots or some function won't work. For example, you can't load the module configuration page. The only fix for this is to recompile the firmware and disable features you don't need. Known large features are web server and TLS, but other things to consider disabling if you don't need them are emulation support, Domoticz support and WS8212 support.","title":"Running out of RAM"},{"location":"Troubleshooting/#program-memory","text":"A 512K firmware binary size is a good \"target\" and rule of thumb for allowing future OTA firmware updates. Flashing over the air (OTA) requires that there is enough free program memory available to upload the new firmware along with the existing copy before the old copy is deleted. If your firmware binary is larger than the available free program memory, you can replace the existing firmware with a minimal functionality version of Tasmota (roughly 375K). This leaves enough free in the 1024K program memory for the final copy of the firmware (i.e., larger than 512K). Flashing Tasmota makes it simpler to update to newer versions because it is built for OTA upgrades. In fact, if the new firmware is larger than the available free memory, Tasmota's OTA process will, automatically, first replace the existing firmware with \"minimal\" to then have enough space to put the new firmware in. If one is loading firmware only via the serial interface (i.e., wired), then theoretically you could load firmware as large at the program memory size. since you can erase the flash and then fill it to the rim with the new firmware. But then you'd be left with performing upgrades by having to have physical access to the device each time.","title":"Program Memory"},{"location":"Tutorials/","text":"Installation Tutorials ~ Installing Tasmota using Tasmotizer How to Flash the RF Bridge Flash your device using a RaspberryPi instead of USB-to-TTL serial connector Video tutorials ~ Tasmota and Tasmotizer Easy Flashing Guide for ESP8266 devices Installation tutorial of Tasmota using PlatformIO made by QuickPi. True 3-Way Smart Switch Make a motion activated switch with temperature and humidity sensor Sonoff Basic as UK Light Switch YouTube Channels covering Tasmota and home automation ~ DigiblurDIY - Great and Easy Tasmota related Videos DrZzs - Great and Easy Tasmota related Videos Super House - Home Automation Tutorials The Hook Up - Home Automation Tutorials BRUH Automation - Home Automation Tutorials Burns Home Automation - Home Automation Tutorials Step to Step Tutorials - Hobbytronics Tutorials Kiril Peyanski - Tasmota Tutorials Non-English Tutorials ~ DE - Tuya Ger\u00e4te Flashen DE - ESP8266 flashen von A - Z FR - Ajouter un bouton physique au Sonoff basic IT - Installazione firmware Tasmota su Sonoff Basic IL - Hebrew - Install Tasmota firmware on all Sonoff devices ?? - Yuval Mejahez - Tasmota Flash tutorials Channel","title":"Tutorials"},{"location":"Tutorials/#installation-tutorials","text":"Installing Tasmota using Tasmotizer How to Flash the RF Bridge Flash your device using a RaspberryPi instead of USB-to-TTL serial connector","title":"Installation Tutorials"},{"location":"Tutorials/#video-tutorials","text":"Tasmota and Tasmotizer Easy Flashing Guide for ESP8266 devices Installation tutorial of Tasmota using PlatformIO made by QuickPi. True 3-Way Smart Switch Make a motion activated switch with temperature and humidity sensor Sonoff Basic as UK Light Switch","title":"Video tutorials"},{"location":"Tutorials/#youtube-channels-covering-tasmota-and-home-automation","text":"DigiblurDIY - Great and Easy Tasmota related Videos DrZzs - Great and Easy Tasmota related Videos Super House - Home Automation Tutorials The Hook Up - Home Automation Tutorials BRUH Automation - Home Automation Tutorials Burns Home Automation - Home Automation Tutorials Step to Step Tutorials - Hobbytronics Tutorials Kiril Peyanski - Tasmota Tutorials","title":"YouTube Channels covering Tasmota and home automation"},{"location":"Tutorials/#non-english-tutorials","text":"DE - Tuya Ger\u00e4te Flashen DE - ESP8266 flashen von A - Z FR - Ajouter un bouton physique au Sonoff basic IT - Installazione firmware Tasmota su Sonoff Basic IL - Hebrew - Install Tasmota firmware on all Sonoff devices ?? - Yuval Mejahez - Tasmota Flash tutorials Channel","title":"Non-English Tutorials"},{"location":"Tuya-Convert/","text":"Tuya devices are sold under numerous brand names but they're all identifiable by the fact that they connect with these phone apps: \" Smart Life \" or \" Tuya Smart \". They incorporate different types of Tuya Wi-Fi modules internally. Tuya has begun manufacturing some Wi-Fi modules using a Realtek RTL8710BN Wi-Fi SOC instead of an ESP82xx chip. Tasmota cannot run on Realtek devices and there are no plans on supporting them . Tuya-Convert is the most successful method of flashing Tuya modules without opening the device and soldering. Tuya-Convert comes with tasmota-wifiman.bin build which includes nearly all Tasmota features required for normal operation with Tuya devices, while removing superfluous sensors, IR and RF support for size. It has pre set WifiConfig = 2 so the device will revert to Wi-Fi Manager mode if it cannot connect to the configured Wi-Fi network. Naturally you can upgrade to any other build of the firmware if needed. To ensure Tasmota runs reliably execute the command reset 5 after Tuya-Convert is finished and Tasmota is up and running. Doing this removes fragments of the original firmware left in flash which can create issues in the future. After all that is done you can proceed with the needed configuration of your device. Help and troubleshooting for Tuya-Convert is done on Tuya-Convert's Github . [!DANGER] The fact that you can flash Tasmota on your device does not mean all of its features are currently supported. Please research before purchasing to see if other users have successfully flashed the device and are able to use it fully Tuya-Convert video walkthrough TuyOTA walkthrough Mock Tuya Cloud - A general purpose framework for interacting with Tuya devices without the Tuya operated cloud. Tuya API - A library for communicating with devices that use the Tuya cloud network.","title":"Tuya Convert"},{"location":"Tuya-Protocols/","text":"The MCU communicates with the Wi-Fi module through the serial port. Protocols are classified into basic and functional protocols. Basic protocols ~ They are common protocols integrated in Tasmota's TuyaMCU module. They stay the same for each product and are mandatory for Tuya module to work correctly. Functional protocols ~ Functional protocols are used for delivering and reporting data of functions. These protocols differ between devices and manufacturers and might require configuration in Tasmota using TuyaMCU command or with TuyaSend<x> command. Anatomy of functional protocols ~ Name Description Frame Header Version Fixed value of 0x55aa Command Word 0x06 - send commands 0x07 - report status Data Length defines expected length of data dpID numbered ID of a function (DP = Data Point or Define Product) Data Type see Data Type table below Function Length length of command Function Command formatted according to Data Type Verification Method checksum = remainder of the byte sum starting from Frame Header to 256 Data Type Hex Tasmota Command Decription Max length 0x01 TuyaSend1 boolean data 0/1 1 byte 0x02 TuyaSend2 value data. If a value contains less than 4 bytes, 0 is supplemented before 4 bytes 0x00 TuyaSend3 string data unknown 0x04 TuyaSend4 enum data 0/1/2/3/4/5 1 byte 0x05 ### fault data, report only 8 bytes Let's dissect and explain the MCU protocol using serial command 55aa0006000501010001010e : Frame Header Version Command Word Data Length dpID Data Type Function Length Function Command Verification Method 55aa00 06 0005 01 01 0001 01 0e This is the command which powers on the device sending Function Command = 1 to dpID 1 (Switch): - Frame Header Version = 0x55aa00 which is a fixed value and always the same - Command Word = 0x06 because we're sending a command - Data Type = 0x01 since the command sent is a 1 byte boolean - Function Length = 0x001 instruct 1 character only for function command length - Function Command = 0x01 in hex which equals 1 in int - Verification Method = 0e is calculated Protocol flow ~ On device boot, TuyaMCU executes the required basic protocols and reads the functional protocol data received, which are used to update status of components mapped in TuyaMCU (Relays, dimmer, power monitoring data). After receiving a command from Tasmota (Command Word 0x06 ), the MCU performs corresponding logical control. When the dpID status is changed, the MCU reports the data (Command Word 0x07 ) to TuyaMCU component. dpId functions tables ~ This information is just for orientation. Functions are assigned by the manufacturer and can be on different dpId's DP ID: dpId. Function Point\uff1aUsed to describe the product function. Identifier: Function codename. Can only be letters, numbers and underscores Data type\uff1a Issue and report: command data can be sent and status data can be reported back to the Wi-Fi module Report only: supports only status reporting, no control options Function Type (Referred as Data Type in TuyaMCU article): Boolean (bool): non-true or false binary variable, such as: switch function, on / off Value (value): suitable for linear adjustment of the type of data, such as: temperature regulation, temperature range 20-40 \u2103 Enum (enum): custom finite set value, such as: working levels, low / mid / high Fault (fault): dedicated to reporting and statistical failure of the function points. Support multi-fault, the data is reported only Integer\uff08integer\uff09: transmitted as integer Transparent (raw): data in binary Switches or plugs/power strips ~ | DP ID | Identifier | Data type | Function type | Properties | |-------|-------------|--------------------|---------------|----------------------------------------------| | 1 | switch_1 | Control and report | Boolean | | | 2 | switch_2 | Control and report | Boolean | | | 3 | switch_3 | Control and report | Boolean | | | 4 | switch_4 | Control and report | Boolean | | | 5 | switch_5 | Control and report | Boolean | | | 9 | countdown_1 | Control and report | Integer | undefined0-86400, undefined1, Scale0, Unit:s | | 10 | countdown_2 | Control and report | Integer | undefined0-86400, undefined1, Scale0, Unit:s | | 11 | countdown_3 | Control and report | Integer | undefined0-86400, undefined1, Scale0, Unit:s | | 12 | countdown_4 | Control and report | Integer | undefined0-86400, undefined1, Scale0, Unit:s | | 13 | countdown_5 | Control and report | Integer | undefined0-86400, undefined1, Scale0, Unit:s | Aromatherapy machine (Oil Diffuser) ~ | DP ID | Function points | Identifier | Data type | Function type | Properties | 1 | Switch | Power | Issue and report | Boolean | | | 6 | Amount of fog | fog | Issue and report | Enum | Enumerated values:small, large| | 11 | Light | Light | Issue and report | Boolean | | | 12 | Fault alarm | fault | Only report | Fault | Barrier values:1| | 13 | Countdown | countdown | Issue and report | Enum | Enumerated values: 0, 1, 2, 3| | 14 | Countdown remaining time | countdown_left | Only report | Integer | Values range: 0-360, Pitch1, Scale0, Unit:min| | 101 | Light mode | work_mode | Issue and report | Enum | Enumerated values: white, colour, scene, scene1, scene2, scene3, scene4 | | 102 | Color value | colour_data | Issue and report | Char type | *see below | | 103 | Light mode | lightmode | Issue and report | Enum | Enumerated values: 1, 2, 3| | 104 | Brightness setting | setlight | Issue and report | Integer | Values range: 0-255, Pitch1, Scale0, Unit:\\%| colour_data format of the lights is a string of 14 characters, for example, 00112233334455, where 00 indicates R, 11 indicates G, 22 indicates B, 3333 indicates the hue, 44 indicates the saturation, and 55 indicates the value. The initial value is saved by default. If you do not want to adjust the light, set the data to the maximum value 100% (0x64). The last four characters have fixed values. Curtain motor ~ | DP ID | Function points | Identifier | Data type | Function type | Properties | |-------|-----------------|---------------|------------------|---------------|-----------------------------------------------| | 1 | Percentage | percent_state | Only report | Integer | Values range:0-100, Pitch1, Scale0, Unit:% | | 2 | Motor Direction | control_back | Issue and report | Boolean | | | 3 | Auto Power | auto_power | Issue and report | Boolean | | | 4 | Left time | countdown | Issue and report | Enum | Enumerated values:cancel, 1, 2, 3, 4 | | 5 | Total Time | time_total | Only report | Integer | Values range:0-120000, Pitch1, Scale0, Unit:m | Complete document on protocols Power monitoring plug ~ | DP ID | Function points | Identifier | Data type | Function type | Properties | |-------|------------------------|-----------------|--------------------|---------------|-----------------------------------------------| | 1 | switch_1 | switch_1 | Control and report | Boolean | | | 9 | countdown_1 | countdown_1 | Control and report | Integer | undefined0-86400, undefined1, Scale0, Unit:s | | 17 | statistics Function | add_ele | Control and report | Integer | undefined0-50000, undefined100, Scale3, Unit: | | 18 | current | cur_current | Data report | Integer | undefined0-30000, undefined1, Scale0, Unit:mA | | 19 | power | cur_power | Data report | Integer | undefined0-50000, undefined1, Scale1, Unit:W | | 20 | voltage | cur_voltage | Data report | Integer | undefined0-5000, undefined1, Scale1, Unit:V | | 21 | test flag | test_bit | Data report | Integer | undefined0-5, undefined1, Scale0, Unit: | | 22 | voltage coefficient | voltage_coe | Data report | Integer | undefined0-1000000, undefined1, Scale0, Unit: | | 23 | current coefficient | electric_coe | Data report | Integer | undefined0-1000000, undefined1, Scale0, Unit: | | 24 | power coefficient | power_coe | Data report | Integer | undefined0-1000000, undefined1, Scale0, Unit: | | 25 | statistics coefficient | electricity_coe | Data report | Integer | undefined0-1000000, undefined1, Scale0, Unit: | | 26 | warning | fault | Data report | Fault | Barrier values:ov_cr | Dehumidifier ~ | DP ID | Function points | Identifier | Data type | Function type | Properties | | ------- | ----------------- | ------------- | ------------------ | --------------- | ---------------------------------------------------------- | | 1 | Switch | Switch | Issue and report | Boolean | | | 2 | PM2 .5 | PM25 | Only report | Integer | Values range : 0 - 999 , Pitch1 , Scale0 , Unit : | | 3 | Work mode | Mode | Issue and report | Enum | Enumerated values : Manual , Auto , Sleep | | 4 | Wind speed | Speed | Issue and report | Enum | Enumerated values : speed1 , speed2 , speed3 , speed4 , speed5 | | 5 | Filter usage | Filter | Only report | Integer | Values range : 0 - 100 , Pitch1 , Scale0 , Unit : % | | 6 | Fresh | Anion | Issue and report | Boolean | | | 7 | Child lock | Lock | Issue and report | Boolean | | | 9 | UV light | UV | Issue and report | Boolean | | | 11 | Filter reset | FilterReset | Issue and report | Boolean | | | 12 | indoor temp | Temp | Only report | Integer | Values range : - 20 - 50 , Pitch1 , Scale0 , Unit :\u2103 | | 13 | Indoor humidity | Humidity | Only report | Integer | Values range : 0 - 100 , Pitch1 , Scale0 , Unit : % | Lighting ~ | DP ID | Function points | Identifier | Data type | Function type | Properties | |-------|-----------------|---------------|--------------------|---------------|----------------------------------------------------------------------------| | 1 | Switch | led_switch | Control and report | Boolean | | | 2 | Mode | work_mode | Control and report | Enum | Enumerated values:white, colour, scene, scene_1, scene_2, scene_3, scene_4 | | 3 | Bright | bright_value | Control and report | Integer | undefined25-255, undefined1, Scale0, Unit: | | 5 | Colour mode | colour_data | Control and report | Char type | | | 6 | Scene | scene_data | Control and report | Char type | | | 7 | Scene1 | flash_scene_1 | Control and report | Char type | | | 8 | Scene2 | flash_scene_2 | Control and report | Char type | | | 9 | Scene3 | flash_scene_3 | Control and report | Char type | | | 10 | Scene4 | flash_scene_4 | Control and report | Char type | | Air purifier ~ | DP ID | Function points | Identifier | Data type | Function type | Properties | | ------- | ----------------- | ------------- | ------------------ | --------------- | ---------------------------------------------------------- | | 1 | Switch | Switch | Issue and report | Boolean | | | 2 | PM2 .5 | PM25 | Only report | Integer | Values range : 0 - 999 , Pitch1 , Scale0 , Unit : | | 3 | Work mode | Mode | Issue and report | Enum | Enumerated values : Manual , Auto , Sleep | | 4 | Wind speed | Speed | Issue and report | Enum | Enumerated values : speed1 , speed2 , speed3 , speed4 , speed5 | | 5 | Filter usage | Filter | Only report | Integer | Values range : 0 - 100 , Pitch1 , Scale0 , Unit : % | | 6 | Fresh | Anion | Issue and report | Boolean | | | 7 | Child lock | Lock | Issue and report | Boolean | | | 9 | UV light | UV | Issue and report | Boolean | | | 11 | Filter reset | FilterReset | Issue and report | Boolean | | | 12 | indoor temp | Temp | Only report | Integer | Values range : - 20 - 50 , Pitch1 , Scale0 , Unit :\u2103 | | 13 | Indoor humidity | Humidity | Only report | Integer | Values range : 0 - 100 , Pitch1 , Scale0 , Unit : % | Heater ~ | DP ID | Function points | Identifier | Data type | Function type | Properties | | ------- | --------------------- | ------------- | ------------------ | --------------- | -------------------------------------------- | | 1 | Switch | Power | Issue and report | Boolean | | | 2 | Target temperature | TempSet | Issue and report | Integer | Values range : 0 - 37 , Pitch1 , Scale0 , Unit :\u2103 | | 3 | Current Temperature | TempCurrent | Only report | Integer | Values range : - 9 - 99 , Pitch1 , Scale0 , Unit :\u2103 | | 4 | Mode | Mode | Issue and report | Enum | Enumerated values : m , p | | 5 | Fault alarm | Fault | Only report | Fault | Barrier values : 1 , 2 , 3 | | 6 | Gear position | gear | Issue and report | Enum | Enumerated values : low , mid , high , off | | 7 | Conservation | eco_mode | Issue and report | Boolean | | Smart fan ~ | DP ID | Function points | Identifier | Data type | Function type | Properties | |-------|----------------------|----------------|------------------|---------------|-------------------------------------------| | 1 | Switch | switch | Issue and report | Boolean | | | 2 | Wind Speed Level | fan_speed | Issue and report | Enum | Enumerated values:1, 2, 3, 4 | | 3 | Left-and-Right Swing | fan_horizontal | Issue and report | Enum | Enumerated values:on, off | | 4 | Up-and-Down Swing | fan_vertical | Issue and report | Enum | Enumerated values:on, off | | 5 | Fault Alarm | fault | Only report | Fault | Barrier values:1, 2 | | 6 | Anion | anion | Issue and report | Boolean | | | 7 | Humidify | humidifier | Issue and report | Boolean | | | 8 | Oxygen | oxygan | Issue and report | Boolean | | | 9 | Child Lock | lock | Issue and report | Boolean | | | 10 | Cool | fan_cool | Issue and report | Boolean | | | 11 | Set Temperate | temp | Issue and report | Integer | Values range:0-50, Pitch1, Scale0, Unit:\u2103 | | 12 | Current Temperature | temp_current | Only report | Integer | Values range:0-50, Pitch1, Scale0, Unit:\u2103 | Kettle ~ | DP ID | Function points | Identifier | Data type | Function type | Properties | |-------|------------------------------------------------------------|----------------------|------------------|---------------|---------------------------------------------------------------------| | 1 | Working switch | start | Issue and report | Boolean | | | 2 | Heat to target temperature shortcut (\u00b0C) | temp_setting_quick_c | Issue and report | Enum | Enumerated values:50, 65, 85, 90, 100 | | 3 | Heat to target temperature shortcut (\u00b0F) | temp_setting_quick_f | Issue and report | Enum | Enumerated values:122, 149, 185, 194, 212 | | 4 | Cool to the target temperature shortcut after boiling (\u00b0C) | temp_boiling_quick_c | Issue and report | Enum | Enumerated values:50, 65, 85, 90, 100 | | 5 | Cool to the target temperature shortcut after boiling (\u00b0F) | temp_boiling_quick_f | Issue and report | Enum | Enumerated values:122, 149, 185, 194, 212 | | 6 | Temperature scale switching | temp_unit_convert | Issue and report | Enum | Enumerated values:c, f | | 7 | Insulation switch | switch_keep_warm | Issue and report | Boolean | | | 8 | Holding time setting | keep_warm_setting | Issue and report | Integer | Values range:0-360, Pitch1, Scale0, Unit:min | | 9 | Mode | work_type | Issue and report | Enum | Enumerated values: setting_quick, boiling_quick, temp_setting, temp_ | BecaThermostat(WIP) ~ | DP ID | Function points | Identifier | Data type | Function type | Properties | | ------- | --------------------- | ------------- | ------------------ | --------------- | -------------------------------------------- | | 1 | Switch | Power | Issue and report | Boolean | | | 2 | Target temperature | TempSet | Issue and report | Integer | Values range : 0 - 37 , Pitch1 , Scale0 , Unit :\u2103 | | 3 | Current Temperature | TempCurrent | Only report | Integer | Values range : - 9 - 99 , Pitch1 , Scale0 , Unit :\u2103 | | 4 | Mode | Mode | Issue and report | Enum | Enumerated values : m , p ( wip ) | | 102 | Floor Temperature | FloorCurrent | Issue and report | Integer | Values range : 0 - 37 , Pitch1 , Scale0 , Unit :\u2103 |","title":"Tuya Protocols"},{"location":"Tuya-Protocols/#basic-protocols","text":"They are common protocols integrated in Tasmota's TuyaMCU module. They stay the same for each product and are mandatory for Tuya module to work correctly.","title":"Basic protocols"},{"location":"Tuya-Protocols/#functional-protocols","text":"Functional protocols are used for delivering and reporting data of functions. These protocols differ between devices and manufacturers and might require configuration in Tasmota using TuyaMCU command or with TuyaSend<x> command.","title":"Functional protocols"},{"location":"Tuya-Protocols/#anatomy-of-functional-protocols","text":"Name Description Frame Header Version Fixed value of 0x55aa Command Word 0x06 - send commands 0x07 - report status Data Length defines expected length of data dpID numbered ID of a function (DP = Data Point or Define Product) Data Type see Data Type table below Function Length length of command Function Command formatted according to Data Type Verification Method checksum = remainder of the byte sum starting from Frame Header to 256","title":"Anatomy of functional protocols"},{"location":"Tuya-Protocols/#protocol-flow","text":"On device boot, TuyaMCU executes the required basic protocols and reads the functional protocol data received, which are used to update status of components mapped in TuyaMCU (Relays, dimmer, power monitoring data). After receiving a command from Tasmota (Command Word 0x06 ), the MCU performs corresponding logical control. When the dpID status is changed, the MCU reports the data (Command Word 0x07 ) to TuyaMCU component.","title":"Protocol flow"},{"location":"Tuya-Protocols/#dpid-functions-tables","text":"This information is just for orientation. Functions are assigned by the manufacturer and can be on different dpId's DP ID: dpId. Function Point\uff1aUsed to describe the product function. Identifier: Function codename. Can only be letters, numbers and underscores Data type\uff1a Issue and report: command data can be sent and status data can be reported back to the Wi-Fi module Report only: supports only status reporting, no control options Function Type (Referred as Data Type in TuyaMCU article): Boolean (bool): non-true or false binary variable, such as: switch function, on / off Value (value): suitable for linear adjustment of the type of data, such as: temperature regulation, temperature range 20-40 \u2103 Enum (enum): custom finite set value, such as: working levels, low / mid / high Fault (fault): dedicated to reporting and statistical failure of the function points. Support multi-fault, the data is reported only Integer\uff08integer\uff09: transmitted as integer Transparent (raw): data in binary","title":"dpId functions tables"},{"location":"Tuya-Protocols/#switches-or-plugspower-strips","text":"| DP ID | Identifier | Data type | Function type | Properties | |-------|-------------|--------------------|---------------|----------------------------------------------| | 1 | switch_1 | Control and report | Boolean | | | 2 | switch_2 | Control and report | Boolean | | | 3 | switch_3 | Control and report | Boolean | | | 4 | switch_4 | Control and report | Boolean | | | 5 | switch_5 | Control and report | Boolean | | | 9 | countdown_1 | Control and report | Integer | undefined0-86400, undefined1, Scale0, Unit:s | | 10 | countdown_2 | Control and report | Integer | undefined0-86400, undefined1, Scale0, Unit:s | | 11 | countdown_3 | Control and report | Integer | undefined0-86400, undefined1, Scale0, Unit:s | | 12 | countdown_4 | Control and report | Integer | undefined0-86400, undefined1, Scale0, Unit:s | | 13 | countdown_5 | Control and report | Integer | undefined0-86400, undefined1, Scale0, Unit:s |","title":"Switches or plugs/power strips"},{"location":"Tuya-Protocols/#aromatherapy-machine-oil-diffuser","text":"| DP ID | Function points | Identifier | Data type | Function type | Properties | 1 | Switch | Power | Issue and report | Boolean | | | 6 | Amount of fog | fog | Issue and report | Enum | Enumerated values:small, large| | 11 | Light | Light | Issue and report | Boolean | | | 12 | Fault alarm | fault | Only report | Fault | Barrier values:1| | 13 | Countdown | countdown | Issue and report | Enum | Enumerated values: 0, 1, 2, 3| | 14 | Countdown remaining time | countdown_left | Only report | Integer | Values range: 0-360, Pitch1, Scale0, Unit:min| | 101 | Light mode | work_mode | Issue and report | Enum | Enumerated values: white, colour, scene, scene1, scene2, scene3, scene4 | | 102 | Color value | colour_data | Issue and report | Char type | *see below | | 103 | Light mode | lightmode | Issue and report | Enum | Enumerated values: 1, 2, 3| | 104 | Brightness setting | setlight | Issue and report | Integer | Values range: 0-255, Pitch1, Scale0, Unit:\\%| colour_data format of the lights is a string of 14 characters, for example, 00112233334455, where 00 indicates R, 11 indicates G, 22 indicates B, 3333 indicates the hue, 44 indicates the saturation, and 55 indicates the value. The initial value is saved by default. If you do not want to adjust the light, set the data to the maximum value 100% (0x64). The last four characters have fixed values.","title":"Aromatherapy machine (Oil Diffuser)"},{"location":"Tuya-Protocols/#curtain-motor","text":"| DP ID | Function points | Identifier | Data type | Function type | Properties | |-------|-----------------|---------------|------------------|---------------|-----------------------------------------------| | 1 | Percentage | percent_state | Only report | Integer | Values range:0-100, Pitch1, Scale0, Unit:% | | 2 | Motor Direction | control_back | Issue and report | Boolean | | | 3 | Auto Power | auto_power | Issue and report | Boolean | | | 4 | Left time | countdown | Issue and report | Enum | Enumerated values:cancel, 1, 2, 3, 4 | | 5 | Total Time | time_total | Only report | Integer | Values range:0-120000, Pitch1, Scale0, Unit:m | Complete document on protocols","title":"Curtain motor"},{"location":"Tuya-Protocols/#power-monitoring-plug","text":"| DP ID | Function points | Identifier | Data type | Function type | Properties | |-------|------------------------|-----------------|--------------------|---------------|-----------------------------------------------| | 1 | switch_1 | switch_1 | Control and report | Boolean | | | 9 | countdown_1 | countdown_1 | Control and report | Integer | undefined0-86400, undefined1, Scale0, Unit:s | | 17 | statistics Function | add_ele | Control and report | Integer | undefined0-50000, undefined100, Scale3, Unit: | | 18 | current | cur_current | Data report | Integer | undefined0-30000, undefined1, Scale0, Unit:mA | | 19 | power | cur_power | Data report | Integer | undefined0-50000, undefined1, Scale1, Unit:W | | 20 | voltage | cur_voltage | Data report | Integer | undefined0-5000, undefined1, Scale1, Unit:V | | 21 | test flag | test_bit | Data report | Integer | undefined0-5, undefined1, Scale0, Unit: | | 22 | voltage coefficient | voltage_coe | Data report | Integer | undefined0-1000000, undefined1, Scale0, Unit: | | 23 | current coefficient | electric_coe | Data report | Integer | undefined0-1000000, undefined1, Scale0, Unit: | | 24 | power coefficient | power_coe | Data report | Integer | undefined0-1000000, undefined1, Scale0, Unit: | | 25 | statistics coefficient | electricity_coe | Data report | Integer | undefined0-1000000, undefined1, Scale0, Unit: | | 26 | warning | fault | Data report | Fault | Barrier values:ov_cr |","title":"Power monitoring plug"},{"location":"Tuya-Protocols/#dehumidifier","text":"| DP ID | Function points | Identifier | Data type | Function type | Properties | | ------- | ----------------- | ------------- | ------------------ | --------------- | ---------------------------------------------------------- | | 1 | Switch | Switch | Issue and report | Boolean | | | 2 | PM2 .5 | PM25 | Only report | Integer | Values range : 0 - 999 , Pitch1 , Scale0 , Unit : | | 3 | Work mode | Mode | Issue and report | Enum | Enumerated values : Manual , Auto , Sleep | | 4 | Wind speed | Speed | Issue and report | Enum | Enumerated values : speed1 , speed2 , speed3 , speed4 , speed5 | | 5 | Filter usage | Filter | Only report | Integer | Values range : 0 - 100 , Pitch1 , Scale0 , Unit : % | | 6 | Fresh | Anion | Issue and report | Boolean | | | 7 | Child lock | Lock | Issue and report | Boolean | | | 9 | UV light | UV | Issue and report | Boolean | | | 11 | Filter reset | FilterReset | Issue and report | Boolean | | | 12 | indoor temp | Temp | Only report | Integer | Values range : - 20 - 50 , Pitch1 , Scale0 , Unit :\u2103 | | 13 | Indoor humidity | Humidity | Only report | Integer | Values range : 0 - 100 , Pitch1 , Scale0 , Unit : % |","title":"Dehumidifier"},{"location":"Tuya-Protocols/#lighting","text":"| DP ID | Function points | Identifier | Data type | Function type | Properties | |-------|-----------------|---------------|--------------------|---------------|----------------------------------------------------------------------------| | 1 | Switch | led_switch | Control and report | Boolean | | | 2 | Mode | work_mode | Control and report | Enum | Enumerated values:white, colour, scene, scene_1, scene_2, scene_3, scene_4 | | 3 | Bright | bright_value | Control and report | Integer | undefined25-255, undefined1, Scale0, Unit: | | 5 | Colour mode | colour_data | Control and report | Char type | | | 6 | Scene | scene_data | Control and report | Char type | | | 7 | Scene1 | flash_scene_1 | Control and report | Char type | | | 8 | Scene2 | flash_scene_2 | Control and report | Char type | | | 9 | Scene3 | flash_scene_3 | Control and report | Char type | | | 10 | Scene4 | flash_scene_4 | Control and report | Char type | |","title":"Lighting"},{"location":"Tuya-Protocols/#air-purifier","text":"| DP ID | Function points | Identifier | Data type | Function type | Properties | | ------- | ----------------- | ------------- | ------------------ | --------------- | ---------------------------------------------------------- | | 1 | Switch | Switch | Issue and report | Boolean | | | 2 | PM2 .5 | PM25 | Only report | Integer | Values range : 0 - 999 , Pitch1 , Scale0 , Unit : | | 3 | Work mode | Mode | Issue and report | Enum | Enumerated values : Manual , Auto , Sleep | | 4 | Wind speed | Speed | Issue and report | Enum | Enumerated values : speed1 , speed2 , speed3 , speed4 , speed5 | | 5 | Filter usage | Filter | Only report | Integer | Values range : 0 - 100 , Pitch1 , Scale0 , Unit : % | | 6 | Fresh | Anion | Issue and report | Boolean | | | 7 | Child lock | Lock | Issue and report | Boolean | | | 9 | UV light | UV | Issue and report | Boolean | | | 11 | Filter reset | FilterReset | Issue and report | Boolean | | | 12 | indoor temp | Temp | Only report | Integer | Values range : - 20 - 50 , Pitch1 , Scale0 , Unit :\u2103 | | 13 | Indoor humidity | Humidity | Only report | Integer | Values range : 0 - 100 , Pitch1 , Scale0 , Unit : % |","title":"Air purifier"},{"location":"Tuya-Protocols/#heater","text":"| DP ID | Function points | Identifier | Data type | Function type | Properties | | ------- | --------------------- | ------------- | ------------------ | --------------- | -------------------------------------------- | | 1 | Switch | Power | Issue and report | Boolean | | | 2 | Target temperature | TempSet | Issue and report | Integer | Values range : 0 - 37 , Pitch1 , Scale0 , Unit :\u2103 | | 3 | Current Temperature | TempCurrent | Only report | Integer | Values range : - 9 - 99 , Pitch1 , Scale0 , Unit :\u2103 | | 4 | Mode | Mode | Issue and report | Enum | Enumerated values : m , p | | 5 | Fault alarm | Fault | Only report | Fault | Barrier values : 1 , 2 , 3 | | 6 | Gear position | gear | Issue and report | Enum | Enumerated values : low , mid , high , off | | 7 | Conservation | eco_mode | Issue and report | Boolean | |","title":"Heater"},{"location":"Tuya-Protocols/#smart-fan","text":"| DP ID | Function points | Identifier | Data type | Function type | Properties | |-------|----------------------|----------------|------------------|---------------|-------------------------------------------| | 1 | Switch | switch | Issue and report | Boolean | | | 2 | Wind Speed Level | fan_speed | Issue and report | Enum | Enumerated values:1, 2, 3, 4 | | 3 | Left-and-Right Swing | fan_horizontal | Issue and report | Enum | Enumerated values:on, off | | 4 | Up-and-Down Swing | fan_vertical | Issue and report | Enum | Enumerated values:on, off | | 5 | Fault Alarm | fault | Only report | Fault | Barrier values:1, 2 | | 6 | Anion | anion | Issue and report | Boolean | | | 7 | Humidify | humidifier | Issue and report | Boolean | | | 8 | Oxygen | oxygan | Issue and report | Boolean | | | 9 | Child Lock | lock | Issue and report | Boolean | | | 10 | Cool | fan_cool | Issue and report | Boolean | | | 11 | Set Temperate | temp | Issue and report | Integer | Values range:0-50, Pitch1, Scale0, Unit:\u2103 | | 12 | Current Temperature | temp_current | Only report | Integer | Values range:0-50, Pitch1, Scale0, Unit:\u2103 |","title":"Smart fan"},{"location":"Tuya-Protocols/#kettle","text":"| DP ID | Function points | Identifier | Data type | Function type | Properties | |-------|------------------------------------------------------------|----------------------|------------------|---------------|---------------------------------------------------------------------| | 1 | Working switch | start | Issue and report | Boolean | | | 2 | Heat to target temperature shortcut (\u00b0C) | temp_setting_quick_c | Issue and report | Enum | Enumerated values:50, 65, 85, 90, 100 | | 3 | Heat to target temperature shortcut (\u00b0F) | temp_setting_quick_f | Issue and report | Enum | Enumerated values:122, 149, 185, 194, 212 | | 4 | Cool to the target temperature shortcut after boiling (\u00b0C) | temp_boiling_quick_c | Issue and report | Enum | Enumerated values:50, 65, 85, 90, 100 | | 5 | Cool to the target temperature shortcut after boiling (\u00b0F) | temp_boiling_quick_f | Issue and report | Enum | Enumerated values:122, 149, 185, 194, 212 | | 6 | Temperature scale switching | temp_unit_convert | Issue and report | Enum | Enumerated values:c, f | | 7 | Insulation switch | switch_keep_warm | Issue and report | Boolean | | | 8 | Holding time setting | keep_warm_setting | Issue and report | Integer | Values range:0-360, Pitch1, Scale0, Unit:min | | 9 | Mode | work_type | Issue and report | Enum | Enumerated values: setting_quick, boiling_quick, temp_setting, temp_ |","title":"Kettle"},{"location":"Tuya-Protocols/#becathermostatwip","text":"| DP ID | Function points | Identifier | Data type | Function type | Properties | | ------- | --------------------- | ------------- | ------------------ | --------------- | -------------------------------------------- | | 1 | Switch | Power | Issue and report | Boolean | | | 2 | Target temperature | TempSet | Issue and report | Integer | Values range : 0 - 37 , Pitch1 , Scale0 , Unit :\u2103 | | 3 | Current Temperature | TempCurrent | Only report | Integer | Values range : - 9 - 99 , Pitch1 , Scale0 , Unit :\u2103 | | 4 | Mode | Mode | Issue and report | Enum | Enumerated values : m , p ( wip ) | | 102 | Floor Temperature | FloorCurrent | Issue and report | Integer | Values range : 0 - 37 , Pitch1 , Scale0 , Unit :\u2103 |","title":"BecaThermostat(WIP)"},{"location":"Tuya-generic-wifi-curtain-motor-WIP/","text":"Wi-Fi Curtain Motor Applicable Tuya Serial Protocols Communication can be found here if you wish to explore and implement the entire functionality. Don't forget to share what you have discovered and tested here in wiki functionId and dpId Setup: stat/tasmota/RESULT = [{\"fnId\":11, \"dpId\":1},{\"fnId\":12, \"dpId\":101},{\"fnId\":13, \"dpId\":103}] 55aa0007000501010001010f -> auto power mode is on (TBD) 55aa00070005650400010075 -> Curtain motor is opening or opened 55aa000700086602000400000032ac -> Control percentage 50% 55aa00070005670100010074 -> report working state ( opening or closing ) 55aa000700086802000400000032ae -> report percentage dpIds 01 -> Auto power mode on or off ( Can be configured as relay ) 0x65 101 -> Curtain mode ( open / close / stop) 0x66 102 -> Curtain open percentage 0x67 103 -> report work state 0x68 104 -> Curtain percentage report only Commands SerialSend5 55aa00060005650400010276 Forward SerialSend5 55aa00060005650400010074 Reverse SerialSend5 55aa00060005650400010175 Stop Additional Possible Commands (Untested) SerialSend5 55aa000600086802000400000032ad Should open curtain to 20% or SerialSend5 55aa000600086602000400000032ab should open curtain to 20% Commands may be necessary to start opening after setting the percentage. SerialSend5 55aa0006000501010001010e -> Should enable auto close mode SerialSend5 55aa0006000501010001000d -> should disable auto close mode If you send the direction changing too fast (from open to close and vice versa), the motor may be blocked by built in failsafes. Consider sending delay (1 sec) before changing direction. For example, these commands work and don't make the motor block: Backlog delay 10; SerialSend5 55aa00060005650400010276 open Backlog delay 10; SerialSend5 55aa00060005650400010074 close Backlog delay 10; SerialSend5 55aa00060005650400010175 stop And if you use html requests: http://ip/cm?cmnd=backlog%20delay%205%3B%20SerialSend5%2055aa00060005650400010276 open http://ip/cm?cmnd=backlog%20delay%205%3B%20SerialSend5%2055aa00060005650400010074 close http://ip/cm?cmnd=backlog%20delay%205%3B%20SerialSend5%2055aa00060005650400010175 stop","title":"Tuya generic wifi curtain motor WIP"},{"location":"TuyaMCU-Devices/","text":"There are several Tuya dimmer and switch variants made by various manufacturers. The switches range from 1 to 8 gangs. The dimmers are usually 1 gang. They dim mains voltage for various lighting types: incandescent, CFL, and LED. Consult the specific device for the type of bulbs and capacity it supports as well as the bulbs themselves to verify they support dimming. Identification and Technical details ~ The basic identification of a Tuya device is when the device information references the \"Tuya Smart\", \"SmartLife\", or \"Smart Living\" app. These switches and dimmers are based on a Tuya TYWE3S Wi-Fi PCB module along with an MCU. TYWE3S is based on the ESP8266 which is supported by Tasmota. Wiki page for TYWE3S The TYWE3S module mostly takes care of Wi-Fi and software features while the MCU controls the actual hardware (buttons, relays, dimmer, power measurement, etc). The MCU is interfaced to TYWE3S using the serial interface which connects to the Rx and Tx pins. The easiest way to identify if your switch or dimmer uses MCU is by using a continuity tester (multimeter, ohmmeter) and checking continuity from the Rx and Tx pins on TYWE3S to any other chip. Then check the datasheet of that chip to see if it is an MCU. Flashing - Preparation ~ To boot the TYWE3S in flashing mode, GPIO0 needs to be connected to GND while powering up. It can be left grounded for the entire process. Flashing a TYWE3S connected to a MCU is a bit trickier than one without MCU. This is due the same Rx Tx pins used by MCU and serial programmer for flashing. The TYWE3S cannot be booted to flash mode with MCU sending data over the same pins. To be able to do that, we need to disable MCU from sending data over Rx and Tx pins. There are few ways to do it: 1. Disconnect TYWE3S module from the rest of board. (Naah, too much work) 2. Just break the Rx track from MCU to TYWE3S, flash and then reconnect. (Messy work, we want cleaner approach) 3. Just keep MCU disabled while flashing TYWE3S without any soldering / cutting. (We like that) The easiest is to keep MCU disabled is by identifying the NRST/RST (Reset) pin of the MCU from its datasheet and connect it to GND for the entire flashing process. This will keep MCU disabled while you flash TYWE3S. If there are some contacts or test points in switches that connect to the MCU, you might be lucky to find contacts for RST that you can easily solder onto. TYWE3S Connection Options ~ 3D print a flashing Jig and use pogo pins to make nice and easy to use flashing jig Solder wires directly onto TYWE3S Use a jumper header like the one below and bend the pins to match VCC, Rx Tx GPIO0 and GND. You can just press the jumper header to the contacts during the flashing process Flashing - Process ~ Once you are done identifying the pins and ready to connect, BEFORE connecting USB to PC you need to connect them as follows: NOTE : Use 3.3V NOT 5V TYWE3S Serial Programmer RX TX TX RX GPIO0 GND GND GND VCC 3.3V If an MCU is present, bridge RST to GND on the MCU Use a 6.6.0.10 Tasmota version or higher. There are lots of Tuya Serial fixes / features added in there and the tutorial below expects them. Now you need to follow the commands explained in the flashing tutorial . TIP: If you are using jumper headers use sleep 15 && before your commands, this would free your hand and give you some time to set the jumper pins and connect the USB to PC. Configuration ~ Once Tasmota is flashed on the TYWE3S, just disconnect GND -> GPIO0 (and RST if there is an MCU), and power your device again from USB. On your PC, you should see a Wi-Fi network named sonoff-xxxx where xxxx is a number from the ESP's MAC address. Connect to it and go to 192.168.4.1 in your browser. Enter the Wi-Fi credentials for your network and click save. Connect your PC back to your network. Now you need to find the IP of newly connected Tasmota device. Refer to this very good video from SuperHouseTV (ignore flashing information) about configuring Tasmota. Once you get to the Tasmota configuration you need to select TuyaMCU module assign GPIO components as indicated below depending on your hardware. You already know the pin connections to the MCU. GPIO Component 01 Tuya Rx (108) 03 Tuya Tx (107) 13 Tuya Rx (108) 15 Tuya Tx (107) If the device is connecting fine to your network, now is the time to power it down and re-assemble it. Connect a test bulb (or to the final place if you don't mind testing there) Once this is saved and device is rebooted. Open the Tasmota configuration page and you should be able to use the Toggle button to toggle the dimmer or at least one of the gangs in a multi gang switch. Follow the process here depending on switch or dimmer. Product Specific guides ~ Otim Dimmer ~ This Device is based on a Tuya Wi-Fi Module. Refer to \"MCU Based Tuya Dimmers and Switches\" for details. Flashing and Setup Video Guide These devices use a Tuya TYWE3S Wi-Fi PCB module. Once the switch is carefully popped open you will need to remove the ribbon cables for flashing and ease of soldering. An easy soldering method is to take several Dupont style jumper wires, cut one end off, and apply a bit of solder to each stripped end. This will keep the wire flexible and prevent any circuit board pads from ripping off. Apply a bit of solder to each pad necessary to flash (double check your pin-outs). Once the wire and pad have solder simply put the two together and apply a bit of heat and they will join together. Attach the GPIO0 wire to ground during initial boot to flash. You may need to also connect MCU RST to GND during initial boot to get it into programming mode as described here . A 3-pin header bridged together works great with GPIO0, GND and the GND from the USB flasher attached. (TX pin to RX pin and RX pin to TX pin on USB flash adapter). Verify that you are using 3.3volts to flash, NOT 5V! Product Links: Oittm Moes DS01 ( Template ) Konesky Heygo Costco Charging Essentials ~ This devices use a Tuya TYWE1S Wi-Fi PCB module. And it uses U1TX (GPIO15) and U1RX (GPIO13) to communicate between ESP8266 and MCU, no other GPIO is used in this device. Flashing The CE dimmer uses standard Tuya GPIO Product Link Touch (EU and US) - Multiple manufacturers ~ Flashing The procedure is similar to above, additionally NRST must be connected to GND during flashing. Optional configuration (recommended) LedState 0 Only use the green LED for Wi-Fi/MQTT connectivity status. Product Links: ~ AIGLEN ALLOMN MakeGood Zemismart Curtain Motor ~ Curtain motors come in a confusing array. This one has a little Wi-Fi dongle, that looks like a USB stick. But it talks using 9600 8N1 , not USB. This means we can unplug the Tuya Dongle and flash it without worrying about the PCI micro. Excellent. U1RX and U1TX , top right of the module are connected to the USB plug on D- and D+ respectively. This dongle uses a Tuya TYWE1S, which is an ESP8266 with 2MB flash. USB3 pin R- connects the onboard LED to the MCU via a 4k7 resistor. R+ , T+ , and T- are all unused and unconnected on the motor PCB, so I liberated them for soldering to GPIO0 , U0RX and U0TX , to flash the chip. short GPIO0 and flash Tasmota Connect to your Wi-Fi and get MQTT and SSL working change to TuyaMCU with module 54 (will reboot) Switch from U0RX/TX to U1RX/TX with backlog gpio1 0; gpio3 0; gpio15 107; gpio13 108 (will reboot) Treat DpId 0x65 as a Dimmer with tuyamcu 21,101 Allow the dimmer to get down to 1% with setoption69 0 And done. The curtain motor now presents as a Dimmer, with 100% full brightness = fully closed, and 0% full darkness = fully open. The curtain motor also presents DpId 0x66 as a single event \"Full Open\" 00 , \"Full Close\" 01 , and \"Stop\" 02 command; but as of September 2019, I can't see how to get that working. The curtain motor also presents DpId 0x67 as a Boolean. I have only seen value 0x01 in all my prodding. 55 aa 00 07 00 05 67 01 00 01 01 75 = 07 Status, 0005 length, 67 DpId, 01 type, 0001 length, 01 value, 75 checksum Product Links: ~ ZemiSmart DM_WF_MDV4 Leading edge dimmer ~ This is a 240V Leading Edge Dimmer with a TYWE3S controller and an STM8 MCU Flashing: ~ The NRST pin of the STM8 needs to be grounded upon boot to disable it, this is brought out to a header pin, along with ground and VCC from the TYWE3S. Confirm by checking continuity with a multimeter IO0 from the TYWE3s also needs to be grounded upon boot, otherwise it's normal tasmota flashing procedure. Header pins from left to right *VCC *Unknown *Ground *STM8 NRST Config: ~ As per main TuyaMCU page using GPIO Component 01 Tuya Rx (108) 03 Tuya Tx (107) More information: ~ Bought from ebay More information on TYWE3S ] Product Links: ~ AIGLEN ALLOMN MakeGood ZemiSmart","title":"TuyaMCU Devices"},{"location":"TuyaMCU-Devices/#identification-and-technical-details","text":"The basic identification of a Tuya device is when the device information references the \"Tuya Smart\", \"SmartLife\", or \"Smart Living\" app. These switches and dimmers are based on a Tuya TYWE3S Wi-Fi PCB module along with an MCU. TYWE3S is based on the ESP8266 which is supported by Tasmota. Wiki page for TYWE3S The TYWE3S module mostly takes care of Wi-Fi and software features while the MCU controls the actual hardware (buttons, relays, dimmer, power measurement, etc). The MCU is interfaced to TYWE3S using the serial interface which connects to the Rx and Tx pins. The easiest way to identify if your switch or dimmer uses MCU is by using a continuity tester (multimeter, ohmmeter) and checking continuity from the Rx and Tx pins on TYWE3S to any other chip. Then check the datasheet of that chip to see if it is an MCU.","title":"Identification and Technical details"},{"location":"TuyaMCU-Devices/#flashing-preparation","text":"To boot the TYWE3S in flashing mode, GPIO0 needs to be connected to GND while powering up. It can be left grounded for the entire process. Flashing a TYWE3S connected to a MCU is a bit trickier than one without MCU. This is due the same Rx Tx pins used by MCU and serial programmer for flashing. The TYWE3S cannot be booted to flash mode with MCU sending data over the same pins. To be able to do that, we need to disable MCU from sending data over Rx and Tx pins. There are few ways to do it: 1. Disconnect TYWE3S module from the rest of board. (Naah, too much work) 2. Just break the Rx track from MCU to TYWE3S, flash and then reconnect. (Messy work, we want cleaner approach) 3. Just keep MCU disabled while flashing TYWE3S without any soldering / cutting. (We like that) The easiest is to keep MCU disabled is by identifying the NRST/RST (Reset) pin of the MCU from its datasheet and connect it to GND for the entire flashing process. This will keep MCU disabled while you flash TYWE3S. If there are some contacts or test points in switches that connect to the MCU, you might be lucky to find contacts for RST that you can easily solder onto.","title":"Flashing - Preparation"},{"location":"TuyaMCU-Devices/#tywe3s-connection-options","text":"3D print a flashing Jig and use pogo pins to make nice and easy to use flashing jig Solder wires directly onto TYWE3S Use a jumper header like the one below and bend the pins to match VCC, Rx Tx GPIO0 and GND. You can just press the jumper header to the contacts during the flashing process","title":"TYWE3S Connection Options"},{"location":"TuyaMCU-Devices/#flashing-process","text":"Once you are done identifying the pins and ready to connect, BEFORE connecting USB to PC you need to connect them as follows: NOTE : Use 3.3V NOT 5V TYWE3S Serial Programmer RX TX TX RX GPIO0 GND GND GND VCC 3.3V If an MCU is present, bridge RST to GND on the MCU Use a 6.6.0.10 Tasmota version or higher. There are lots of Tuya Serial fixes / features added in there and the tutorial below expects them. Now you need to follow the commands explained in the flashing tutorial . TIP: If you are using jumper headers use sleep 15 && before your commands, this would free your hand and give you some time to set the jumper pins and connect the USB to PC.","title":"Flashing - Process"},{"location":"TuyaMCU-Devices/#configuration","text":"Once Tasmota is flashed on the TYWE3S, just disconnect GND -> GPIO0 (and RST if there is an MCU), and power your device again from USB. On your PC, you should see a Wi-Fi network named sonoff-xxxx where xxxx is a number from the ESP's MAC address. Connect to it and go to 192.168.4.1 in your browser. Enter the Wi-Fi credentials for your network and click save. Connect your PC back to your network. Now you need to find the IP of newly connected Tasmota device. Refer to this very good video from SuperHouseTV (ignore flashing information) about configuring Tasmota. Once you get to the Tasmota configuration you need to select TuyaMCU module assign GPIO components as indicated below depending on your hardware. You already know the pin connections to the MCU. GPIO Component 01 Tuya Rx (108) 03 Tuya Tx (107) 13 Tuya Rx (108) 15 Tuya Tx (107) If the device is connecting fine to your network, now is the time to power it down and re-assemble it. Connect a test bulb (or to the final place if you don't mind testing there) Once this is saved and device is rebooted. Open the Tasmota configuration page and you should be able to use the Toggle button to toggle the dimmer or at least one of the gangs in a multi gang switch. Follow the process here depending on switch or dimmer.","title":"Configuration"},{"location":"TuyaMCU-Devices/#product-specific-guides","text":"","title":"Product Specific guides"},{"location":"TuyaMCU-Devices/#otim-dimmer","text":"This Device is based on a Tuya Wi-Fi Module. Refer to \"MCU Based Tuya Dimmers and Switches\" for details. Flashing and Setup Video Guide These devices use a Tuya TYWE3S Wi-Fi PCB module. Once the switch is carefully popped open you will need to remove the ribbon cables for flashing and ease of soldering. An easy soldering method is to take several Dupont style jumper wires, cut one end off, and apply a bit of solder to each stripped end. This will keep the wire flexible and prevent any circuit board pads from ripping off. Apply a bit of solder to each pad necessary to flash (double check your pin-outs). Once the wire and pad have solder simply put the two together and apply a bit of heat and they will join together. Attach the GPIO0 wire to ground during initial boot to flash. You may need to also connect MCU RST to GND during initial boot to get it into programming mode as described here . A 3-pin header bridged together works great with GPIO0, GND and the GND from the USB flasher attached. (TX pin to RX pin and RX pin to TX pin on USB flash adapter). Verify that you are using 3.3volts to flash, NOT 5V! Product Links: Oittm Moes DS01 ( Template ) Konesky Heygo","title":"Otim Dimmer"},{"location":"TuyaMCU-Devices/#costco-charging-essentials","text":"This devices use a Tuya TYWE1S Wi-Fi PCB module. And it uses U1TX (GPIO15) and U1RX (GPIO13) to communicate between ESP8266 and MCU, no other GPIO is used in this device.","title":"Costco Charging Essentials"},{"location":"TuyaMCU-Devices/#touch-eu-and-us-multiple-manufacturers","text":"","title":"Touch (EU and US) - Multiple manufacturers"},{"location":"TuyaMCU-Devices/#product-links","text":"AIGLEN ALLOMN MakeGood","title":"Product Links:"},{"location":"TuyaMCU-Devices/#zemismart-curtain-motor","text":"Curtain motors come in a confusing array. This one has a little Wi-Fi dongle, that looks like a USB stick. But it talks using 9600 8N1 , not USB. This means we can unplug the Tuya Dongle and flash it without worrying about the PCI micro. Excellent. U1RX and U1TX , top right of the module are connected to the USB plug on D- and D+ respectively. This dongle uses a Tuya TYWE1S, which is an ESP8266 with 2MB flash. USB3 pin R- connects the onboard LED to the MCU via a 4k7 resistor. R+ , T+ , and T- are all unused and unconnected on the motor PCB, so I liberated them for soldering to GPIO0 , U0RX and U0TX , to flash the chip. short GPIO0 and flash Tasmota Connect to your Wi-Fi and get MQTT and SSL working change to TuyaMCU with module 54 (will reboot) Switch from U0RX/TX to U1RX/TX with backlog gpio1 0; gpio3 0; gpio15 107; gpio13 108 (will reboot) Treat DpId 0x65 as a Dimmer with tuyamcu 21,101 Allow the dimmer to get down to 1% with setoption69 0 And done. The curtain motor now presents as a Dimmer, with 100% full brightness = fully closed, and 0% full darkness = fully open. The curtain motor also presents DpId 0x66 as a single event \"Full Open\" 00 , \"Full Close\" 01 , and \"Stop\" 02 command; but as of September 2019, I can't see how to get that working. The curtain motor also presents DpId 0x67 as a Boolean. I have only seen value 0x01 in all my prodding. 55 aa 00 07 00 05 67 01 00 01 01 75 = 07 Status, 0005 length, 67 DpId, 01 type, 0001 length, 01 value, 75 checksum","title":"Zemismart Curtain Motor"},{"location":"TuyaMCU-Devices/#product-links_1","text":"ZemiSmart","title":"Product Links:"},{"location":"TuyaMCU-Devices/#dm_wf_mdv4-leading-edge-dimmer","text":"This is a 240V Leading Edge Dimmer with a TYWE3S controller and an STM8 MCU","title":"DM_WF_MDV4 Leading edge dimmer"},{"location":"TuyaMCU-Devices/#flashing","text":"The NRST pin of the STM8 needs to be grounded upon boot to disable it, this is brought out to a header pin, along with ground and VCC from the TYWE3S. Confirm by checking continuity with a multimeter IO0 from the TYWE3s also needs to be grounded upon boot, otherwise it's normal tasmota flashing procedure. Header pins from left to right *VCC *Unknown *Ground *STM8 NRST","title":"Flashing:"},{"location":"TuyaMCU-Devices/#config","text":"As per main TuyaMCU page using GPIO Component 01 Tuya Rx (108) 03 Tuya Tx (107)","title":"Config:"},{"location":"TuyaMCU-Devices/#more-information","text":"Bought from ebay More information on TYWE3S ]","title":"More information:"},{"location":"TuyaMCU-Devices/#product-links_2","text":"AIGLEN ALLOMN MakeGood ZemiSmart","title":"Product Links:"},{"location":"TuyaMCU/","text":"TuyaMCU - Module (54) is configured for devices with a Tuya Wi-Fi module and a secondary MCU. Originally, in those devices, the Wi-Fi module takes care of network and software features. Meanwhile, the MCU controls the hardware based on commands received from the Wi-Fi module or built-in controls (buttons, switches, remotes and similar) and reports the status back to the Wi-Fi module. TuyaMCU module facilitates communication between Tasmota and the MCU using Tuya Serial Port Communication Protocol : TuyaMCU command maps device functions to Tasmota components TuyaSend<x> command calculates and sends complex serial commands using only two parameters TuyaReceived MCU response interpreted and publishes as status message and a JSON payload to an MQTT topic Warning Used only if your device is defined as module TuyaMCU (54) . Command value consists of two comma separated parameters: fnId and dpId. TuyaMCU <fnId>,<dpId> Example TuyaMCU 11,1 maps Relay1 (fnId 11) to dpId 1. If any existing entry with same fnId or dpId is already present, it will be updated to the new value. Entry is removed when fnId or dpId is 0 . When no parameters are provided TuyaMCU prints the current mapped values. dpId ~ All the device functions controlled by the MCU are identified by a dpId. Whenever a command is sent to the MCU, this dpId determines which component needs to be controlled and the applies when the status is received from MCU. There is no way to autodetect dpId's and their functions. Use this procedure to determine which dpId's are available: Go to Configure -> Console option in Tasmota web interface. Use command weblog 4 to enable verbose logging in web interface. Observe the log. After every 9-10 seconds you should see log messages similar to: json TYA: Heartbeat TYA: RX Packet: \"55aa0107000501010001000f\" TYA: FnId=0 is set for dpId=1 TYA: RX Packet: \"55aa01070005020100010010\" TYA: FnId=0 is set for dpId=2 TYA: RX Packet: \"55aa01070005030100010011\" TYA: FnId=0 is set for dpId=3 TYA: RX Packet: \"55aa01070005040100010012\" TYA: FnId=0 is set for dpId=4 TYA: RX Packet: \"55aa0107000807020004000000001c\" TYA: FnId=0 is set for dpId=7 TYA: RX Packet: \"55aa0107000808020004000000001d\" TYA: FnId=0 is set for dpId=8 TYA: RX Packet: \"55aa0107000809020004000000001e\" TYA: FnId=0 is set for dpId=9 TYA: RX Packet: \"55aa010700080a020004000000001f\" TYA: FnId=0 is set for dpId=0 TYA: RX Packet: \"55aa0107000865020004000000007a\" TYA: FnId=0 is set for dpId=101 TYA: RX Packet: \"55aa0107000866020004000000007b\" TYA: FnId=0 is set for dpId=102 TYA: RX Packet: \"55aa0107000867020004000000007c\" TYA: FnId=0 is set for dpId=103 TYA: RX Packet: \"55aa0107000868020004000009870d\" TYA: FnId=0 is set for dpId=104 Observe all lines printed as TYA: FnId=0 is set for dpId=XXX and note all dpId values. Now that you have a list of usable dpId's you need to determine what their functions are: Consulting our list of commonly used dpId's and existing device configurations Observing Tasmota logs while activating features of the device (with a remote or on device controls) and correlating log messages Extrapolating possible function of the dpId based on Data Type and Function Command, then testing using TuyaSend<x> fnId ~ Identifier used in TuyaMCU command to map a dpId to a Tasmota component. Component FunctionId Note Switch1 to Switch4 1 to 4 Map only to dpId with on / off function Relay1 to Relay8 11 to 18 Map only to dpId with on / off function Dimmer 21 Only on dpId with dimming function Power (in deci Watt) 31 Current (in milli Amps) 32 Voltage (in deci Volt) 33 Relay Inverted1 to Relay Inverted8 41 to 48 Map only to dpId with on / off function Battery powered sensor mode 51 Note This component is under active development which means the function list may expand in the future. Since the majority of devices have a power on/off functions on dpId 1 its mapped to fnId 11 (Relay1) by default. Danger Mapping a relay or switch to a dpId that is not a simple on/off function (data Type 1) might result in unwanted power toggling (f.e. dpId sends value of 4 which toggles the relay to Power 4 aka blink mode) TuyaSend Command ~ Command TuyaSend is used to send commands to dpId's. It is required for dpId's that shouldn't be mapped to a fnId. With this command it is possible to control every function of the dpId that is controllable, providing you know its data type and data length. With them provided, the rest of the protocol command is calculated. Command's value consists of two comma separated parameters: dpId and data. TuyaSend<x> dpId,data There are 4 different commands, one for each data type . TuyaSend1 Sends boolean (Type 1) data ( 0/1 ) to dpId (Max data length 1 byte) Example TuyaSend1 1,0 sends vaue 0 to dpId=1 switching the device off TuyaSend2 Sends integer or 4 byte (Type 2) data to dpId (Max data length 4 bytes) Example TuyaSend2 14,100 sends value 100 to dpId=14 setting timer to 100 minutes TuyaSend3 Sends string (Type 3) data to dpId (Max data length? Not known at this time). Warning Note that when sending color values, the MCU may interpret lower case and upper case hex codes differently. You may need to test with your specific MCU to ensure that the values sent properly render the color you desire. Example TuyaSend3 108,ff0000646464ff sends a 14 char hex string to dpId=108 (Type 3) containing RGBHSV values to control a light TuyaSend4 Sends enum (Type 4) data ( 0/1/2/3/4/5 ) to dpId (Max data length 1 bytes) Example TuyaSend4 103,2 sends value 2 to dpId=103 to set fan speed to high TuyaReceived ~ Every status message from the MCU gets a JSON response named TuyaReceived which contains the MCU protocol status message inside key/value pairs which are hidden from the user by default. To publish them to an MQTT Topic of tele/%topic%/RESULT you need to enable SetOption66 1 . Example After issuing serial command 55aa0006000501010001010e (Device power (dpId=1) is mapped to Relay1 (fnId=11)) we get the following console output (with weblog 4 ): 19 : 54 : 18 TYA : Send \"55aa0006000501010001010e\" 19 : 54 : 18 MQT : stat /GD-30W/ STATE = { \"Time\" : \"2019-10-25T19:54:18\" , \"Uptime\" : \"0T01:45:51\" , \"UptimeSec\" : 6351 , \"Heap\" : 27 , \"SleepMode\" : \"Dynamic\" , \"Sleep\" : 0 , \"LoadAvg\" : 999 , \"MqttCount\" : 1 , \"POWER1\" : \"ON\" , \"POWER2\" : \"OFF\" , \"POWER3\" : \"ON\" , \"POWER4\" : \"OFF\" , \"POWER5\" : \"ON\" , \"Dimmer\" : 100 , \"Fade\" : \"OFF\" , \"Speed\" : 1 , \"LedTable\" : \"OFF\" , \"Wifi\" :{ \"AP\" : 1 , \"SSId\" : \"HTPC\" , \"BSSId\" : \"50:64:2B:5B:41:59\" , \"Channel\" : 10 , \"RSSI\" : 24 , \"LinkCount\" : 1 , \"Downtime\" : \"0T00:00:08\" }} 19 : 54 : 18 MQT : stat /GD-30W/ RESULT = { \"POWER1\" : \"ON\" } 19 : 54 : 18 MQT : stat /GD-30W/ POWER1 = ON 19 : 54 : 18 MQT : stat /GD-30W/ RESULT = { \"TuyaReceived\" :{ \"Data\" : \"55AA0007000501010001010F\" , \"ChkSum\" : \"0x0F\" , \"Cmnd\" : 7 , \"CmndDataLen\" : 5 , \"CmndData\" : \"0101000101\" , \"DpId\" : 1 , \"DpIdType\" : 1 , \"DpIdLen\" : 1 , \"DpIdData\" : \"01\" }} 19 : 54 : 18 TYA : fnId = 11 is set for dpId = 1 19 : 54 : 18 TYA : RX Relay - 1 --> MCU State : On Current State : On Above TYA: fnId=11 is set for dpId=1 you can see the JSON response for that dpId. This JSON string displays the response MCU gave to our command. \"Data\" field contains the complete response and the rest of the key/value pairs show the protocol broken into parts. \"DpId\", \"DpIdData\" and \"DpIdType\" are the ones we're most interested in since we can use them for TuyaSend . Tip Use command SerialSend5 55aa0001000000 at any time to request statuses of all dpId's from the MCU. Use in Rules This data can also be used as a trigger for rules using TuyaReceivedData#Data=hex_string Rule1 on TuyaReceived # Data = 55 AA000700056E040001007E do publish2 stat / tuya_light / effect rgb_cycle endon will publish a status message to a custom topic when 55AA000700056E040001007E appears in \"Data\" field of the response. Device Configurations ~ Before proceeding identify dpId's and their function. Dimmers ~ We need to configure four functions of a dimmer: Dimming dpId Dimming Range Power metering if supported. Dimming less than 10% Dimming dpId The dimmer FunctionId is 21 . On a dimmer dpId generally is 2 or 3 . Try both. Go to the Tasmota Console and type TuyaMCU 21,2 and wait for it to reboot. Enter Backlog Dimmer 10; Dimmer 100 in the Console. If your bulb responds to Dimmer commands, you have successfully configured the dimmer FunctionId. Make note of it. If not try id 3 and if even 3 doesn't work keep trying Ids from all unknown Ids from the log until one works. Dimming Range Once you have figured out the dimming functionId, we need to find the maximum dimming range. Once the dimming Id is set, the logs will continue TYA : Heartbeat TYA : RX Packet : \"55aa03070005010100010011\" TYA : RX Relay - 1 --> MCU State : Off Current State : Off TYA : RX Packet : \"55aa03070008020200040000000720\" TYA : FnId = 21 is set for dpId = 2 TYA : RX Dim State = 7 Now using the hardware buttons increase the dimmer to its maximum and observe the log. The Dim State=XXX shows the current dimmer level reported by MCU. Once the dimmer is at max, note this number. Again using hardware buttons decrease dimmer to minimum and note the number for minimum. Now we need to tell Tasmota to use maximum and minimum values. This controlled by DimmerRange command. We can set it using DimmerRange <Min>,<Max> where <Min> is the minimum dimmer state and <Max> maximum dimmer state reported in logs. Once set, try dimmer 100 in the Console and check if the brightness of bulb is same is the same as when the maximum was set using hardware buttons. Video instructions by Digiblur Power Metering Some Tuya MCU devices support Power measurement support over serial. For this its better to use a bulb with known wattage rating. Observe the logs in the Console TYA : RX Packet : \"55aa03070005010100010011\" TYA : FnId = 11 is set for dpId = 1 TYA : RX Device - 1 --> MCU State : Off Current State : Off TYA : RX Packet : \"55aa03070008020200040000000720\" TYA : FnId = 21 is set for dpId = 2 TYA : RX Dim State = 7 TYA : RX Packet : \"55aa0307000803020004000000001a\" TYA : FnId = 0 is set for dpId = 3 TYA : RX Packet : \"55aa0307000804020004000000251b\" TYA : FnId = 0 is set for dpId = 4 TYA : RX Packet : \"55aa0307000805020004000000591c\" TYA : FnId = 0 is set for dpId = 5 TYA : RX Packet : \"55aa03070008060200040000098fb5\" TYA : FnId = 0 is set for dpId = 6 In the RX Packet we are interested in the 3 digits before last 2 digits. For example: 98f in \"55aa03070008060200040000098fb5\" Make sure the bulb if off. Find out the voltage standard of your country (generally 220, 240, 120v) from this table . Multiply that number by 10 (2400) and Convert that number (2400) to Hex using any hex converter (2400 = 0x960) Now look for the number nearest to 960 in the logs. In our case it is 98f . So we expect that's the voltage which is ID=6 in our example. Set voltage functionId 33 by entering TuyaMCU 33,6 . Now set dimmer to 100% using the dimmer 100 command and observe the logs. Now we need the power rating of your bulb example 9W . Multiply by 10 (90) and convert to hex which gives us 0x5A. Check which unknown ID is close to 5A . I this example it is 59 for ID=5 . This is the Id of Active Power function. Set the active power functionId 31 by entering TuyaMCU 31,5 . Once Power and Voltage are set you should see something such as this in the logs: TYA: RX Packet: \"55aa03070005010100010011\" TYA: FnId=11 is set for dpId=1 TYA: RX Device-1 --> MCU State: Off Current State:Off TYA: RX Packet: \"55aa03070008020200040000000720\" TYA: FnId=21 is set for dpId=2 TYA: RX Dim State=7 TYA: RX Packet: \"55aa0307000803020004000000001a\" TYA: FnId=0 is set for dpId=3 TYA: RX Packet: \"55aa0307000804020004000000251b\" TYA: FnId=0 is set for dpId=4 TYA: RX Packet: \"55aa0307000805020004000000591c\" TYA: FnId=31 is set for dpId=5 TYA: Rx ID=5 Active_Power=9 TYA: RX Packet: \"55aa03070008060200040000098fb5\" TYA: FnId=33 is set for dpId=6 TYA: Rx ID=6 Voltage=244.7 To get the Id for the current, calculate Current = Power / Voltage ( 9 / 244.7 ) = 0.0367. Multiply this by 1000 = 36.77. Now convert 36 to hex which is 0x24. This is closest to 25 which is Id 4. Set the current FunctionId 32 using command TuyaMCU 32,4 . Observe the logs should start showing TYA: RX Packet: \"55aa03070005010100010011\" TYA: FnId=11 is set for dpId=1 TYA: RX Device-1 --> MCU State: Off Current State:Off TYA: RX Packet: \"55aa03070008020200040000000720\" TYA: FnId=21 is set for dpId=2 TYA: RX Dim State=7 TYA: RX Packet: \"55aa0307000803020004000000001a\" TYA: FnId=0 is set for dpId=3 TYA: RX Packet: \"55aa0307000804020004000000251b\" TYA: FnId=32 is set for dpId=4 TYA: Rx ID=4 Current=312 TYA: RX Packet: \"55aa0307000805020004000000591c\" TYA: FnId=31 is set for dpId=5 TYA: Rx ID=5 Active_Power=9 TYA: RX Packet: \"55aa03070008060200040000098fb5\" TYA: FnId=33 is set for dpId=6 TYA: Rx ID=6 Voltage=2447 Power and current should change on dimming high / low. The Tasmota web UI should show power values now. Switches ~ For switches we need to Configure the number of relays. Configure Power metering. Number of Relays By default, the TuyaMCU module expects a 1 gang switch. There is currenty no way to detect the number of relays present in an MCU based switch. We need to tell the number of relays to Tasmota using FunctionIDs 12 to 18 for Relay2 to Relay4. Example For a 4 gang switch set TuyaMCU 12,2 , TuyaMCU 13,3 and TuyaMCU 14,4 if the dpIds for Relays 2-4 are 2 , 3 , 4 . Tip You can configure all at once by using Backlog TuyaMCU 12,2; TuyaMCU 13,3; TuyaMCU 14,4 Power Metering Power metering configuration is same as for dimmers . Curtain Motors ~ The Zemismart WiFi curtain motor uses a Tuya TYWE1S inside the little white dongle as a radio modem. U1TX is connected to \"USB D+\", U1RX is connected to \"USB D-\", and there is a blue LED in the dongle connected to \"USB3 R-\" controlled by the MCU. To flash Tasmota, we need U0RX , U0TX , and GPIO0 . None of which are broken out on the PCB, so soldering or Tuya-Convert are necessary. The stock Tuya App communicates with the PIC Micro inside the motor housing at 9600 8N1. dpId 101 is the \"partial open/partial close\" command with a 4 byte field of 0-100%. dpId 102 is a \"fully open/fully close\" command with a 1-byte Boolean field. dpId 103 is unknown. Debugging 55 aa 00 06 \"deliver dp\" 0005 \"len=5\" 66 04 00 01 <00=close100%,01=open0%> <chksum> is the fully open/close command 07 \"report dp\" 0005 (len) 66 04 00 01 <00 or 01> <chksum> is the reply. 55 aa 00 06 \"deliver dp\" 0008 (len=8) 65 02 00 04 <value.32 <chksum> is the move partial command 55 aa 00 07 \"report dp\" 0008 (len=8) 65 02 00 04 <value.32> <chksum> is the reply. There may first be a reply of 65 02 00 04 before the motor engages dpId Configuration module 54 # TuyaMCU (will reboot) backlog gpio1 0; gpio3 0; gpio15 107; gpio13 108 # change GPIO assignments. The dongle uses gpio15 for U1TX and gpio13 for U1RX (will reboot) tuyamcu 21,101 # declare curtain as a dimmer (will reboot) # no idea what a good tuyamcu xx,102 is # no idea what a good tuyamcu xx,103 is setoption 69 0 # allow dimmer below 25% or 10%. (won't reboot) With these settings, the dimmer command can adjust the curtain from 100% (closed) to 1% (almost fully open, 0% is the motor limit, but 1% is the Tasmota limit?) Things That Did Not Work tuyamcu 1 , 102 # make 0x66 a button tuyamcu 1 , 103 # make 0x67 a button Having 0x66 declared a button caused the motor to oscillate - open part way and then close again. Like Tasmota was sending the \"fully open\" command and then immediately cancelling it with a \"partial close\" command. tuyamcu 11 , 102 # make 0x66 a relay tuyamcu 11 , 103 # make 0x67 a relay Does not appear to have any impact on the curtain. Aromatherapy Diffuser ~ Applies to devices using the PCB marked GD-HDFW05-v1.0. This diffuser uses the same dpId scheme as the example protocol Functions dpID 1 device power: 0 = off / 1 = on dpID 11 led power: 0 = off / 1 = on dpID 12 error notification: 0 = ok / 1 = error dpID 13 countdown mode options: 0 = off / 1 = 1hr / 2 = 3hr not needed with Tasmota dpID 14 countdown status: reports value of 0...360 minutes not needed with Tasmota dpID 103 mist strength: 0 = low / 1 = high dpID 108 led color: 14 char value in hex (can define only RGB and send HSV value as max: RRGGBBffff6464 ) dpID 110 led mode: 0 = rgb_cycle / 1 = color / 2 = white dpID 110 led dimmer color and white modes only it is important to define 'DimmerRange 1,255' Configuration After applying the template and configuring Wi-Fi and MQTT issue Backlog SetOption66 1 ; TuyaMCU 21 , 111 ; TuyaMCU 11 , 1 ; TuyaMCU 12 , 11 ; TuyaMCU 13 , 103 ; TuyaMCU 14 , 12 ; TuyaMCU 15 , 110 ; DimmerRange 1 , 255 ; SetOption59 1 Rule1 on TuyaReceived # data = 55 AA000700056E040001007E do publish2 stat / GD - 30 W / EFFECT rgb_cycle endon on TuyaReceived # data = 55 AA000700056E040001017F do publish2 stat / GD - 30 W / EFFECT color endon on event # rgb_cycle do tuyasend4 110 , 0 endon on event # color do tuyasend4 110 , 1 endon on event # ON do backlog tuyasend4 110 , 1 ; tuyasend 11 , 1 endon on event # off do tuyasend1 11 , 0 endon on power3 # state = 1 do tuyasend4 103 , 1 endon on power3 # state = 0 do tuyasend4 103 , 0 endon Rule1 1 Optional rule used to prevent the device going into countdown mode (f.e. using on device controls) and complete MCU status update on restart Rule3 on TuyaReceived # data = 55 AA000700050D040001011E do tuyasend4 13 , 0 endon on TuyaReceived # data = 55 AA000700050D040001021F do tuyasend4 13 , 0 endon on mqtt # connected do serialsend5 55 aa0001000000 endon Rule3 1 All commands in .txt What you get Relay1 turns the diffuser on or off in stored mist strength mode, turns led on or off in stored mode and serves as device power status Relay2 turns light on or off and serves as light power status. Relay3 mist strength status and control using Rule1 Relay4 is used for error status (ON = error), no control Relay5 is used for light mode status (0 = rgb_cycle, 1 = color), no control LED mode status is reported to mqtt topic stat/GD-30W/EFFECT and command Event is used to control some functions using TuyaSend4 command. All this is defined in Rule1 Color can be changed using TuyaSend3 108,RRGGBB64646464 (RR, GG and BB are hex value) only in color mode. Dimming works using slider and Dimmer command but only when in color mode, in rgb_cycle there are no brightness controls. Long press on device's power button initiates Tasmota's Wi-Fi config Battery Powered Door Window Sensor ~ Read more here... Tuya Protocols ~ The MCU communicates with the Wi-Fi module through the serial port with a Tuya specified protocol. Those are classified into basic and functional protocols. Basic protocols ~ They are common protocols integrated in Tasmota's TuyaMCU module. They stay the same for each product and are mandatory for Tuya module to work correctly. Functional protocols ~ Functional protocols are used for delivering and reporting data of functions. These protocols differ between devices and manufacturers and might require configuration in Tasmota using TuyaMCU command or with TuyaSend<x> command. Anatomy of Functional Protocols ~ Name Description Frame Header Version Fixed value of 0x55aa Command Word 0x06 - send commands 0x07 - report status Data Length defines expected length of data dpID numbered ID of a function (DP = Data Point or Define Product) Data Type see Data Type table below Function Length length of command Function Command formatted according to Data Type Verification Method checksum = remainder of the byte sum starting from Frame Header to 256 Data Type Hex Tasmota Command Decription Max length 0x01 TuyaSend1 boolean data 0/1 1 byte 0x02 TuyaSend2 value data. If a value contains less than 4 bytes, 0 is supplemented before 4 bytes 0x00 TuyaSend3 string data unknown 0x04 TuyaSend4 enum data 0/1/2/3/4/5 1 byte 0x05 ### fault data, report only 8 bytes Let's dissect and explain the MCU protocol using serial command 55aa0006000501010001010e : Frame Header Version Command Word Data Length dpID Data Type Function Length Function Command Verification Method 55aa00 06 0005 01 01 0001 01 0e This is the command which powers on the device sending Function Command = 1 to dpID 1 (Switch): - Frame Header Version = 0x55aa00 which is a fixed value and always the same - Command Word = 0x06 because we're sending a command - Data Type = 0x01 since the command sent is a 1 byte boolean - Function Length = 0x001 instruct 1 character only for function command length - Function Command = 0x01 in hex which equals 1 in int - Verification Method = 0e is calculated Protocol flow ~ On device boot, TuyaMCU executes the required basic protocols and reads the functional protocol data received, which are used to update status of components mapped in TuyaMCU (Relays, dimmer, power monitoring data). After receiving a command from Tasmota (Command Word 0x06 ), the MCU performs corresponding logical control. When the dpID status is changed, the MCU reports the data (Command Word 0x07 ) to TuyaMCU component. dpId Function Tables ~ This information is just for orientation. Functions are assigned by the manufacturer and can be on different dpId's DP ID: dpId. Function Point\uff1aUsed to describe the product function. Identifier: Function codename. Can only be letters, numbers and underscores Data type\uff1a Issue and report: command data can be sent and status data can be reported back to the Wi-Fi module Report only: supports only status reporting, no control options Function Type (Referred as Data Type in Tuya Protocols article): Boolean (bool): non-true or false binary variable, such as: switch function, on / off Value (value): suitable for linear adjustment of the type of data, such as: temperature regulation, temperature range 20-40 \u2103 Enum (enum): custom finite set value, such as: working levels, low / mid / high Fault (fault): dedicated to reporting and statistical failure of the function points. Support multi-fault, the data is reported only Integer\uff08integer\uff09: transmitted as integer Transparent (raw): data in binary Switches or Plugs/Power Strips ~ DP ID Identifier Data type Function type Properties 1 switch_1 Control and report Boolean 2 switch_2 Control and report Boolean 3 switch_3 Control and report Boolean 4 switch_4 Control and report Boolean 5 switch_5 Control and report Boolean 9 countdown_1 Control and report Integer undefined0-86400, undefined1, Scale0, Unit:s 10 countdown_2 Control and report Integer undefined0-86400, undefined1, Scale0, Unit:s 11 countdown_3 Control and report Integer undefined0-86400, undefined1, Scale0, Unit:s 12 countdown_4 Control and report Integer undefined0-86400, undefined1, Scale0, Unit:s 13 countdown_5 Control and report Integer undefined0-86400, undefined1, Scale0, Unit:s Aromatherapy Machine (Oil Diffuser) ~ DP ID Function points Identifier Data type Function type Properties 1 Switch Power Issue and report Boolean 6 Amount of fog fog Issue and report Enum Enumerated values:small, large 11 Light Light Issue and report Boolean 12 Fault alarm fault Only report Fault Barrier values:1 13 Countdown countdown Issue and report Enum Enumerated values: 0, 1, 2, 3 14 Countdown remaining time countdown_left Only report Integer Values range: 0-360, Pitch1, Scale0, Unit:min 101 Light mode work_mode Issue and report Enum Enumerated values: white, colour, scene, scene1, scene2, scene3, scene4 102 Color value colour_data Issue and report Char type *see below 103 Light mode lightmode Issue and report Enum Enumerated values: 1, 2, 3 104 Brightness setting setlight Issue and report Integer Values range: 0-255, Pitch1, Scale0, Unit:\\% colour_data format of the lights is a string of 14 characters, for example, 00112233334455, where 00 indicates R, 11 indicates G, 22 indicates B, 3333 indicates the hue, 44 indicates the saturation, and 55 indicates the value. The initial value is saved by default. If you do not want to adjust the light, set the data to the maximum value 100% (0x64). The last four characters have fixed values. Curtain Motor ~ DP ID Function points Identifier Data type Function type Properties 1 Percentage percent_state Only report Integer Values range:0-100, Pitch1, Scale0, Unit:% 2 Motor Direction control_back Issue and report Boolean 3 Auto Power auto_power Issue and report Boolean 4 Left time countdown Issue and report Enum Enumerated values:cancel, 1, 2, 3, 4 5 Total Time time_total Only report Integer Values range:0-120000, Pitch1, Scale0, Unit:m Complete document on protocols Power Monitoring Plug ~ DP ID Function points Identifier Data type Function type Properties 1 switch_1 switch_1 Control and report Boolean 9 countdown_1 countdown_1 Control and report Integer undefined0-86400, undefined1, Scale0, Unit:s 17 statistics Function add_ele Control and report Integer undefined0-50000, undefined100, Scale3, Unit: 18 current cur_current Data report Integer undefined0-30000, undefined1, Scale0, Unit:mA 19 power cur_power Data report Integer undefined0-50000, undefined1, Scale1, Unit:W 20 voltage cur_voltage Data report Integer undefined0-5000, undefined1, Scale1, Unit:V 21 test flag test_bit Data report Integer undefined0-5, undefined1, Scale0, Unit: 22 voltage coefficient voltage_coe Data report Integer undefined0-1000000, undefined1, Scale0, Unit: 23 current coefficient electric_coe Data report Integer undefined0-1000000, undefined1, Scale0, Unit: 24 power coefficient power_coe Data report Integer undefined0-1000000, undefined1, Scale0, Unit: 25 statistics coefficient electricity_coe Data report Integer undefined0-1000000, undefined1, Scale0, Unit: 26 warning fault Data report Fault Barrier values:ov_cr Dehumidifier ~ DP ID Function points Identifier Data type Function type Properties 1 Switch Switch Issue and report Boolean 2 PM2.5 PM25 Only report Integer Values range:0-999, Pitch1, Scale0, Unit: 3 Work mode Mode Issue and report Enum Enumerated values:Manual, Auto, Sleep 4 Wind speed Speed Issue and report Enum Enumerated values:speed1, speed2, speed3, speed4, speed5 5 Filter usage Filter Only report Integer Values range:0-100, Pitch1, Scale0, Unit:% 6 Fresh Anion Issue and report Boolean 7 Child lock Lock Issue and report Boolean 9 UV light UV Issue and report Boolean 11 Filter reset FilterReset Issue and report Boolean 12 indoor temp Temp Only report Integer Values range:-20-50, Pitch1, Scale0, Unit:\u2103 13 Indoor humidity Humidity Only report Integer Values range:0-100, Pitch1, Scale0, Unit:% Lighting ~ DP ID Function points Identifier Data type Function type Properties 1 Switch led_switch Control and report Boolean 2 Mode work_mode Control and report Enum Enumerated values:white, colour, scene, scene_1, scene_2, scene_3, scene_4 3 Bright bright_value Control and report Integer undefined25-255, undefined1, Scale0, Unit: 5 Colour mode colour_data Control and report Char type 6 Scene scene_data Control and report Char type 7 Scene1 flash_scene_1 Control and report Char type 8 Scene2 flash_scene_2 Control and report Char type 9 Scene3 flash_scene_3 Control and report Char type 10 Scene4 flash_scene_4 Control and report Char type Contact Sensor ~ DP ID Function points Identifier Data type Function type Properties 1 Door Sensor doorcontact_state Only report Boolean 2 Battery Level battery_percentage Only report Integer Values range:0-100, Pitch1, Scale0, Unit:% 3 Battery Level battery_state Only report Enum Enumerated values:low, middle, high 4 Anti-remove Alarm temper_alarm Only report Boolean Air purifier ~ DP ID Function points Identifier Data type Function type Properties 1 Switch Switch Issue and report Boolean 2 PM2.5 PM25 Only report Integer Values range:0-999, Pitch1, Scale0, Unit: 3 Work mode Mode Issue and report Enum Enumerated values:Manual, Auto, Sleep 4 Wind speed Speed Issue and report Enum Enumerated values:speed1, speed2, speed3, speed4, speed5 5 Filter usage Filter Only report Integer Values range:0-100, Pitch1, Scale0, Unit:% 6 Fresh Anion Issue and report Boolean 7 Child lock Lock Issue and report Boolean 9 UV light UV Issue and report Boolean 11 Filter reset FilterReset Issue and report Boolean 12 indoor temp Temp Only report Integer Values range:-20-50, Pitch1, Scale0, Unit:\u2103 13 Indoor humidity Humidity Only report Integer Values range:0-100, Pitch1, Scale0, Unit:% Heater ~ DP ID Function points Identifier Data type Function type Properties 1 Switch Power Issue and report Boolean 2 Target temperature TempSet Issue and report Integer Values range:0-37, Pitch1, Scale0, Unit:\u2103 3 Current Temperature TempCurrent Only report Integer Values range:-9-99, Pitch1, Scale0, Unit:\u2103 4 Mode Mode Issue and report Enum Enumerated values:m, p 5 Fault alarm Fault Only report Fault Barrier values:1, 2, 3 6 Gear position gear Issue and report Enum Enumerated values:low, mid, high, off 7 Conservation eco_mode Issue and report Boolean Smart fan ~ DP ID Function points Identifier Data type Function type Properties 1 Switch switch Issue and report Boolean 2 Wind Speed Level fan_speed Issue and report Enum Enumerated values:1, 2, 3, 4 3 Left-and-Right Swing fan_horizontal Issue and report Enum Enumerated values:on, off 4 Up-and-Down Swing fan_vertical Issue and report Enum Enumerated values:on, off 5 Fault Alarm fault Only report Fault Barrier values:1, 2 6 Anion anion Issue and report Boolean 7 Humidify humidifier Issue and report Boolean 8 Oxygen oxygan Issue and report Boolean 9 Child Lock lock Issue and report Boolean 10 Cool fan_cool Issue and report Boolean 11 Set Temperate temp Issue and report Integer Values range:0-50, Pitch1, Scale0, Unit:\u2103 12 Current Temperature temp_current Only report Integer Values range:0-50, Pitch1, Scale0, Unit:\u2103 Kettle ~ DP ID Function points Identifier Data type Function type Properties 1 Working switch start Issue and report Boolean 2 Heat to target temperature shortcut (\u00b0C) temp_setting_quick_c Issue and report Enum Enumerated values:50, 65, 85, 90, 100 3 Heat to target temperature shortcut (\u00b0F) temp_setting_quick_f Issue and report Enum Enumerated values:122, 149, 185, 194, 212 4 Cool to the target temperature shortcut after boiling (\u00b0C) temp_boiling_quick_c Issue and report Enum Enumerated values:50, 65, 85, 90, 100 5 Cool to the target temperature shortcut after boiling (\u00b0F) temp_boiling_quick_f Issue and report Enum Enumerated values:122, 149, 185, 194, 212 6 Temperature scale switching temp_unit_convert Issue and report Enum Enumerated values:c, f 7 Insulation switch switch_keep_warm Issue and report Boolean 8 Holding time setting keep_warm_setting Issue and report Integer Values range:0-360, Pitch1, Scale0, Unit:min 9 Mode work_type Issue and report Enum Enumerated values: setting_quick, boiling_quick, temp_setting, temp_ BecaThermostat(WIP) ~ DP ID Function points Identifier Data type Function type Properties 1 Switch Power Issue and report Boolean 2 Target temperature TempSet Issue and report Integer Values range:0-37, Pitch1, Scale0, Unit:\u2103 3 Current Temperature TempCurrent Only report Integer Values range:-9-99, Pitch1, Scale0, Unit:\u2103 4 Mode Mode Issue and report Enum Enumerated values:m, p (wip) 102 Floor Temperature FloorCurrent Issue and report Integer Values range:0-37, Pitch1, Scale0, Unit:\u2103 Inkbird ITC-308-Wifi Temperature controller with individual plug in sockets for heating/cooling ~ DP ID Function points Identifier Data type Function type Properties 101 Temperature unit Cf Issue and report Integer 0=C, 1=F 102 Calibration Ca Issue and report Integer Unit is 0.1C 104 Temperature sensor Issue and report Integer Unit is 0.1C 106 Temperature set point Ts Issue and report Integer Unit is 0.1C 108 Compressor delay time Pt Issue and report Integer Unit is minutes 109 Alarm high temperature Ah Issue and report Integer Unit is 0.1C 110 Alarm low temperature Al Issue and report Integer Unit is 0.1C, For negative values use -(0xFFFFFFFF - value) 115 Relay status Only report Integer 01=cool, 02=off, 03=heating 116 Temperature sensor Issue and report Integer Unit is 0.1F 117 Heating differential value Hd Issue and report Integer Unit is 0.1C 118 Cooling differential value Cd Issue and report Integer Unit is 0.1C The unit will constantly be sending the temperature sensor value in celcius and fahrenheit: 104 and 116. To trigger the unit to send all settings, send any value to a non-used register, e.g. TuyaSend1 2,1 Example: Tasmota command Result TuyaSend1 2,1 Trigger the unit to reveal all settings TuyaSend2 106,250 Change set-point to 25.0C TuyaSend2 101,1 Change units to Fahrenheit Further Reading ~ TuyaMCU Flashing and Device Configuration","title":"TuyaMCU"},{"location":"TuyaMCU/#dpid","text":"All the device functions controlled by the MCU are identified by a dpId. Whenever a command is sent to the MCU, this dpId determines which component needs to be controlled and the applies when the status is received from MCU. There is no way to autodetect dpId's and their functions. Use this procedure to determine which dpId's are available: Go to Configure -> Console option in Tasmota web interface. Use command weblog 4 to enable verbose logging in web interface. Observe the log. After every 9-10 seconds you should see log messages similar to: json TYA: Heartbeat TYA: RX Packet: \"55aa0107000501010001000f\" TYA: FnId=0 is set for dpId=1 TYA: RX Packet: \"55aa01070005020100010010\" TYA: FnId=0 is set for dpId=2 TYA: RX Packet: \"55aa01070005030100010011\" TYA: FnId=0 is set for dpId=3 TYA: RX Packet: \"55aa01070005040100010012\" TYA: FnId=0 is set for dpId=4 TYA: RX Packet: \"55aa0107000807020004000000001c\" TYA: FnId=0 is set for dpId=7 TYA: RX Packet: \"55aa0107000808020004000000001d\" TYA: FnId=0 is set for dpId=8 TYA: RX Packet: \"55aa0107000809020004000000001e\" TYA: FnId=0 is set for dpId=9 TYA: RX Packet: \"55aa010700080a020004000000001f\" TYA: FnId=0 is set for dpId=0 TYA: RX Packet: \"55aa0107000865020004000000007a\" TYA: FnId=0 is set for dpId=101 TYA: RX Packet: \"55aa0107000866020004000000007b\" TYA: FnId=0 is set for dpId=102 TYA: RX Packet: \"55aa0107000867020004000000007c\" TYA: FnId=0 is set for dpId=103 TYA: RX Packet: \"55aa0107000868020004000009870d\" TYA: FnId=0 is set for dpId=104 Observe all lines printed as TYA: FnId=0 is set for dpId=XXX and note all dpId values. Now that you have a list of usable dpId's you need to determine what their functions are: Consulting our list of commonly used dpId's and existing device configurations Observing Tasmota logs while activating features of the device (with a remote or on device controls) and correlating log messages Extrapolating possible function of the dpId based on Data Type and Function Command, then testing using TuyaSend<x>","title":"dpId"},{"location":"TuyaMCU/#fnid","text":"Identifier used in TuyaMCU command to map a dpId to a Tasmota component. Component FunctionId Note Switch1 to Switch4 1 to 4 Map only to dpId with on / off function Relay1 to Relay8 11 to 18 Map only to dpId with on / off function Dimmer 21 Only on dpId with dimming function Power (in deci Watt) 31 Current (in milli Amps) 32 Voltage (in deci Volt) 33 Relay Inverted1 to Relay Inverted8 41 to 48 Map only to dpId with on / off function Battery powered sensor mode 51 Note This component is under active development which means the function list may expand in the future. Since the majority of devices have a power on/off functions on dpId 1 its mapped to fnId 11 (Relay1) by default. Danger Mapping a relay or switch to a dpId that is not a simple on/off function (data Type 1) might result in unwanted power toggling (f.e. dpId sends value of 4 which toggles the relay to Power 4 aka blink mode)","title":"fnId"},{"location":"TuyaMCU/#tuyasend-command","text":"Command TuyaSend is used to send commands to dpId's. It is required for dpId's that shouldn't be mapped to a fnId. With this command it is possible to control every function of the dpId that is controllable, providing you know its data type and data length. With them provided, the rest of the protocol command is calculated. Command's value consists of two comma separated parameters: dpId and data. TuyaSend<x> dpId,data There are 4 different commands, one for each data type .","title":"TuyaSend Command"},{"location":"TuyaMCU/#tuyareceived","text":"Every status message from the MCU gets a JSON response named TuyaReceived which contains the MCU protocol status message inside key/value pairs which are hidden from the user by default. To publish them to an MQTT Topic of tele/%topic%/RESULT you need to enable SetOption66 1 .","title":"TuyaReceived"},{"location":"TuyaMCU/#device-configurations","text":"Before proceeding identify dpId's and their function.","title":"Device Configurations"},{"location":"TuyaMCU/#dimmers","text":"We need to configure four functions of a dimmer: Dimming dpId Dimming Range Power metering if supported. Dimming less than 10%","title":"Dimmers"},{"location":"TuyaMCU/#switches","text":"For switches we need to Configure the number of relays. Configure Power metering.","title":"Switches"},{"location":"TuyaMCU/#curtain-motors","text":"The Zemismart WiFi curtain motor uses a Tuya TYWE1S inside the little white dongle as a radio modem. U1TX is connected to \"USB D+\", U1RX is connected to \"USB D-\", and there is a blue LED in the dongle connected to \"USB3 R-\" controlled by the MCU. To flash Tasmota, we need U0RX , U0TX , and GPIO0 . None of which are broken out on the PCB, so soldering or Tuya-Convert are necessary. The stock Tuya App communicates with the PIC Micro inside the motor housing at 9600 8N1. dpId 101 is the \"partial open/partial close\" command with a 4 byte field of 0-100%. dpId 102 is a \"fully open/fully close\" command with a 1-byte Boolean field. dpId 103 is unknown.","title":"Curtain Motors"},{"location":"TuyaMCU/#aromatherapy-diffuser","text":"Applies to devices using the PCB marked GD-HDFW05-v1.0. This diffuser uses the same dpId scheme as the example protocol","title":"Aromatherapy Diffuser"},{"location":"TuyaMCU/#battery-powered-door-window-sensor","text":"Read more here...","title":"Battery Powered Door Window Sensor"},{"location":"TuyaMCU/#tuya-protocols","text":"The MCU communicates with the Wi-Fi module through the serial port with a Tuya specified protocol. Those are classified into basic and functional protocols.","title":"Tuya Protocols"},{"location":"TuyaMCU/#basic-protocols","text":"They are common protocols integrated in Tasmota's TuyaMCU module. They stay the same for each product and are mandatory for Tuya module to work correctly.","title":"Basic protocols"},{"location":"TuyaMCU/#functional-protocols","text":"Functional protocols are used for delivering and reporting data of functions. These protocols differ between devices and manufacturers and might require configuration in Tasmota using TuyaMCU command or with TuyaSend<x> command.","title":"Functional protocols"},{"location":"TuyaMCU/#anatomy-of-functional-protocols","text":"Name Description Frame Header Version Fixed value of 0x55aa Command Word 0x06 - send commands 0x07 - report status Data Length defines expected length of data dpID numbered ID of a function (DP = Data Point or Define Product) Data Type see Data Type table below Function Length length of command Function Command formatted according to Data Type Verification Method checksum = remainder of the byte sum starting from Frame Header to 256","title":"Anatomy of Functional Protocols"},{"location":"TuyaMCU/#protocol-flow","text":"On device boot, TuyaMCU executes the required basic protocols and reads the functional protocol data received, which are used to update status of components mapped in TuyaMCU (Relays, dimmer, power monitoring data). After receiving a command from Tasmota (Command Word 0x06 ), the MCU performs corresponding logical control. When the dpID status is changed, the MCU reports the data (Command Word 0x07 ) to TuyaMCU component.","title":"Protocol flow"},{"location":"TuyaMCU/#dpid-function-tables","text":"This information is just for orientation. Functions are assigned by the manufacturer and can be on different dpId's DP ID: dpId. Function Point\uff1aUsed to describe the product function. Identifier: Function codename. Can only be letters, numbers and underscores Data type\uff1a Issue and report: command data can be sent and status data can be reported back to the Wi-Fi module Report only: supports only status reporting, no control options Function Type (Referred as Data Type in Tuya Protocols article): Boolean (bool): non-true or false binary variable, such as: switch function, on / off Value (value): suitable for linear adjustment of the type of data, such as: temperature regulation, temperature range 20-40 \u2103 Enum (enum): custom finite set value, such as: working levels, low / mid / high Fault (fault): dedicated to reporting and statistical failure of the function points. Support multi-fault, the data is reported only Integer\uff08integer\uff09: transmitted as integer Transparent (raw): data in binary","title":"dpId Function Tables"},{"location":"TuyaMCU/#switches-or-plugspower-strips","text":"DP ID Identifier Data type Function type Properties 1 switch_1 Control and report Boolean 2 switch_2 Control and report Boolean 3 switch_3 Control and report Boolean 4 switch_4 Control and report Boolean 5 switch_5 Control and report Boolean 9 countdown_1 Control and report Integer undefined0-86400, undefined1, Scale0, Unit:s 10 countdown_2 Control and report Integer undefined0-86400, undefined1, Scale0, Unit:s 11 countdown_3 Control and report Integer undefined0-86400, undefined1, Scale0, Unit:s 12 countdown_4 Control and report Integer undefined0-86400, undefined1, Scale0, Unit:s 13 countdown_5 Control and report Integer undefined0-86400, undefined1, Scale0, Unit:s","title":"Switches or Plugs/Power Strips"},{"location":"TuyaMCU/#aromatherapy-machine-oil-diffuser","text":"DP ID Function points Identifier Data type Function type Properties 1 Switch Power Issue and report Boolean 6 Amount of fog fog Issue and report Enum Enumerated values:small, large 11 Light Light Issue and report Boolean 12 Fault alarm fault Only report Fault Barrier values:1 13 Countdown countdown Issue and report Enum Enumerated values: 0, 1, 2, 3 14 Countdown remaining time countdown_left Only report Integer Values range: 0-360, Pitch1, Scale0, Unit:min 101 Light mode work_mode Issue and report Enum Enumerated values: white, colour, scene, scene1, scene2, scene3, scene4 102 Color value colour_data Issue and report Char type *see below 103 Light mode lightmode Issue and report Enum Enumerated values: 1, 2, 3 104 Brightness setting setlight Issue and report Integer Values range: 0-255, Pitch1, Scale0, Unit:\\% colour_data format of the lights is a string of 14 characters, for example, 00112233334455, where 00 indicates R, 11 indicates G, 22 indicates B, 3333 indicates the hue, 44 indicates the saturation, and 55 indicates the value. The initial value is saved by default. If you do not want to adjust the light, set the data to the maximum value 100% (0x64). The last four characters have fixed values.","title":"Aromatherapy Machine (Oil Diffuser)"},{"location":"TuyaMCU/#curtain-motor","text":"DP ID Function points Identifier Data type Function type Properties 1 Percentage percent_state Only report Integer Values range:0-100, Pitch1, Scale0, Unit:% 2 Motor Direction control_back Issue and report Boolean 3 Auto Power auto_power Issue and report Boolean 4 Left time countdown Issue and report Enum Enumerated values:cancel, 1, 2, 3, 4 5 Total Time time_total Only report Integer Values range:0-120000, Pitch1, Scale0, Unit:m Complete document on protocols","title":"Curtain Motor"},{"location":"TuyaMCU/#power-monitoring-plug","text":"DP ID Function points Identifier Data type Function type Properties 1 switch_1 switch_1 Control and report Boolean 9 countdown_1 countdown_1 Control and report Integer undefined0-86400, undefined1, Scale0, Unit:s 17 statistics Function add_ele Control and report Integer undefined0-50000, undefined100, Scale3, Unit: 18 current cur_current Data report Integer undefined0-30000, undefined1, Scale0, Unit:mA 19 power cur_power Data report Integer undefined0-50000, undefined1, Scale1, Unit:W 20 voltage cur_voltage Data report Integer undefined0-5000, undefined1, Scale1, Unit:V 21 test flag test_bit Data report Integer undefined0-5, undefined1, Scale0, Unit: 22 voltage coefficient voltage_coe Data report Integer undefined0-1000000, undefined1, Scale0, Unit: 23 current coefficient electric_coe Data report Integer undefined0-1000000, undefined1, Scale0, Unit: 24 power coefficient power_coe Data report Integer undefined0-1000000, undefined1, Scale0, Unit: 25 statistics coefficient electricity_coe Data report Integer undefined0-1000000, undefined1, Scale0, Unit: 26 warning fault Data report Fault Barrier values:ov_cr","title":"Power Monitoring Plug"},{"location":"TuyaMCU/#dehumidifier","text":"DP ID Function points Identifier Data type Function type Properties 1 Switch Switch Issue and report Boolean 2 PM2.5 PM25 Only report Integer Values range:0-999, Pitch1, Scale0, Unit: 3 Work mode Mode Issue and report Enum Enumerated values:Manual, Auto, Sleep 4 Wind speed Speed Issue and report Enum Enumerated values:speed1, speed2, speed3, speed4, speed5 5 Filter usage Filter Only report Integer Values range:0-100, Pitch1, Scale0, Unit:% 6 Fresh Anion Issue and report Boolean 7 Child lock Lock Issue and report Boolean 9 UV light UV Issue and report Boolean 11 Filter reset FilterReset Issue and report Boolean 12 indoor temp Temp Only report Integer Values range:-20-50, Pitch1, Scale0, Unit:\u2103 13 Indoor humidity Humidity Only report Integer Values range:0-100, Pitch1, Scale0, Unit:%","title":"Dehumidifier"},{"location":"TuyaMCU/#lighting","text":"DP ID Function points Identifier Data type Function type Properties 1 Switch led_switch Control and report Boolean 2 Mode work_mode Control and report Enum Enumerated values:white, colour, scene, scene_1, scene_2, scene_3, scene_4 3 Bright bright_value Control and report Integer undefined25-255, undefined1, Scale0, Unit: 5 Colour mode colour_data Control and report Char type 6 Scene scene_data Control and report Char type 7 Scene1 flash_scene_1 Control and report Char type 8 Scene2 flash_scene_2 Control and report Char type 9 Scene3 flash_scene_3 Control and report Char type 10 Scene4 flash_scene_4 Control and report Char type","title":"Lighting"},{"location":"TuyaMCU/#contact-sensor","text":"DP ID Function points Identifier Data type Function type Properties 1 Door Sensor doorcontact_state Only report Boolean 2 Battery Level battery_percentage Only report Integer Values range:0-100, Pitch1, Scale0, Unit:% 3 Battery Level battery_state Only report Enum Enumerated values:low, middle, high 4 Anti-remove Alarm temper_alarm Only report Boolean","title":"Contact Sensor"},{"location":"TuyaMCU/#air-purifier","text":"DP ID Function points Identifier Data type Function type Properties 1 Switch Switch Issue and report Boolean 2 PM2.5 PM25 Only report Integer Values range:0-999, Pitch1, Scale0, Unit: 3 Work mode Mode Issue and report Enum Enumerated values:Manual, Auto, Sleep 4 Wind speed Speed Issue and report Enum Enumerated values:speed1, speed2, speed3, speed4, speed5 5 Filter usage Filter Only report Integer Values range:0-100, Pitch1, Scale0, Unit:% 6 Fresh Anion Issue and report Boolean 7 Child lock Lock Issue and report Boolean 9 UV light UV Issue and report Boolean 11 Filter reset FilterReset Issue and report Boolean 12 indoor temp Temp Only report Integer Values range:-20-50, Pitch1, Scale0, Unit:\u2103 13 Indoor humidity Humidity Only report Integer Values range:0-100, Pitch1, Scale0, Unit:%","title":"Air purifier"},{"location":"TuyaMCU/#heater","text":"DP ID Function points Identifier Data type Function type Properties 1 Switch Power Issue and report Boolean 2 Target temperature TempSet Issue and report Integer Values range:0-37, Pitch1, Scale0, Unit:\u2103 3 Current Temperature TempCurrent Only report Integer Values range:-9-99, Pitch1, Scale0, Unit:\u2103 4 Mode Mode Issue and report Enum Enumerated values:m, p 5 Fault alarm Fault Only report Fault Barrier values:1, 2, 3 6 Gear position gear Issue and report Enum Enumerated values:low, mid, high, off 7 Conservation eco_mode Issue and report Boolean","title":"Heater"},{"location":"TuyaMCU/#smart-fan","text":"DP ID Function points Identifier Data type Function type Properties 1 Switch switch Issue and report Boolean 2 Wind Speed Level fan_speed Issue and report Enum Enumerated values:1, 2, 3, 4 3 Left-and-Right Swing fan_horizontal Issue and report Enum Enumerated values:on, off 4 Up-and-Down Swing fan_vertical Issue and report Enum Enumerated values:on, off 5 Fault Alarm fault Only report Fault Barrier values:1, 2 6 Anion anion Issue and report Boolean 7 Humidify humidifier Issue and report Boolean 8 Oxygen oxygan Issue and report Boolean 9 Child Lock lock Issue and report Boolean 10 Cool fan_cool Issue and report Boolean 11 Set Temperate temp Issue and report Integer Values range:0-50, Pitch1, Scale0, Unit:\u2103 12 Current Temperature temp_current Only report Integer Values range:0-50, Pitch1, Scale0, Unit:\u2103","title":"Smart fan"},{"location":"TuyaMCU/#kettle","text":"DP ID Function points Identifier Data type Function type Properties 1 Working switch start Issue and report Boolean 2 Heat to target temperature shortcut (\u00b0C) temp_setting_quick_c Issue and report Enum Enumerated values:50, 65, 85, 90, 100 3 Heat to target temperature shortcut (\u00b0F) temp_setting_quick_f Issue and report Enum Enumerated values:122, 149, 185, 194, 212 4 Cool to the target temperature shortcut after boiling (\u00b0C) temp_boiling_quick_c Issue and report Enum Enumerated values:50, 65, 85, 90, 100 5 Cool to the target temperature shortcut after boiling (\u00b0F) temp_boiling_quick_f Issue and report Enum Enumerated values:122, 149, 185, 194, 212 6 Temperature scale switching temp_unit_convert Issue and report Enum Enumerated values:c, f 7 Insulation switch switch_keep_warm Issue and report Boolean 8 Holding time setting keep_warm_setting Issue and report Integer Values range:0-360, Pitch1, Scale0, Unit:min 9 Mode work_type Issue and report Enum Enumerated values: setting_quick, boiling_quick, temp_setting, temp_","title":"Kettle"},{"location":"TuyaMCU/#becathermostatwip","text":"DP ID Function points Identifier Data type Function type Properties 1 Switch Power Issue and report Boolean 2 Target temperature TempSet Issue and report Integer Values range:0-37, Pitch1, Scale0, Unit:\u2103 3 Current Temperature TempCurrent Only report Integer Values range:-9-99, Pitch1, Scale0, Unit:\u2103 4 Mode Mode Issue and report Enum Enumerated values:m, p (wip) 102 Floor Temperature FloorCurrent Issue and report Integer Values range:0-37, Pitch1, Scale0, Unit:\u2103","title":"BecaThermostat(WIP)"},{"location":"TuyaMCU/#inkbird-itc-308-wifi-temperature-controller-with-individual-plug-in-sockets-for-heatingcooling","text":"DP ID Function points Identifier Data type Function type Properties 101 Temperature unit Cf Issue and report Integer 0=C, 1=F 102 Calibration Ca Issue and report Integer Unit is 0.1C 104 Temperature sensor Issue and report Integer Unit is 0.1C 106 Temperature set point Ts Issue and report Integer Unit is 0.1C 108 Compressor delay time Pt Issue and report Integer Unit is minutes 109 Alarm high temperature Ah Issue and report Integer Unit is 0.1C 110 Alarm low temperature Al Issue and report Integer Unit is 0.1C, For negative values use -(0xFFFFFFFF - value) 115 Relay status Only report Integer 01=cool, 02=off, 03=heating 116 Temperature sensor Issue and report Integer Unit is 0.1F 117 Heating differential value Hd Issue and report Integer Unit is 0.1C 118 Cooling differential value Cd Issue and report Integer Unit is 0.1C The unit will constantly be sending the temperature sensor value in celcius and fahrenheit: 104 and 116. To trigger the unit to send all settings, send any value to a non-used register, e.g. TuyaSend1 2,1 Example: Tasmota command Result TuyaSend1 2,1 Trigger the unit to reveal all settings TuyaSend2 106,250 Change set-point to 25.0C TuyaSend2 101,1 Change units to Fahrenheit","title":"Inkbird ITC-308-Wifi Temperature controller with individual plug in sockets for heating/cooling"},{"location":"TuyaMCU/#further-reading","text":"TuyaMCU Flashing and Device Configuration","title":"Further Reading"},{"location":"Upgrade/","text":"Moved to Upgrading","title":"Upgrade"},{"location":"Upgrading/","text":"Easily upgrade Tasmota to a newer version or different build while keeping all your settings. The first rule of upgrading: If it ain't broke, don't fix it! In other words, ensure that there is a good reason to mess with a working installation (e.g., a need to use a new feature or address a found problem fixed in the current version). Tip Any time you upgrade it is highly recommended that you back up your device settings . It is easily done in webUI under Configuration - Backup Config page in the webUI OTA Upgrade ~ Upgrading the device firmware over-the-air , or OTA, is the convenient way to upgrade. Open a web browser to you device's web UI and select Firmware Upgrade. You are presented with two choices. Using an OTA server or by uploading a downloaded or self-compiled binary file. Using Web UI ~ If you want to upgrade to the latest release version click the first Start Upgrade button. This screen should appear During this process Tasmota will download the new firmware from the url and install it. It might need to download tasmota-minimal.bin first but all that happens automatically. All you have to do is wait 2 to 5 minutes . After the upgrade is completed you can reconnect back to the web UI and check the firmware version on the bottom of the page. Changing OtaUrl If you wish to switch to a different build you have to change OtaUrl to the desired binary from our OTA Server . It is possible to create your own simple http OTA server (https is not supported) using Python and perform upgrades from there. Install Python3 and from the folder where the binary resides (make sure tasmota-minimal.bin is located there too) run: python -m http.server 8000 (If the response is \"No module named http\" then try again with python3 instead of python .) Change your OtaUrl to http://ipoftheserver:8000/yourbinary.bin and start the upgrade process. Note: do not use / , - , or . characters in the name of yourbinary . If your binary build (yourbinary.bin) is larger than the available free flash program space, Tasmota will need to first install the minimal version of Tasmota to make more space. To have this work via the web server OTA process, you have to copy the file tasmota-minimal.bin in the same folder where OTAURL for yourbinary.bin is placed, and rename tasmota-minimal.bin to yourbinary-minimal.bin . By File Upload ~ This process requires you to have a minimal build tasmota-minimal.bin of the firmware since the upload process needs the space in flash memory to upload the new binary. When you try to immediately upgrade to a new binary without using minimal firmware you will be greeted with this error. Browse to the minimal binary with Choose File . The chosen filename should be visible. In our example its tasmota-minimal.bin . Wait until the device restarts. In the Main Menu web UI will display this warning message on top. Go to Firmware Upgrade again. This time browse to the binary you want to upgrade to with Choose File and click Start upgrade . In our example its tasmota-sensors.bin . You will see an Upload starting... and then Upload successful message. Wait until the device restarts, reconnect back to the web UI and check the firmware version on the bottom of the page. Using Commands ~ Your device can be upgraded using commands via MQTT, web requests or Console in the web UI. OtaUrl is used to set your OTA address. OtaUrl http :// thehackbox . org / tasmota / tasmota - sensors . bin In this example we chose a development branch version with additional sensors support Initiate upgrade from OTA server Upgrade 1 Wait for the upgrade process to complete and check the Tasmota version. If in console you can use Status 2 . Using Device Button ~ Devices with a built in button (the one used to put your device into flash mode ) can initiate OTA upgrade with it. 7 short presses of the button will start OTA download of firmware using the Ota Url. Device LED is lit during the update. Serial Upgrade ~ Upgrade over the serial connection using serial-to-USB adapter. Upload the new version over serial using the same process as in Flashing but DO NOT erase flash. The new binary will flash over the old one and keep all your settings intact. External Programs ~ Tasmota Device Manager or TDM is a multiplatform GUI application written in Python for discovery and management of Tasmota devices. You can set up OTA url and initiate OTA upgrade from TDM using GUI. openHAB - implement an automation rule to upgrade devices from openHAB Node-RED OTA server and firmware manager - Node-RED flow for managing OTA updates OTA over SCP - setup and configure \"OTA over SCP\" upload for PlatformIO Backing Up Settings ~ Tasmota uses flash memory to store options and settings. New versions add (or remove) features that use various regions of that memory. If you did not erase flash when you flashed your device, an updated version of Tasmota may be accessing areas with values left over from the old Tasmota or even the original factory firmware. This might cause unexpected and unwanted behavior or even major problems (constant reboots or reconnects). To avoid this use our decode-config tool to easily create and restore backups in Tasmota: decode-config tool ~ decode-config.py - installation instructions in Python for Windows or Linux decode-config.exe - Windows only executable. If using this replace decode-config.py with decode-config.exe or decode-config_x64.exe in the instruction examples. 1. make a configuration backup: Create a new backup straight from your device decode-config.py -d <deviceIP> --backup-file Config-@f --backup-type json @f will be replaced by decode-config to device's FriendlyName or Convert a previously made .dmp backup into a JSON file decode-config.py -f <dmp_filename> --backup-file Config-@f --backup-type json 2. perform a device reset Erase flash settings area but keep Wi-Fi and MQTT settings Reset 6 3. upgrade the firmware via OTA or file upload 4. restore configuration decode-config.py -d <deviceIP> --restore-file <config-filename> ...and you're done! If you can't restore configuration directly you can configure the device manually referring to the Commands article and the settings (e.g., SetOptions, Rules, etc.) in the JSON file you created in step #1. You can paste the JSON into a JSON parser to make it easily readable. Migration Path ~ ![WARNING] While fallback or downgrading is common practice it was never supported due to Settings additions or changes in newer releases. Starting with release v8.1.0 Doris the Settings are re-allocated in such a way that fallback is only allowed and possible to release v7.2.0 Constance. Once at v7.2.0 you're on your own when downgrading even further. Until now several versions of Tasmota have been released starting with the C version Sonoff-MQTT-OTA followed by Sonoff-MQTT-OTA-Arduino, Sonoff-Tasmota and ultimately Tasmota . Intermediate upgrade steps might be needed to migrate from an older firmware version to the latest. The following table lists all relevant firmware versions and a direct link to their minimal build. Remember that you must take each individual step between the device firmeware version and the latest available. As a safeguard perform \"Backup Configuration\" before installing a new version. If settings are lost \"Restore Configuration\" should bring them back. Project Name Release Direct Download Sonoff-Tasmota v3.9.22 firmware.bin Sonoff-Tasmota v4.2.0 firmware.bin Sonoff-Tasmota v5.14.0 sonoff-minimal.bin Sonoff-Tasmota v6.7.1 sonoff-minimal.bin Tasmota v7.2.0 tasmota-minimal.bin Tasmota latest (Check \"Assets\" section) Follow the path till you reach the latest Tasmota version. Background Info and Details ~ Migrating from one minor version to the next is mostly painless as the settings are saved in the same location in flash and newer settings are appended. As said, mostly painless. There are some deviations to this rule as I rearranged the flash. In the next list you'll find an overview of supported migrations paths. No migration from Sonoff-MQTT-OTA to Sonoff-MQTT-OTA-Arduino or Tasmota . The settings flash layout and OTA image locations are different from the Arduino versions Easy migration from Sonoff-MQTT-OTA-Arduino 1.0.11 to Sonoff-Tasmota 3.9.x . After installing Tasmota for the first time some settings need to be adjusted via web configuration or MQTT commands. Easy migration from Sonoff-MQTT-OTA-Arduino 3.1.0 to Sonoff-Tasmota 4.x . After installing Tasmota for the first time some settings need to be adjusted via web configuration or MQTT commands. Easy migration from Sonoff-Tasmota 4.x to Sonoff-Tasmota 5.14 . As a safeguard perform a Backup Configuration before installing the new version. If settings are lost after the upgrade perform a Restore Configuration. Easy migration from Sonoff-Tasmota 5.2 to Sonoff-Tasmota 6.x . As a safeguard perform a Backup Configuration before installing the new version. If settings are lost after the upgrade perform a Restore Configuration . !!! warning If you've used development versions between 6.6.0.7 and 6.6.0.11 back up your device settings as described above. Convert the backup to human readable form as you MUST restore these settings manually. Perform a Reset 6 before upgrading the firmware and, for safe measure, after the upgrade completes. Enter your device configurations using the settings saved in the first step. Easy migration from Tasmota 6.x to Tasmota 7.x . As a safeguard perform a Backup Configuration before installing the new version. If settings are lost after the upgrade perform a Restore Configuration . Warning Tasmota 8.1 introduced a major change in parameter storage. Downgrading is not recommended and upgrading to 8.1 has to follow the recommended path and can still fail in some cases. Upgrade from Tasmota 7.2 to Tasmota 8.1 Upgrade from Tasmota 8.1 to Tasmota 8.x Tip If Backup Configuration -> Restore Configuration fails, reset to firmware defaults and use decode-config tool to restore your backed up configuration.","title":"Upgrading"},{"location":"Upgrading/#ota-upgrade","text":"Upgrading the device firmware over-the-air , or OTA, is the convenient way to upgrade. Open a web browser to you device's web UI and select Firmware Upgrade. You are presented with two choices. Using an OTA server or by uploading a downloaded or self-compiled binary file.","title":"OTA Upgrade"},{"location":"Upgrading/#using-web-ui","text":"If you want to upgrade to the latest release version click the first Start Upgrade button. This screen should appear During this process Tasmota will download the new firmware from the url and install it. It might need to download tasmota-minimal.bin first but all that happens automatically. All you have to do is wait 2 to 5 minutes . After the upgrade is completed you can reconnect back to the web UI and check the firmware version on the bottom of the page.","title":"Using Web UI"},{"location":"Upgrading/#by-file-upload","text":"This process requires you to have a minimal build tasmota-minimal.bin of the firmware since the upload process needs the space in flash memory to upload the new binary. When you try to immediately upgrade to a new binary without using minimal firmware you will be greeted with this error. Browse to the minimal binary with Choose File . The chosen filename should be visible. In our example its tasmota-minimal.bin . Wait until the device restarts. In the Main Menu web UI will display this warning message on top. Go to Firmware Upgrade again. This time browse to the binary you want to upgrade to with Choose File and click Start upgrade . In our example its tasmota-sensors.bin . You will see an Upload starting... and then Upload successful message. Wait until the device restarts, reconnect back to the web UI and check the firmware version on the bottom of the page.","title":"By File Upload"},{"location":"Upgrading/#using-commands","text":"Your device can be upgraded using commands via MQTT, web requests or Console in the web UI. OtaUrl is used to set your OTA address. OtaUrl http :// thehackbox . org / tasmota / tasmota - sensors . bin In this example we chose a development branch version with additional sensors support Initiate upgrade from OTA server Upgrade 1 Wait for the upgrade process to complete and check the Tasmota version. If in console you can use Status 2 .","title":"Using Commands"},{"location":"Upgrading/#using-device-button","text":"Devices with a built in button (the one used to put your device into flash mode ) can initiate OTA upgrade with it. 7 short presses of the button will start OTA download of firmware using the Ota Url. Device LED is lit during the update.","title":"Using Device Button"},{"location":"Upgrading/#serial-upgrade","text":"Upgrade over the serial connection using serial-to-USB adapter. Upload the new version over serial using the same process as in Flashing but DO NOT erase flash. The new binary will flash over the old one and keep all your settings intact.","title":"Serial Upgrade"},{"location":"Upgrading/#external-programs","text":"Tasmota Device Manager or TDM is a multiplatform GUI application written in Python for discovery and management of Tasmota devices. You can set up OTA url and initiate OTA upgrade from TDM using GUI. openHAB - implement an automation rule to upgrade devices from openHAB Node-RED OTA server and firmware manager - Node-RED flow for managing OTA updates OTA over SCP - setup and configure \"OTA over SCP\" upload for PlatformIO","title":"External Programs"},{"location":"Upgrading/#backing-up-settings","text":"Tasmota uses flash memory to store options and settings. New versions add (or remove) features that use various regions of that memory. If you did not erase flash when you flashed your device, an updated version of Tasmota may be accessing areas with values left over from the old Tasmota or even the original factory firmware. This might cause unexpected and unwanted behavior or even major problems (constant reboots or reconnects). To avoid this use our decode-config tool to easily create and restore backups in Tasmota:","title":"Backing Up Settings"},{"location":"Upgrading/#decode-config-tool","text":"decode-config.py - installation instructions in Python for Windows or Linux decode-config.exe - Windows only executable. If using this replace decode-config.py with decode-config.exe or decode-config_x64.exe in the instruction examples.","title":"decode-config tool"},{"location":"Upgrading/#migration-path","text":"![WARNING] While fallback or downgrading is common practice it was never supported due to Settings additions or changes in newer releases. Starting with release v8.1.0 Doris the Settings are re-allocated in such a way that fallback is only allowed and possible to release v7.2.0 Constance. Once at v7.2.0 you're on your own when downgrading even further. Until now several versions of Tasmota have been released starting with the C version Sonoff-MQTT-OTA followed by Sonoff-MQTT-OTA-Arduino, Sonoff-Tasmota and ultimately Tasmota . Intermediate upgrade steps might be needed to migrate from an older firmware version to the latest. The following table lists all relevant firmware versions and a direct link to their minimal build. Remember that you must take each individual step between the device firmeware version and the latest available. As a safeguard perform \"Backup Configuration\" before installing a new version. If settings are lost \"Restore Configuration\" should bring them back. Project Name Release Direct Download Sonoff-Tasmota v3.9.22 firmware.bin Sonoff-Tasmota v4.2.0 firmware.bin Sonoff-Tasmota v5.14.0 sonoff-minimal.bin Sonoff-Tasmota v6.7.1 sonoff-minimal.bin Tasmota v7.2.0 tasmota-minimal.bin Tasmota latest (Check \"Assets\" section) Follow the path till you reach the latest Tasmota version.","title":"Migration Path"},{"location":"Upgrading/#background-info-and-details","text":"Migrating from one minor version to the next is mostly painless as the settings are saved in the same location in flash and newer settings are appended. As said, mostly painless. There are some deviations to this rule as I rearranged the flash. In the next list you'll find an overview of supported migrations paths. No migration from Sonoff-MQTT-OTA to Sonoff-MQTT-OTA-Arduino or Tasmota . The settings flash layout and OTA image locations are different from the Arduino versions Easy migration from Sonoff-MQTT-OTA-Arduino 1.0.11 to Sonoff-Tasmota 3.9.x . After installing Tasmota for the first time some settings need to be adjusted via web configuration or MQTT commands. Easy migration from Sonoff-MQTT-OTA-Arduino 3.1.0 to Sonoff-Tasmota 4.x . After installing Tasmota for the first time some settings need to be adjusted via web configuration or MQTT commands. Easy migration from Sonoff-Tasmota 4.x to Sonoff-Tasmota 5.14 . As a safeguard perform a Backup Configuration before installing the new version. If settings are lost after the upgrade perform a Restore Configuration. Easy migration from Sonoff-Tasmota 5.2 to Sonoff-Tasmota 6.x . As a safeguard perform a Backup Configuration before installing the new version. If settings are lost after the upgrade perform a Restore Configuration . !!! warning If you've used development versions between 6.6.0.7 and 6.6.0.11 back up your device settings as described above. Convert the backup to human readable form as you MUST restore these settings manually. Perform a Reset 6 before upgrading the firmware and, for safe measure, after the upgrade completes. Enter your device configurations using the settings saved in the first step. Easy migration from Tasmota 6.x to Tasmota 7.x . As a safeguard perform a Backup Configuration before installing the new version. If settings are lost after the upgrade perform a Restore Configuration . Warning Tasmota 8.1 introduced a major change in parameter storage. Downgrading is not recommended and upgrading to 8.1 has to follow the recommended path and can still fail in some cases. Upgrade from Tasmota 7.2 to Tasmota 8.1 Upgrade from Tasmota 8.1 to Tasmota 8.x Tip If Backup Configuration -> Restore Configuration fails, reset to firmware defaults and use decode-config tool to restore your backed up configuration.","title":"Background Info and Details"},{"location":"Upload-tools/","text":"Tools for compiling and uploading (flashing) Tasmota: ~ Tasmotizer - Tasmotizer.py is the flashing tool for Tasmota Esptool - esptool.py is the official flashing tool from Espressif Tasmota PyFlasher - GUI wrapper for esptool.py PlatformIO - setup and configure PlatformIO for Tasmota compilation and upload PlatformIO CLI - how to flash Tasmota using the PlatformIO command line interface on Linux Visual Studio Code - setup and configure Visual Studio Code with PlatformIO for Tasmota Arduino IDE - setup and configure Arduino IDE for Tasmota compilation and upload Sonoff DIY - OTA flash for select Sonoff devices (some disassembly required) Node-RED OTA server and firmware manager - Node-RED flow for managing OTA updates OTA over SCP - setup and configure \"OTA over SCP\" upload for PlatformIO Python HTTP OTA server - setting up a small Python server to serve OTA upgrade binaries Tuya-Convert - easy OTA flash for devices with Tuya chips, no disassembly required","title":"Upload tools"},{"location":"Upload-tools/#tools-for-compiling-and-uploading-flashing-tasmota","text":"Tasmotizer - Tasmotizer.py is the flashing tool for Tasmota Esptool - esptool.py is the official flashing tool from Espressif Tasmota PyFlasher - GUI wrapper for esptool.py PlatformIO - setup and configure PlatformIO for Tasmota compilation and upload PlatformIO CLI - how to flash Tasmota using the PlatformIO command line interface on Linux Visual Studio Code - setup and configure Visual Studio Code with PlatformIO for Tasmota Arduino IDE - setup and configure Arduino IDE for Tasmota compilation and upload Sonoff DIY - OTA flash for select Sonoff devices (some disassembly required) Node-RED OTA server and firmware manager - Node-RED flow for managing OTA updates OTA over SCP - setup and configure \"OTA over SCP\" upload for PlatformIO Python HTTP OTA server - setting up a small Python server to serve OTA upgrade binaries Tuya-Convert - easy OTA flash for devices with Tuya chips, no disassembly required","title":"Tools for compiling and uploading (flashing) Tasmota:"},{"location":"User-created-templates/","text":"Follow this link to new templates repository .","title":"User created templates"},{"location":"VEML6070/","text":"!> This feature is included only in tasmota-sensors.bin Otherwise you must compile your build . Add the following to user_config_override.h : #ifndef USE_VEML6070 #define USE_VEML6070 // Add I2C code for VEML6070 sensor (+0k5 code) #endif This little sensor is a great way to add UV light sensing to any microcontroller project. The VEML6070 from Vishay has a true UV A light sensor and an I 2 C-controlled ADC that will take readings and integrate them for you over ~60ms to 500ms.\" See VEML6070 UV Sensor for more information. Configuration ~ Wiring ~ VEML6070 ESP8266 GND GND VCC 3.3V SDA GPIOx SCL GPIOy Tasmota Settings ~ In the Configuration -> Configure Module page assign: 1. GPIOx to I2C SDA (6) 2. GPIOy to I2C SCL (5) Tasmota Main ~ After a reboot the driver will detect VEML6070 automatically and display UV light intensity. Breakout Boards ~","title":"VEML6070"},{"location":"VEML6070/#configuration","text":"","title":"Configuration"},{"location":"VEML6070/#wiring","text":"VEML6070 ESP8266 GND GND VCC 3.3V SDA GPIOx SCL GPIOy","title":"Wiring"},{"location":"VEML6070/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: 1. GPIOx to I2C SDA (6) 2. GPIOy to I2C SCL (5)","title":"Tasmota Settings"},{"location":"VEML6070/#tasmota-main","text":"After a reboot the driver will detect VEML6070 automatically and display UV light intensity.","title":"Tasmota Main"},{"location":"VEML6070/#breakout-boards","text":"","title":"Breakout Boards"},{"location":"VL53L0x/","text":"The VL53L0X is a Time-of-Flight (ToF) laser-ranging module. Configuration ~ Wiring ~ VL53L0x ESP8266 GND GND VCC 3.3V SDA GPIOx SCL GPIOy Tasmota Settings ~ In the Configuration -> Configure Module page assign: 1. GPIOx to I2C SDA (6) 2. GPIOy to I2C SCL (5) After a reboot the driver will detect VL530L0x automatically and display Illuminance. Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2019-12-20T11:29:22\" , \"VL53L0X\" :{ \"Distance\" : 263 }} Breakout Boards ~","title":"VL53L0x"},{"location":"VL53L0x/#configuration","text":"","title":"Configuration"},{"location":"VL53L0x/#wiring","text":"VL53L0x ESP8266 GND GND VCC 3.3V SDA GPIOx SCL GPIOy","title":"Wiring"},{"location":"VL53L0x/#tasmota-settings","text":"In the Configuration -> Configure Module page assign: 1. GPIOx to I2C SDA (6) 2. GPIOy to I2C SCL (5) After a reboot the driver will detect VL530L0x automatically and display Illuminance. Sensor sends a tele/%topic%/SENSOR JSON reponse: { \"Time\" : \"2019-12-20T11:29:22\" , \"VL53L0X\" :{ \"Distance\" : 263 }}","title":"Tasmota Settings"},{"location":"VL53L0x/#breakout-boards","text":"","title":"Breakout Boards"},{"location":"Visual-Studio-Code/","text":"How to setup and configure Visual Studio Code with PlatformIO for Tasmota compilation and upload. Easy way (only Windows): Portable install of Visual Studio Code for Tasmota ~ Download the ready made Portable Installation of VSC/PlatformIO and extract the ZIP to a folder or a fast extern drive. Grab the Tasmota compile package and extract it to the same destination. Start VS Code.exe (in folder VSC) Full Install (Windows, Linux and Mac) ~ Download and Install Visual Studio Code ~ Download Visual Studio Code (VSC) from https://code.visualstudio.com/ Install PlatformIO Extension ~ Install the PlatformIO IDE extension in VSC. Select View - Extensions and type PlatformIO in the search box. Make sure to select the official PlatformIO.org PlatformIO IDE extension and select Install . Accept to install dependencies. Download Tasmota ~ Download the latest Tasmota version from https://github.com/arendst/Tasmota and unzip to a known folder. Copy files ~ Copy all files from the Tasmota Source code into your VSC working folder. Compile Tasmota ~ Start VSC and select File - Open Folder... to point to the working folder. Note: Press Ctrl + Shift + P and type PlatformIO to see all options. Select the desired firmware by editing file platformio.ini as needed. Easy compilation can be performed from the icons at the bottom of the VSC screen. Upload Tasmota ~ Enable desired options in platformio.ini for serial upload like: ; *** Upload Serial reset method for Wemos and NodeMCU upload_port = COM5 ;upload_speed = 512000 upload_speed = 115200 ;upload_resetmethod = nodemcu Enable desired options in platformio_override.ini for upload to your local OTA server like: ; *** Upload file to OTA server using HTTP upload_port = domus1:80/api/upload-arduino.php extra_scripts = pio/http-uploader.py Easy compilation and upload can be performed from the icons at the bottom of the VSC screen or use Ctrl + Alt + U to upload (will build if needed). Hint: ~ In case vscode shows a huge amount of errors using PlatformIO - Intellisense a possible \"solution\" is to change the cpp-Intelli Sense Engine type to \"TAG PARSER\" This setting can be changed in workspace settings by: Use Ctrl + Shift + P and type Preferences: Open Workspace Settings and type intelli Sense in the search box. Now change the value for Intelli Sense Engine to Tag Parser .","title":"Visual Studio Code"},{"location":"Visual-Studio-Code/#easy-way-only-windows-portable-install-of-visual-studio-code-for-tasmota","text":"Download the ready made Portable Installation of VSC/PlatformIO and extract the ZIP to a folder or a fast extern drive. Grab the Tasmota compile package and extract it to the same destination. Start VS Code.exe (in folder VSC)","title":"Easy way (only Windows): Portable install of Visual Studio Code for Tasmota"},{"location":"Visual-Studio-Code/#full-install-windows-linux-and-mac","text":"","title":"Full Install (Windows, Linux and Mac)"},{"location":"Visual-Studio-Code/#download-and-install-visual-studio-code","text":"Download Visual Studio Code (VSC) from https://code.visualstudio.com/","title":"Download and Install Visual Studio Code"},{"location":"Visual-Studio-Code/#install-platformio-extension","text":"Install the PlatformIO IDE extension in VSC. Select View - Extensions and type PlatformIO in the search box. Make sure to select the official PlatformIO.org PlatformIO IDE extension and select Install . Accept to install dependencies.","title":"Install PlatformIO Extension"},{"location":"Visual-Studio-Code/#download-tasmota","text":"Download the latest Tasmota version from https://github.com/arendst/Tasmota and unzip to a known folder.","title":"Download Tasmota"},{"location":"Visual-Studio-Code/#copy-files","text":"Copy all files from the Tasmota Source code into your VSC working folder.","title":"Copy files"},{"location":"Visual-Studio-Code/#compile-tasmota","text":"Start VSC and select File - Open Folder... to point to the working folder. Note: Press Ctrl + Shift + P and type PlatformIO to see all options. Select the desired firmware by editing file platformio.ini as needed. Easy compilation can be performed from the icons at the bottom of the VSC screen.","title":"Compile Tasmota"},{"location":"Visual-Studio-Code/#upload-tasmota","text":"Enable desired options in platformio.ini for serial upload like: ; *** Upload Serial reset method for Wemos and NodeMCU upload_port = COM5 ;upload_speed = 512000 upload_speed = 115200 ;upload_resetmethod = nodemcu Enable desired options in platformio_override.ini for upload to your local OTA server like: ; *** Upload file to OTA server using HTTP upload_port = domus1:80/api/upload-arduino.php extra_scripts = pio/http-uploader.py Easy compilation and upload can be performed from the icons at the bottom of the VSC screen or use Ctrl + Alt + U to upload (will build if needed).","title":"Upload Tasmota"},{"location":"Visual-Studio-Code/#hint","text":"In case vscode shows a huge amount of errors using PlatformIO - Intellisense a possible \"solution\" is to change the cpp-Intelli Sense Engine type to \"TAG PARSER\" This setting can be changed in workspace settings by: Use Ctrl + Shift + P and type Preferences: Open Workspace Settings and type intelli Sense in the search box. Now change the value for Intelli Sense Engine to Tag Parser .","title":"Hint:"},{"location":"WS2812B-RGB-Shield/","text":"WS2812B RGB Shield (single pin) ~ From the Wemos ws2812b shield specs the DATA pin is connected to D2 of the Wemos. Tasmota Settings ~ In the Configuration -> Configure Module page, select the following: * D2 GPIO4 : 07 WS2812 Tasmota Main ~ After reboot of the device the dark-bright slider and toggle button are displayed to control the led.","title":"WS2812B RGB Shield"},{"location":"WS2812B-RGB-Shield/#ws2812b-rgb-shield-single-pin","text":"From the Wemos ws2812b shield specs the DATA pin is connected to D2 of the Wemos.","title":"WS2812B RGB Shield (single pin)"},{"location":"WS2812B-RGB-Shield/#tasmota-settings","text":"In the Configuration -> Configure Module page, select the following: * D2 GPIO4 : 07 WS2812","title":"Tasmota Settings"},{"location":"WS2812B-RGB-Shield/#tasmota-main","text":"After reboot of the device the dark-bright slider and toggle button are displayed to control the led.","title":"Tasmota Main"},{"location":"WS2812B-and-WS2813/","text":"WS2813B versus WS2812B ~ The newer version of ws2812b is the ws2813b, which has dual signal lines to prevent a led failure also consecutive leds fail. Wemos D1 Mini - WS2813B schematic ~ Below the schematics to connect a Wemos to a WS2813B via a PNP emitter-follower. \" In order to prevent damage to the ESP GPIO pin. It\u2019s very easy to isolate your ESP8266 from the WS2813 5v supply voltage and provide a low impedance drive for the WS2813 bus at the same time, using a cheap, PNP transistor in emitter-follower configuration. An emitter-follower is a non-inverting buffer, which provides a medium to high impedance on it\u2019s input (so it doesn\u2019t place any significant load on the GPIO pin) and presents a low impedance output (meaning it can drive more current than the ESP GPIO pin can alone). PNP Emitter Follower Unlike the more traditional common-emitter transistor circuit, the emitter follower doesn\u2019t amplify the input signal at all; in this circuit it is acting as a switch, but while the output from the GPIO is switching between 0v and 3v3, the output of the emitter-follower is switching between 0v and 5v. Thus this simple circuit not only protects your ESP from damage, but also provides the correct voltage swing for the WS2812 data bus, too. Almost any common, small-signal PNP transistor (2N3906, BC560) will work in this configuration; specific type is not too critical. \" ~ source note: connect the ledstrip from both sides to the power supply Bill of materials ~ Wemos D1 Mini WS2813B or WS2812B ledstrip PNP transistor (ie BC560C ) 1k8 and 3k3 resistors 5V power supply : the power of the power supply depends on the number of leds. A pixel has 3 leds (RGB), each led drains a max of 20mA, so a pixel drains a max of 60mA (3 * 20mA). So the total current that the power supply must deliver is 60mA times the number of pixels. For example 80 pixels: 60mA * 80 = 4800mA = 4.8A. Also the Wemos is powered by the power supply so in this example a power supply of 6A (30W) will do. Electrolytic Capacitor 1000uf 16v place close to the circuit, to make sure the wemos and ledstrip are powered by a clean signal. Tasmota Configuration ~ In the Configuration -> Configure Module page, select the following: D4 GPIO2 : 07 WS2812 Tasmota Main ~","title":"WS2812B and WS2813"},{"location":"WS2812B-and-WS2813/#ws2813b-versus-ws2812b","text":"The newer version of ws2812b is the ws2813b, which has dual signal lines to prevent a led failure also consecutive leds fail.","title":"WS2813B versus WS2812B"},{"location":"WS2812B-and-WS2813/#wemos-d1-mini-ws2813b-schematic","text":"Below the schematics to connect a Wemos to a WS2813B via a PNP emitter-follower. \" In order to prevent damage to the ESP GPIO pin. It\u2019s very easy to isolate your ESP8266 from the WS2813 5v supply voltage and provide a low impedance drive for the WS2813 bus at the same time, using a cheap, PNP transistor in emitter-follower configuration. An emitter-follower is a non-inverting buffer, which provides a medium to high impedance on it\u2019s input (so it doesn\u2019t place any significant load on the GPIO pin) and presents a low impedance output (meaning it can drive more current than the ESP GPIO pin can alone). PNP Emitter Follower Unlike the more traditional common-emitter transistor circuit, the emitter follower doesn\u2019t amplify the input signal at all; in this circuit it is acting as a switch, but while the output from the GPIO is switching between 0v and 3v3, the output of the emitter-follower is switching between 0v and 5v. Thus this simple circuit not only protects your ESP from damage, but also provides the correct voltage swing for the WS2812 data bus, too. Almost any common, small-signal PNP transistor (2N3906, BC560) will work in this configuration; specific type is not too critical. \" ~ source note: connect the ledstrip from both sides to the power supply","title":"Wemos D1 Mini - WS2813B schematic"},{"location":"WS2812B-and-WS2813/#bill-of-materials","text":"Wemos D1 Mini WS2813B or WS2812B ledstrip PNP transistor (ie BC560C ) 1k8 and 3k3 resistors 5V power supply : the power of the power supply depends on the number of leds. A pixel has 3 leds (RGB), each led drains a max of 20mA, so a pixel drains a max of 60mA (3 * 20mA). So the total current that the power supply must deliver is 60mA times the number of pixels. For example 80 pixels: 60mA * 80 = 4800mA = 4.8A. Also the Wemos is powered by the power supply so in this example a power supply of 6A (30W) will do. Electrolytic Capacitor 1000uf 16v place close to the circuit, to make sure the wemos and ledstrip are powered by a clean signal.","title":"Bill of materials"},{"location":"WS2812B-and-WS2813/#tasmota-configuration","text":"In the Configuration -> Configure Module page, select the following: D4 GPIO2 : 07 WS2812","title":"Tasmota Configuration"},{"location":"WS2812B-and-WS2813/#tasmota-main","text":"","title":"Tasmota Main"},{"location":"WebUI/","text":"Tasmota's web user interface is a practical way to control and manage your tasmotised device. To access it use your device's IP address in your favorite web browser. Configuration Configuration menu allows you to configure everything from components to Wi-Fi and gives you the option to backup and restore the configuration in a secure location. Information Displays a single page loaded with information about the device including: current Tasmota version, Wi-Fi AP data, MQTT host data and more Firmware Upgrade An easy to use menu to initiate a firmware upgrade from an uploaded .bin or an OTA server. Console Terminal access to Tasmota. Issue commands here or follow the information stream. Useful for debugging when using \u02d9Weblog 4` . Themes ~ WebUI is themable using WebColor commands. To apply the theme copy the entire code block and send it in console or via MQTT. Dark (default theme) WebColor { \"WebColor\" : [ \"#eaeaea\" , \"#252525\" , \"#4f4f4f\" , \"#000000\" , \"#dddddd\" , \"#65c115\" , \"#1f1f1f\" , \"#ff5661\" , \"#008000\" , \"#faffff\" , \"#1fa3ec\" , \"#0e70a4\" , \"#d43535\" , \"#931f1f\" , \"#47c266\" , \"#5aaf6f\" , \"#faffff\" , \"#999999\" , \"#eaeaea\" ]} Light (default until 6.7.1.) WebColor { \"WebColor\" : [ \"#000000\" , \"#ffffff\" , \"#f2f2f2\" , \"#000000\" , \"#ffffff\" , \"#000000\" , \"#ffffff\" , \"#ff0000\" , \"#008000\" , \"#ffffff\" , \"#1fa3ec\" , \"#0e70a4\" , \"#d43535\" , \"#931f1f\" , \"#47c266\" , \"#5aaf6f\" , \"#ffffff\" , \"#999999\" , \"#000000\" ]} Halloween WebColor { \"WebColor\" : [ \"#cccccc\" , \"#2f3133\" , \"#3d3f41\" , \"#dddddd\" , \"#293134\" , \"#ffb000\" , \"#293134\" , \"#ff5661\" , \"#008000\" , \"#ffffff\" , \"#ec7600\" , \"#bf5f00\" , \"#d43535\" , \"#931f1f\" , \"#47c266\" , \"#5aaf6f\" , \"#ffffff\" , \"#999999\" , \"#bc4d90\" ]} Navy WebColor { \"WebColor\" : [ \"#e0e0c0\" , \"#000033\" , \"#4f4f4f\" , \"#000000\" , \"#dddddd\" , \"#a7f432\" , \"#1e1e1e\" , \"#ff0000\" , \"#008000\" , \"#ffffff\" , \"#1fa3ec\" , \"#0e70a4\" , \"#d43535\" , \"#931f1f\" , \"#47c266\" , \"#5aaf6f\" , \"#ffffff\" , \"#999999\" , \"#eedd77\" ]} Purple Rain WebColor { \"WebColor\" : [ \"#eaeaea\" , \"#252525\" , \"#282531\" , \"#eaeaea\" , \"#282531\" , \"#d7ccff\" , \"#1d1b26\" , \"#ff5661\" , \"#008000\" , \"#faffff\" , \"#694fa8\" , \"#4d3e7f\" , \"#b73d5d\" , \"#822c43\" , \"#1f917c\" , \"#156353\" , \"#faffff\" , \"#716b7f\" , \"#eaeaea\" ]} Tip When using an MQTT client such as mosquitto_pub , enclose the message payload in single quotes ( ' ) mosquitto_pub -h 192.168.1.20 -t \"cmnd/myTopic/WebColor\" -m '{\"WebColor\":[\"#eaeaea\",\"#252525\",\"#4f4f4f\",\"#000000\",\"#dddddd\",\"#65c115\",\"#1f1f1f\",\"#ff5661\",\"#008000\",\"#faffff\",\"#1fa3ec\",\"#0e70a4\",\"#d43535\",\"#931f1f\",\"#47c266\",\"#5aaf6f\",\"#faffff\",\"#999999\",\"#eaeaea\"]}'","title":"WebUI"},{"location":"WebUI/#themes","text":"WebUI is themable using WebColor commands. To apply the theme copy the entire code block and send it in console or via MQTT.","title":"Themes"},{"location":"What%27s-New/","text":"remoteMarkdownUrl","title":"What's New"},{"location":"White-Blend-Mode/","text":"White Blend Mode is used for 4 channel (RGBW) and 5 channel (RGBWC) devices. It is enabled by setting the last PWM channel to zero (e.g., RGBWWTable 255,255,255,<n>,0 ) to lower the white channel intensity. Generally, white LEDs are brighter than RGB LEDs. If you want to keep the same brightness, you need to calibrate the white level. In this mode, any white component will be removed from RGB LEDs and sent to the white LEDs. This makes whites look much better. Example: Color 30508000 will be converted to Color 0020503000 (0x30 is subtracted from R,G,B channels and added to the White channel) To calibrate: Color FFFFFF00 RGBWWTable 255,255,255,255,255 - reset to RGB mode RGBWWTable 255,255,255,<n>,0 (begin the calibration process with <n> == 150) If too bright, decrease <n> . If too dim, increase <n> Go back to step 2 and iterate until satisfied with the color intensities. Examples: * Sonoff B1: RGBWWTable 255,255,255,35,0 * Teckin SB50: RGBWWTable 255,255,255,80,0","title":"White Blend Mode"},{"location":"WifiPower/","text":"WifiPower allows you to fine tune the Wi-Fi transmission power level. The default is 17dBm which should be enough power for the device to transmit to the Wi-Fi access point (AP) in a normal network environment use case. Changing this setting will impact the Wi-Fi range of the device. The general rule of thumb is for every 3dBm change up or down will double or halve the range, respectively. However, this is largely dependent on the Wi-Fi router's capabilities. Use the RSSI signal level reported by the router for a particular Tasmota device to adjust the power level of a device. Lower the value incrementally until you achieve a balance between connection stability and energy saving. In some cases a device may require slightly more power to maintain a stable connection to the Wi-Fi network. In this case, increment the value in 1 dBm increments until stable connectivity is observed. Do not exceed 17dBm! Exceeding the default 17dBm transmit power setting may cause unreliable device operation. Most devices have been designed with the 17dBm theoretical power setting and may not have the ability to dissipate the additional heat generated. Setting the transmit power too high may cause interference in the device antenna causing Wi-Fi reception problems. This setting will not affect the signal level received from the AP (i.e., the RSSI reading that Tasmota reports). Improper setting of this parameter may cause operational instability and can generate exceptions. Increasing WifiPower puts additional demand on the device electrical power supply. Exceeding the capabilities of the power supply can cause other erratic device behaviors. Of course, the opposite may be the case when reducing transmit power levels allowing a device with a borderline power regulator to operate reliably. You should perform substantial testing and monitoring to find the sweet spot for WifiPower .","title":"WifiPower"},{"location":"Yeti/","text":"Yeti is a smart home mobile app (available for Android & iOS ) that allows you to control your different brands from a single interface. It supports a wide range of devices and brands. From Smart Plugs and Lights to Thermostats and Speakers. Currently, it supports the following brands: Philips Hue (Lights) LIFX (Lights) Wemo (Lights & Sockets) Sonos (Play1, Play3, Play5) Yeelight (Lights) Ecobee (Thermostats) Nest (Thermostats) Nuki (Locker) Netatmo (Thermostats & Cameras) And from now on, in the newest version, it also supports devices with latest Tasmota version installed. Check out this guide about Controlling your Tasmota devices with Yeti Yeti & Tasmota Integration ~ There is a guide where you can see step by step how to control your Tasmota devices using Yeti. In that guide, there is an example using Sonoff devices but it will work with almost any device which has the latest Tasmota version installed How to control Tasmota devices with Yeti Requirements ~ Yeti for Android Yeti for iOS Tasmota version >= 5.12.0 Having your Tasmota devices connected to the same Wifi network as your phone Connect your Tasmota devices to Yeti ~ Once you have your Tasmota devices connected to the same network as your phone and Yeti installed on it, open the app. After opening the app and creating an account, Yeti will start scanning for your smart home devices in your network. If you have any other additional supported brand it'll also find it. If Yeti can't find your Tasmota devices automatically in the first scan (This will happen if you don't have a Sonoff device) you can find it manually. Being in the home view, tap in the + button, then select the option configure brands and look for \"Sonoff\" and then select \"Advanced Options\". You'll be asked to introduce the Ip of your device manually. After that Yeti will scan for that device in your network Finally, you'll be able to control your Tasmota devices Common Issues ~ Yeti can't find my devices in the first Scan ~ If Yeti can't find your devices in the first scan it can be because Yeti is not able to find it automatically or you have your Sonoff Password-Protected. To solve this issue, we've implemented an \"Advanced Option\" menu where you can introduce the Ip of your devices manually and also the user and password in case you have a sonoff password-protected. In the home screen press the + button . Then tap Configure Brands , look for Sonoff and the press connect In that menu you will see some information and also an Advanced Menu text in the bottom. Tap it Finally you'll be required to introduce the Ip and in case you have password set up, you can also introduce it. By default username is admin, in case you changed it, please add the new username Anything Else? ~ I highly recommend trying charms and routines features in Yeti What's coming ~ Right now, only switch control is available. In the next version, sensor information will be available for users to check them within Yeti and use it as a trigger for routines and charms.","title":"Yeti"},{"location":"Yeti/#yeti-tasmota-integration","text":"There is a guide where you can see step by step how to control your Tasmota devices using Yeti. In that guide, there is an example using Sonoff devices but it will work with almost any device which has the latest Tasmota version installed How to control Tasmota devices with Yeti","title":"Yeti &amp; Tasmota Integration"},{"location":"Yeti/#requirements","text":"Yeti for Android Yeti for iOS Tasmota version >= 5.12.0 Having your Tasmota devices connected to the same Wifi network as your phone","title":"Requirements"},{"location":"Yeti/#connect-your-tasmota-devices-to-yeti","text":"Once you have your Tasmota devices connected to the same network as your phone and Yeti installed on it, open the app. After opening the app and creating an account, Yeti will start scanning for your smart home devices in your network. If you have any other additional supported brand it'll also find it. If Yeti can't find your Tasmota devices automatically in the first scan (This will happen if you don't have a Sonoff device) you can find it manually. Being in the home view, tap in the + button, then select the option configure brands and look for \"Sonoff\" and then select \"Advanced Options\". You'll be asked to introduce the Ip of your device manually. After that Yeti will scan for that device in your network Finally, you'll be able to control your Tasmota devices","title":"Connect your Tasmota devices to Yeti"},{"location":"Yeti/#common-issues","text":"","title":"Common Issues"},{"location":"Yeti/#yeti-cant-find-my-devices-in-the-first-scan","text":"If Yeti can't find your devices in the first scan it can be because Yeti is not able to find it automatically or you have your Sonoff Password-Protected. To solve this issue, we've implemented an \"Advanced Option\" menu where you can introduce the Ip of your devices manually and also the user and password in case you have a sonoff password-protected. In the home screen press the + button . Then tap Configure Brands , look for Sonoff and the press connect In that menu you will see some information and also an Advanced Menu text in the bottom. Tap it Finally you'll be required to introduce the Ip and in case you have password set up, you can also introduce it. By default username is admin, in case you changed it, please add the new username","title":"Yeti can't find my devices in the first Scan"},{"location":"Yeti/#anything-else","text":"I highly recommend trying charms and routines features in Yeti","title":"Anything Else?"},{"location":"Yeti/#whats-coming","text":"Right now, only switch control is available. In the next version, sensor information will be available for users to check them within Yeti and use it as a trigger for routines and charms.","title":"What's coming"},{"location":"Zigbee-Internals/","text":"Zigbee internals ~ Back to Zigbee This page is for developers who want to understand how Zigbee2Tasmota (Z2T) works and its implementation details. CC2530 ZNP protocol ~ The CC2530 is flashed with Texas Instrument ZNP Software version 1.2. The protocol is build on a serial communication between the main cpu and the CC2530. Z-Stack 1.2 Monitor and Test API Serial communication is configured as 8N1, 115200 bauds. We suggest to use GPIO13/15 because they have hardware serial support. Please note that there is only one usable hardware serial, either on GPIO1/3 or GPIO13/15. To enable hardware serial on GPIO13/15 for Tasmota, set Serial 0 and restart. Otherwise Z2T will use Software serial provided by TasmotaSerial. Receiving 115200 bauds in software is a timing challenge. Here is the anatomy of a byte transmitted in serial mode. Each bit is 8.7\u00b5s, or ~700 CPU cycles at 80MHz (1400 cycles at 160MHz). It all starts with a LOW \"start bit\" that generates an interrupt transferred to TasmotaSerial. Then TasmotaSerial enters a tightly controlled loop to read each bit (least sifnificant first). The frame stops with a HIGH stop bit. What can go wrong? Tasmota may be already handling an interrupt when the start bit arrives, potentially causing a shift by 1 bit and a wrong message. Here is a 0xFE byte correctly received: Same frame with a delay in the interrupt handler, and mistakenly read 0xFF: TasmotaSerial has been improved to allow receiving a train of bytes withtout any disruption. CC2530 generally sends all the bytes one after the other for a single ZNP message (up to 250 bytes). Instead of giving back control after the first byte, the TasmotaSerial interrupt handler continues to monitor the serial RX line for the next 4 bits and checks whether a new start bit arrived. It avoids any error after the first byte was received. Still the first byte in the message could have been wrong. Fortunately, the first byte sent by ZNP is always 0xFE (see below). This means that if the interrupt arrives too late, Tasmota will read 0xFF instead of 0xFE. Z2T software does automatic error correction in this case, i.e. if the first byte received is 0xFF, it is automatically assumed to be 0xFE and the rest of the message is read normally. With these two schemes, software serial for Zigbee proved to be extremely reliable, even at 80MHz. It is highly recommended though to run at 160MHz.","title":"Zigbee internals"},{"location":"Zigbee-Internals/#zigbee-internals","text":"Back to Zigbee This page is for developers who want to understand how Zigbee2Tasmota (Z2T) works and its implementation details.","title":"Zigbee internals"},{"location":"Zigbee-Internals/#cc2530-znp-protocol","text":"The CC2530 is flashed with Texas Instrument ZNP Software version 1.2. The protocol is build on a serial communication between the main cpu and the CC2530. Z-Stack 1.2 Monitor and Test API Serial communication is configured as 8N1, 115200 bauds. We suggest to use GPIO13/15 because they have hardware serial support. Please note that there is only one usable hardware serial, either on GPIO1/3 or GPIO13/15. To enable hardware serial on GPIO13/15 for Tasmota, set Serial 0 and restart. Otherwise Z2T will use Software serial provided by TasmotaSerial. Receiving 115200 bauds in software is a timing challenge. Here is the anatomy of a byte transmitted in serial mode. Each bit is 8.7\u00b5s, or ~700 CPU cycles at 80MHz (1400 cycles at 160MHz). It all starts with a LOW \"start bit\" that generates an interrupt transferred to TasmotaSerial. Then TasmotaSerial enters a tightly controlled loop to read each bit (least sifnificant first). The frame stops with a HIGH stop bit. What can go wrong? Tasmota may be already handling an interrupt when the start bit arrives, potentially causing a shift by 1 bit and a wrong message. Here is a 0xFE byte correctly received: Same frame with a delay in the interrupt handler, and mistakenly read 0xFF: TasmotaSerial has been improved to allow receiving a train of bytes withtout any disruption. CC2530 generally sends all the bytes one after the other for a single ZNP message (up to 250 bytes). Instead of giving back control after the first byte, the TasmotaSerial interrupt handler continues to monitor the serial RX line for the next 4 bits and checks whether a new start bit arrived. It avoids any error after the first byte was received. Still the first byte in the message could have been wrong. Fortunately, the first byte sent by ZNP is always 0xFE (see below). This means that if the interrupt arrives too late, Tasmota will read 0xFF instead of 0xFE. Z2T software does automatic error correction in this case, i.e. if the first byte received is 0xFF, it is automatically assumed to be 0xFE and the rest of the message is read normally. With these two schemes, software serial for Zigbee proved to be extremely reliable, even at 80MHz. It is highly recommended though to run at 160MHz.","title":"CC2530 ZNP protocol"},{"location":"Zigbee/","text":"?> Zigbee2Tasmota serves as a gateway for devices connected to a Zigbee wireless network to bridge their communications over to Wi-Fi. Zigbee2Tasmota is a lightweight Zigbee solution running on an ESP82xx Wi-Fi chip. Hence it is easier to deploy in your living room or around your home. It is largely inspired from Zigbee2mqtt but it's a complete rewrite to make it fit on an ESP82xx with 80kB of RAM and only 1MB of flash memory. A list of compatible devices is maintained in the Zigbee Device Compatibility Repository . Zigbee Introduction ~ Before using Zigbee to Tasmota, you need to understand a few concepts. Here is a simplified comparison to the Wi-Fi equivalent (sort of). Zigbee concept Wi-Fi equivalent Zigbee coordinator The coordinator is responsible for selecting the channel, PanID, security policy, and stack profile for a network. Zigbee2Tasmota will act as a coordinator. You can have multiple coordinators as long as they have different PanIDs. Wi-Fi Access Point PanID (Personal Area Network IDentifier) This parameter is unique in a Zigbee network (16-bit integer, 0x0000\u20130x3FFF). Default: 0x1A63 SSID (the Wi-Fi network name) ShortAddr Address of the device on the Zigbee network. This address is randomly assigned when the device first connects to the coordinator (16 bits integer, 0x0000\u20130xFFF7). The coordinator has address 0x0000. You need to track which device has which address or assing a \"Friendly Name\" to each new discovered device. IP address GroupAddr Group address of a collection of devices, it allows a single message to address multiple devices at once (16 bits integer, 0x0000\u20130xFFFF). For example a remote can turn on/off a group of lights. GroupAddr 0x0000 is not assigned. Multicast Endpoint The endpoint on the coordinator or on the Zigbee device the message is sent from/to. You can see endpoints as logical device providing distinct features (8 bits integer, 1\u2013240). IP Port IEEEAddr Device hardware address (64 bits). This is unique per device and factory assigned. MAC address Channel 11-26 Default: 11 (See Zigbee-Wifi coexistence ) Wi-Fi Channel Encryption Key 128-bit encryption key. default: 0x0D0C0A08060402000F0D0B0907050301 Wi-Fi password Pairing By default the coordinator does not accept new devices unless put in pairing mode. When in pairing mode, it will accept pairing requests from any device within range. Default: pairing disabled WPS Hardware ~ Zigbee Adapter ~ You cannot use any CC2531 based device with Tasmota! CC2531 supports USB communication and not serial communication required by Zigbee2Tasmota. CC2530 with PCB antenna, DL-20 CC2530 with external antenna CC2530 with external antenna and CC2591 RF front end Wi-Fi Adapter ~ Using an ESP82xx device such as a Wemos D1 Mini or a NodeMCU to flash the CC2530 (described below) is a lower cost alternative than using a single purpose CC_DEBUGGER . When in normal operation, this ESP82xx device can then also serve as the Wi-Fi adapter for the Zigbee2Tasmota messaging. In normal operation, only two free GPIO are needed for the serial communications with the CC2530. You can use the ESP82xx device above to flash the CC2530 adapter(s) and then use any other ESP82xx device flashed with Zigbee2Tasmota as the gateway between Zigbee and Wi-Fi. Connecting to Tasmota ~ 1. Flash the CC2530 module ~ Zigbee2Tasmota requires a TI CC2530 based module flashed with Z-Stack-firmware from Koen Kanters . To simplify this procedure, a ready to use fork of the needed firmware files is available. Due to memory constraints of the CC2530, you can only pair 16 devices to a coordinator ( See details ). There is an alternative firmware allowing for Zigbee routers to create a mesh network and go beyond 16 devices. This is currently not tested nor supported by Zigbee2Tasmota. It may be added later. A. Flash CCLib on an ESP82xx Device Flashing the CC2530 normally requires a CC_DEBUGGER . Using an ESP82xx device like a Wemos D1 Mini is a lower cost alternative. If you are using a Wemos D1 Mini or NodeMCU, just plug the microUSB port. Vcc (3.3V), GND, Tx (GPIO1), and Rx (GPIO3) are connected via the microUSB port. Be sure that you are using a USB data cable. For ESP devices that do not have a microUSB connector, make the following connections: ESP Device Serial Programming Adapter Vcc Vcc GND GND GPIO0 GND GPIO1 Rx GPIO3 Tx Follow the usual ESP82xx flashing process - you are just using CCLib_proxy.ino.bin instead of Tasmota. Once the firmware upload completes, retain the serial interface connections (3.3V, GND, Tx, Rx). These will be used later for flashing the CC2530. B. Ready-made PCB These PCB make all the connections required to flash the CC2530 and to run Z2T. SuperHouse.tv Jon Oxer created a custom PCB to connect a Wemos D1 Mini and a CC2530 board (with or without CC2591). Complete module H4NC User h4nc created a custom PCB to connect a NodeMCU and a CC2530 board. You can also get a complete Z2T module with case, pre-flashed and ready to configure and deploy. Prototype C. Flash a DL-20 Zigbee module The DL-20 Zigbee module has a 5-pin 1.27mm pitch unpopulated header with 0.6mm througholes. For flashing any of the Zigbee modules, you need the following connections: ESP Pin D1 Mini NodeMCU CC2530 Pin DL-20 J2 Pin Location GPIO12 D6 CC_DD (A.K.A. P2_1 ('P21') or Debug Data) 5 GPIO4 D2 CC_DC (A.K.A. P2_2 ('P22') or Debug Clock) 4 Vcc 3.3v Vcc 3 GPIO5 D1 CC_RST 2 GND GND GND 1 DL-20 Flashing Jumpers Insert alternating male Dupont jumpers; one jumper on one side, the next one on other side. This allows the pins to provide the friction themselves to maintain contact and remain firmly in place. You only need DD, DC, and RST (a fourth jumper is shown which is used to keep the RST jumper in place). Vcc and GND are available on the main serial interface pins. D. Upload the firmware to the CC2530 The CC2530 requires Z-Stack_Home_1.2 , of type Default (not Source Routing ). For convenience, ready to use firmware files are provided. Select the right one for your hardware: CC2530 , CC2530 + CC2591 or CC2530 + CC2592 . These Python scripts require Python 2.7. 1. Ensure that you have Python 2.7 installed 2. Install pyserial 3.0.1: pip install pyserial==3.0.1 3. Check for connectivity before flashing: python Python/cc_info.py -p <serial_port> where \\ is the serial port for the ESP82xx device. e.g. /dev/cu.usbserial-xxxx or COM7 Example of result: ``` INFO: Found a CC2530 chip on /dev/cu.usbserial-xxxx Chip information: Chip ID : 0xa524 Flash size : 16 Kb Page size : 2 Kb SRAM size : 1 Kb USB : No Device information: IEEE Address : 000000000000 PC : 0000 Debug status: [ ] CHIP_ERASE_BUSY [ ] PCON_IDLE [X] CPU_HALTED [ ] PM_ACTIVE [ ] HALT_STATUS [X] DEBUG_LOCKED [X] OSCILLATOR_STABLE [ ] STACK_OVERFLOW Debug config: [ ] SOFT_POWER_MODE [ ] TIMERS_OFF [ ] DMA_PAUSE [ ] TIMER_SUSPEND ``` If your CC2530 is DEBUG_LOCKED, then the flash size will be incorrectly reported as 16kB. Dont worry flashing the Z-Stack firmware will work and reset the DEBUG_LOCKED bit. In some situation flashing fails with a error message flash have not enough space . If this happens do the following: python Python/cc_read_flash.py -p <serial_port> -o x.hex python Python/cc_write_flash.py --erase -p <serial_port> -i x.hex Recheck for connectivity and the correct flash size by repeating step #3. Flash the Z-Stack firmware using the following command: Flashing the CC2530 takes about 20 minutes python Python/cc_write_flash.py -e -p <serial_port> -i Bin/CC2530_DEFAULT_20190608_CC2530ZNP-Prod.hex ``` INFO: Found a CC2530 chip on /dev/cu.usbserial-xxxx Chip information: Chip ID : 0xa524 Flash size : 256 Kb Page size : 2 Kb SRAM size : 8 Kb USB : No Sections in Bin/CC2530_DEFAULT_20190608_CC2530ZNP-Prod.hex: Addr. Size 0x0000 8176 B 0x1ff6 10 B 0x3fff0 1 B 0x2000 239616 B This is going to ERASE and REPROGRAM the chip. Are you sure? : y Flashing: - Chip erase... - Flashing 4 memory blocks... -> 0x0000 : 8176 bytes Progress 100%... OK -> 0x1ff6 : 10 bytes Progress 100%... OK -> 0x3fff0 : 1 bytes Progress 100%... OK -> 0x2000 : 239616 bytes Progress 100%... OK Completed ``` If you don't see any on screen activity that flashing has begun (i.e., progress percentages increasing) within a couple minutes, then abort the command, cycle power on the ESP82xx, and start this step over. Additional References: - Flashing with CCLoader using a NodeMCU/Wemos D1 Mini - Flashing with a Wemos D1 Mini or equivalent and CCLib is described in greater detail in this blog post . - Koen Kanters Z-Stack CC2530 firmware files . - There are many tutorials online on how to flash a CC2530 with a dedicated CC_DEBUGGER . 2. Flash an ESP82xx Device with Zigbee2Tasmota Tasmota ~ Once the CC2530 flashing process completes, you can re-use that ESP82xx device by flashing it with the Zigbee2Tasmota firmware. Otherwise, you can use any ESP82xx device. - Compile Tasmota - #define USE_ZIGBEE in user_config_override.h . - optional Run the ESP at 160MHz instead of 80MHz, this ensures higher reliability in serial communication with CC2530. In platformio_override.ini - Uncomment: board_build.f_cpu = 160000000L [!WARNING] If you find that your Zigbee2Tasmota operation is unstable, you may have an ESP82xx device that cannot operate reliably at the higher frequency. If you are using hardware serial (see below) and you still have unreliability, try compiling for 80MHz (reverse the options above) and flash the ESP82xx device again to see if operating at a lower frequency improves stability. Running at 80MHz will impact software serial communications so hardware serial is highly recommended if running the ESP82xx at 80MHz. Follow the usual Tasmota flashing process 3. Connect the CC2530 to the Tasmota Device ~ The connection uses a 115200 baud serial connection. Hence you need to configure two GPIOs: Zigbee TX and Zigbee RX . If you are using your ESP82xx device to flash the Zigbee adapter as described in the flashing section, GPIO4, GPIO5, and GPIO12 are already in use. You may want to leave these connections in place in case you need to update the CC2530 firmware in the future. Otherwise, any of these GPIO can also be used. The interface between the ESP82xx Wi-Fi device and the CC2530 Zigbee module uses high speed serial. It is recommended that hardware serial pins be used (GPIO1/GPIO3 or GPIO13[Rx]/GPIO15[Tx]) . Due to ESP82xx GPIO pin constraints, GPIO15 can only be used as serial Tx. Tasmota also provides serial communications emulation through software (i.e., software serial). This allows any GPIO to be used. TasmotaSerial version 2.4.x (PR #6377 ) has improved the reliability of software serial making it feasible for use in this application. However, if you have an option to use hardware serial, choose that. ?> Z2T uses software serial by default to allow for serial logging on GPIO1/GPIO3. Use SerialLog 0 to enable hardware serial on GPIO13[Rx]/GPIO15[Tx] . Recommended connections: ESP Device Tasmota Component CC2530 GPIO13 Zigbee RX (166) CC_TXD (A.K.A. P0_3) GPIO15 Zigbee TX (165) CC_RXD (A.K.A. P0_2) Configure the Tasmota device using a custom template. Assign Zigbee Tx (165) and Zigbee Rx (166) to the corresponding GPIOs to be used for serial communication with the CC2530. For example: { \"NAME\" : \"Zigbee\" , \"GPIO\" :[ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 166 , 0 , 165 , 0 ], \"FLAG\" : 0 , \"BASE\" : 18 } 4. First run ~ When the Tasmota device boots, Zigbee2Tasmota will wait for 15 seconds before initializing the CC2530. This time allows for Wi-Fi and MQTT connection (hopefully). When you first run your CC2530, you will see additional steps to configure the device: MQT : tele /<topic>/ RESULT = { \"ZbState\" :{ \"Status\" : 1 , \"Message\" : \"CC2530 booted\" , \"RestartReason\" : \"Watchdog\" , \"MajorRel\" : 2 , \"MinorRel\" : 6 }} MQT : tele /<topic>/ RESULT = { \"ZbState\" :{ \"Status\" : 50 , \"MajorRel\" : 2 , \"MinorRel\" : 6 , \"MaintRel\" : 3 , \"Revision\" : 20190608 }} MQT : tele /<topic>/ RESULT = { \"ZbState\" :{ \"Status\" : 2 , \"Message\" : \"Reseting configuration\" }} MQT : tele /<topic>/ RESULT = { \"ZbState\" :{ \"Status\" : 3 , \"Message\" : \"Configured, starting coordinator\" }} MQT : tele /<topic>/ RESULT = { \"ZbState\" :{ \"Status\" : 51 , \"IEEEAddr\" : \"0x00124B00199DF06F\" , \"ShortAddr\" : \"0x0000\" , \"DeviceType\" : 7 , \"DeviceState\" : 9 , \"NumAssocDevices\" : 0 }} MQT : tele /tasmota/Zigbee_home/ RESULT = { \"ZbState\" :{ \"Status\" : 0 , \"Message\" : \"Started\" }} ZIG : Zigbee started ZIG : No zigbee devices data in Flash Normal boot looks like: MQT : tele /<topic>/ RESULT = { \"ZbState\" :{ \"Status\" : 1 , \"Message\" : \"CC2530 booted\" , \"RestartReason\" : \"Watchdog\" , \"MajorRel\" : 2 , \"MinorRel\" : 6 }} MQT : tele /<topic>/ RESULT = { \"ZbState\" :{ \"Status\" : 50 , \"MajorRel\" : 2 , \"MinorRel\" : 6 , \"MaintRel\" : 3 , \"Revision\" : 20190608 }} MQT : tele /<topic>/ RESULT = { \"ZbState\" :{ \"Status\" : 3 , \"Message\" : \"Configured, starting coordinator\" }} MQT : tele /<topic>/ RESULT = { \"ZbState\" :{ \"Status\" : 51 , \"IEEEAddr\" : \"0x00124B00199DF06F\" , \"ShortAddr\" : \"0x0000\" , \"DeviceType\" : 7 , \"DeviceState\" : 9 , \"NumAssocDevices\" : 0 }} MQT : tele /<topic>/ RESULT = { \"ZbState\" :{ \"Status\" : 0 , \"Message\" : \"Started\" }} ZIG : Zigbee started ZIG : Zigbee devices data in Flash ( 516 bytes ) You can also force a factory reset of your CC2530 with the following command, and reboot: ZigbeeReset 1 Using Zigbee2Tasmota ~ For a list of available command see Zigbee Commands . [!NOTE] Zigbee will automatically boot the CC2530 device, configure the device and wait for Zigbee messages. Pairing Zigbee Devices ~ When you first create a Zigbee network, it contains no device except the coordinator. The first step is to add devices to the network, which is called pairing . By default, and for security reasons, the Zigbee coordinator does not automatically accept new devices. To pair new devices, use ZbPermitJoin 1 . Once Zigbee2Tasmota is in pairing mode, put the Zigbee device into pairing mode. This is usually accomplished by pressing the button on the device for 5 seconds or more. To stop pairing, use ZbPermitJoin 0 . ZbPermitJoin 1 xx:xx:xx CMD : ZbPermitJoin 1 xx:xx:xx MQT : stat/<topic>/RESULT = {\"ZbPermitJoin\":\"Done\"} xx:xx:xx MQT : tele/<topic>/RESULT = {\"ZbState\":{\"Status\":21,\"Message\":\"Enable Pairing mode for 60 seconds\"}} 60 seconds later: xx:xx:xx MQT : tele/<topic>/RESULT = {\"ZbState\":{\"Status\":20,\"Message\":\"Disable Pairing mode\"}} Although this is highly discouraged, you can permanently enable Zigbee pairing, until the next reboot, with ZbPermitJoin 99 . ZbPermitJoin 99 xx:xx:xx MQT : tele/<topic>/RESULT = {\"ZbState\":{\"Status\":22,\"Message\":\"Enable Pairing mode until next boot\"}} ZbPermitJoin 0 xx:xx:xx MQT : tele/<topic>/RESULT = {\"ZbState\":{\"Status\":20,\"Message\":\"Disable Pairing mode\"}} yaml MQT: tele/<topic>/SENSOR = {\"ZbState\":{\"Status\":30,\"IEEEAddr\":\"0x00158D00036B50AE\",\"ShortAddr\":\"0x8F20\",\"PowerSource\":false,\"ReceiveWhenIdle\":false,\"Security\":false}} Example for Aqara Temperature & Humidity Sensor To pair this sensor, press and hold the button for 5 seconds. The led will flash several times and you will see logs entries, especially this one: Put Zigbee2Tasmota into pairing mode using the ZigbeePermitJoin command as described above Press the Xiaomi Aqara sensor's button for 5 seconds to pair the devices. You will see a message as follows: MQT: tele/<topic>/SENSOR = {\"ZbState\":{\"Status\":30,\"IEEEAddr\":\"0x00158D00036B50AE\",\"ShortAddr\":\"0x8F20\",\"PowerSource\":false,\"ReceiveWhenIdle\":false,\"Security\":false}} Message with \"Status\":30 shows some characteristics of the device: Field name Value Status 30 indicates a device connect or reconnect. This is the opportunity to match IEEEAddress and short address IEEEAddr Long unique address (64 bits) of the device - factory set ShortAddr Short address (16 bits) randomly assigned to the device on this Zigbee network PowerSource true = the device is connected to a power source false = the device runs on battery ReceiveWhenIdle true = the device can receive commands when idle false = the device is not listening. Commands should be sent when the device reconnects and is idle Security Security capability (meaning unknown, to be determined) Zigbee Friendly Names ~ Since version 8.1.0.4, Z2T supports friendly names for devices. Instead of a short address like \"0x4773\" you can assign a friendly name like \"Room_Plug\" . See ZbName command to set names. Example with a Xiaomi Aqara Cube with address 0x128F : xx:xx:xx MQT : tele/<topic>/RESULT = {\"ZbReceived\":{\"0x128F\":{\"AqaraVibrationMode\":\"tilt\",\"AqaraVibrationsOrAngle\":162,\"AqaraAccelerometer\":[-690,2,138],\"AqaraAngles\":[-78,0,11],\"LinkQuality\":158}}} Setting its name to Vibration_sensor : ZigbeeName 0x128F,Vibration_sensor xx:xx:xx CMD : ZbName 0x128F,Vibration_sensor xx:xx:xx MQT : stat/<topic>/RESULT = {\"0x128F\":{\"Name\":\"Vibration_sensor\"}} (10 seconds later) xx:xx:xx ZIG : Zigbee Devices Data store in Flash (0x402FF800 - 270 bytes) Now the sensor readings include the friendly name: xx:xx:xx MQT : tele/<topic>/RESULT = {\"ZbReceived\":{\"0x128F\":{\"Name\":\"Vibration_sensor\",\"AqaraVibrationMode\":\"tilt\",\"AqaraVibrationsOrAngle\":171,\"AqaraAccelerometer\":[-691,12,130],\"AqaraAngles\":[-78,1,11],\"LinkQuality\":153}}} If you set SetOption83 1 sensor readings will use the friendly name as KSON key, short address is added as Device : xx:xx:xx MQT : tele/<topic>/RESULT = {\"ZbReceived\":{\"Vibration_sensor\":{\"Device\":\"0x128F\",\"AqaraVibrationMode\":\"tilt\",\"AqaraVibrationsOrAngle\":171,\"AqaraAccelerometer\":[-691,8,136],\"AqaraAngles\":[-78,1,11],\"LinkQuality\":153}}} Reading Sensors ~ Most sensors will spontaneously publish their readings, regularly or once a signifcant change happened: temperature, pressure, humidity, presence, illuminance... Sensor messages are published via MQTT when they are received from the Zigbee device. Similar to Zigbee2MQTT, Z2T tries to group and debounce sensor values when they are received within a 300ms window. Example for Aqara Temperature & Humidity Sensor This sensor monitors humidity, temperature, and air pressure. Its Zigbee model ID is lumi.weather . This device publishes sensor values roughly every hour or when a change occurs. You can also force an update pressing the device's button. It sends two kinds of messages, either 3x standard Zigbee messages, or a single proprietary message containing all sensor values. Examples: 0x8F20 is the ShortAddress of the sensor, and its name is Kitchen if you used ZbName 0x8F20,Kithchen . MQT : tele/<topic>/SENSOR ={\"ZbReceived\" : { \"0x8F20\" : { \"Name\" : \"Kitchen\" , \"Voltage\" : 2.995 , \"Battery\" : 98 , \"Temperature\" : 21.01 , \"Humidity\" : 53.68 , \"Pressure\" : 1004.04 , \"PressureUnit\" : \"hPa\" , \"Endpoint\" : 1 , \"LinkQuality\" : 88 }} or prefixed by name if you set SetOption83 1 MQT : tele/<topic>/SENSOR ={\"ZbReceived\" : { \"Kitchen\" : { \"Device\" : \"0x8F20\" , \"Voltage\" : 2.995 , \"Battery\" : 98 , \"Temperature\" : 21.01 , \"Humidity\" : 53.68 , \"Pressure\" : 1004.04 , \"PressureUnit\" : \"hPa\" , \"Endpoint\" : 1 , \"LinkQuality\" : 88 }} Topic is device specific, to allow more effective retained messages, if you set SetOption89 1 MQT : tele/<topic>/8F20/SENSOR ={\"ZbReceived\" : { \"Kitchen\" : { \"Device\" : \"0x8F20\" , \"Voltage\" : 2.995 , \"Battery\" : 98 , \"Temperature\" : 21.01 , \"Humidity\" : 53.68 , \"Pressure\" : 1004.04 , \"PressureUnit\" : \"hPa\" , \"Endpoint\" : 1 , \"LinkQuality\" : 88 }} Supported values: Field name Value LinkQuality Stength of the Zigbee signal, between 1 and 254 (integer). See this ZigBee and WiFi Coexistence Humidity Humidity in percentage (float) Pressure and PressureUnit Atmospheric pressure (float) and unit (string) Currently only hPa (A.K.A. mbar) is supported Temperature Temperature in Celsius (float) Voltage Battery voltage (float) Battery Battery charge in percentage (integer) ModelId Model name of the Zigbee device (string) Ex: lumi.weather ScaledValue and Scale Give the raw measure and the scale correction as 10^scale And many more... If a value is not decoded, it will appear as \"<cluster>_<attr>\":<value> where <cluster> is the Zigbee ZCL Cluster of the attribute (family), <attr> is the attribute number and <value> its published value. Example: \"0402_0000\":2240 is attribute 0x0000 from cluster 0x0402, which is the temperature in hundredth of \u00b0C. It is automatically converted to \"Temperature\":22.40 . Sending Commands ~ You can send commands to device or groups of device, for example to turn on/off a light, set its brightness of open/close shutters. Here is a list of supported commands, see below how to send any command if it's not in the list. Command Parameters Cluster Power 1\\|true\\|\"true\"\\|\"on\" : On 0\\|false\\|\"false\"\\|\"off\" : Off 2\\|\"Toggle\" : Toggle 0x0006 Dimmer 0..254 : Dimmer value 255 is normally considered as invalid, and may be converted to 254 0x0008 DimmerUp null : no parameter. Increases dimmer by 10% 0x0008 DimmerDown null : no parameter. Decreases dimmer by 10% 0x0008 DimmerStop null : no parameter. Stops any running increase of decrease of dimmer. 0x0008 ResetAlarm <alarmcode>,<clusterid> : (to be documented later) 0x0009 ResetAllAlarms null : no parameter, (to be documented later) 0x0009 Hue 0..254 : change Hue value 0x0300 Sat 0..254 : change Sat value 0x0300 HueSat 0..254,0..254 : change both Hue and Sat values 0x0300 Color 0..65534,0..65534 : change the color using [x,y] coordinates 0x0300 CT 0..65534 : change the white color-temperature in Mireds 0x0300 Shutter 0..254 : send any Shutter command (prefer the commands below) 0x0102 ShutterOpen null : no parameter, open shutter 0x0102 ShutterClose null : no parameter, close shutter 0x0102 ShutterStop null : no parameter, stop shutter movement 0x0102 ShutterLift 0..100 : move shutter to a specific position in percent 0 %=open, 100 %=closed 0x0102 ShutterTilt 0..100 : move the shutter to the specific tilt position in percent 0x0102 The format of the command is following: ZbSend {\"Device\":\"<device>\",\"Send\":{\"<sendcmd>\":<sendparam>}} where <device> identifies the target and can be a shortaddr 0x1234 , a longaddr 0x1234567812345678 or a name Kitchen . \u2003 \"<sendcmd>\":<sendparam> the command and its parameters If the device has been correctly paired and its endpoints recorded by Z2T, you shouldn't need to specify a target endpoint. You can use an option \"endpoitn\":<endpoint> parameter if Z2T can't find the correct endpoint or if you want to change from the default endpoint. See below Understanding endpoints . Low-level commands ~ There is a special syntax if you want to send arbitrary commands: \"Send\":\"<send_bytes>\" where <send_bytes> has the following syntax: \"<cluster>_<cmd>/<bytes>\" : send a non-cluster specific command for cluster id <cluster> , command id <cmd> and payload <bytes> . Example: ZbSend {\"Device\":\"0x1234\",\"Send\":\"0000_00/0500\"} I.e. send a Read command (0x00) to the general cluster (0x0000) for attribute ManufId (0x0005). Note: all values are little-endian. Or use '!' instead of '_' to specify cluster-specific commands: \"<cluster>!<cmd>/<bytes>\" : send a cluster specific command for cluster id <cluster> , command id <cmd> and payload <bytes> . Example: ZbSend {\"Device\":\"0x1234\",\"Send\":\"0008_04/800A00\"} I.e. send a Dimmer command (0x04) from Level Control cluster (0x0008) with payload being: Dimmer value 0x80, and transition time of 1 second (0x000A = 10 tenths of seconds). Of course the latter example could be simply: ZbSend {\"Device\":\"0x1234\",\"Send\":{\"Dimmer\":\"0x80\"} Examples: ~ OSRAM Plug ZbSend { \"device\" : \"0x4773\" , \"send\" :{ \"Power\" : \"On\" } } ZbSend { \"device\" : \"0x4773\" , \"send\" :{ \"Power\" : 1 } } ZbSend { \"device\" : \"0x4773\" , \"send\" :{ \"Power\" : false } } ZbSend { \"device\" : \"0x4773\" , \"send\" :{ \"Power\" : \"Toggle\" } } Read the On/Off status: (all three commands below are synonyms) ZbRead { \"device\" : \"0x4773\" , \"endpoint\" : \"0x03\" , \"cluster\" : \"0x0006\" , \"read\" : \"0x0000\" } ZbRead { \"device\" : \"0x4773\" , \"endpoint\" : \"0x03\" , \"cluster\" : \"0x0006\" , \"read\" :[ \"0x0000\" ] } ZbRead { \"device\" : \"0x4773\" , \"endpoint\" : 3 , \"cluster\" : 6 , \"read\" : 0 } xx:xx:xx MQT: tele/tasmota/SENSOR = { \"ZbReceived\" :{ \"0x4773\" :{ \"Power\" : true , \"LinkQuality\" : 52 }}} Philips Hue bulb ZbSend { \"device\" : \"0x3D82\" , \"send\" :{ \"Power\" : \"Off\" } } ZbSend { \"device\" : \"0x3D82\" , \"send\" :{ \"Dimmer\" : 128 } } ZbSend { \"device\" : \"0x3D82\" , \"send\" :{ \"Dimmer\" : 254 } } ZbSend { \"device\" : \"0x3D82\" , \"endpoint\" : \"0x0B\" , \"send\" :{ \"Dimmer\" : 0 } } Receiving Commands ~ If you pair device like switches and remotes, you will also see received commands from thos devices. When a command is received, attributes are published both in their low-level and high-level formats (if known). Low level format is the following: \"<cluster>!<cmd>\":\"<payload\" Example for IKEA Remote: {\"ZbReceived\":{\"IKEA_remote\":{\"Device\":\"0xF72F\",\"0006!02\":\"\",\"Power\":2,\"Endpoint\":1,\"LinkQuality\":31}}} The command received \"0006!02\":\"\" is Power Toggle (0x02) from On/Off cluster (0x0006) with no payload. It is also translated as \"Power\":2 . \"Endpoint\":1 tells you from which endpoint the command was send. Some Xiaomi multi-switches use different endpoints for each switch. Light state tracking ~ Once Z2T receives a command related to a light (Power, Dimmer, Color, ColorTemp), it sends right after a Read command to get the actual state of the light. This is used for Hue Emulation and Alexa support. The final attributes are read betwenn 200ms and 1000ms later, to allow for the light to achieve its target state. Example: 16 : 02 : 04 MQT : tele /<topic>/ SENSOR = { \"ZbReceived\" :{ \"IKEA_remote\" :{ \"Device\" : \"0xF72F\" , \"0006!02\" : \"\" , \"Power\" : 2 , \"Endpoint\" : 1 , \"Group\" : 100 , \"LinkQuality\" : 75 }}} 16 : 02 : 05 MQT : tele /<topic>/ SENSOR = { \"ZbReceived\" :{ \"IKEA_Light\" :{ \"Device\" : \"0x5ADF\" , \"Power\" : true , \"Endpoint\" : 1 , \"LinkQuality\" : 80 }}} 16 : 02 : 06 MQT : tele /<topic>/ SENSOR = { \"ZbReceived\" :{ \"IKEA_remote\" :{ \"Device\" : \"0xF72F\" , \"0008!06\" : \"002B0500\" , \"DimmerUp\" : true , \"Endpoint\" : 1 , \"Group\" : 100 , \"LinkQuality\" : 75 }}} 16 : 02 : 08 MQT : tele /<topic>/ SENSOR = { \"ZbReceived\" :{ \"IKEA_Light\" :{ \"Device\" : \"0x5ADF\" , \"Dimmer\" : 102 , \"Endpoint\" : 1 , \"LinkQuality\" : 80 }}} Ikea Remote (E1524/E1810) ~ \"ModelId\":\"TRADFRI remote control\",\"Manufacturer\":\"IKEA of Sweden\" Short press center button - \"0006!02\":\"\" and \"Power\":2 Short press dimmer up - \"0008!06\":\"002B0500\" and \"DimmerUp\":true Short press dimmer down - \"0008!02\":\"012B05000000\" and \"DimmerStep\":1 Short press arrow right - \"0005!07\":\"00010D00\" and \"ArrowClick\":0 Short press arrow left - \"0xF72F\",\"0005!07\":\"01010D00\" and \"ArrowClick\":1 Long press dimmer up - \"0008!05\":\"0054\" and \"DimmerMove\":0 Long press dimmer up release - \"0008!07\":\"\" and \"DimmerStop\":true Long press dimmer down - \"0008!01\":\"01540000\" and \"DimmerMove\":1 Long press dimmer down release - ,\"0008!03\":\"0000\" and \"DimmerStop\":true Group address ~ Zigbee has a unique feature call Groups. It allows you to send a single command to a group of devices. For example a remote can control a group of multiple lights. Zigbee groups are 16 bits arbitrary numbers that you can freely assign. When you send to a group, you don't specify a targer address anymore nor an endpoint. Groups works in two steps: first you add devices to groups, second you send commands to groups. See the below Zigbee Binding to configure a remote to send commands to a specific group. Adding groups to devices ~ Configuring groups for devices requires to send commands. Make sure the device is powered and awake (i.e. wake-up battery powered devices). List all groups for a device. ZbSend {\"device\":\"IKEA_Light\",\"Send\":{\"GetAllGroups\":true}} xx : xx : xx MQT : tele /<topic>/ SENSOR = { \"ZbReceived\" :{ \"IKEA_Light\" :{ \"Device\" : \"0x5ADF\" , \"0004<02\" : \"FF00\" , \"GetGroupCapacity\" : 255 , \"GetGroupCount\" : 0 , \"GetGroup\" :[], \"Endpoint\" : 1 , \"LinkQuality\" : 80 }}} The following response tells you: \"GetGroupCount\":1 the light belongs to one group \"GetGroup\":[100] and the group number is 100 . xx : xx : xx MQT : tele /<topic>/ SENSOR = { \"ZbReceived\" :{ \"IKEA_Light\" :{ \"Device\" : \"0x5ADF\" , \"0004<02\" : \"FF016400\" , \"GetGroupCapacity\" : 255 , \"GetGroupCount\" : 1 , \"GetGroup\" :[ 100 ], \"Endpoint\" : 1 , \"LinkQuality\" : 80 }}} Add a group to a device ZbSend {\"device\":\"IKEA_Light\",\"Send\":{\"AddGroup\":100}} xx : xx : xx MQT : tele /<topic>/ SENSOR = { \"ZbReceived\" :{ \"IKEA_Light\" :{ \"Device\" : \"0x5ADF\" , \"0004<00\" : \"006400\" , \"AddGroup\" : 100 , \"AddGroupStatus\" : 0 , \"AddGroupStatusMsg\" : \"SUCCESS\" , \"Endpoint\" : 1 , \"LinkQuality\" : 80 }}} Or if the group already exists: xx : xx : xx MQT : tele /<topic>/ SENSOR = { \"ZbReceived\" :{ \"IKEA_Light\" :{ \"Device\" : \"0x5ADF\" , \"0004<00\" : \"8A6400\" , \"AddGroup\" : 100 , \"AddGroupStatus\" : 138 , \"AddGroupStatusMsg\" : \"DUPLICATE_EXISTS\" , \"Endpoint\" : 1 , \"LinkQuality\" : 80 }}} Remove a group ZbSend {\"device\":\"IKEA_Light\",\"Send\":{\"RemoveGroup\":100}} xx : xx : xx MQT : tele /<topic>/ SENSOR = { \"ZbReceived\" :{ \"IKEA_Light\" :{ \"Device\" : \"0x5ADF\" , \"0004<03\" : \"006400\" , \"RemoveGroup\" : 100 , \"RemoveGroupStatus\" : 0 , \"RemoveGroupStatusMsg\" : \"SUCCESS\" , \"Endpoint\" : 1 , \"LinkQuality\" : 80 }}} or if the group does not exist xx : xx : xx MQT : tele /<topic>/ SENSOR = { \"ZbReceived\" :{ \"IKEA_Light\" :{ \"Device\" : \"0x5ADF\" , \"0004<03\" : \"8B6400\" , \"RemoveGroup\" : 100 , \"RemoveGroupStatus\" : 139 , \"RemoveGroupStatusMsg\" : \"NOT_FOUND\" , \"Endpoint\" : 1 , \"LinkQuality\" : 80 }}} Remove all groups ZbSend {\"device\":\"IKEA_Light\",\"Send\":{\"RemoveAllGroups\":true}} xx : xx : xx MQT : tele /<topic>/ SENSOR = { \"ZbResponse\" :{ \"Device\" : \"0x5ADF\" , \"Name\" : \"IKEA_Light\" , \"Command\" : \"0004!04\" , \"Status\" : 0 , \"StatusMessage\" : \"SUCCESS\" , \"Endpoint\" : 1 , \"LinkQuality\" : 80 }} Sending commands to a group ~ Just use the attribute \"Group\":<group_id> instead of \"Device\":<device> when sending a command. Example: power on all light in group 100: ZbSend {\"group\":100,\"Send\":{\"Power\":1}} set all dimmers in group 100 to 50%: ZbSend {\"group\":100,\"Send\":{\"Dimmer\":127}} Zigbee binding ~ Binding allows a device to send command to another device in the same Zigbee network, without any additional logic. For example, you can set a remote to control directly a group of lights, without any rules on the coordinator. The coordinator will still receive all commands. Example of direct binding ZbBind {\"Device\":\"0xC2EF\",\"ToDevice\":\"0x5ADF\",\"Endpoint\":1,\"ToEndpoint\":1,\"Cluster\":6} This command links the device 0xC2EF that will send all commands for cluster 6 (On/off cluster) frome endpoint 1 to the target device 0x5ADF on endpoint 1 . Example of group binding ZbBind {\"Device\":\"0xC2EF\",\"ToGroup\":100,\"Endpoint\":1,\"Cluster\":6} This command links the device 0xC2EF that will send all commands for cluster 6 (On/off clustre) and from endpoint 1 to the group 100 . Reponse in case of success: xx : xx : xx MQT : tele /<topic>/ RESULT = { \"ZbBind\" :{ \"Device\" : \"0xF72F\" , \"Name\" : \"IKEA_Remote\" , \"Status\" : 0 , \"StatusMessage\" : \"SUCCESS\" }} Example: IKEA remote and IKEA Light ~ IKEA remotes only support 1 group, and can be linked to a light only via group numbers (no direct binding). Add the light to group 100 ZbSend {\"device\":\"IKEA_Light\",\"Send\":{\"AddGroup\":100}} Bind the remote to group 100. Note: you need to press a button on the remote right before sending this command to make sure it's not in sleep mode ZbBind {\"Device\":\"IKEA_Remote\",\"ToGroup\":100,\"Endpoint\":1,\"Cluster\":6} Zigbee and Hue Emulation (for Alexa) ~ Z2T now supports Hue Emulation for Zigbee lights. It will mimic most of Zigbee gateways, and allows you to control Zigbee lights directly with Alexa, without any MQTT broker nor Alexa skill. Command ZbLight configures a Zigbee device to be Alexa controllable. Specify the number of channels the light supports: Simple On/Off light White Light with Dimmer White Light with Dimmer and Cold/Warm White RGB Light RGBW Light RGBCW Light, RGB and Cold/Warm White To set the light, use ZbLight <device>,<nb_of_channels . Ex: ZbLight 0x1234,2 ZbLight Kitchen_Light,1 (see ZbName) Once a light is declared, Z2T will monitor any change made to the light via Z2T or via remotes, either from a direct message or via a group message. Z2T will then send a read command to the light, between 200ms and 1000ms later, and memorize the last value. To read the last known status of a light, use ZbLight <device> Ex: ZbLight Kitchen_Light xx:xx:xx MQT: stat/<topic>/RESULT = {\"ZbLight\":{\"Kitchen_Light\":{\"Device\":\"0x5ADF\",\"Light\":2,\"Power\":0,\"Dimmer\":130,\"Colormode\":2,\"CT\":350}}} Device Configuration ~ If your device pairs successfully with Zigbee2Tasmota but doesn't report on standardized endpoint you will see messages like these: {\"ZbReceived\":{\"0x099F\":{\"0500!00\":\"010000FF0000\",\"LinkQuality\":70}}} {\"ZbReceived\":{\"0x7596\":{\"0006!01\":\"\",\"LinkQuality\":65}}} In this case you will have to use rules or an external home automation solution to parse the ZbReceived messages. The following section will focus only on rules to utilize the device inside Tasmota ecosystem. Ikea ON/OFF Switch (E1743) ~ \"ModelId\":\"TRADFRI on/off switch\",\"Manufacturer\":\"IKEA of Sweden\" Short press O - 0006!00 Short press I - 0006!01 Long press O - 0008!01 Long press I - 0008!05 Long press release O or I - 0008!07 In this example Tradfri switch reports on 0x7596 and is used to control another Tasmota light device: Rule on ZbReceived # 0x7596 # 0006 ! 00 = do publish cmnd /% topic %/ POWER OFF endon on ZbReceived # 0x7596 # 0006 ! 01 = do publish cmnd /% topic %/ POWER OFF endon on ZbReceived # 0x7596 # 0008 ! 01 = do publish cmnd /% topic %/ Dimmer - endon on ZbReceived # 0x7596 # 0008 ! 05 = do publish cmnd /% topic %/ Dimmer + endon Aqara Water Leak Sensor (SJCGQ11LM) ~ \"ModelId\":\"lumi.sensor_wleak.aq1\",\"Manufacturer\":\"LUMI\" In this example sensor reports on 0x099F and sends an mqtt message to topic stat/leak_sensor/LEAK : Rule on ZbReceived # 0x099F # 0500 ! 00 = 010000 FF0000 do publish stat / leak_sensor / LEAK ON endon on ZbReceived # 0x099F # 0500 ! 00 = 000000 FF0000 do publish stat / leak_sensor / LEAK OFF endon Device Information ~ You can dump the internal information gathered about connected Zigbee devices with the command ZigbeeStatus . You can use ZbStatus2 to display all information and endpoints. If probing was successful (at pairing time or using ZbProbe ), Tasmota will automatically find the right endpoint. Depending on the number of device you have, ZbStatus2 output can exceed tha maximum MQTT message size. You can request the status of each individual device using ZbStatus2 1 , ZbStatus2 2 , ZbStatus2 3 ... ZbStatus1 - List all connected devices { \"ZbStatus1\" :[{ \"Device\" : \"0x6B58\" },{ \"Device\" : \"0xE9C3\" },{ \"Device\" : \"0x3D82\" }]} ZbStatus2 - Display detailed information for each device, including long address, model and manufacturer: { \"ZbStatus2\" :[{ \"Device\" : \"0x4773\" , \"IEEEAddr\" : \"0x7CB03EAA0A0292DD\" , \"ModelId\" : \"Plug 01\" , \"Manufacturer\" : \"OSRAM\" , \"Endpoints\" :[ \"0x03\" ]},{ \"Device\" : \"0x135D\" , \"Name\" : \"Temp_sensor\" , \"IEEEAddr\" : \"0x00158D00036B50AE\" , \"ModelId\" : \"lumi.weather\" , \"Manufacturer\" : \"LUMI\" , \"Endpoints\" :[ \"0x01\" ]}]} (formatted for readability) { \"ZbStatus2\" : [{ \"Device\" : \"0x4773\" , \"IEEEAddr\" : \"0x7CB03EAA0A0292DD\" , \"ModelId\" : \"Plug 01\" , \"Manufacturer\" : \"OSRAM\" , \"Endpoints\" : [ \"0x03\" ] }, { \"Device\" : \"0x135D\" , \"Name\" : \"Temp_sensor\" , \"IEEEAddr\" : \"0x00158D00036B50AE\" , \"ModelId\" : \"lumi.weather\" , \"Manufacturer\" : \"LUMI\" , \"Endpoints\" : [ \"0x01\" ] }] } Understanding endpoints ~ Z2T will automatically take the first endpoint in the list; this works most of the time. You normally don't need to specify the endpoint number. In rare case, you can still force a specific endpoint. Example Endpoints Device Endpoint OSRAM Plug 0x03 Philips Hue Bulb 0x0B Zigbee2Tasmota Status ~ You can inspect the log output to determine whether Zigbee2Tasmota started correctly. Zigbee2Tasmota sends several status messages to inform the MQTT host about initialization. Ex: {\"ZbState\":{\"Status\":1,\"Message\":\"CC2530 booted\",\"RestartReason\":\"Watchdog\",\"MajorRel\":2,\"MinorRel\":6}} - Status contains a numeric code about the status message - 0 : initialization complete, Zigbee2Tasmota is running normally - 1 : booting - 2 : resetting CC2530 configuration - 3 : starting Zigbee coordinator - 20 : disabling Permit Join - 21 : allowing Permit Join for 60 seconds - 22 : allowing Permit Join until next boot - 30 : Zigbee device connects or reconnects - 31 : Received Node Descriptor information for a Zigbee device - 32 : Received the list of active endpoints for a Zigbee device - 33 : Received the simple Descriptor with active ZCL clusters for a Zigbee device - 50 : reporting CC2530 firmware version - 51 : reporting CC2530 device information and associated devices - 98 : error, unsupported CC2530 firmware - 99 : general error, Zigbee2Tasmota was unable to start - Message (optional) a human-readable message - other fields depending on the message (e.g., Status= 50 or Status= 51 )","title":"Zigbee"},{"location":"Zigbee/#zigbee-introduction","text":"Before using Zigbee to Tasmota, you need to understand a few concepts. Here is a simplified comparison to the Wi-Fi equivalent (sort of). Zigbee concept Wi-Fi equivalent Zigbee coordinator The coordinator is responsible for selecting the channel, PanID, security policy, and stack profile for a network. Zigbee2Tasmota will act as a coordinator. You can have multiple coordinators as long as they have different PanIDs. Wi-Fi Access Point PanID (Personal Area Network IDentifier) This parameter is unique in a Zigbee network (16-bit integer, 0x0000\u20130x3FFF). Default: 0x1A63 SSID (the Wi-Fi network name) ShortAddr Address of the device on the Zigbee network. This address is randomly assigned when the device first connects to the coordinator (16 bits integer, 0x0000\u20130xFFF7). The coordinator has address 0x0000. You need to track which device has which address or assing a \"Friendly Name\" to each new discovered device. IP address GroupAddr Group address of a collection of devices, it allows a single message to address multiple devices at once (16 bits integer, 0x0000\u20130xFFFF). For example a remote can turn on/off a group of lights. GroupAddr 0x0000 is not assigned. Multicast Endpoint The endpoint on the coordinator or on the Zigbee device the message is sent from/to. You can see endpoints as logical device providing distinct features (8 bits integer, 1\u2013240). IP Port IEEEAddr Device hardware address (64 bits). This is unique per device and factory assigned. MAC address Channel 11-26 Default: 11 (See Zigbee-Wifi coexistence ) Wi-Fi Channel Encryption Key 128-bit encryption key. default: 0x0D0C0A08060402000F0D0B0907050301 Wi-Fi password Pairing By default the coordinator does not accept new devices unless put in pairing mode. When in pairing mode, it will accept pairing requests from any device within range. Default: pairing disabled WPS","title":"Zigbee Introduction"},{"location":"Zigbee/#hardware","text":"","title":"Hardware"},{"location":"Zigbee/#zigbee-adapter","text":"You cannot use any CC2531 based device with Tasmota! CC2531 supports USB communication and not serial communication required by Zigbee2Tasmota. CC2530 with PCB antenna, DL-20 CC2530 with external antenna CC2530 with external antenna and CC2591 RF front end","title":"Zigbee Adapter"},{"location":"Zigbee/#wi-fi-adapter","text":"Using an ESP82xx device such as a Wemos D1 Mini or a NodeMCU to flash the CC2530 (described below) is a lower cost alternative than using a single purpose CC_DEBUGGER . When in normal operation, this ESP82xx device can then also serve as the Wi-Fi adapter for the Zigbee2Tasmota messaging. In normal operation, only two free GPIO are needed for the serial communications with the CC2530. You can use the ESP82xx device above to flash the CC2530 adapter(s) and then use any other ESP82xx device flashed with Zigbee2Tasmota as the gateway between Zigbee and Wi-Fi.","title":"Wi-Fi Adapter"},{"location":"Zigbee/#connecting-to-tasmota","text":"","title":"Connecting to Tasmota"},{"location":"Zigbee/#1-flash-the-cc2530-module","text":"Zigbee2Tasmota requires a TI CC2530 based module flashed with Z-Stack-firmware from Koen Kanters . To simplify this procedure, a ready to use fork of the needed firmware files is available. Due to memory constraints of the CC2530, you can only pair 16 devices to a coordinator ( See details ). There is an alternative firmware allowing for Zigbee routers to create a mesh network and go beyond 16 devices. This is currently not tested nor supported by Zigbee2Tasmota. It may be added later. A. Flash CCLib on an ESP82xx Device Flashing the CC2530 normally requires a CC_DEBUGGER . Using an ESP82xx device like a Wemos D1 Mini is a lower cost alternative. If you are using a Wemos D1 Mini or NodeMCU, just plug the microUSB port. Vcc (3.3V), GND, Tx (GPIO1), and Rx (GPIO3) are connected via the microUSB port. Be sure that you are using a USB data cable. For ESP devices that do not have a microUSB connector, make the following connections: ESP Device Serial Programming Adapter Vcc Vcc GND GND GPIO0 GND GPIO1 Rx GPIO3 Tx Follow the usual ESP82xx flashing process - you are just using CCLib_proxy.ino.bin instead of Tasmota. Once the firmware upload completes, retain the serial interface connections (3.3V, GND, Tx, Rx). These will be used later for flashing the CC2530. B. Ready-made PCB These PCB make all the connections required to flash the CC2530 and to run Z2T. SuperHouse.tv Jon Oxer created a custom PCB to connect a Wemos D1 Mini and a CC2530 board (with or without CC2591). Complete module H4NC User h4nc created a custom PCB to connect a NodeMCU and a CC2530 board. You can also get a complete Z2T module with case, pre-flashed and ready to configure and deploy. Prototype C. Flash a DL-20 Zigbee module The DL-20 Zigbee module has a 5-pin 1.27mm pitch unpopulated header with 0.6mm througholes. For flashing any of the Zigbee modules, you need the following connections: ESP Pin D1 Mini NodeMCU CC2530 Pin DL-20 J2 Pin Location GPIO12 D6 CC_DD (A.K.A. P2_1 ('P21') or Debug Data) 5 GPIO4 D2 CC_DC (A.K.A. P2_2 ('P22') or Debug Clock) 4 Vcc 3.3v Vcc 3 GPIO5 D1 CC_RST 2 GND GND GND 1 DL-20 Flashing Jumpers Insert alternating male Dupont jumpers; one jumper on one side, the next one on other side. This allows the pins to provide the friction themselves to maintain contact and remain firmly in place. You only need DD, DC, and RST (a fourth jumper is shown which is used to keep the RST jumper in place). Vcc and GND are available on the main serial interface pins. D. Upload the firmware to the CC2530 The CC2530 requires Z-Stack_Home_1.2 , of type Default (not Source Routing ). For convenience, ready to use firmware files are provided. Select the right one for your hardware: CC2530 , CC2530 + CC2591 or CC2530 + CC2592 . These Python scripts require Python 2.7. 1. Ensure that you have Python 2.7 installed 2. Install pyserial 3.0.1: pip install pyserial==3.0.1 3. Check for connectivity before flashing: python Python/cc_info.py -p <serial_port> where \\ is the serial port for the ESP82xx device. e.g. /dev/cu.usbserial-xxxx or COM7 Example of result: ``` INFO: Found a CC2530 chip on /dev/cu.usbserial-xxxx Chip information: Chip ID : 0xa524 Flash size : 16 Kb Page size : 2 Kb SRAM size : 1 Kb USB : No Device information: IEEE Address : 000000000000 PC : 0000 Debug status: [ ] CHIP_ERASE_BUSY [ ] PCON_IDLE [X] CPU_HALTED [ ] PM_ACTIVE [ ] HALT_STATUS [X] DEBUG_LOCKED [X] OSCILLATOR_STABLE [ ] STACK_OVERFLOW Debug config: [ ] SOFT_POWER_MODE [ ] TIMERS_OFF [ ] DMA_PAUSE [ ] TIMER_SUSPEND ``` If your CC2530 is DEBUG_LOCKED, then the flash size will be incorrectly reported as 16kB. Dont worry flashing the Z-Stack firmware will work and reset the DEBUG_LOCKED bit. In some situation flashing fails with a error message flash have not enough space . If this happens do the following: python Python/cc_read_flash.py -p <serial_port> -o x.hex python Python/cc_write_flash.py --erase -p <serial_port> -i x.hex Recheck for connectivity and the correct flash size by repeating step #3. Flash the Z-Stack firmware using the following command: Flashing the CC2530 takes about 20 minutes python Python/cc_write_flash.py -e -p <serial_port> -i Bin/CC2530_DEFAULT_20190608_CC2530ZNP-Prod.hex ``` INFO: Found a CC2530 chip on /dev/cu.usbserial-xxxx Chip information: Chip ID : 0xa524 Flash size : 256 Kb Page size : 2 Kb SRAM size : 8 Kb USB : No Sections in Bin/CC2530_DEFAULT_20190608_CC2530ZNP-Prod.hex: Addr. Size 0x0000 8176 B 0x1ff6 10 B 0x3fff0 1 B 0x2000 239616 B This is going to ERASE and REPROGRAM the chip. Are you sure? : y Flashing: - Chip erase... - Flashing 4 memory blocks... -> 0x0000 : 8176 bytes Progress 100%... OK -> 0x1ff6 : 10 bytes Progress 100%... OK -> 0x3fff0 : 1 bytes Progress 100%... OK -> 0x2000 : 239616 bytes Progress 100%... OK Completed ``` If you don't see any on screen activity that flashing has begun (i.e., progress percentages increasing) within a couple minutes, then abort the command, cycle power on the ESP82xx, and start this step over. Additional References: - Flashing with CCLoader using a NodeMCU/Wemos D1 Mini - Flashing with a Wemos D1 Mini or equivalent and CCLib is described in greater detail in this blog post . - Koen Kanters Z-Stack CC2530 firmware files . - There are many tutorials online on how to flash a CC2530 with a dedicated CC_DEBUGGER .","title":"1. Flash the CC2530 module"},{"location":"Zigbee/#2-flash-an-esp82xx-device-with-zigbee2tasmota-tasmota","text":"Once the CC2530 flashing process completes, you can re-use that ESP82xx device by flashing it with the Zigbee2Tasmota firmware. Otherwise, you can use any ESP82xx device. - Compile Tasmota - #define USE_ZIGBEE in user_config_override.h . - optional Run the ESP at 160MHz instead of 80MHz, this ensures higher reliability in serial communication with CC2530. In platformio_override.ini - Uncomment: board_build.f_cpu = 160000000L [!WARNING] If you find that your Zigbee2Tasmota operation is unstable, you may have an ESP82xx device that cannot operate reliably at the higher frequency. If you are using hardware serial (see below) and you still have unreliability, try compiling for 80MHz (reverse the options above) and flash the ESP82xx device again to see if operating at a lower frequency improves stability. Running at 80MHz will impact software serial communications so hardware serial is highly recommended if running the ESP82xx at 80MHz. Follow the usual Tasmota flashing process","title":"2. Flash an ESP82xx Device with Zigbee2Tasmota Tasmota"},{"location":"Zigbee/#3-connect-the-cc2530-to-the-tasmota-device","text":"The connection uses a 115200 baud serial connection. Hence you need to configure two GPIOs: Zigbee TX and Zigbee RX . If you are using your ESP82xx device to flash the Zigbee adapter as described in the flashing section, GPIO4, GPIO5, and GPIO12 are already in use. You may want to leave these connections in place in case you need to update the CC2530 firmware in the future. Otherwise, any of these GPIO can also be used. The interface between the ESP82xx Wi-Fi device and the CC2530 Zigbee module uses high speed serial. It is recommended that hardware serial pins be used (GPIO1/GPIO3 or GPIO13[Rx]/GPIO15[Tx]) . Due to ESP82xx GPIO pin constraints, GPIO15 can only be used as serial Tx. Tasmota also provides serial communications emulation through software (i.e., software serial). This allows any GPIO to be used. TasmotaSerial version 2.4.x (PR #6377 ) has improved the reliability of software serial making it feasible for use in this application. However, if you have an option to use hardware serial, choose that. ?> Z2T uses software serial by default to allow for serial logging on GPIO1/GPIO3. Use SerialLog 0 to enable hardware serial on GPIO13[Rx]/GPIO15[Tx] . Recommended connections: ESP Device Tasmota Component CC2530 GPIO13 Zigbee RX (166) CC_TXD (A.K.A. P0_3) GPIO15 Zigbee TX (165) CC_RXD (A.K.A. P0_2) Configure the Tasmota device using a custom template. Assign Zigbee Tx (165) and Zigbee Rx (166) to the corresponding GPIOs to be used for serial communication with the CC2530. For example: { \"NAME\" : \"Zigbee\" , \"GPIO\" :[ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 166 , 0 , 165 , 0 ], \"FLAG\" : 0 , \"BASE\" : 18 }","title":"3. Connect the CC2530 to the Tasmota Device"},{"location":"Zigbee/#4-first-run","text":"When the Tasmota device boots, Zigbee2Tasmota will wait for 15 seconds before initializing the CC2530. This time allows for Wi-Fi and MQTT connection (hopefully). When you first run your CC2530, you will see additional steps to configure the device: MQT : tele /<topic>/ RESULT = { \"ZbState\" :{ \"Status\" : 1 , \"Message\" : \"CC2530 booted\" , \"RestartReason\" : \"Watchdog\" , \"MajorRel\" : 2 , \"MinorRel\" : 6 }} MQT : tele /<topic>/ RESULT = { \"ZbState\" :{ \"Status\" : 50 , \"MajorRel\" : 2 , \"MinorRel\" : 6 , \"MaintRel\" : 3 , \"Revision\" : 20190608 }} MQT : tele /<topic>/ RESULT = { \"ZbState\" :{ \"Status\" : 2 , \"Message\" : \"Reseting configuration\" }} MQT : tele /<topic>/ RESULT = { \"ZbState\" :{ \"Status\" : 3 , \"Message\" : \"Configured, starting coordinator\" }} MQT : tele /<topic>/ RESULT = { \"ZbState\" :{ \"Status\" : 51 , \"IEEEAddr\" : \"0x00124B00199DF06F\" , \"ShortAddr\" : \"0x0000\" , \"DeviceType\" : 7 , \"DeviceState\" : 9 , \"NumAssocDevices\" : 0 }} MQT : tele /tasmota/Zigbee_home/ RESULT = { \"ZbState\" :{ \"Status\" : 0 , \"Message\" : \"Started\" }} ZIG : Zigbee started ZIG : No zigbee devices data in Flash Normal boot looks like: MQT : tele /<topic>/ RESULT = { \"ZbState\" :{ \"Status\" : 1 , \"Message\" : \"CC2530 booted\" , \"RestartReason\" : \"Watchdog\" , \"MajorRel\" : 2 , \"MinorRel\" : 6 }} MQT : tele /<topic>/ RESULT = { \"ZbState\" :{ \"Status\" : 50 , \"MajorRel\" : 2 , \"MinorRel\" : 6 , \"MaintRel\" : 3 , \"Revision\" : 20190608 }} MQT : tele /<topic>/ RESULT = { \"ZbState\" :{ \"Status\" : 3 , \"Message\" : \"Configured, starting coordinator\" }} MQT : tele /<topic>/ RESULT = { \"ZbState\" :{ \"Status\" : 51 , \"IEEEAddr\" : \"0x00124B00199DF06F\" , \"ShortAddr\" : \"0x0000\" , \"DeviceType\" : 7 , \"DeviceState\" : 9 , \"NumAssocDevices\" : 0 }} MQT : tele /<topic>/ RESULT = { \"ZbState\" :{ \"Status\" : 0 , \"Message\" : \"Started\" }} ZIG : Zigbee started ZIG : Zigbee devices data in Flash ( 516 bytes ) You can also force a factory reset of your CC2530 with the following command, and reboot: ZigbeeReset 1","title":"4. First run"},{"location":"Zigbee/#using-zigbee2tasmota","text":"For a list of available command see Zigbee Commands . [!NOTE] Zigbee will automatically boot the CC2530 device, configure the device and wait for Zigbee messages.","title":"Using Zigbee2Tasmota"},{"location":"Zigbee/#pairing-zigbee-devices","text":"When you first create a Zigbee network, it contains no device except the coordinator. The first step is to add devices to the network, which is called pairing . By default, and for security reasons, the Zigbee coordinator does not automatically accept new devices. To pair new devices, use ZbPermitJoin 1 . Once Zigbee2Tasmota is in pairing mode, put the Zigbee device into pairing mode. This is usually accomplished by pressing the button on the device for 5 seconds or more. To stop pairing, use ZbPermitJoin 0 . ZbPermitJoin 1 xx:xx:xx CMD : ZbPermitJoin 1 xx:xx:xx MQT : stat/<topic>/RESULT = {\"ZbPermitJoin\":\"Done\"} xx:xx:xx MQT : tele/<topic>/RESULT = {\"ZbState\":{\"Status\":21,\"Message\":\"Enable Pairing mode for 60 seconds\"}} 60 seconds later: xx:xx:xx MQT : tele/<topic>/RESULT = {\"ZbState\":{\"Status\":20,\"Message\":\"Disable Pairing mode\"}} Although this is highly discouraged, you can permanently enable Zigbee pairing, until the next reboot, with ZbPermitJoin 99 . ZbPermitJoin 99 xx:xx:xx MQT : tele/<topic>/RESULT = {\"ZbState\":{\"Status\":22,\"Message\":\"Enable Pairing mode until next boot\"}} ZbPermitJoin 0 xx:xx:xx MQT : tele/<topic>/RESULT = {\"ZbState\":{\"Status\":20,\"Message\":\"Disable Pairing mode\"}} yaml MQT: tele/<topic>/SENSOR = {\"ZbState\":{\"Status\":30,\"IEEEAddr\":\"0x00158D00036B50AE\",\"ShortAddr\":\"0x8F20\",\"PowerSource\":false,\"ReceiveWhenIdle\":false,\"Security\":false}}","title":"Pairing Zigbee Devices"},{"location":"Zigbee/#zigbee-friendly-names","text":"Since version 8.1.0.4, Z2T supports friendly names for devices. Instead of a short address like \"0x4773\" you can assign a friendly name like \"Room_Plug\" . See ZbName command to set names. Example with a Xiaomi Aqara Cube with address 0x128F : xx:xx:xx MQT : tele/<topic>/RESULT = {\"ZbReceived\":{\"0x128F\":{\"AqaraVibrationMode\":\"tilt\",\"AqaraVibrationsOrAngle\":162,\"AqaraAccelerometer\":[-690,2,138],\"AqaraAngles\":[-78,0,11],\"LinkQuality\":158}}} Setting its name to Vibration_sensor : ZigbeeName 0x128F,Vibration_sensor xx:xx:xx CMD : ZbName 0x128F,Vibration_sensor xx:xx:xx MQT : stat/<topic>/RESULT = {\"0x128F\":{\"Name\":\"Vibration_sensor\"}} (10 seconds later) xx:xx:xx ZIG : Zigbee Devices Data store in Flash (0x402FF800 - 270 bytes) Now the sensor readings include the friendly name: xx:xx:xx MQT : tele/<topic>/RESULT = {\"ZbReceived\":{\"0x128F\":{\"Name\":\"Vibration_sensor\",\"AqaraVibrationMode\":\"tilt\",\"AqaraVibrationsOrAngle\":171,\"AqaraAccelerometer\":[-691,12,130],\"AqaraAngles\":[-78,1,11],\"LinkQuality\":153}}} If you set SetOption83 1 sensor readings will use the friendly name as KSON key, short address is added as Device : xx:xx:xx MQT : tele/<topic>/RESULT = {\"ZbReceived\":{\"Vibration_sensor\":{\"Device\":\"0x128F\",\"AqaraVibrationMode\":\"tilt\",\"AqaraVibrationsOrAngle\":171,\"AqaraAccelerometer\":[-691,8,136],\"AqaraAngles\":[-78,1,11],\"LinkQuality\":153}}}","title":"Zigbee Friendly Names"},{"location":"Zigbee/#reading-sensors","text":"Most sensors will spontaneously publish their readings, regularly or once a signifcant change happened: temperature, pressure, humidity, presence, illuminance... Sensor messages are published via MQTT when they are received from the Zigbee device. Similar to Zigbee2MQTT, Z2T tries to group and debounce sensor values when they are received within a 300ms window.","title":"Reading Sensors"},{"location":"Zigbee/#sending-commands","text":"You can send commands to device or groups of device, for example to turn on/off a light, set its brightness of open/close shutters. Here is a list of supported commands, see below how to send any command if it's not in the list. Command Parameters Cluster Power 1\\|true\\|\"true\"\\|\"on\" : On 0\\|false\\|\"false\"\\|\"off\" : Off 2\\|\"Toggle\" : Toggle 0x0006 Dimmer 0..254 : Dimmer value 255 is normally considered as invalid, and may be converted to 254 0x0008 DimmerUp null : no parameter. Increases dimmer by 10% 0x0008 DimmerDown null : no parameter. Decreases dimmer by 10% 0x0008 DimmerStop null : no parameter. Stops any running increase of decrease of dimmer. 0x0008 ResetAlarm <alarmcode>,<clusterid> : (to be documented later) 0x0009 ResetAllAlarms null : no parameter, (to be documented later) 0x0009 Hue 0..254 : change Hue value 0x0300 Sat 0..254 : change Sat value 0x0300 HueSat 0..254,0..254 : change both Hue and Sat values 0x0300 Color 0..65534,0..65534 : change the color using [x,y] coordinates 0x0300 CT 0..65534 : change the white color-temperature in Mireds 0x0300 Shutter 0..254 : send any Shutter command (prefer the commands below) 0x0102 ShutterOpen null : no parameter, open shutter 0x0102 ShutterClose null : no parameter, close shutter 0x0102 ShutterStop null : no parameter, stop shutter movement 0x0102 ShutterLift 0..100 : move shutter to a specific position in percent 0 %=open, 100 %=closed 0x0102 ShutterTilt 0..100 : move the shutter to the specific tilt position in percent 0x0102 The format of the command is following: ZbSend {\"Device\":\"<device>\",\"Send\":{\"<sendcmd>\":<sendparam>}} where <device> identifies the target and can be a shortaddr 0x1234 , a longaddr 0x1234567812345678 or a name Kitchen . \u2003 \"<sendcmd>\":<sendparam> the command and its parameters If the device has been correctly paired and its endpoints recorded by Z2T, you shouldn't need to specify a target endpoint. You can use an option \"endpoitn\":<endpoint> parameter if Z2T can't find the correct endpoint or if you want to change from the default endpoint. See below Understanding endpoints .","title":"Sending Commands"},{"location":"Zigbee/#low-level-commands","text":"There is a special syntax if you want to send arbitrary commands: \"Send\":\"<send_bytes>\" where <send_bytes> has the following syntax: \"<cluster>_<cmd>/<bytes>\" : send a non-cluster specific command for cluster id <cluster> , command id <cmd> and payload <bytes> . Example: ZbSend {\"Device\":\"0x1234\",\"Send\":\"0000_00/0500\"} I.e. send a Read command (0x00) to the general cluster (0x0000) for attribute ManufId (0x0005). Note: all values are little-endian. Or use '!' instead of '_' to specify cluster-specific commands: \"<cluster>!<cmd>/<bytes>\" : send a cluster specific command for cluster id <cluster> , command id <cmd> and payload <bytes> . Example: ZbSend {\"Device\":\"0x1234\",\"Send\":\"0008_04/800A00\"} I.e. send a Dimmer command (0x04) from Level Control cluster (0x0008) with payload being: Dimmer value 0x80, and transition time of 1 second (0x000A = 10 tenths of seconds). Of course the latter example could be simply: ZbSend {\"Device\":\"0x1234\",\"Send\":{\"Dimmer\":\"0x80\"}","title":"Low-level commands"},{"location":"Zigbee/#examples","text":"","title":"Examples:"},{"location":"Zigbee/#receiving-commands","text":"If you pair device like switches and remotes, you will also see received commands from thos devices. When a command is received, attributes are published both in their low-level and high-level formats (if known). Low level format is the following: \"<cluster>!<cmd>\":\"<payload\" Example for IKEA Remote: {\"ZbReceived\":{\"IKEA_remote\":{\"Device\":\"0xF72F\",\"0006!02\":\"\",\"Power\":2,\"Endpoint\":1,\"LinkQuality\":31}}} The command received \"0006!02\":\"\" is Power Toggle (0x02) from On/Off cluster (0x0006) with no payload. It is also translated as \"Power\":2 . \"Endpoint\":1 tells you from which endpoint the command was send. Some Xiaomi multi-switches use different endpoints for each switch.","title":"Receiving Commands"},{"location":"Zigbee/#light-state-tracking","text":"Once Z2T receives a command related to a light (Power, Dimmer, Color, ColorTemp), it sends right after a Read command to get the actual state of the light. This is used for Hue Emulation and Alexa support. The final attributes are read betwenn 200ms and 1000ms later, to allow for the light to achieve its target state. Example: 16 : 02 : 04 MQT : tele /<topic>/ SENSOR = { \"ZbReceived\" :{ \"IKEA_remote\" :{ \"Device\" : \"0xF72F\" , \"0006!02\" : \"\" , \"Power\" : 2 , \"Endpoint\" : 1 , \"Group\" : 100 , \"LinkQuality\" : 75 }}} 16 : 02 : 05 MQT : tele /<topic>/ SENSOR = { \"ZbReceived\" :{ \"IKEA_Light\" :{ \"Device\" : \"0x5ADF\" , \"Power\" : true , \"Endpoint\" : 1 , \"LinkQuality\" : 80 }}} 16 : 02 : 06 MQT : tele /<topic>/ SENSOR = { \"ZbReceived\" :{ \"IKEA_remote\" :{ \"Device\" : \"0xF72F\" , \"0008!06\" : \"002B0500\" , \"DimmerUp\" : true , \"Endpoint\" : 1 , \"Group\" : 100 , \"LinkQuality\" : 75 }}} 16 : 02 : 08 MQT : tele /<topic>/ SENSOR = { \"ZbReceived\" :{ \"IKEA_Light\" :{ \"Device\" : \"0x5ADF\" , \"Dimmer\" : 102 , \"Endpoint\" : 1 , \"LinkQuality\" : 80 }}}","title":"Light state tracking"},{"location":"Zigbee/#ikea-remote-e1524e1810","text":"\"ModelId\":\"TRADFRI remote control\",\"Manufacturer\":\"IKEA of Sweden\" Short press center button - \"0006!02\":\"\" and \"Power\":2 Short press dimmer up - \"0008!06\":\"002B0500\" and \"DimmerUp\":true Short press dimmer down - \"0008!02\":\"012B05000000\" and \"DimmerStep\":1 Short press arrow right - \"0005!07\":\"00010D00\" and \"ArrowClick\":0 Short press arrow left - \"0xF72F\",\"0005!07\":\"01010D00\" and \"ArrowClick\":1 Long press dimmer up - \"0008!05\":\"0054\" and \"DimmerMove\":0 Long press dimmer up release - \"0008!07\":\"\" and \"DimmerStop\":true Long press dimmer down - \"0008!01\":\"01540000\" and \"DimmerMove\":1 Long press dimmer down release - ,\"0008!03\":\"0000\" and \"DimmerStop\":true","title":"Ikea Remote (E1524/E1810)"},{"location":"Zigbee/#group-address","text":"Zigbee has a unique feature call Groups. It allows you to send a single command to a group of devices. For example a remote can control a group of multiple lights. Zigbee groups are 16 bits arbitrary numbers that you can freely assign. When you send to a group, you don't specify a targer address anymore nor an endpoint. Groups works in two steps: first you add devices to groups, second you send commands to groups. See the below Zigbee Binding to configure a remote to send commands to a specific group.","title":"Group address"},{"location":"Zigbee/#adding-groups-to-devices","text":"Configuring groups for devices requires to send commands. Make sure the device is powered and awake (i.e. wake-up battery powered devices).","title":"Adding groups to devices"},{"location":"Zigbee/#sending-commands-to-a-group","text":"Just use the attribute \"Group\":<group_id> instead of \"Device\":<device> when sending a command. Example: power on all light in group 100: ZbSend {\"group\":100,\"Send\":{\"Power\":1}} set all dimmers in group 100 to 50%: ZbSend {\"group\":100,\"Send\":{\"Dimmer\":127}}","title":"Sending commands to a group"},{"location":"Zigbee/#zigbee-binding","text":"Binding allows a device to send command to another device in the same Zigbee network, without any additional logic. For example, you can set a remote to control directly a group of lights, without any rules on the coordinator. The coordinator will still receive all commands. Example of direct binding ZbBind {\"Device\":\"0xC2EF\",\"ToDevice\":\"0x5ADF\",\"Endpoint\":1,\"ToEndpoint\":1,\"Cluster\":6} This command links the device 0xC2EF that will send all commands for cluster 6 (On/off cluster) frome endpoint 1 to the target device 0x5ADF on endpoint 1 . Example of group binding ZbBind {\"Device\":\"0xC2EF\",\"ToGroup\":100,\"Endpoint\":1,\"Cluster\":6} This command links the device 0xC2EF that will send all commands for cluster 6 (On/off clustre) and from endpoint 1 to the group 100 . Reponse in case of success: xx : xx : xx MQT : tele /<topic>/ RESULT = { \"ZbBind\" :{ \"Device\" : \"0xF72F\" , \"Name\" : \"IKEA_Remote\" , \"Status\" : 0 , \"StatusMessage\" : \"SUCCESS\" }}","title":"Zigbee binding"},{"location":"Zigbee/#example-ikea-remote-and-ikea-light","text":"IKEA remotes only support 1 group, and can be linked to a light only via group numbers (no direct binding). Add the light to group 100 ZbSend {\"device\":\"IKEA_Light\",\"Send\":{\"AddGroup\":100}} Bind the remote to group 100. Note: you need to press a button on the remote right before sending this command to make sure it's not in sleep mode ZbBind {\"Device\":\"IKEA_Remote\",\"ToGroup\":100,\"Endpoint\":1,\"Cluster\":6}","title":"Example: IKEA remote and IKEA Light"},{"location":"Zigbee/#zigbee-and-hue-emulation-for-alexa","text":"Z2T now supports Hue Emulation for Zigbee lights. It will mimic most of Zigbee gateways, and allows you to control Zigbee lights directly with Alexa, without any MQTT broker nor Alexa skill. Command ZbLight configures a Zigbee device to be Alexa controllable. Specify the number of channels the light supports: Simple On/Off light White Light with Dimmer White Light with Dimmer and Cold/Warm White RGB Light RGBW Light RGBCW Light, RGB and Cold/Warm White To set the light, use ZbLight <device>,<nb_of_channels . Ex: ZbLight 0x1234,2 ZbLight Kitchen_Light,1 (see ZbName) Once a light is declared, Z2T will monitor any change made to the light via Z2T or via remotes, either from a direct message or via a group message. Z2T will then send a read command to the light, between 200ms and 1000ms later, and memorize the last value. To read the last known status of a light, use ZbLight <device> Ex: ZbLight Kitchen_Light xx:xx:xx MQT: stat/<topic>/RESULT = {\"ZbLight\":{\"Kitchen_Light\":{\"Device\":\"0x5ADF\",\"Light\":2,\"Power\":0,\"Dimmer\":130,\"Colormode\":2,\"CT\":350}}}","title":"Zigbee and Hue Emulation (for Alexa)"},{"location":"Zigbee/#device-configuration","text":"If your device pairs successfully with Zigbee2Tasmota but doesn't report on standardized endpoint you will see messages like these: {\"ZbReceived\":{\"0x099F\":{\"0500!00\":\"010000FF0000\",\"LinkQuality\":70}}} {\"ZbReceived\":{\"0x7596\":{\"0006!01\":\"\",\"LinkQuality\":65}}} In this case you will have to use rules or an external home automation solution to parse the ZbReceived messages. The following section will focus only on rules to utilize the device inside Tasmota ecosystem.","title":"Device Configuration"},{"location":"Zigbee/#ikea-onoff-switch-e1743","text":"\"ModelId\":\"TRADFRI on/off switch\",\"Manufacturer\":\"IKEA of Sweden\" Short press O - 0006!00 Short press I - 0006!01 Long press O - 0008!01 Long press I - 0008!05 Long press release O or I - 0008!07 In this example Tradfri switch reports on 0x7596 and is used to control another Tasmota light device: Rule on ZbReceived # 0x7596 # 0006 ! 00 = do publish cmnd /% topic %/ POWER OFF endon on ZbReceived # 0x7596 # 0006 ! 01 = do publish cmnd /% topic %/ POWER OFF endon on ZbReceived # 0x7596 # 0008 ! 01 = do publish cmnd /% topic %/ Dimmer - endon on ZbReceived # 0x7596 # 0008 ! 05 = do publish cmnd /% topic %/ Dimmer + endon","title":"Ikea ON/OFF Switch (E1743)"},{"location":"Zigbee/#aqara-water-leak-sensor-sjcgq11lm","text":"\"ModelId\":\"lumi.sensor_wleak.aq1\",\"Manufacturer\":\"LUMI\" In this example sensor reports on 0x099F and sends an mqtt message to topic stat/leak_sensor/LEAK : Rule on ZbReceived # 0x099F # 0500 ! 00 = 010000 FF0000 do publish stat / leak_sensor / LEAK ON endon on ZbReceived # 0x099F # 0500 ! 00 = 000000 FF0000 do publish stat / leak_sensor / LEAK OFF endon","title":"Aqara Water Leak Sensor (SJCGQ11LM)"},{"location":"Zigbee/#device-information","text":"You can dump the internal information gathered about connected Zigbee devices with the command ZigbeeStatus . You can use ZbStatus2 to display all information and endpoints. If probing was successful (at pairing time or using ZbProbe ), Tasmota will automatically find the right endpoint. Depending on the number of device you have, ZbStatus2 output can exceed tha maximum MQTT message size. You can request the status of each individual device using ZbStatus2 1 , ZbStatus2 2 , ZbStatus2 3 ... ZbStatus1 - List all connected devices { \"ZbStatus1\" :[{ \"Device\" : \"0x6B58\" },{ \"Device\" : \"0xE9C3\" },{ \"Device\" : \"0x3D82\" }]} ZbStatus2 - Display detailed information for each device, including long address, model and manufacturer: { \"ZbStatus2\" :[{ \"Device\" : \"0x4773\" , \"IEEEAddr\" : \"0x7CB03EAA0A0292DD\" , \"ModelId\" : \"Plug 01\" , \"Manufacturer\" : \"OSRAM\" , \"Endpoints\" :[ \"0x03\" ]},{ \"Device\" : \"0x135D\" , \"Name\" : \"Temp_sensor\" , \"IEEEAddr\" : \"0x00158D00036B50AE\" , \"ModelId\" : \"lumi.weather\" , \"Manufacturer\" : \"LUMI\" , \"Endpoints\" :[ \"0x01\" ]}]} (formatted for readability) { \"ZbStatus2\" : [{ \"Device\" : \"0x4773\" , \"IEEEAddr\" : \"0x7CB03EAA0A0292DD\" , \"ModelId\" : \"Plug 01\" , \"Manufacturer\" : \"OSRAM\" , \"Endpoints\" : [ \"0x03\" ] }, { \"Device\" : \"0x135D\" , \"Name\" : \"Temp_sensor\" , \"IEEEAddr\" : \"0x00158D00036B50AE\" , \"ModelId\" : \"lumi.weather\" , \"Manufacturer\" : \"LUMI\" , \"Endpoints\" : [ \"0x01\" ] }] }","title":"Device Information"},{"location":"Zigbee/#understanding-endpoints","text":"Z2T will automatically take the first endpoint in the list; this works most of the time. You normally don't need to specify the endpoint number. In rare case, you can still force a specific endpoint.","title":"Understanding endpoints"},{"location":"Zigbee/#zigbee2tasmota-status","text":"You can inspect the log output to determine whether Zigbee2Tasmota started correctly. Zigbee2Tasmota sends several status messages to inform the MQTT host about initialization. Ex: {\"ZbState\":{\"Status\":1,\"Message\":\"CC2530 booted\",\"RestartReason\":\"Watchdog\",\"MajorRel\":2,\"MinorRel\":6}} - Status contains a numeric code about the status message - 0 : initialization complete, Zigbee2Tasmota is running normally - 1 : booting - 2 : resetting CC2530 configuration - 3 : starting Zigbee coordinator - 20 : disabling Permit Join - 21 : allowing Permit Join for 60 seconds - 22 : allowing Permit Join until next boot - 30 : Zigbee device connects or reconnects - 31 : Received Node Descriptor information for a Zigbee device - 32 : Received the list of active endpoints for a Zigbee device - 33 : Received the simple Descriptor with active ZCL clusters for a Zigbee device - 50 : reporting CC2530 firmware version - 51 : reporting CC2530 device information and associated devices - 98 : error, unsupported CC2530 firmware - 99 : general error, Zigbee2Tasmota was unable to start - Message (optional) a human-readable message - other fields depending on the message (e.g., Status= 50 or Status= 51 )","title":"Zigbee2Tasmota Status"},{"location":"changelog-7.2/","text":"Version 7.2.0 Constance ~ Change Exception reporting removing exception details from Status 1 and consolidated in Status 12 if available Change HTTP CORS from command SetOption73 0/1 to Cors <cors_domain> allowing user control of specific CORS domain by Shantur Rathore (#7066) Change GUI Shutter button text to Up and Down Arrows based on PR by Xavier Muller (#7166) Change amount of supported DHT sensors from 3 to 4 by Xavier Muller (#7167) Change some Settings locations freeing up space for future single char allowing variable length text Change tasmota-basic.bin and FIRMWARE_BASIC to tasmota-lite.bin and FIRMWARE_LITE Fix flashing H801 led at boot by Stefan Hadinger (#7165, #649) Fix duplicated Backlog when using Event inside a Backlog by Adrian Scillato (#7178, #7147) Fix Gui Timer when using a negative zero offset of -00:00 by Peter Ooms (#7174) Fix DeepSleep in case there is no wifi by Stefan Bode (#7213) Fix Fade would ignore savedata 0 and store to flash anyways (#7262) Fix Arduino IDE compile error (#7277) Fix no AP on initial install (#7282) Add command SerialConfig 0..23 or SerialConfig 8N1 to select Serial Config based in PR by Luis Teixeira (#7108) Add command Sensor34 9 <weight code> to set minimum delta to trigger JSON message by @tobox (#7188) Add rule var %topic% by Adrian Scillato (#5522) Add rule triggers tele-wifi1#xxx by Adrian Scillato (#7093) Add SML bus decoder syntax support for byte order by Gerhard Mutz (#7112) Add experimental support for stepper motor shutter control by Stefan Bode Add optional USE_MQTT_TLS to tasmota-minimal.bin by Bohdan Kmit (#7115) Add save call stack in RTC memory in case of crash, command Status 12 to dump the stack by Stefan Hadinger Add Home Assistant force update by Frederico Leoni (#7140, #7074) Add Wifi Signal Strength in dBm in addition to RSSI Wifi Experience by Andreas Schultz (#7145) Add Yaw, Pitch and Roll support for MPU6050 by Philip Barclay (#7058) Add reporting of raw weight to JSON from HX711 to overcome auto-tare functionality by @tobox (#7171) Add Zigbee support for Xiaomi Aqara Vibration Sensor and Presence Sensor by Stefan Hadinger Add Shutter functions ramp up/down and MQTT reporting by Stefan Bode Add fallback support from version 8.x Add restriction if fallback firmware is incompatible with settings resulting in unreachable device Add support for DHT12 Temperature and Humidity sensor by Stefan Oskamp","title":"Changelog 7.2"},{"location":"changelog-7.2/#version-720-constance","text":"Change Exception reporting removing exception details from Status 1 and consolidated in Status 12 if available Change HTTP CORS from command SetOption73 0/1 to Cors <cors_domain> allowing user control of specific CORS domain by Shantur Rathore (#7066) Change GUI Shutter button text to Up and Down Arrows based on PR by Xavier Muller (#7166) Change amount of supported DHT sensors from 3 to 4 by Xavier Muller (#7167) Change some Settings locations freeing up space for future single char allowing variable length text Change tasmota-basic.bin and FIRMWARE_BASIC to tasmota-lite.bin and FIRMWARE_LITE Fix flashing H801 led at boot by Stefan Hadinger (#7165, #649) Fix duplicated Backlog when using Event inside a Backlog by Adrian Scillato (#7178, #7147) Fix Gui Timer when using a negative zero offset of -00:00 by Peter Ooms (#7174) Fix DeepSleep in case there is no wifi by Stefan Bode (#7213) Fix Fade would ignore savedata 0 and store to flash anyways (#7262) Fix Arduino IDE compile error (#7277) Fix no AP on initial install (#7282) Add command SerialConfig 0..23 or SerialConfig 8N1 to select Serial Config based in PR by Luis Teixeira (#7108) Add command Sensor34 9 <weight code> to set minimum delta to trigger JSON message by @tobox (#7188) Add rule var %topic% by Adrian Scillato (#5522) Add rule triggers tele-wifi1#xxx by Adrian Scillato (#7093) Add SML bus decoder syntax support for byte order by Gerhard Mutz (#7112) Add experimental support for stepper motor shutter control by Stefan Bode Add optional USE_MQTT_TLS to tasmota-minimal.bin by Bohdan Kmit (#7115) Add save call stack in RTC memory in case of crash, command Status 12 to dump the stack by Stefan Hadinger Add Home Assistant force update by Frederico Leoni (#7140, #7074) Add Wifi Signal Strength in dBm in addition to RSSI Wifi Experience by Andreas Schultz (#7145) Add Yaw, Pitch and Roll support for MPU6050 by Philip Barclay (#7058) Add reporting of raw weight to JSON from HX711 to overcome auto-tare functionality by @tobox (#7171) Add Zigbee support for Xiaomi Aqara Vibration Sensor and Presence Sensor by Stefan Hadinger Add Shutter functions ramp up/down and MQTT reporting by Stefan Bode Add fallback support from version 8.x Add restriction if fallback firmware is incompatible with settings resulting in unreachable device Add support for DHT12 Temperature and Humidity sensor by Stefan Oskamp","title":"Version 7.2.0 Constance"},{"location":"changelog-8.1/","text":"Version 8.1.0 Doris ~ Change Settings text handling allowing variable length text within a total text pool of 699 characters Change Smoother Fade using 100Hz instead of 20Hz animation (#7179) Change number of rule Var s and Mem s from 5 to 16 (#4933) Change number of FriendlyName s from 4 to 8 Add commands WebButton1 until WebButton16 to support user defined GUI button text (#7166) Add support for max 150 characters in most command parameter strings (#3686, #4754) Add support for GPS as NTP server by Christian Baars and Adrian Scillato Add support for AdcParam parameters to control ADC0 Moisture formula by Federico Leoni (#7309) Add Zigbee coalesce sensor attributes into a single message Add Zigbee better support for Xiaomi Double Switch and Xiaomi Vibration sensor Add Deepsleep start delay based on Teleperiod if Teleperiod differs from 10 or 300","title":"Changelog 8.1"},{"location":"changelog-8.1/#version-810-doris","text":"Change Settings text handling allowing variable length text within a total text pool of 699 characters Change Smoother Fade using 100Hz instead of 20Hz animation (#7179) Change number of rule Var s and Mem s from 5 to 16 (#4933) Change number of FriendlyName s from 4 to 8 Add commands WebButton1 until WebButton16 to support user defined GUI button text (#7166) Add support for max 150 characters in most command parameter strings (#3686, #4754) Add support for GPS as NTP server by Christian Baars and Adrian Scillato Add support for AdcParam parameters to control ADC0 Moisture formula by Federico Leoni (#7309) Add Zigbee coalesce sensor attributes into a single message Add Zigbee better support for Xiaomi Double Switch and Xiaomi Vibration sensor Add Deepsleep start delay based on Teleperiod if Teleperiod differs from 10 or 300","title":"Version 8.1.0 Doris"},{"location":"changelog-8.2/","text":"Version 8.2.0 Elliot ~ Change default my_user_config.h driver and sensor support removing most sensors and adding most drivers to tasmota.bin Change DHT driver ( 7468 , 7717 ) Change Lights: simplified gamma correction and 10 bits internal computation Change commands Prefix , Ssid , StateText , NTPServer , and FriendlyName displaying all items Change Zigbee command prefix from Zigbee* to Zb* Change MQTT message size with additional 200 characters Change display of some date and time messages from Wed Feb 19 10:45:12 2020 to 2020-02-19T10:45:12 Change IRremoteESP8266 library updated to v2.7.4 Fix PowerDelta zero power detection ( 7515 ) Fix White added to light status ( 7142 ) Fix WakeUp <x> ignores provided value ( 7473 ) Fix RGBWWTable ignored ( 7572 ) Fix commands Display and Counter from overruling command processing ( 7322 ) Fix Sonoff Bridge, Sc, L1, iFan03 and CSE7766 serial interface to forced speed, config and disable logging Fix Improved fade linearity with gamma correction Fix PWM flickering at low levels ( 7415 ) Fix LCD line and column positioning ( 7387 ) Fix Display handling of hexadecimal escape characters ( 7387 ) Fix exception 9 restart on log message in Ticker interrupt service routines NTP, Wemos and Hue emulation ( 7496 ) Fix Hass sensor discovery by Federico Leoni ( 7582 , 7548 ) Fix MaxPower functionality ( 7647 ) Fix relation between Wifi RSSI and signal strength Add command SetOption79 0/1 to enable reset of counters at teleperiod time by Andre Thomas ( 7355 ) Add command SetOption82 0/1 to limit the CT range for Alexa to 200..380 Add command SetOption84 0/1 to send AWS IoT device shadow updates (alternative to retained) Add commands SetOption85 0/1 and DevGroupShare supporting UDP Group command using GroupTopic without MQTT by Paul Diem ( 7790 ) Add command SetOption86 0/1 for PWM dimmer to turn brightness LED's off 5 seconds after last change Add command SetOption87 0/1 for PWM dimmer to turn red LED on when powered off Add command SetOption88 0/1 for PWM dimmer to let buttons control remote devices Add command SetOption89 0/1 for Zigbee distinct MQTT topics per device for SENSOR, allowing retained messages ( 7835 ) Add command ShutterButton <parameters> to control shutter(s) by to-scho ( 7403 ) Add commands SwitchMode 8 ToggleMulti, SwitchMode 9 FollowMulti and SwitchMode 10 FollowMultiInverted ( 7522 ) Add commands SwitchMode 11 PushHoldMulti and SwitchMode 12 PushHoldInverted ( 7603 ) Add commands SwitchMode 13 PushOn and SwitchMode 14 PushOnInverted ( 7912 ) Add command Buzzer -1 for infinite mode and command Buzzer -2 for following led mode ( 7623 ) Add command HumOffset -10.0 .. 10.0 to set global humidity sensor offset ( 7934 ) Add support for AdcParam parameters to control ADC0 Current Transformer Apparent Power formula by Jodi Dillon ( 7100 ) Add optional parameter <startcolor> to command Scheme <scheme>, <startcolor> to control initial start color Add web page sliders when SetOption37 128 is active allowing control of white(s) Add SerialConfig to Status 1 Add BootCount Reset Time as BCResetTime to Status 1 Add WifiPower to Status 5 Add most SetOptions as defines to my_user_config.h Add optional Wifi AccessPoint passphrase define WIFI_AP_PASSPHRASE in my_user_config.h ( 7690 ) Add SoftwareSerial to CSE7766 driver allowing different GPIOs ( 7563 ) Add rule trigger on one level deeper using syntax with two # like on zbreceived#vibration_sensor#aqaracubeside=0 do ... Add Zigbee attribute decoder for Xiaomi Aqara Cube Add ZbZNPReceived and ZbZCLReceived being published to MQTT when SetOption66 1 Add Zigbee enhanced commands decoding, added ZbPing Add Zigbee features and improvements Add Zigbee support for Hue emulation by Stefan Hadinger Add HAss Discovery support for Button and Switch triggers by Federico Leoni ( 7901 ) Add Dew Point to Temperature and Humidity sensors Add optional support for Prometheus using file xsns_91_prometheus.ino ( 7216 ) Add support for gzipped binaries Add support for Romanian language translations by Augustin Marti Add support for sensors DS18x20 and DHT family on Shelly 1 and Shelly 1PM using Shelly Add-On adapter ( 7469 ) Add support to BMP driver to enter reset state (sleep enable) when deep sleep is used in Tasmota Add support for DS1624, DS1621 Temperature sensor by Leonid Myravjev Add support for NRF24L01 as BLE-bridge for Mijia Bluetooth sensors by Christian Baars ( 7394 ) Add support for MI-BLE sensors using HM-10 Bluetooth 4.0 module by Christian Staars ( 7683 ) Add support for FiF LE-01MR energy meter by saper-2 ( 7584 ) Add support for Sensors AHT10 and AHT15 by Martin Wagner ( 7596 ) Add support for Wemos Motor Shield V1 by Denis Sborets ( 7764 ) Add support for La Crosse TX23 Anemometer by Norbert Richter ( 3146 , 7765 ) Add support for Martin Jerry/acenx/Tessan/NTONPOWER SD0x PWM dimmer switches by Paul Diem ( 7791 ) Add support for UDP Group control without MQTT by Paul Diem ( 7790 ) Add support for Jarolift rollers by Keeloq algorithm Add support for MaxBotix HRXL-MaxSonar ultrasonic range finders by Jon Little ( 7814 ) Add support for HDC1080 Temperature and Humidity sensor by Luis Teixeira ( 7888 ) Add support for ElectriQ iQ-wifiMOODL RGBW light by Ian King ( 7947 )","title":"Changelog 8.2"},{"location":"changelog-8.2/#version-820-elliot","text":"Change default my_user_config.h driver and sensor support removing most sensors and adding most drivers to tasmota.bin Change DHT driver ( 7468 , 7717 ) Change Lights: simplified gamma correction and 10 bits internal computation Change commands Prefix , Ssid , StateText , NTPServer , and FriendlyName displaying all items Change Zigbee command prefix from Zigbee* to Zb* Change MQTT message size with additional 200 characters Change display of some date and time messages from Wed Feb 19 10:45:12 2020 to 2020-02-19T10:45:12 Change IRremoteESP8266 library updated to v2.7.4 Fix PowerDelta zero power detection ( 7515 ) Fix White added to light status ( 7142 ) Fix WakeUp <x> ignores provided value ( 7473 ) Fix RGBWWTable ignored ( 7572 ) Fix commands Display and Counter from overruling command processing ( 7322 ) Fix Sonoff Bridge, Sc, L1, iFan03 and CSE7766 serial interface to forced speed, config and disable logging Fix Improved fade linearity with gamma correction Fix PWM flickering at low levels ( 7415 ) Fix LCD line and column positioning ( 7387 ) Fix Display handling of hexadecimal escape characters ( 7387 ) Fix exception 9 restart on log message in Ticker interrupt service routines NTP, Wemos and Hue emulation ( 7496 ) Fix Hass sensor discovery by Federico Leoni ( 7582 , 7548 ) Fix MaxPower functionality ( 7647 ) Fix relation between Wifi RSSI and signal strength Add command SetOption79 0/1 to enable reset of counters at teleperiod time by Andre Thomas ( 7355 ) Add command SetOption82 0/1 to limit the CT range for Alexa to 200..380 Add command SetOption84 0/1 to send AWS IoT device shadow updates (alternative to retained) Add commands SetOption85 0/1 and DevGroupShare supporting UDP Group command using GroupTopic without MQTT by Paul Diem ( 7790 ) Add command SetOption86 0/1 for PWM dimmer to turn brightness LED's off 5 seconds after last change Add command SetOption87 0/1 for PWM dimmer to turn red LED on when powered off Add command SetOption88 0/1 for PWM dimmer to let buttons control remote devices Add command SetOption89 0/1 for Zigbee distinct MQTT topics per device for SENSOR, allowing retained messages ( 7835 ) Add command ShutterButton <parameters> to control shutter(s) by to-scho ( 7403 ) Add commands SwitchMode 8 ToggleMulti, SwitchMode 9 FollowMulti and SwitchMode 10 FollowMultiInverted ( 7522 ) Add commands SwitchMode 11 PushHoldMulti and SwitchMode 12 PushHoldInverted ( 7603 ) Add commands SwitchMode 13 PushOn and SwitchMode 14 PushOnInverted ( 7912 ) Add command Buzzer -1 for infinite mode and command Buzzer -2 for following led mode ( 7623 ) Add command HumOffset -10.0 .. 10.0 to set global humidity sensor offset ( 7934 ) Add support for AdcParam parameters to control ADC0 Current Transformer Apparent Power formula by Jodi Dillon ( 7100 ) Add optional parameter <startcolor> to command Scheme <scheme>, <startcolor> to control initial start color Add web page sliders when SetOption37 128 is active allowing control of white(s) Add SerialConfig to Status 1 Add BootCount Reset Time as BCResetTime to Status 1 Add WifiPower to Status 5 Add most SetOptions as defines to my_user_config.h Add optional Wifi AccessPoint passphrase define WIFI_AP_PASSPHRASE in my_user_config.h ( 7690 ) Add SoftwareSerial to CSE7766 driver allowing different GPIOs ( 7563 ) Add rule trigger on one level deeper using syntax with two # like on zbreceived#vibration_sensor#aqaracubeside=0 do ... Add Zigbee attribute decoder for Xiaomi Aqara Cube Add ZbZNPReceived and ZbZCLReceived being published to MQTT when SetOption66 1 Add Zigbee enhanced commands decoding, added ZbPing Add Zigbee features and improvements Add Zigbee support for Hue emulation by Stefan Hadinger Add HAss Discovery support for Button and Switch triggers by Federico Leoni ( 7901 ) Add Dew Point to Temperature and Humidity sensors Add optional support for Prometheus using file xsns_91_prometheus.ino ( 7216 ) Add support for gzipped binaries Add support for Romanian language translations by Augustin Marti Add support for sensors DS18x20 and DHT family on Shelly 1 and Shelly 1PM using Shelly Add-On adapter ( 7469 ) Add support to BMP driver to enter reset state (sleep enable) when deep sleep is used in Tasmota Add support for DS1624, DS1621 Temperature sensor by Leonid Myravjev Add support for NRF24L01 as BLE-bridge for Mijia Bluetooth sensors by Christian Baars ( 7394 ) Add support for MI-BLE sensors using HM-10 Bluetooth 4.0 module by Christian Staars ( 7683 ) Add support for FiF LE-01MR energy meter by saper-2 ( 7584 ) Add support for Sensors AHT10 and AHT15 by Martin Wagner ( 7596 ) Add support for Wemos Motor Shield V1 by Denis Sborets ( 7764 ) Add support for La Crosse TX23 Anemometer by Norbert Richter ( 3146 , 7765 ) Add support for Martin Jerry/acenx/Tessan/NTONPOWER SD0x PWM dimmer switches by Paul Diem ( 7791 ) Add support for UDP Group control without MQTT by Paul Diem ( 7790 ) Add support for Jarolift rollers by Keeloq algorithm Add support for MaxBotix HRXL-MaxSonar ultrasonic range finders by Jon Little ( 7814 ) Add support for HDC1080 Temperature and Humidity sensor by Luis Teixeira ( 7888 ) Add support for ElectriQ iQ-wifiMOODL RGBW light by Ian King ( 7947 )","title":"Version 8.2.0 Elliot"},{"location":"moving-to-v7/","text":"Tasmota v7 comes with a HUGE change! The official firmware name is Tasmota instead of Sonoff-Tasmota and this introduces a few, possibly breaking, changes that need to be addressed: References to sonoff in the UI, code and wiki are replaced with tasmota Default device topic is now tasmota and default friendly name is Tasmota . Default AP for WiFiConfig is tasmota-xxxx instead of sonoff-xxxx All binaries are now named tasmota-xxxx.bin and default OTA url is http://thehackbox.org/tasmota/release/tasmota.bin Upgrading Note ~ Upgrading from older versions will not be painless!!! It is highly recommended to backup your configuration first, upgrade, erase flash and reset the device to firmware defaults and finally use decode-config tool to restore the configuration. If you're upgrading from a core version older than 6.2 and you're experiencing connectivity issues use reset 3 command to reset wi-fi calibration settings. Always fully power cycle your device after the reset is complete to make sure everything is cleared. v7 Tips ~ GroupTopic ~ All sweeping changes across all devices are done through publishing to the group topic so this is required to do first for all other changes to be effective! If you have custom group topics defined you're on your own Default GroupTopic changed from sonoffs to tasmotas . Every new device will have tasmotas as the default GroupTopic but previously flashed ones will remain on sonoffs . To change GroupTopic of all old devices to the new one (if you're using the default FullTopic): Publish cmnd/sonoffs/GroupTopic tasmotas For Home Assistant autodiscovery enabled devices Publish sonoffs/cmnd/GroupTopic tasmotas Wi-Fi Config AP ~ To configure your device after flashing it for the first time you searched for AP named \"sonoff-xxxx\" but from now on you have to search for \"tasmota-xxxx\". OTAUrl ~ Default OTAUrl is now http://thehackbox.org/tasmota/tasmota.bin . If you're using other precompiled builds in your OTAUrl simply change sonoff to tasmota . To change OTAUrl for all devices ( after changing GroupTopic with the above command ): Publish cmnd/tasmotas/OTAUrl http://thehackbox.org/tasmota/tasmota.bin Dark Theme ~ New default theme is the Dark theme. Note that upgraded devices will keep their old theme. If you want your device on the dark side use WebColor 0 . If you want all your devices switched to the dark theme use: Publish cmnd/tasmotas/WebColor 0","title":"Moving to v7"},{"location":"moving-to-v7/#upgrading-note","text":"Upgrading from older versions will not be painless!!! It is highly recommended to backup your configuration first, upgrade, erase flash and reset the device to firmware defaults and finally use decode-config tool to restore the configuration. If you're upgrading from a core version older than 6.2 and you're experiencing connectivity issues use reset 3 command to reset wi-fi calibration settings. Always fully power cycle your device after the reset is complete to make sure everything is cleared.","title":"Upgrading Note"},{"location":"moving-to-v7/#v7-tips","text":"","title":"v7 Tips"},{"location":"moving-to-v7/#grouptopic","text":"All sweeping changes across all devices are done through publishing to the group topic so this is required to do first for all other changes to be effective! If you have custom group topics defined you're on your own Default GroupTopic changed from sonoffs to tasmotas . Every new device will have tasmotas as the default GroupTopic but previously flashed ones will remain on sonoffs . To change GroupTopic of all old devices to the new one (if you're using the default FullTopic): Publish cmnd/sonoffs/GroupTopic tasmotas For Home Assistant autodiscovery enabled devices Publish sonoffs/cmnd/GroupTopic tasmotas","title":"GroupTopic"},{"location":"moving-to-v7/#wi-fi-config-ap","text":"To configure your device after flashing it for the first time you searched for AP named \"sonoff-xxxx\" but from now on you have to search for \"tasmota-xxxx\".","title":"Wi-Fi Config AP"},{"location":"moving-to-v7/#otaurl","text":"Default OTAUrl is now http://thehackbox.org/tasmota/tasmota.bin . If you're using other precompiled builds in your OTAUrl simply change sonoff to tasmota . To change OTAUrl for all devices ( after changing GroupTopic with the above command ): Publish cmnd/tasmotas/OTAUrl http://thehackbox.org/tasmota/tasmota.bin","title":"OTAUrl"},{"location":"moving-to-v7/#dark-theme","text":"New default theme is the Dark theme. Note that upgraded devices will keep their old theme. If you want your device on the dark side use WebColor 0 . If you want all your devices switched to the dark theme use: Publish cmnd/tasmotas/WebColor 0","title":"Dark Theme"},{"location":"nymea/","text":"nymea ~ nymea is an open source IoT platform. It can be used in various IoT applications such as smart home appliances, IoT technology gateways or general \"thing\" automation. nymea is technology agnostic and uses a plugin framework to extend functionality towards different device types, online services or data transports. Using nymea-plugin-tasmota it can also interact with tasmota based devices. nymea consists of three main parts: nymea:core, nymea:app and nymea:cloud. nymea:core is the core piece of nymea and is meant to be installed on a persistent node in your network or the internet. It connects to devices and services and manages them using automation rules. Typically, nymea:core is installed on a IoT \"box\", such as a raspberry Pi or the nymea:box, however, it can be installed on Desktop PCs (Linux based), cloud servers, VM's or any other machine running Linux. nymea hosts pre-built packages for Ubuntu and Debian GNU/Linux as well as Snap packages which can be installed on any major Linux Distribution. nymea:app is the frontend for nymea:core. It is used to configure the system as well as interact with it. It allows to control configured IoT devices, monitor states and logs and set up automation rules. nymea:cloud is the cloud connectivity suite. It is optional (nymea can work fully offline, not requiring any registration or online service at all) and extends nymea with features such as easy remote connection without having to fiddle with firewall ports and allows to send nymea:core push notifications to phones/tablets having nymea:app installed. More information about nymea can be found at the nymea website and the nymea wiki . Configuring Sonoff/Tasmota devices for use with nymea ~ Requirements ~ A working nymea installation (see nymea wiki for install instructions) A Tasmota device connected to the same network as nymea:core Once those above requirements are met, use nymea:app to add the sonoff device. Depending how you've set it up it will appear as a switch or light bulb in nymea. How does it work? ~ nymea:core features an internal MQTT broker. There is no need to set up an external MQTT broker. Also, during the setup, nymea will configure the Tasmota device. The only thing required is the IP address of the Tasmota device. Please note that for this to work the nymea internal MQTT broker needs to be enabled. This is the default setting so there should not be the need to manually configure anything unless you've previously disabled the internal MQTT broker. Support, troubleshooting, contributing ~ You are welcome to report issues and feature requests in the nymea bug trackers on nymea:core's github page and the nymea app github page as well as ask for help or just discuss about Tasmota and nymea in the nymea forum .","title":"nymea"},{"location":"nymea/#nymea","text":"nymea is an open source IoT platform. It can be used in various IoT applications such as smart home appliances, IoT technology gateways or general \"thing\" automation. nymea is technology agnostic and uses a plugin framework to extend functionality towards different device types, online services or data transports. Using nymea-plugin-tasmota it can also interact with tasmota based devices. nymea consists of three main parts: nymea:core, nymea:app and nymea:cloud. nymea:core is the core piece of nymea and is meant to be installed on a persistent node in your network or the internet. It connects to devices and services and manages them using automation rules. Typically, nymea:core is installed on a IoT \"box\", such as a raspberry Pi or the nymea:box, however, it can be installed on Desktop PCs (Linux based), cloud servers, VM's or any other machine running Linux. nymea hosts pre-built packages for Ubuntu and Debian GNU/Linux as well as Snap packages which can be installed on any major Linux Distribution. nymea:app is the frontend for nymea:core. It is used to configure the system as well as interact with it. It allows to control configured IoT devices, monitor states and logs and set up automation rules. nymea:cloud is the cloud connectivity suite. It is optional (nymea can work fully offline, not requiring any registration or online service at all) and extends nymea with features such as easy remote connection without having to fiddle with firewall ports and allows to send nymea:core push notifications to phones/tablets having nymea:app installed. More information about nymea can be found at the nymea website and the nymea wiki .","title":"nymea"},{"location":"nymea/#configuring-sonofftasmota-devices-for-use-with-nymea","text":"","title":"Configuring Sonoff/Tasmota devices for use with nymea"},{"location":"nymea/#requirements","text":"A working nymea installation (see nymea wiki for install instructions) A Tasmota device connected to the same network as nymea:core Once those above requirements are met, use nymea:app to add the sonoff device. Depending how you've set it up it will appear as a switch or light bulb in nymea.","title":"Requirements"},{"location":"nymea/#how-does-it-work","text":"nymea:core features an internal MQTT broker. There is no need to set up an external MQTT broker. Also, during the setup, nymea will configure the Tasmota device. The only thing required is the IP address of the Tasmota device. Please note that for this to work the nymea internal MQTT broker needs to be enabled. This is the default setting so there should not be the need to manually configure anything unless you've previously disabled the internal MQTT broker.","title":"How does it work?"},{"location":"nymea/#support-troubleshooting-contributing","text":"You are welcome to report issues and feature requests in the nymea bug trackers on nymea:core's github page and the nymea app github page as well as ask for help or just discuss about Tasmota and nymea in the nymea forum .","title":"Support, troubleshooting, contributing"},{"location":"openHAB/","text":"The \"open Home Automation Bus\" ( openHAB ) is an open source, technology agnostic home automation platform which runs as the center of your smart home. Besides 200 other add-ons for all kinds of technologies, openHAB provides an MQTT add-on (\"binding\") to interface with systems like Tasmota. By following the guide below you'll be able to observe, control and manage your Tasmotamodules from your openHAB system. If you are new to openHAB, please learn about the basic concepts and the initial setup. The below article will not cover any basics which are out of scope to the Tasmota integration. Example Result: The screenshot of an openHAB Sitemap below features a few Sonoff modules for lighting, two modified Sonoff Basic with sensors for temperature and humidity readings and two Sonoff Pow for power measurements of a washing machine and dishwasher: Requirements ~ Working openHAB installation (https://www.openhab.org/docs/) Configured Tasmota device (accessible from your local network) MQTT broker available (e.g. Eclipse Mosquitto via openHABian ) A basic understanding of MQTT Working and tested connection between openHAB and the MQTT broker (optional) Standalone MQTT client (e.g. mqtt-spy ) to observe and identify messages on the MQTT broker Highly recommended: If you are new to openHAB + MQTT, go through this tutorial: \u21e8 MQTT Binding - Getting Started 101 Before continuing, please make sure you assigned unique MQTT \"Topics\" in the Tasmota configuration interface of each pf your devices. The default MQTT topic is \"tasmota\", in the examples below we will use names like \"tasmota-A00EEA\". If not done yet, you first need to install and activate the MQTTv1 / MQTTv2 *, the MQTT action and the JsonPath transformation , e.g. via the openHAB Paper UI Add-ons section. ?> MQTTv1 vs. MQTTv2 Binding Information The openHAB community has released a new native openHAB 2 MQTT Binding, which complies with enhancements and significantly changes. Be aware that if you update your openHAB instance, the new MQTT binding may be get installed and mqtt1 could be uninstalled! This means that any MQTT openHAB automations in your openHAB environment will exhibit odd behavior or not operate at all. If you are using mqtt1 , jump to the mqtt1 section below . MQTTv2 Integration ~ .things File: Bridge mqtt : broker : myMQTTBroker [ host = \"IPofBroker\" , secure = false , username = \"myUser\" , password = \"myPassword\" , clientID = \"myMQTTClient\" ] { Thing topic tasmota_TH_Thing \"Light_TH\" { Channels : Type switch : PowerSwitch [ stateTopic = \"stat/tasmota_TH/POWER\" , transformationPattern = \"JSONPATH:$.POWER\" , commandTopic = \"cmnd/tasmota_TH/POWER\" , on = \"ON\" , off = \"OFF\" ] Type string : Version [ stateTopic = \"stat/tasmota_TH/STATUS2\" , transformationPattern = \"JSONPATH:$.StatusFWR.Version\" ] Type string : Temperature [ stateTopic = \"tele/tasmota_TH/SENSOR\" , transformationPattern = \"JSONPATH:$.AM2301.Temperature\" ] } } .items File: Switch Switch_TH \"Switch_TH\" { channel = \"mqtt:topic:myMQTTBroker:tasmota_TH_Thing:PowerSwitch\" } String Switch_TH_Temperatur \"Temperatur [%s \u00b0C]\" < temperature > { channel = \"mqtt:topic:myMQTTBroker:tasmota_TH_Thing:Temperature\" } String Sonoff_Version \"Tasmota Version: [%s]\" < tasmota_basic > { channel = \"mqtt:topic:myMQTTBroker:tasmota_6_Thing:Version\" } .rules File for the Maintenance Action: // Work with a list of selected Tasmota modules val tasmota_device_ids = newArrayList ( \"tasmota-A00EEA\" , //\u2026 add all your modules here! \"tasmota-E8A6E4\" ) // OR // Work with the grouptopic, addressing ALL modules at once //val tasmota_device_ids = newArrayList(\"tasmotas\") rule \"TasmotaMaintenance\" when Item Sonoff_Action received command then logInfo ( \"tasmota.rules\" , \"TasmotaMaintenance on all devices: \" + receivedCommand ) val actionsBroker = getActions ( \"mqtt\" , \"mqtt:broker:MyMQTTBroker\" ) // change to your broker name! for ( String device_id : tasmota_device_ids ) { switch ( receivedCommand ) { case \"restart\" : actionsBroker . publishMQTT ( \"cmnd/\" + device_id + \"/restart\" , \"1\" ) case \"queryFW\" : actionsBroker . publishMQTT ( \"cmnd/\" + device_id + \"/status\" , \"2\" ) case \"upgrade\" : { actionsBroker . publishMQTT ( \"cmnd/\" + device_id + \"/otaurl\" , \"http://thehackbox.org/tasmota/release/tasmota.bin\" ) // Replace with your preferred build actionsBroker . publishMQTT ( \"cmnd/\" + device_id + \"/upgrade\" , \"1\" ) } } } Sonoff_Action . postUpdate ( NULL ) end MQTTv1 Integration ~ Please note that since mqtt1 is a legacy binding, it will no longer receive updates or fixes. If you update your openHAB instance, the new MQTT binding will be installed and mqtt1 will be uninstalled! This means that any MQTT openHAB automations in your openHAB environment will exhibit odd behavior or not operate at all. Fortunately, the mqtt1 Binding can be reinstalled. To do so, turn on \"Include Legacy 1.x Bindings\" via PaperUI (Configuration > System) or set legacy = true in addons.cfg . Then reinstall the mqtt1 Binding. Installing both mqtt2 and mqtt1 bindings will allow you to migrate over time to be ready for the eventuality of mqtt1 end of life. For users that intend to migrate to the new MQTT Binding some examples for the integration have been added above . In the example configuration you can see a non-default Full Topic definition, which is not used in the following examples (but which can be recommended). Simply set up items for all Tasmota MQTT topics you are interested in. Examples for most needed topics are given below. Some Tasmota topics are JSON encoded, the JSONPATH transformation can be used to extract this data. Additional or further interesting topics are easily identified by reading up on the Tasmota wiki and by subscribing to the modules topics. Subscribe to all topics of one module with the MQTT wildcard topic string +/tasmota-XYZ/# (String depends on your user-configured Topic/FullTopic). Configure items for the identified topics similar to the ones below. Example: MQTT messages published by a Sonoff Pow module are shown below (using mosquitto_sub ). The module reports its device state and energy readings periodically. In the second half of the example the module relay was switched into the OFF position. $ mosquitto_sub - h localhost - t \"+/tasmota-E8A6E4/#\" - v tele / tasmota - E8A6E4 / LWT Online tele / tasmota - E8A6E4 / UPTIME { \"Time\" : \"2017-07-25T12:02:00\" , \"Uptime\" : 68 } tele / tasmota - E8A6E4 / STATE { \"Time\" : \"2017-07-25T12:06:28\" , \"Uptime\" : 68 , \"Vcc\" : 3.122 , \"POWER\" : \"POWER\" , \"Wifi\" : { \"AP\" : 1 , \"SSID\" : \"HotelZurBirke\" , \"RSSI\" : 100 , \"APMac\" : \"24:65:11:BF:12:D8\" }} tele / tasmota - E8A6E4 / ENERGY { \"Time\" : \"2017-07-25T12:06:28\" , \"Total\" : 0.640 , \"Yesterday\" : 0.007 , \"Today\" : 0.003 , \"Period\" : 0 , \"Power\" : 0 , \"Factor\" : 0.00 , \"Voltage\" : 0 , \"Current\" : 0.000 } tele / tasmota - E8A6E4 / STATE { \"Time\" : \"2017-07-25T12:11:28\" , \"Uptime\" : 68 , \"Vcc\" : 3.122 , \"POWER\" : \"POWER\" , \"Wifi\" : { \"AP\" : 1 , \"SSID\" : \"HotelZurBirke\" , \"RSSI\" : 100 , \"APMac\" : \"24:65:11:BF:12:D8\" }} tele / tasmota - E8A6E4 / ENERGY { \"Time\" : \"2017-07-25T12:11:28\" , \"Total\" : 0.640 , \"Yesterday\" : 0.007 , \"Today\" : 0.003 , \"Period\" : 0 , \"Power\" : 0 , \"Factor\" : 0.00 , \"Voltage\" : 0 , \"Current\" : 0.000 } cmnd / tasmota - E8A6E4 / POWER OFF stat / tasmota - E8A6E4 / RESULT { \"POWER\" : \"OFF\" } stat / tasmota - E8A6E4 / POWER OFF Following this method, the behavior-linked messages can be identified and bound to openHAB items. Mandatory Topics / Items ~ This it the minimal set of items for the basic functionality of different Tasmota devices. You'll need to replace the given example dive name (e.g. \"tasmota-A00EEA\") by the one chosen for your module. ( Note: Lines have been wrapped for better presentation ) tasmota.items: Sonoff Basic / Sonoff S20 Smart Socket (Read and switch on-state) js Switch LivingRoom_Light \"Living Room Light\" <light> (LR,gLight) { mqtt=\">[broker:cmnd/tasmota-A00EEA/POWER:command:*:default], <[broker:stat/tasmota-A00EEA/POWER:state:default]\" } Sonoff Pow (Read and switch on-state, read current wattage) ```js // compare with example message stream above! Switch BA_Washingmachine \"Washingmachine\" (BA) { mqtt=\">[broker:cmnd/tasmota-E8A6E4/POWER:command:*:default], <[broker:stat/tasmota-E8A6E4/POWER:state:default]\" } Number BA_Washingmachine_Power \"Washingmachine Power [%.1f W]\" (BA,gPower) { mqtt=\"<[broker:tele/tasmota-E8A6E4/SENSOR:state:JSONPATH($.ENERGY.Power)]\" } ``` RGB(CW) LED stripes or other devices which support Color command (Read and switch on-state) js Switch LivingRoom_Light \"Living Room Light\" <light> (LR,gLight) { mqtt=\">[broker:cmnd/tasmota-000000/POWER:command:*:default], <[broker:stat/tasmota-000000/RESULT:state:JSONPATH($.POWER)]\" } Status Topics / Items ~ It is furthermore recommended, to add the following status items for every Tasmota device. tasmota.items: A switch being 'ON' as long as the device is reachable \ud83d\udcac js Switch LivingRoom_Light_Reachable \"Living Room Light: reachable\" (gReachable) { mqtt=\"<[broker:tele/tasmota-A00EEA/LWT:state:MAP(reachable.map)]\" } Wifi Signal Strength in Percent js Number LivingRoom_Light_RSSI \"Living Room Light: RSSI [%d %%]\" (gRSSI) { mqtt=\"<[broker:tele/tasmota-A00EEA/STATE:state:JSONPATH($.Wifi.RSSI)]\" } Optional! A collection of return messages by the Sonoff module Recommendation: Define specific items for what you really need on a regular basis, use standalone MQTT client for troubleshooting js String LivingRoom_Light_Verbose \"Living Room Light: MQTT return message [%s]\" { mqtt=\"<[broker:tele/tasmota-A00EEA/INFO1:state:default], <[broker:stat/tasmota-A00EEA/STATUS2:state:default], <[broker:stat/tasmota-A00EEA/RESULT:state:default]\" } \ud83d\udcac The \"LWT\" topic ( \"Last Will and Testament\" ) will receive regular \"Online\" messages by the module and an \"Offline\" message a short time after the module is disconnected, generated by the MQTT broker. These messages are transformed to a valid ON / OFF state by the MAP transformation. Of course you can implement Unreachable instead of Reachable if you prefer. The following transformation file is needed: reachable.map: Online = ON Offline = OFF Maintenance Actions ~ A home automation system setup would not be complete without a certain maintenance automation! Add the following elements to your openHAB setup to be able to perform actions on your Tasmota devices by the press of a simple sitemap button. The example below includes upgrading the firmware of all devices. A shoutout to @evilgreen for the idea and a big thanks to @smadds for providing the public firmware server used in the example. tasmota.items: //... all the above //Maintenance String Sonoff_Action \"Tasmota Action\" < tasmota_basic > yourhome.sitemap: //... Switch item = Sonoff_Action mappings = [ restart = \"Restart\" , queryFW = \"Query FW\" , upgrade = \"Upgrade FW\" ] //... tasmota.rules: // Work with a list of selected Tasmota modules val tasmota_device_ids = newArrayList ( \"tasmota-A00EEA\" , //... add all your modules here! \"tasmota-E8A6E4\" ) // OR // Work with the grouptopic, addressing ALL modules at once //val tasmota_device_ids = newArrayList(\"tasmotas\") rule \"Tasmota Maintenance\" when Item Sonoff_Action received command then logInfo ( \"tasmota.rules\" , \"TasmotaMaintenance on all devices: \" + receivedCommand ) for ( String device_id : tasmota_device_ids ) { switch ( receivedCommand ) { case \"restart\" : publish ( \"broker\" , \"cmnd/\" + device_id + \"/restart\" , \"1\" ) case \"queryFW\" : publish ( \"broker\" , \"cmnd/\" + device_id + \"/status\" , \"2\" ) case \"upgrade\" : { publish ( \"broker\" , \"cmnd/\" + device_id + \"/otaurl\" , \"http://thehackbox.org/tasmota/tasmota.bin\" ) publish ( \"broker\" , \"cmnd/\" + device_id + \"/upgrade\" , \"1\" ) } } } Sonoff_Action . postUpdate ( NULL ) end Comparing your device firmware with the current Tasmota GitHub Release Knowing your devices firmware version(s) is good. Being able to compare it with the current release directly, is even better. You can archive this by combining the maintenance actions with the openHAB http binding, the jsonpath transformation and the GitHub API. Just extend the maintenance setup with the following Item and config: http.cfg: # Tasmota Release Status ( cached twice a day ) tasmotaRelease . url = https : //api.github.com/repos/arendst/Tasmota/tags tasmotaRelease . updateInterval = 43200000 tasmota.items: String Sonoff_Current_FW_Available \"Current Release [%s]\" < tasmota_basic > ( Sonoff_Maintenance ) { http = \"<[tasmotaRelease:10000:JSONPATH($[0].name)]\" } With the item in your sitemap, you will now see the latest release/tag from the tasmota repository. Community Forum ~ For more openHAB related details and questions, please visit the openHAB community forum thread on Sonoff and Tasmota .","title":"openHAB"},{"location":"openHAB/#requirements","text":"Working openHAB installation (https://www.openhab.org/docs/) Configured Tasmota device (accessible from your local network) MQTT broker available (e.g. Eclipse Mosquitto via openHABian ) A basic understanding of MQTT Working and tested connection between openHAB and the MQTT broker (optional) Standalone MQTT client (e.g. mqtt-spy ) to observe and identify messages on the MQTT broker Highly recommended: If you are new to openHAB + MQTT, go through this tutorial: \u21e8 MQTT Binding - Getting Started 101 Before continuing, please make sure you assigned unique MQTT \"Topics\" in the Tasmota configuration interface of each pf your devices. The default MQTT topic is \"tasmota\", in the examples below we will use names like \"tasmota-A00EEA\". If not done yet, you first need to install and activate the MQTTv1 / MQTTv2 *, the MQTT action and the JsonPath transformation , e.g. via the openHAB Paper UI Add-ons section. ?> MQTTv1 vs. MQTTv2 Binding Information The openHAB community has released a new native openHAB 2 MQTT Binding, which complies with enhancements and significantly changes. Be aware that if you update your openHAB instance, the new MQTT binding may be get installed and mqtt1 could be uninstalled! This means that any MQTT openHAB automations in your openHAB environment will exhibit odd behavior or not operate at all. If you are using mqtt1 , jump to the mqtt1 section below .","title":"Requirements"},{"location":"openHAB/#mqttv2-integration","text":".things File: Bridge mqtt : broker : myMQTTBroker [ host = \"IPofBroker\" , secure = false , username = \"myUser\" , password = \"myPassword\" , clientID = \"myMQTTClient\" ] { Thing topic tasmota_TH_Thing \"Light_TH\" { Channels : Type switch : PowerSwitch [ stateTopic = \"stat/tasmota_TH/POWER\" , transformationPattern = \"JSONPATH:$.POWER\" , commandTopic = \"cmnd/tasmota_TH/POWER\" , on = \"ON\" , off = \"OFF\" ] Type string : Version [ stateTopic = \"stat/tasmota_TH/STATUS2\" , transformationPattern = \"JSONPATH:$.StatusFWR.Version\" ] Type string : Temperature [ stateTopic = \"tele/tasmota_TH/SENSOR\" , transformationPattern = \"JSONPATH:$.AM2301.Temperature\" ] } } .items File: Switch Switch_TH \"Switch_TH\" { channel = \"mqtt:topic:myMQTTBroker:tasmota_TH_Thing:PowerSwitch\" } String Switch_TH_Temperatur \"Temperatur [%s \u00b0C]\" < temperature > { channel = \"mqtt:topic:myMQTTBroker:tasmota_TH_Thing:Temperature\" } String Sonoff_Version \"Tasmota Version: [%s]\" < tasmota_basic > { channel = \"mqtt:topic:myMQTTBroker:tasmota_6_Thing:Version\" } .rules File for the Maintenance Action: // Work with a list of selected Tasmota modules val tasmota_device_ids = newArrayList ( \"tasmota-A00EEA\" , //\u2026 add all your modules here! \"tasmota-E8A6E4\" ) // OR // Work with the grouptopic, addressing ALL modules at once //val tasmota_device_ids = newArrayList(\"tasmotas\") rule \"TasmotaMaintenance\" when Item Sonoff_Action received command then logInfo ( \"tasmota.rules\" , \"TasmotaMaintenance on all devices: \" + receivedCommand ) val actionsBroker = getActions ( \"mqtt\" , \"mqtt:broker:MyMQTTBroker\" ) // change to your broker name! for ( String device_id : tasmota_device_ids ) { switch ( receivedCommand ) { case \"restart\" : actionsBroker . publishMQTT ( \"cmnd/\" + device_id + \"/restart\" , \"1\" ) case \"queryFW\" : actionsBroker . publishMQTT ( \"cmnd/\" + device_id + \"/status\" , \"2\" ) case \"upgrade\" : { actionsBroker . publishMQTT ( \"cmnd/\" + device_id + \"/otaurl\" , \"http://thehackbox.org/tasmota/release/tasmota.bin\" ) // Replace with your preferred build actionsBroker . publishMQTT ( \"cmnd/\" + device_id + \"/upgrade\" , \"1\" ) } } } Sonoff_Action . postUpdate ( NULL ) end","title":"MQTTv2 Integration"},{"location":"openHAB/#mqttv1-integration","text":"Please note that since mqtt1 is a legacy binding, it will no longer receive updates or fixes. If you update your openHAB instance, the new MQTT binding will be installed and mqtt1 will be uninstalled! This means that any MQTT openHAB automations in your openHAB environment will exhibit odd behavior or not operate at all. Fortunately, the mqtt1 Binding can be reinstalled. To do so, turn on \"Include Legacy 1.x Bindings\" via PaperUI (Configuration > System) or set legacy = true in addons.cfg . Then reinstall the mqtt1 Binding. Installing both mqtt2 and mqtt1 bindings will allow you to migrate over time to be ready for the eventuality of mqtt1 end of life. For users that intend to migrate to the new MQTT Binding some examples for the integration have been added above . In the example configuration you can see a non-default Full Topic definition, which is not used in the following examples (but which can be recommended). Simply set up items for all Tasmota MQTT topics you are interested in. Examples for most needed topics are given below. Some Tasmota topics are JSON encoded, the JSONPATH transformation can be used to extract this data. Additional or further interesting topics are easily identified by reading up on the Tasmota wiki and by subscribing to the modules topics. Subscribe to all topics of one module with the MQTT wildcard topic string +/tasmota-XYZ/# (String depends on your user-configured Topic/FullTopic). Configure items for the identified topics similar to the ones below. Example: MQTT messages published by a Sonoff Pow module are shown below (using mosquitto_sub ). The module reports its device state and energy readings periodically. In the second half of the example the module relay was switched into the OFF position. $ mosquitto_sub - h localhost - t \"+/tasmota-E8A6E4/#\" - v tele / tasmota - E8A6E4 / LWT Online tele / tasmota - E8A6E4 / UPTIME { \"Time\" : \"2017-07-25T12:02:00\" , \"Uptime\" : 68 } tele / tasmota - E8A6E4 / STATE { \"Time\" : \"2017-07-25T12:06:28\" , \"Uptime\" : 68 , \"Vcc\" : 3.122 , \"POWER\" : \"POWER\" , \"Wifi\" : { \"AP\" : 1 , \"SSID\" : \"HotelZurBirke\" , \"RSSI\" : 100 , \"APMac\" : \"24:65:11:BF:12:D8\" }} tele / tasmota - E8A6E4 / ENERGY { \"Time\" : \"2017-07-25T12:06:28\" , \"Total\" : 0.640 , \"Yesterday\" : 0.007 , \"Today\" : 0.003 , \"Period\" : 0 , \"Power\" : 0 , \"Factor\" : 0.00 , \"Voltage\" : 0 , \"Current\" : 0.000 } tele / tasmota - E8A6E4 / STATE { \"Time\" : \"2017-07-25T12:11:28\" , \"Uptime\" : 68 , \"Vcc\" : 3.122 , \"POWER\" : \"POWER\" , \"Wifi\" : { \"AP\" : 1 , \"SSID\" : \"HotelZurBirke\" , \"RSSI\" : 100 , \"APMac\" : \"24:65:11:BF:12:D8\" }} tele / tasmota - E8A6E4 / ENERGY { \"Time\" : \"2017-07-25T12:11:28\" , \"Total\" : 0.640 , \"Yesterday\" : 0.007 , \"Today\" : 0.003 , \"Period\" : 0 , \"Power\" : 0 , \"Factor\" : 0.00 , \"Voltage\" : 0 , \"Current\" : 0.000 } cmnd / tasmota - E8A6E4 / POWER OFF stat / tasmota - E8A6E4 / RESULT { \"POWER\" : \"OFF\" } stat / tasmota - E8A6E4 / POWER OFF Following this method, the behavior-linked messages can be identified and bound to openHAB items.","title":"MQTTv1 Integration"},{"location":"openHAB/#mandatory-topics-items","text":"This it the minimal set of items for the basic functionality of different Tasmota devices. You'll need to replace the given example dive name (e.g. \"tasmota-A00EEA\") by the one chosen for your module. ( Note: Lines have been wrapped for better presentation ) tasmota.items: Sonoff Basic / Sonoff S20 Smart Socket (Read and switch on-state) js Switch LivingRoom_Light \"Living Room Light\" <light> (LR,gLight) { mqtt=\">[broker:cmnd/tasmota-A00EEA/POWER:command:*:default], <[broker:stat/tasmota-A00EEA/POWER:state:default]\" } Sonoff Pow (Read and switch on-state, read current wattage) ```js // compare with example message stream above! Switch BA_Washingmachine \"Washingmachine\" (BA) { mqtt=\">[broker:cmnd/tasmota-E8A6E4/POWER:command:*:default], <[broker:stat/tasmota-E8A6E4/POWER:state:default]\" } Number BA_Washingmachine_Power \"Washingmachine Power [%.1f W]\" (BA,gPower) { mqtt=\"<[broker:tele/tasmota-E8A6E4/SENSOR:state:JSONPATH($.ENERGY.Power)]\" } ``` RGB(CW) LED stripes or other devices which support Color command (Read and switch on-state) js Switch LivingRoom_Light \"Living Room Light\" <light> (LR,gLight) { mqtt=\">[broker:cmnd/tasmota-000000/POWER:command:*:default], <[broker:stat/tasmota-000000/RESULT:state:JSONPATH($.POWER)]\" }","title":"Mandatory Topics / Items"},{"location":"openHAB/#status-topics-items","text":"It is furthermore recommended, to add the following status items for every Tasmota device. tasmota.items: A switch being 'ON' as long as the device is reachable \ud83d\udcac js Switch LivingRoom_Light_Reachable \"Living Room Light: reachable\" (gReachable) { mqtt=\"<[broker:tele/tasmota-A00EEA/LWT:state:MAP(reachable.map)]\" } Wifi Signal Strength in Percent js Number LivingRoom_Light_RSSI \"Living Room Light: RSSI [%d %%]\" (gRSSI) { mqtt=\"<[broker:tele/tasmota-A00EEA/STATE:state:JSONPATH($.Wifi.RSSI)]\" } Optional! A collection of return messages by the Sonoff module Recommendation: Define specific items for what you really need on a regular basis, use standalone MQTT client for troubleshooting js String LivingRoom_Light_Verbose \"Living Room Light: MQTT return message [%s]\" { mqtt=\"<[broker:tele/tasmota-A00EEA/INFO1:state:default], <[broker:stat/tasmota-A00EEA/STATUS2:state:default], <[broker:stat/tasmota-A00EEA/RESULT:state:default]\" } \ud83d\udcac The \"LWT\" topic ( \"Last Will and Testament\" ) will receive regular \"Online\" messages by the module and an \"Offline\" message a short time after the module is disconnected, generated by the MQTT broker. These messages are transformed to a valid ON / OFF state by the MAP transformation. Of course you can implement Unreachable instead of Reachable if you prefer. The following transformation file is needed: reachable.map: Online = ON Offline = OFF","title":"Status Topics / Items"},{"location":"openHAB/#maintenance-actions","text":"A home automation system setup would not be complete without a certain maintenance automation! Add the following elements to your openHAB setup to be able to perform actions on your Tasmota devices by the press of a simple sitemap button. The example below includes upgrading the firmware of all devices. A shoutout to @evilgreen for the idea and a big thanks to @smadds for providing the public firmware server used in the example. tasmota.items: //... all the above //Maintenance String Sonoff_Action \"Tasmota Action\" < tasmota_basic > yourhome.sitemap: //... Switch item = Sonoff_Action mappings = [ restart = \"Restart\" , queryFW = \"Query FW\" , upgrade = \"Upgrade FW\" ] //... tasmota.rules: // Work with a list of selected Tasmota modules val tasmota_device_ids = newArrayList ( \"tasmota-A00EEA\" , //... add all your modules here! \"tasmota-E8A6E4\" ) // OR // Work with the grouptopic, addressing ALL modules at once //val tasmota_device_ids = newArrayList(\"tasmotas\") rule \"Tasmota Maintenance\" when Item Sonoff_Action received command then logInfo ( \"tasmota.rules\" , \"TasmotaMaintenance on all devices: \" + receivedCommand ) for ( String device_id : tasmota_device_ids ) { switch ( receivedCommand ) { case \"restart\" : publish ( \"broker\" , \"cmnd/\" + device_id + \"/restart\" , \"1\" ) case \"queryFW\" : publish ( \"broker\" , \"cmnd/\" + device_id + \"/status\" , \"2\" ) case \"upgrade\" : { publish ( \"broker\" , \"cmnd/\" + device_id + \"/otaurl\" , \"http://thehackbox.org/tasmota/tasmota.bin\" ) publish ( \"broker\" , \"cmnd/\" + device_id + \"/upgrade\" , \"1\" ) } } } Sonoff_Action . postUpdate ( NULL ) end","title":"Maintenance Actions"},{"location":"openHAB/#community-forum","text":"For more openHAB related details and questions, please visit the openHAB community forum thread on Sonoff and Tasmota .","title":"Community Forum"},{"location":"otto/","text":"\u0298tt\u0298 is a web interface for controlling devices, such as Tasmota enabled devices, over MQTT. See the quick-start guide and instructions for Tasmota devices .","title":"Otto"},{"location":"peripherals/","text":"HTML Meta Tag Redirecting to peripherals </div>","title":"Peripherals"},{"location":"%23/","text":"window.location.replace(\"/\"); Moved","title":"Index"},{"location":"changelogs/changelog-7.2/","text":"Version 7.2.0 Constance ~ Change Exception reporting removing exception details from Status 1 and consolidated in Status 12 if available Change HTTP CORS from command SetOption73 0/1 to Cors <cors_domain> allowing user control of specific CORS domain by Shantur Rathore (#7066) Change GUI Shutter button text to Up and Down Arrows based on PR by Xavier Muller (#7166) Change amount of supported DHT sensors from 3 to 4 by Xavier Muller (#7167) Change some Settings locations freeing up space for future single char allowing variable length text Change tasmota-basic.bin and FIRMWARE_BASIC to tasmota-lite.bin and FIRMWARE_LITE Fix flashing H801 led at boot by Stefan Hadinger (#7165, #649) Fix duplicated Backlog when using Event inside a Backlog by Adrian Scillato (#7178, #7147) Fix Gui Timer when using a negative zero offset of -00:00 by Peter Ooms (#7174) Fix DeepSleep in case there is no wifi by Stefan Bode (#7213) Fix Fade would ignore savedata 0 and store to flash anyways (#7262) Fix Arduino IDE compile error (#7277) Fix no AP on initial install (#7282) Add command SerialConfig 0..23 or SerialConfig 8N1 to select Serial Config based in PR by Luis Teixeira (#7108) Add command Sensor34 9 <weight code> to set minimum delta to trigger JSON message by @tobox (#7188) Add rule var %topic% by Adrian Scillato (#5522) Add rule triggers tele-wifi1#xxx by Adrian Scillato (#7093) Add SML bus decoder syntax support for byte order by Gerhard Mutz (#7112) Add experimental support for stepper motor shutter control by Stefan Bode Add optional USE_MQTT_TLS to tasmota-minimal.bin by Bohdan Kmit (#7115) Add save call stack in RTC memory in case of crash, command Status 12 to dump the stack by Stefan Hadinger Add Home Assistant force update by Frederico Leoni (#7140, #7074) Add Wifi Signal Strength in dBm in addition to RSSI Wifi Experience by Andreas Schultz (#7145) Add Yaw, Pitch and Roll support for MPU6050 by Philip Barclay (#7058) Add reporting of raw weight to JSON from HX711 to overcome auto-tare functionality by @tobox (#7171) Add Zigbee support for Xiaomi Aqara Vibration Sensor and Presence Sensor by Stefan Hadinger Add Shutter functions ramp up/down and MQTT reporting by Stefan Bode Add fallback support from version 8.x Add restriction if fallback firmware is incompatible with settings resulting in unreachable device Add support for DHT12 Temperature and Humidity sensor by Stefan Oskamp","title":"Changelog 7.2"},{"location":"changelogs/changelog-7.2/#version-720-constance","text":"Change Exception reporting removing exception details from Status 1 and consolidated in Status 12 if available Change HTTP CORS from command SetOption73 0/1 to Cors <cors_domain> allowing user control of specific CORS domain by Shantur Rathore (#7066) Change GUI Shutter button text to Up and Down Arrows based on PR by Xavier Muller (#7166) Change amount of supported DHT sensors from 3 to 4 by Xavier Muller (#7167) Change some Settings locations freeing up space for future single char allowing variable length text Change tasmota-basic.bin and FIRMWARE_BASIC to tasmota-lite.bin and FIRMWARE_LITE Fix flashing H801 led at boot by Stefan Hadinger (#7165, #649) Fix duplicated Backlog when using Event inside a Backlog by Adrian Scillato (#7178, #7147) Fix Gui Timer when using a negative zero offset of -00:00 by Peter Ooms (#7174) Fix DeepSleep in case there is no wifi by Stefan Bode (#7213) Fix Fade would ignore savedata 0 and store to flash anyways (#7262) Fix Arduino IDE compile error (#7277) Fix no AP on initial install (#7282) Add command SerialConfig 0..23 or SerialConfig 8N1 to select Serial Config based in PR by Luis Teixeira (#7108) Add command Sensor34 9 <weight code> to set minimum delta to trigger JSON message by @tobox (#7188) Add rule var %topic% by Adrian Scillato (#5522) Add rule triggers tele-wifi1#xxx by Adrian Scillato (#7093) Add SML bus decoder syntax support for byte order by Gerhard Mutz (#7112) Add experimental support for stepper motor shutter control by Stefan Bode Add optional USE_MQTT_TLS to tasmota-minimal.bin by Bohdan Kmit (#7115) Add save call stack in RTC memory in case of crash, command Status 12 to dump the stack by Stefan Hadinger Add Home Assistant force update by Frederico Leoni (#7140, #7074) Add Wifi Signal Strength in dBm in addition to RSSI Wifi Experience by Andreas Schultz (#7145) Add Yaw, Pitch and Roll support for MPU6050 by Philip Barclay (#7058) Add reporting of raw weight to JSON from HX711 to overcome auto-tare functionality by @tobox (#7171) Add Zigbee support for Xiaomi Aqara Vibration Sensor and Presence Sensor by Stefan Hadinger Add Shutter functions ramp up/down and MQTT reporting by Stefan Bode Add fallback support from version 8.x Add restriction if fallback firmware is incompatible with settings resulting in unreachable device Add support for DHT12 Temperature and Humidity sensor by Stefan Oskamp","title":"Version 7.2.0 Constance"},{"location":"changelogs/changelog-8.1/","text":"Version 8.1.0 Doris ~ Change Settings text handling allowing variable length text within a total text pool of 699 characters Change Smoother Fade using 100Hz instead of 20Hz animation (#7179) Change number of rule Var s and Mem s from 5 to 16 (#4933) Change number of FriendlyName s from 4 to 8 Add commands WebButton1 until WebButton16 to support user defined GUI button text (#7166) Add support for max 150 characters in most command parameter strings (#3686, #4754) Add support for GPS as NTP server by Christian Baars and Adrian Scillato Add support for AdcParam parameters to control ADC0 Moisture formula by Federico Leoni (#7309) Add Zigbee coalesce sensor attributes into a single message Add Zigbee better support for Xiaomi Double Switch and Xiaomi Vibration sensor Add Deepsleep start delay based on Teleperiod if Teleperiod differs from 10 or 300","title":"Changelog 8.1"},{"location":"changelogs/changelog-8.1/#version-810-doris","text":"Change Settings text handling allowing variable length text within a total text pool of 699 characters Change Smoother Fade using 100Hz instead of 20Hz animation (#7179) Change number of rule Var s and Mem s from 5 to 16 (#4933) Change number of FriendlyName s from 4 to 8 Add commands WebButton1 until WebButton16 to support user defined GUI button text (#7166) Add support for max 150 characters in most command parameter strings (#3686, #4754) Add support for GPS as NTP server by Christian Baars and Adrian Scillato Add support for AdcParam parameters to control ADC0 Moisture formula by Federico Leoni (#7309) Add Zigbee coalesce sensor attributes into a single message Add Zigbee better support for Xiaomi Double Switch and Xiaomi Vibration sensor Add Deepsleep start delay based on Teleperiod if Teleperiod differs from 10 or 300","title":"Version 8.1.0 Doris"},{"location":"changelogs/changelog-8.2/","text":"Version 8.2.0 Elliot ~ Change default my_user_config.h driver and sensor support removing most sensors and adding most drivers to tasmota.bin Change DHT driver ( 7468 , 7717 ) Change Lights: simplified gamma correction and 10 bits internal computation Change commands Prefix , Ssid , StateText , NTPServer , and FriendlyName displaying all items Change Zigbee command prefix from Zigbee* to Zb* Change MQTT message size with additional 200 characters Change display of some date and time messages from Wed Feb 19 10:45:12 2020 to 2020-02-19T10:45:12 Change IRremoteESP8266 library updated to v2.7.4 Fix PowerDelta zero power detection ( 7515 ) Fix White added to light status ( 7142 ) Fix WakeUp <x> ignores provided value ( 7473 ) Fix RGBWWTable ignored ( 7572 ) Fix commands Display and Counter from overruling command processing ( 7322 ) Fix Sonoff Bridge, Sc, L1, iFan03 and CSE7766 serial interface to forced speed, config and disable logging Fix Improved fade linearity with gamma correction Fix PWM flickering at low levels ( 7415 ) Fix LCD line and column positioning ( 7387 ) Fix Display handling of hexadecimal escape characters ( 7387 ) Fix exception 9 restart on log message in Ticker interrupt service routines NTP, Wemos and Hue emulation ( 7496 ) Fix Hass sensor discovery by Federico Leoni ( 7582 , 7548 ) Fix MaxPower functionality ( 7647 ) Fix relation between Wifi RSSI and signal strength Add command SetOption79 0/1 to enable reset of counters at teleperiod time by Andre Thomas ( 7355 ) Add command SetOption82 0/1 to limit the CT range for Alexa to 200..380 Add command SetOption84 0/1 to send AWS IoT device shadow updates (alternative to retained) Add commands SetOption85 0/1 and DevGroupShare supporting UDP Group command using GroupTopic without MQTT by Paul Diem ( 7790 ) Add command SetOption86 0/1 for PWM dimmer to turn brightness LED's off 5 seconds after last change Add command SetOption87 0/1 for PWM dimmer to turn red LED on when powered off Add command SetOption88 0/1 for PWM dimmer to let buttons control remote devices Add command SetOption89 0/1 for Zigbee distinct MQTT topics per device for SENSOR, allowing retained messages ( 7835 ) Add command ShutterButton <parameters> to control shutter(s) by to-scho ( 7403 ) Add commands SwitchMode 8 ToggleMulti, SwitchMode 9 FollowMulti and SwitchMode 10 FollowMultiInverted ( 7522 ) Add commands SwitchMode 11 PushHoldMulti and SwitchMode 12 PushHoldInverted ( 7603 ) Add commands SwitchMode 13 PushOn and SwitchMode 14 PushOnInverted ( 7912 ) Add command Buzzer -1 for infinite mode and command Buzzer -2 for following led mode ( 7623 ) Add command HumOffset -10.0 .. 10.0 to set global humidity sensor offset ( 7934 ) Add support for AdcParam parameters to control ADC0 Current Transformer Apparent Power formula by Jodi Dillon ( 7100 ) Add optional parameter <startcolor> to command Scheme <scheme>, <startcolor> to control initial start color Add web page sliders when SetOption37 128 is active allowing control of white(s) Add SerialConfig to Status 1 Add BootCount Reset Time as BCResetTime to Status 1 Add WifiPower to Status 5 Add most SetOptions as defines to my_user_config.h Add optional Wifi AccessPoint passphrase define WIFI_AP_PASSPHRASE in my_user_config.h ( 7690 ) Add SoftwareSerial to CSE7766 driver allowing different GPIOs ( 7563 ) Add rule trigger on one level deeper using syntax with two # like on zbreceived#vibration_sensor#aqaracubeside=0 do ... Add Zigbee attribute decoder for Xiaomi Aqara Cube Add ZbZNPReceived and ZbZCLReceived being published to MQTT when SetOption66 1 Add Zigbee enhanced commands decoding, added ZbPing Add Zigbee features and improvements Add Zigbee support for Hue emulation by Stefan Hadinger Add HAss Discovery support for Button and Switch triggers by Federico Leoni ( 7901 ) Add Dew Point to Temperature and Humidity sensors Add optional support for Prometheus using file xsns_91_prometheus.ino ( 7216 ) Add support for gzipped binaries Add support for Romanian language translations by Augustin Marti Add support for sensors DS18x20 and DHT family on Shelly 1 and Shelly 1PM using Shelly Add-On adapter ( 7469 ) Add support to BMP driver to enter reset state (sleep enable) when deep sleep is used in Tasmota Add support for DS1624, DS1621 Temperature sensor by Leonid Myravjev Add support for NRF24L01 as BLE-bridge for Mijia Bluetooth sensors by Christian Baars ( 7394 ) Add support for MI-BLE sensors using HM-10 Bluetooth 4.0 module by Christian Staars ( 7683 ) Add support for FiF LE-01MR energy meter by saper-2 ( 7584 ) Add support for Sensors AHT10 and AHT15 by Martin Wagner ( 7596 ) Add support for Wemos Motor Shield V1 by Denis Sborets ( 7764 ) Add support for La Crosse TX23 Anemometer by Norbert Richter ( 3146 , 7765 ) Add support for Martin Jerry/acenx/Tessan/NTONPOWER SD0x PWM dimmer switches by Paul Diem ( 7791 ) Add support for UDP Group control without MQTT by Paul Diem ( 7790 ) Add support for Jarolift rollers by Keeloq algorithm Add support for MaxBotix HRXL-MaxSonar ultrasonic range finders by Jon Little ( 7814 ) Add support for HDC1080 Temperature and Humidity sensor by Luis Teixeira ( 7888 ) Add support for ElectriQ iQ-wifiMOODL RGBW light by Ian King ( 7947 )","title":"Changelog 8.2"},{"location":"changelogs/changelog-8.2/#version-820-elliot","text":"Change default my_user_config.h driver and sensor support removing most sensors and adding most drivers to tasmota.bin Change DHT driver ( 7468 , 7717 ) Change Lights: simplified gamma correction and 10 bits internal computation Change commands Prefix , Ssid , StateText , NTPServer , and FriendlyName displaying all items Change Zigbee command prefix from Zigbee* to Zb* Change MQTT message size with additional 200 characters Change display of some date and time messages from Wed Feb 19 10:45:12 2020 to 2020-02-19T10:45:12 Change IRremoteESP8266 library updated to v2.7.4 Fix PowerDelta zero power detection ( 7515 ) Fix White added to light status ( 7142 ) Fix WakeUp <x> ignores provided value ( 7473 ) Fix RGBWWTable ignored ( 7572 ) Fix commands Display and Counter from overruling command processing ( 7322 ) Fix Sonoff Bridge, Sc, L1, iFan03 and CSE7766 serial interface to forced speed, config and disable logging Fix Improved fade linearity with gamma correction Fix PWM flickering at low levels ( 7415 ) Fix LCD line and column positioning ( 7387 ) Fix Display handling of hexadecimal escape characters ( 7387 ) Fix exception 9 restart on log message in Ticker interrupt service routines NTP, Wemos and Hue emulation ( 7496 ) Fix Hass sensor discovery by Federico Leoni ( 7582 , 7548 ) Fix MaxPower functionality ( 7647 ) Fix relation between Wifi RSSI and signal strength Add command SetOption79 0/1 to enable reset of counters at teleperiod time by Andre Thomas ( 7355 ) Add command SetOption82 0/1 to limit the CT range for Alexa to 200..380 Add command SetOption84 0/1 to send AWS IoT device shadow updates (alternative to retained) Add commands SetOption85 0/1 and DevGroupShare supporting UDP Group command using GroupTopic without MQTT by Paul Diem ( 7790 ) Add command SetOption86 0/1 for PWM dimmer to turn brightness LED's off 5 seconds after last change Add command SetOption87 0/1 for PWM dimmer to turn red LED on when powered off Add command SetOption88 0/1 for PWM dimmer to let buttons control remote devices Add command SetOption89 0/1 for Zigbee distinct MQTT topics per device for SENSOR, allowing retained messages ( 7835 ) Add command ShutterButton <parameters> to control shutter(s) by to-scho ( 7403 ) Add commands SwitchMode 8 ToggleMulti, SwitchMode 9 FollowMulti and SwitchMode 10 FollowMultiInverted ( 7522 ) Add commands SwitchMode 11 PushHoldMulti and SwitchMode 12 PushHoldInverted ( 7603 ) Add commands SwitchMode 13 PushOn and SwitchMode 14 PushOnInverted ( 7912 ) Add command Buzzer -1 for infinite mode and command Buzzer -2 for following led mode ( 7623 ) Add command HumOffset -10.0 .. 10.0 to set global humidity sensor offset ( 7934 ) Add support for AdcParam parameters to control ADC0 Current Transformer Apparent Power formula by Jodi Dillon ( 7100 ) Add optional parameter <startcolor> to command Scheme <scheme>, <startcolor> to control initial start color Add web page sliders when SetOption37 128 is active allowing control of white(s) Add SerialConfig to Status 1 Add BootCount Reset Time as BCResetTime to Status 1 Add WifiPower to Status 5 Add most SetOptions as defines to my_user_config.h Add optional Wifi AccessPoint passphrase define WIFI_AP_PASSPHRASE in my_user_config.h ( 7690 ) Add SoftwareSerial to CSE7766 driver allowing different GPIOs ( 7563 ) Add rule trigger on one level deeper using syntax with two # like on zbreceived#vibration_sensor#aqaracubeside=0 do ... Add Zigbee attribute decoder for Xiaomi Aqara Cube Add ZbZNPReceived and ZbZCLReceived being published to MQTT when SetOption66 1 Add Zigbee enhanced commands decoding, added ZbPing Add Zigbee features and improvements Add Zigbee support for Hue emulation by Stefan Hadinger Add HAss Discovery support for Button and Switch triggers by Federico Leoni ( 7901 ) Add Dew Point to Temperature and Humidity sensors Add optional support for Prometheus using file xsns_91_prometheus.ino ( 7216 ) Add support for gzipped binaries Add support for Romanian language translations by Augustin Marti Add support for sensors DS18x20 and DHT family on Shelly 1 and Shelly 1PM using Shelly Add-On adapter ( 7469 ) Add support to BMP driver to enter reset state (sleep enable) when deep sleep is used in Tasmota Add support for DS1624, DS1621 Temperature sensor by Leonid Myravjev Add support for NRF24L01 as BLE-bridge for Mijia Bluetooth sensors by Christian Baars ( 7394 ) Add support for MI-BLE sensors using HM-10 Bluetooth 4.0 module by Christian Staars ( 7683 ) Add support for FiF LE-01MR energy meter by saper-2 ( 7584 ) Add support for Sensors AHT10 and AHT15 by Martin Wagner ( 7596 ) Add support for Wemos Motor Shield V1 by Denis Sborets ( 7764 ) Add support for La Crosse TX23 Anemometer by Norbert Richter ( 3146 , 7765 ) Add support for Martin Jerry/acenx/Tessan/NTONPOWER SD0x PWM dimmer switches by Paul Diem ( 7791 ) Add support for UDP Group control without MQTT by Paul Diem ( 7790 ) Add support for Jarolift rollers by Keeloq algorithm Add support for MaxBotix HRXL-MaxSonar ultrasonic range finders by Jon Little ( 7814 ) Add support for HDC1080 Temperature and Humidity sensor by Luis Teixeira ( 7888 ) Add support for ElectriQ iQ-wifiMOODL RGBW light by Ian King ( 7947 )","title":"Version 8.2.0 Elliot"},{"location":"devices/","text":"Visit Tasmota Device Templates Repository for a complete list of devices working with Tasmota. Devices listed here are the ones existing as modules in Tasmota.","title":"Index"},{"location":"devices/4CH-Wifi-Socket-with-USB-Charger-SA-P402A-%28TYWE2S%29/","text":"Products ~ WiFi-Socket-Smart-Power-Strip at aliexpress AKA: SA-P402A BY-V1.1. 180823 Wifi Smart Power Strip 4 EU Outlets Plug with 4 USBCharging Port at aliexpress also at Amazon.de as AOFO ZLD-44EU-W Koogeek Wifi Smart USB Power Strip Socket at aliexpress AKA: 0710033644644 / KLOE4 Opening ~ To open take a very small screwdrive to pull out the six feets. Don't remove the rubber plates, it won't help. Flashing ~ You'll have to connect GPIO0 manually, the switch is connected to GPIO1. It marked the pin in the picture. Because the TYWE2S has 2mm pitch, I made a little adapter to 2,54mm pitch. Then it can easy soldered to the first four pins. From left to right 3,3V, Gnd, Rx, Tx. Configuration ~ Configure the USB-Charger as number five, then the next socket as number one and so on. This is the configuration: For the other model (Koogeek and AOFO) the GPIO connections are a bit different: LED: GPIO1 Switch: GPIO3 Socket 1: GPIO5 Socket 2: GPIO4 Socket 3: GPIO12 Socket 4: GPIO13 USB: GPIO14","title":"4CH Wifi Socket with USB Charger SA P402A (TYWE2S)"},{"location":"devices/4CH-Wifi-Socket-with-USB-Charger-SA-P402A-%28TYWE2S%29/#products","text":"WiFi-Socket-Smart-Power-Strip at aliexpress AKA: SA-P402A BY-V1.1. 180823 Wifi Smart Power Strip 4 EU Outlets Plug with 4 USBCharging Port at aliexpress also at Amazon.de as AOFO ZLD-44EU-W Koogeek Wifi Smart USB Power Strip Socket at aliexpress AKA: 0710033644644 / KLOE4","title":"Products"},{"location":"devices/4CH-Wifi-Socket-with-USB-Charger-SA-P402A-%28TYWE2S%29/#opening","text":"To open take a very small screwdrive to pull out the six feets. Don't remove the rubber plates, it won't help.","title":"Opening"},{"location":"devices/4CH-Wifi-Socket-with-USB-Charger-SA-P402A-%28TYWE2S%29/#flashing","text":"You'll have to connect GPIO0 manually, the switch is connected to GPIO1. It marked the pin in the picture. Because the TYWE2S has 2mm pitch, I made a little adapter to 2,54mm pitch. Then it can easy soldered to the first four pins. From left to right 3,3V, Gnd, Rx, Tx.","title":"Flashing"},{"location":"devices/4CH-Wifi-Socket-with-USB-Charger-SA-P402A-%28TYWE2S%29/#configuration","text":"Configure the USB-Charger as number five, then the next socket as number one and so on. This is the configuration: For the other model (Koogeek and AOFO) the GPIO connections are a bit different: LED: GPIO1 Switch: GPIO3 Socket 1: GPIO5 Socket 2: GPIO4 Socket 3: GPIO12 Socket 4: GPIO13 USB: GPIO14","title":"Configuration"},{"location":"devices/Arilux-LC02/","text":"This device is a RGBW led controller and need a different setup against the ex Arilux LC01 You can configure it as a \"generic module\" And set the GPIO as follow: Red: * D1 GPIO5 = 33 PWM1 Blue: * D6 GPIO12 = 35 PWM3 White: * D7 GPIO13 = 36 PWM4 Green: * D5 GPIO14 = 34 PWM2 Learn more about Arilux devices","title":"Arilux LC02"},{"location":"devices/Arilux-LC04/","text":"Arilux AL-LC04 ~ (WIFI Smart RGBW Controller With 24-key IR Remote, Working Voltage: DC 9-12V, Output Current: RGBW, 4*4A) These devices can be configured as \"generic module\" with this GPIO configuration: GPIO04 = [51] IRrecv GPIO05 = [38] PWM2 (G) GPIO12 = [39] PWM3 (R) GPIO14 = [37] PWM1 (B) GPIO13 = [40] PWM4 (W) [Only for RGBW-Stripe] A later version has been found to use the following configuration: GPIO04 = [51] IRrecv GPIO05 = [38] PWM2 (G) GPIO13 = [39] PWM3 (R) GPIO12 = [37] PWM1 (B) GPIO15 = [40] PWM4 (W) [Only for RGBW-Stripe] Note: as of #5523 IRCodes are now 64 bits. Copy this Code to your console to use the 24 Button IR Remote rule1 on IrReceived#Data=0x00FFB04F do power1 on endon on IrReceived#Data=0x00FFF807 do power1 off endon on IrReceived#Data=0x00FF906F do dimmer + endon on IrReceived#Data=0x00FFB847 do dimmer - endon on IrReceived#Data=0x00FFB24D do scheme 0 endon on IrReceived#Data=0x00FF00FF do scheme 4 endon on IrReceived#Data=0x00FF58A7 do scheme 2 endon on IrReceived#Data=0x00FF30CF do scheme 3 endon rule2 on IrReceived#Data=0x00FF9867 do color2 #FF0000 endon on IrReceived#Data=0x00FFE817 do color2 #470D00 endon on IrReceived#Data=0x00FF02FD do color2 #381600 endon on IrReceived#Data=0x00FF50AF do color2 #331E00 endon on IrReceived#Data=0x00FF38C7 do color2 #332800 endon on IrReceived#Data=0x00FFD827 do color2 #00FF00 endon on IrReceived#Data=0x00FF48B7 do color2 #00330A endon on IrReceived#Data=0x00FF32CD do color2 #003314 endon on IrReceived#Data=0x00FF7887 do color2 #00331E endon rule3 on IrReceived#Data=0x00FF28D7 do color2 #003328 endon on IrReceived#Data=0x00FF8877 do color2 #0000FF endon on IrReceived#Data=0x00FF6897 do color2 #0A0033 endon on IrReceived#Data=0x00FF20DF do color2 #140033 endon on IrReceived#Data=0x00FF708F do color2 #140033 endon on IrReceived#Data=0x00FFF00F do color2 #280033 endon on IrReceived#Data=0x00FFA857 do color2 #FFFFFF endon and then activate the rules Backlog rule1 1; rule2 1; rule3 1 Learn more about Arilux devices","title":"Arilux AL-LC04"},{"location":"devices/Arilux-LC04/#arilux-al-lc04","text":"(WIFI Smart RGBW Controller With 24-key IR Remote, Working Voltage: DC 9-12V, Output Current: RGBW, 4*4A) These devices can be configured as \"generic module\" with this GPIO configuration: GPIO04 = [51] IRrecv GPIO05 = [38] PWM2 (G) GPIO12 = [39] PWM3 (R) GPIO14 = [37] PWM1 (B) GPIO13 = [40] PWM4 (W) [Only for RGBW-Stripe] A later version has been found to use the following configuration: GPIO04 = [51] IRrecv GPIO05 = [38] PWM2 (G) GPIO13 = [39] PWM3 (R) GPIO12 = [37] PWM1 (B) GPIO15 = [40] PWM4 (W) [Only for RGBW-Stripe] Note: as of #5523 IRCodes are now 64 bits. Copy this Code to your console to use the 24 Button IR Remote rule1 on IrReceived#Data=0x00FFB04F do power1 on endon on IrReceived#Data=0x00FFF807 do power1 off endon on IrReceived#Data=0x00FF906F do dimmer + endon on IrReceived#Data=0x00FFB847 do dimmer - endon on IrReceived#Data=0x00FFB24D do scheme 0 endon on IrReceived#Data=0x00FF00FF do scheme 4 endon on IrReceived#Data=0x00FF58A7 do scheme 2 endon on IrReceived#Data=0x00FF30CF do scheme 3 endon rule2 on IrReceived#Data=0x00FF9867 do color2 #FF0000 endon on IrReceived#Data=0x00FFE817 do color2 #470D00 endon on IrReceived#Data=0x00FF02FD do color2 #381600 endon on IrReceived#Data=0x00FF50AF do color2 #331E00 endon on IrReceived#Data=0x00FF38C7 do color2 #332800 endon on IrReceived#Data=0x00FFD827 do color2 #00FF00 endon on IrReceived#Data=0x00FF48B7 do color2 #00330A endon on IrReceived#Data=0x00FF32CD do color2 #003314 endon on IrReceived#Data=0x00FF7887 do color2 #00331E endon rule3 on IrReceived#Data=0x00FF28D7 do color2 #003328 endon on IrReceived#Data=0x00FF8877 do color2 #0000FF endon on IrReceived#Data=0x00FF6897 do color2 #0A0033 endon on IrReceived#Data=0x00FF20DF do color2 #140033 endon on IrReceived#Data=0x00FF708F do color2 #140033 endon on IrReceived#Data=0x00FFF00F do color2 #280033 endon on IrReceived#Data=0x00FFA857 do color2 #FFFFFF endon and then activate the rules Backlog rule1 1; rule2 1; rule3 1 Learn more about Arilux devices","title":"Arilux AL-LC04"},{"location":"devices/Armtronix-Dimmers/","text":"There is a small company making dimmers in about the same formfactor as a sonoff dual and single. These Single and Dual dimmer boards have open source firmware. Supported since version 6.4.0 as ARMTR Dimmer (56) Hardware ~ The dimmers contain an ESP8266 for the wifi connection and an Atmega328 which monitors the mains frequency and dimm the lights using a triac and phase controlled dimming. Communication between the two is done using the serial port at 115200 baud. The dimmers contain extra connections (pin headers) for a 10K potentiometer. When this one is connected you get 10 step dimming of the lights which overrides the tasmota dimm level. This feature also works when the Tasmota firmware is non-functional, so it is nice as a fail safe feature. The setting of the potentiometer is fed back to the Tasmota firmware, so when the potentiometer dimmer is turned and the Tasmota setting overridden, the value in the Tasmota channel is representable of the dimmer value. WARNINGS ~ Phase dimming is not for all lights. Most incandescent bulbs will work, but for LED and CCFL bulbs you will need the special dimmable versions of these lights. The large Blue/Yellow Swedish furniture store has some nice ones. Because these dimmers come in a small package, they lack a bit on the safety and interference side. A good idea would be to add a 1A fuse in the AC line and a R/C Snubber on the output. I also read somewhere that they work less well on 110VAC but this could probably be solved using a firmware update. The ESP8266 and Atmega are isolated from Mains. The used 220v-5V converter is the tried and tested HiLink 5V 0.6A PM01, but without the case. Software ~ For now, to use these dimmers you need to take it apart and flash new firmware to the ESP8266 and the Atmega328p using the Arduino IDE. The whole process is quite well documented for the single and dual dimmers. But you do need a USB to serial bridge, at best one with the DTR and RTS signals broken out as well. The software can be found in two Github repositories, for the single and dual dimmer. The Armtronix dimmer can be used in the Tasmota firmware by uncommenting the line #define USE_ARMTRONIX_DIMMERS in my_user_config.h and setting the module to ARMTR Dimmer. The Dual dimmer has a dual color led, which for now shows the wifi status of the Tasmota firmware. But this can be changed in the Tasmota firmware.","title":"Armtronix Dimmers"},{"location":"devices/Armtronix-Dimmers/#hardware","text":"The dimmers contain an ESP8266 for the wifi connection and an Atmega328 which monitors the mains frequency and dimm the lights using a triac and phase controlled dimming. Communication between the two is done using the serial port at 115200 baud. The dimmers contain extra connections (pin headers) for a 10K potentiometer. When this one is connected you get 10 step dimming of the lights which overrides the tasmota dimm level. This feature also works when the Tasmota firmware is non-functional, so it is nice as a fail safe feature. The setting of the potentiometer is fed back to the Tasmota firmware, so when the potentiometer dimmer is turned and the Tasmota setting overridden, the value in the Tasmota channel is representable of the dimmer value.","title":"Hardware"},{"location":"devices/Armtronix-Dimmers/#warnings","text":"Phase dimming is not for all lights. Most incandescent bulbs will work, but for LED and CCFL bulbs you will need the special dimmable versions of these lights. The large Blue/Yellow Swedish furniture store has some nice ones. Because these dimmers come in a small package, they lack a bit on the safety and interference side. A good idea would be to add a 1A fuse in the AC line and a R/C Snubber on the output. I also read somewhere that they work less well on 110VAC but this could probably be solved using a firmware update. The ESP8266 and Atmega are isolated from Mains. The used 220v-5V converter is the tried and tested HiLink 5V 0.6A PM01, but without the case.","title":"WARNINGS"},{"location":"devices/Armtronix-Dimmers/#software","text":"For now, to use these dimmers you need to take it apart and flash new firmware to the ESP8266 and the Atmega328p using the Arduino IDE. The whole process is quite well documented for the single and dual dimmers. But you do need a USB to serial bridge, at best one with the DTR and RTS signals broken out as well. The software can be found in two Github repositories, for the single and dual dimmer. The Armtronix dimmer can be used in the Tasmota firmware by uncommenting the line #define USE_ARMTRONIX_DIMMERS in my_user_config.h and setting the module to ARMTR Dimmer. The Dual dimmer has a dual color led, which for now shows the wifi status of the Tasmota firmware. But this can be changed in the Tasmota firmware.","title":"Software"},{"location":"devices/BlitzWolf-BW-SHP4-%28UK-Version%29/","text":"Product Page: https://www.amazon.co.uk/gp/product/B07GJ26TCQ Serial Connection ~ Please see the Hardware Preparation page for general instructions. MAKE SURE YOU DON'T HAVE IT PLUGGED IN WHEN DOING ANY OF THIS INCLUDING FLASHING - YOU HAVE BEEN WARNED. AS ALWAYS, YOU DO ANY OF THIS AT YOUR OWN RISK. Overview ~ The UK version of the BW SHP works perfectly as module number 45 (BlitzWolf SHP) but is challenging to flash with Tasmota firmware for two reasons: The case is glued; this is relatively easy to overcome as you can insert a very thin screwdriver into the case then simply slide it all the way around the perimeter to free off the glue. A much bigger issue is that the programming pins for the esp8266 are underneath the PCB very close to the case, so there's no way to get to them easily. This is the biggest challenge to installing Tasmota. There are three choices here: Open the case, unsolder the main PCB from the live and neutral pins. This is very difficult to do without deforming the plastic protection on the pins themselves and needs a powerful soldering iron. Open the case, bend the main PCB up from the case. I've done one this way and it's possible, but not ideal as the copper live and neutral bars could crack from fatigue. In either of these two methods, you also have to glue the case back together before the plug is safe to use, otherwise if you try and pull it out of a socket the cover simply comes off, exposing all the mains potentials. Make a slot in the bottom of the case, exposing the programming pins. This is my recommended way of doing it because it doesn't risk damaging the case or having it come apart from improper gluing, nor does it potentially fatigue the power pins or deform their safety plastic. However it does leave a big hole in the bottom of the case! That said, the hole is only accessible when the plug is not in a socket and you can always cover it with more plastic later. Holes in the base method ~ If you want to go for method 3 ie hole in the base, this is where they should be. There's a better picture of this area of the PCB further down this page on a version I removed from its case. Opening the case ~ If you really feel a need to open the case - not recommended - get something very thin and fairly strong, push it into the base and pry a little until it goes in 3-4 millimetres. Then slowly rotate the plug with the wedge held in the opening so you end up pushing the top of the case away from the base all the way around. Once you're done, this is what you'll find inside. Gently pull the white shutter mechanism upwards and off the copper pins - it comes away very smoothly and easily but be careful to hold upright so the little spring doesn't pop out and disappear. To get at the programming pins you then either have to desolder the live and neutral from the PCB and lift the whole thing off - strongly recommend you don't do this as you will almost certainly deform the plastic protecting the pins - or you will need to bend the PCB gently upwards so you can get at the underside. If you do that it will look like this..... It's then pretty easy to flash using the pin connections I've annotated on the drawing - make sure you power it from low voltage though - DON'T EVER CONNECT TO THE MAINS TO FLASH OR WHEN CASE IS OPEN. Once done, bend the PCB back into place, pop the white shutter assembly back on top and put the two case halves together with strong glue. MAKE SURE THE GLUE IS WELL HELD AS OTHERWISE WHEN YOU PULL THE PLUG OUT OF A SOCKET THE TOP COULD COME OFF, EXPOSING ALL THE LIVE CONNECTIONS. This is why I DON'T recommend opening the case to flash the firmware but instead suggest cutting a slot in the base and cover it afterwards.","title":"BlitzWolf BW SHP4 (UK Version)"},{"location":"devices/BlitzWolf-BW-SHP4-%28UK-Version%29/#serial-connection","text":"Please see the Hardware Preparation page for general instructions. MAKE SURE YOU DON'T HAVE IT PLUGGED IN WHEN DOING ANY OF THIS INCLUDING FLASHING - YOU HAVE BEEN WARNED. AS ALWAYS, YOU DO ANY OF THIS AT YOUR OWN RISK.","title":"Serial Connection"},{"location":"devices/BlitzWolf-BW-SHP4-%28UK-Version%29/#overview","text":"The UK version of the BW SHP works perfectly as module number 45 (BlitzWolf SHP) but is challenging to flash with Tasmota firmware for two reasons: The case is glued; this is relatively easy to overcome as you can insert a very thin screwdriver into the case then simply slide it all the way around the perimeter to free off the glue. A much bigger issue is that the programming pins for the esp8266 are underneath the PCB very close to the case, so there's no way to get to them easily. This is the biggest challenge to installing Tasmota. There are three choices here: Open the case, unsolder the main PCB from the live and neutral pins. This is very difficult to do without deforming the plastic protection on the pins themselves and needs a powerful soldering iron. Open the case, bend the main PCB up from the case. I've done one this way and it's possible, but not ideal as the copper live and neutral bars could crack from fatigue. In either of these two methods, you also have to glue the case back together before the plug is safe to use, otherwise if you try and pull it out of a socket the cover simply comes off, exposing all the mains potentials. Make a slot in the bottom of the case, exposing the programming pins. This is my recommended way of doing it because it doesn't risk damaging the case or having it come apart from improper gluing, nor does it potentially fatigue the power pins or deform their safety plastic. However it does leave a big hole in the bottom of the case! That said, the hole is only accessible when the plug is not in a socket and you can always cover it with more plastic later.","title":"Overview"},{"location":"devices/BlitzWolf-BW-SHP4-%28UK-Version%29/#holes-in-the-base-method","text":"If you want to go for method 3 ie hole in the base, this is where they should be. There's a better picture of this area of the PCB further down this page on a version I removed from its case.","title":"Holes in the base method"},{"location":"devices/BlitzWolf-BW-SHP4-%28UK-Version%29/#opening-the-case","text":"If you really feel a need to open the case - not recommended - get something very thin and fairly strong, push it into the base and pry a little until it goes in 3-4 millimetres. Then slowly rotate the plug with the wedge held in the opening so you end up pushing the top of the case away from the base all the way around. Once you're done, this is what you'll find inside. Gently pull the white shutter mechanism upwards and off the copper pins - it comes away very smoothly and easily but be careful to hold upright so the little spring doesn't pop out and disappear. To get at the programming pins you then either have to desolder the live and neutral from the PCB and lift the whole thing off - strongly recommend you don't do this as you will almost certainly deform the plastic protecting the pins - or you will need to bend the PCB gently upwards so you can get at the underside. If you do that it will look like this..... It's then pretty easy to flash using the pin connections I've annotated on the drawing - make sure you power it from low voltage though - DON'T EVER CONNECT TO THE MAINS TO FLASH OR WHEN CASE IS OPEN. Once done, bend the PCB back into place, pop the white shutter assembly back on top and put the two case halves together with strong glue. MAKE SURE THE GLUE IS WELL HELD AS OTHERWISE WHEN YOU PULL THE PLUG OUT OF A SOCKET THE TOP COULD COME OFF, EXPOSING ALL THE LIVE CONNECTIONS. This is why I DON'T recommend opening the case to flash the firmware but instead suggest cutting a slot in the base and cover it afterwards.","title":"Opening the case"},{"location":"devices/BlitzWolf-SHP2/","text":"The BlitzWolf BW-SHP2, HomeCube SP1, and Teckin SP22 are basically the same device barring the branding. September 2019 - Recent versions of the Teckin SP22 have been redesigned with a Tuya WR2 Wi-Fi module based on the Realtek RTL8710BN. Since these are not ESP82xx based, Tasmota will not function on this newer version of the device. Product Page: - BlitzWolf BW-SHP2 - Gosund-SP1 OTA install ~ October 2019 - As far as the newer firmware versions and shipments are delivered, the devices possibly won't work with this method. Try it at your own discretion. Since SHP2 is one of those Tuya based devices this OTA Tasmota installation method works just fine: https://github.com/ct-Open-Source/tuya-convert The Tuya-convert has a built in Tasmota v6.5.0 basic(but you can define any firmware during the install), remember, that basic version doesn't come with homeassistant auto discovery support, but Tasmota OTA works as expected. This method does't need any wiring. Serial Connection ~ Please see the Hardware Preparation page for general instructions. Step 1. ~ Be sure it is NOT plugged in! Remove the 4 triangle screws. Triangular 2.3mm Screwdriver required (a Torx T6 works well too)! Step 2. ~ Solder cables to the ESP Pins Step 3. ~ For version 2.3 and 2.4, see: devices/Gosund-SP1 . Connect serial adapter and make a shortwire between Pin IO0 and GND during startup. (For entering flashmode) RX and TX must be crossed. Step 4. ~ Flash Tasmota OpenHab configuration ~ sonoff.items: Switch BlitzwoIFSHP2 \"Switch\" { mqtt=\">[broker:cmnd/BlitzwoIFSHP2/POWER:command:*:default],<[broker:stat/BlitzwoIFSHP2/POWER:state:default]\" } Number Power_Total \"Total: [%.3f kWh]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Total)]\" } Number Power_Today \"Today: [%.3f kWh]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Today)]\" } Number Power_Yesterday \"Yesterday: [%.3f kWh]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Yesterday)]\" } Number Power \"Power: [%.1f Watt]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Power)]\" } Number Voltage \"Voltage: [%.0f V]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Voltage)]\" } Number Current \"Current: [%.3f A]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Current)]\" } Number Factor \"Factor: [%.2f]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Factor)]\" } default.sitemap: Switch item=BlitzwoIFSHP2 label=\"BlitzWoIF SHP2\" icon=\"socket\" mappings=[OFF=\"Off\",ON=\"On\"] Text item=Power label=\"Power: [%.1f Watt]\" icon=\"energy\" Text item=Voltage label=\"Voltage: [%.0f V]\" icon=\"energy\" Text item=Current label=\"Current: [%.3f A]\" icon=\"energy\" Text item=Factor label=\"Factor: [%.2f]\" icon=\"energy\" Text item=Power_Total label=\"Power Total: [%.3f kWh]\" icon=\"energy\" Text item=Power_Today label=\"Power Today: [%.3f kWh]\" icon=\"energy\" Text item=Power_Yesterday label=\"Power Yesterday: [%.3f kWh]\" icon=\"energy\" Home Assistant configuration ~ configuration.yaml switch: - platform: mqtt name: \"Blitzwolf\" state_topic: \"stat/blitzwolf/POWER\" command_topic: \"cmnd/blitzwolf/POWER\" payload_on: \"ON\" payload_off: \"OFF\" retain: false sensor: - platform: mqtt name: \"Blitzwolf Energy Today\" state_topic: \"tele/blitzwolf/SENSOR\" value_template: ' {{ value_json [ \"ENERGY\" ][ \"Today\" ] }} ' unit_of_measurement: \"kWh\" - platform: mqtt name: \"Blitzwolf Energy Yesterday\" state_topic: \"tele/blitzwolf/SENSOR\" value_template: ' {{ value_json [ \"ENERGY\" ][ \"Yesterday\" ] }} ' unit_of_measurement: \"kWh\" - platform: mqtt name: \"Blitzwolf Energy Total\" state_topic: \"tele/blitzwolf/SENSOR\" value_template: ' {{ value_json [ \"ENERGY\" ][ \"Total\" ] }} ' unit_of_measurement: \"kWh\" - platform: mqtt name: \"Blitzwolf Power\" state_topic: \"tele/blitzwolf/SENSOR\" value_template: ' {{ value_json [ \"ENERGY\" ][ \"Power\" ] }} ' unit_of_measurement: \"W\" - platform: mqtt name: \"Blitzwolf Voltage\" state_topic: \"tele/blitzwolf/SENSOR\" value_template: ' {{ value_json [ \"ENERGY\" ][ \"Voltage\" ] }} ' unit_of_measurement: \"V\" - platform: mqtt name: \"Blitzwolf Power Factor\" state_topic: \"tele/blitzwolf/SENSOR\" value_template: ' {{ value_json [ \"ENERGY\" ][ \"Factor\" ] }} ' Attention ~ There is a newer hardware revision (v2.3) which is supported too. Use latest release. See also devices/Gosund-SP1","title":"BlitzWolf SHP2"},{"location":"devices/BlitzWolf-SHP2/#ota-install","text":"October 2019 - As far as the newer firmware versions and shipments are delivered, the devices possibly won't work with this method. Try it at your own discretion. Since SHP2 is one of those Tuya based devices this OTA Tasmota installation method works just fine: https://github.com/ct-Open-Source/tuya-convert The Tuya-convert has a built in Tasmota v6.5.0 basic(but you can define any firmware during the install), remember, that basic version doesn't come with homeassistant auto discovery support, but Tasmota OTA works as expected. This method does't need any wiring.","title":"OTA install"},{"location":"devices/BlitzWolf-SHP2/#serial-connection","text":"Please see the Hardware Preparation page for general instructions.","title":"Serial Connection"},{"location":"devices/BlitzWolf-SHP2/#step-1","text":"Be sure it is NOT plugged in! Remove the 4 triangle screws. Triangular 2.3mm Screwdriver required (a Torx T6 works well too)!","title":"Step 1."},{"location":"devices/BlitzWolf-SHP2/#step-2","text":"Solder cables to the ESP Pins","title":"Step 2."},{"location":"devices/BlitzWolf-SHP2/#step-3","text":"For version 2.3 and 2.4, see: devices/Gosund-SP1 . Connect serial adapter and make a shortwire between Pin IO0 and GND during startup. (For entering flashmode) RX and TX must be crossed.","title":"Step 3."},{"location":"devices/BlitzWolf-SHP2/#step-4","text":"Flash Tasmota","title":"Step 4."},{"location":"devices/BlitzWolf-SHP2/#openhab-configuration","text":"sonoff.items: Switch BlitzwoIFSHP2 \"Switch\" { mqtt=\">[broker:cmnd/BlitzwoIFSHP2/POWER:command:*:default],<[broker:stat/BlitzwoIFSHP2/POWER:state:default]\" } Number Power_Total \"Total: [%.3f kWh]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Total)]\" } Number Power_Today \"Today: [%.3f kWh]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Today)]\" } Number Power_Yesterday \"Yesterday: [%.3f kWh]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Yesterday)]\" } Number Power \"Power: [%.1f Watt]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Power)]\" } Number Voltage \"Voltage: [%.0f V]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Voltage)]\" } Number Current \"Current: [%.3f A]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Current)]\" } Number Factor \"Factor: [%.2f]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Factor)]\" } default.sitemap: Switch item=BlitzwoIFSHP2 label=\"BlitzWoIF SHP2\" icon=\"socket\" mappings=[OFF=\"Off\",ON=\"On\"] Text item=Power label=\"Power: [%.1f Watt]\" icon=\"energy\" Text item=Voltage label=\"Voltage: [%.0f V]\" icon=\"energy\" Text item=Current label=\"Current: [%.3f A]\" icon=\"energy\" Text item=Factor label=\"Factor: [%.2f]\" icon=\"energy\" Text item=Power_Total label=\"Power Total: [%.3f kWh]\" icon=\"energy\" Text item=Power_Today label=\"Power Today: [%.3f kWh]\" icon=\"energy\" Text item=Power_Yesterday label=\"Power Yesterday: [%.3f kWh]\" icon=\"energy\"","title":"OpenHab configuration"},{"location":"devices/BlitzWolf-SHP2/#home-assistant-configuration","text":"configuration.yaml switch: - platform: mqtt name: \"Blitzwolf\" state_topic: \"stat/blitzwolf/POWER\" command_topic: \"cmnd/blitzwolf/POWER\" payload_on: \"ON\" payload_off: \"OFF\" retain: false sensor: - platform: mqtt name: \"Blitzwolf Energy Today\" state_topic: \"tele/blitzwolf/SENSOR\" value_template: ' {{ value_json [ \"ENERGY\" ][ \"Today\" ] }} ' unit_of_measurement: \"kWh\" - platform: mqtt name: \"Blitzwolf Energy Yesterday\" state_topic: \"tele/blitzwolf/SENSOR\" value_template: ' {{ value_json [ \"ENERGY\" ][ \"Yesterday\" ] }} ' unit_of_measurement: \"kWh\" - platform: mqtt name: \"Blitzwolf Energy Total\" state_topic: \"tele/blitzwolf/SENSOR\" value_template: ' {{ value_json [ \"ENERGY\" ][ \"Total\" ] }} ' unit_of_measurement: \"kWh\" - platform: mqtt name: \"Blitzwolf Power\" state_topic: \"tele/blitzwolf/SENSOR\" value_template: ' {{ value_json [ \"ENERGY\" ][ \"Power\" ] }} ' unit_of_measurement: \"W\" - platform: mqtt name: \"Blitzwolf Voltage\" state_topic: \"tele/blitzwolf/SENSOR\" value_template: ' {{ value_json [ \"ENERGY\" ][ \"Voltage\" ] }} ' unit_of_measurement: \"V\" - platform: mqtt name: \"Blitzwolf Power Factor\" state_topic: \"tele/blitzwolf/SENSOR\" value_template: ' {{ value_json [ \"ENERGY\" ][ \"Factor\" ] }} '","title":"Home Assistant configuration"},{"location":"devices/BlitzWolf-SHP2/#attention","text":"There is a newer hardware revision (v2.3) which is supported too. Use latest release. See also devices/Gosund-SP1","title":"Attention"},{"location":"devices/BlitzWolf-SHP6/","text":"The BlitzWolf BW-SHP6 and the Gosund SP111 are basically the same device, barring the branding. Product page: - BlitzWolf\u00ae BW-SHP6 - 2300W EU WIFI Smart Socket - Gosund SP111 Device needs exact calibration with a load >=60 Watt to gain good results! For further infos see Issue #4727 Serial Connection ~ Please see the Hardware Preparation page for general instructions. Step 1 ~ Disconnect device from power source! Step 2 ~ Remove one screw on the back of the device. PH1 screwdriver required. Step 3 ~ Undo 2 screws. PH1 screwdriver required. Disconnect antenna. Step 4 ~ Carefully remove PCB from casing for easier soldering. * Don't stress antenna cable too much. * Don't lose metal tube. Step 5 ~ Solder cables to the ESP Pins. SHP6 10A model: SHP6 15A model: If you do not want to solder you can try using crocodile clips and manually push a jumper cable first to IO0 (enter flash mode while booting, i.e. connect IO0 to ground) and then during flashing push a jumper to TX. Just be careful to not cause any short-circuit with the clips on the other side of the pads. Crocodile clips Step 6 ~ Connect serial adapter and make a shortwire between Pin IO0 and GND during startup (for entering flashmode). Step 7 ~ Erase flash to avoid issues with dropping WiFi connection. Example using esptool: esptool.py --port COM3 erase_flash Step 8 ~ Flash Tasmota. Step 9 ~ Select the correct configuration under Configuration -> Configure Module or apply correct template SHP6 10A model SHP6 15A model (compatible with SP111 v2) As an alternative for steps 2 to 5: ~ The following programming adapter could be an option, which requires no soldering or significant disassembly on the SHP-6. It significantly reduces the effort of reflashing multiple SHP-6 units. Thingiverse link Other photos ~ Power monitoring calibration ~ Approach the calibration using the Method 2. If not satisfied with the results, you could mod the SMD direct measure resistor or mitigate this using a Tasmota set of rules (values valid only for the 10A model): Rule1 ON energy#power<=100 DO Currentcal 2500 BREAK ON energy#power<=500 DO Currentcal 2635 BREAK ON energy#power<=1000 DO Currentcal 2788 BREAK ON energy#power<=1500 DO Currentcal 2942 BREAK ON energy#power<=2000 DO Currentcal 3095 BREAK ON energy#power<=2500 DO Currentcal 3249 BREAK ON energy#power>2500 DO Currentcal 3402 BREAK Rule1 1 Take the CurrentCal values above as a first approach and should be corrected through the Tasmota Method 2 calibration procedure: [[devices/Power-Monitoring-Calibration]] Home Assistant configuration ~ switch : - platform : mqtt name : \"Blitzwolf\" state_topic : \"stat/blitzwolf/POWER\" command_topic : \"cmnd/blitzwolf/POWER\" payload_on : \"ON\" payload_off : \"OFF\" retain : false sensor : - platform : mqtt name : \"Blitzwolf Energy Today\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Today\"] }}' unit_of_measurement : \"kWh\" - platform : mqtt name : \"Blitzwolf Energy Yesterday\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Yesterday\"] }}' unit_of_measurement : \"kWh\" - platform : mqtt name : \"Blitzwolf Energy Total\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Total\"] }}' unit_of_measurement : \"kWh\" - platform : mqtt name : \"Blitzwolf Power\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Power\"] }}' unit_of_measurement : \"W\" - platform : mqtt name : \"Blitzwolf Voltage\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Voltage\"] }}' unit_of_measurement : \"V\" - platform : mqtt name : \"Blitzwolf Power Factor\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Factor\"] }}'","title":"BlitzWolf SHP6"},{"location":"devices/BlitzWolf-SHP6/#serial-connection","text":"Please see the Hardware Preparation page for general instructions.","title":"Serial Connection"},{"location":"devices/BlitzWolf-SHP6/#step-1","text":"Disconnect device from power source!","title":"Step 1"},{"location":"devices/BlitzWolf-SHP6/#step-2","text":"Remove one screw on the back of the device. PH1 screwdriver required.","title":"Step 2"},{"location":"devices/BlitzWolf-SHP6/#step-3","text":"Undo 2 screws. PH1 screwdriver required. Disconnect antenna.","title":"Step 3"},{"location":"devices/BlitzWolf-SHP6/#step-4","text":"Carefully remove PCB from casing for easier soldering. * Don't stress antenna cable too much. * Don't lose metal tube.","title":"Step 4"},{"location":"devices/BlitzWolf-SHP6/#step-5","text":"Solder cables to the ESP Pins. SHP6 10A model: SHP6 15A model: If you do not want to solder you can try using crocodile clips and manually push a jumper cable first to IO0 (enter flash mode while booting, i.e. connect IO0 to ground) and then during flashing push a jumper to TX. Just be careful to not cause any short-circuit with the clips on the other side of the pads. Crocodile clips","title":"Step 5"},{"location":"devices/BlitzWolf-SHP6/#step-6","text":"Connect serial adapter and make a shortwire between Pin IO0 and GND during startup (for entering flashmode).","title":"Step 6"},{"location":"devices/BlitzWolf-SHP6/#step-7","text":"Erase flash to avoid issues with dropping WiFi connection. Example using esptool: esptool.py --port COM3 erase_flash","title":"Step 7"},{"location":"devices/BlitzWolf-SHP6/#step-8","text":"Flash Tasmota.","title":"Step 8"},{"location":"devices/BlitzWolf-SHP6/#step-9","text":"Select the correct configuration under Configuration -> Configure Module or apply correct template SHP6 10A model SHP6 15A model (compatible with SP111 v2)","title":"Step 9"},{"location":"devices/BlitzWolf-SHP6/#as-an-alternative-for-steps-2-to-5","text":"The following programming adapter could be an option, which requires no soldering or significant disassembly on the SHP-6. It significantly reduces the effort of reflashing multiple SHP-6 units. Thingiverse link","title":"As an alternative for steps 2 to 5:"},{"location":"devices/BlitzWolf-SHP6/#other-photos","text":"","title":"Other photos"},{"location":"devices/BlitzWolf-SHP6/#power-monitoring-calibration","text":"Approach the calibration using the Method 2. If not satisfied with the results, you could mod the SMD direct measure resistor or mitigate this using a Tasmota set of rules (values valid only for the 10A model): Rule1 ON energy#power<=100 DO Currentcal 2500 BREAK ON energy#power<=500 DO Currentcal 2635 BREAK ON energy#power<=1000 DO Currentcal 2788 BREAK ON energy#power<=1500 DO Currentcal 2942 BREAK ON energy#power<=2000 DO Currentcal 3095 BREAK ON energy#power<=2500 DO Currentcal 3249 BREAK ON energy#power>2500 DO Currentcal 3402 BREAK Rule1 1 Take the CurrentCal values above as a first approach and should be corrected through the Tasmota Method 2 calibration procedure: [[devices/Power-Monitoring-Calibration]]","title":"Power monitoring calibration"},{"location":"devices/BlitzWolf-SHP6/#home-assistant-configuration","text":"switch : - platform : mqtt name : \"Blitzwolf\" state_topic : \"stat/blitzwolf/POWER\" command_topic : \"cmnd/blitzwolf/POWER\" payload_on : \"ON\" payload_off : \"OFF\" retain : false sensor : - platform : mqtt name : \"Blitzwolf Energy Today\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Today\"] }}' unit_of_measurement : \"kWh\" - platform : mqtt name : \"Blitzwolf Energy Yesterday\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Yesterday\"] }}' unit_of_measurement : \"kWh\" - platform : mqtt name : \"Blitzwolf Energy Total\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Total\"] }}' unit_of_measurement : \"kWh\" - platform : mqtt name : \"Blitzwolf Power\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Power\"] }}' unit_of_measurement : \"W\" - platform : mqtt name : \"Blitzwolf Voltage\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Voltage\"] }}' unit_of_measurement : \"V\" - platform : mqtt name : \"Blitzwolf Power Factor\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Factor\"] }}'","title":"Home Assistant configuration"},{"location":"devices/BlitzWolf-SHP7/","text":"Serial Connection ~ Please see the Hardware Preparation page for general instructions. Step 1 ~ Disconnect device from power source! Step 2 ~ Remove the two stickers on the front. Step 3 ~ Undo 2 screws. PH1 screwdriver required. Step 4 ~ Remove back with screwdriver Step 4 ~ Undo 2 screws at the back. PH1 screwdriver required. Step 5 ~ Remove PCB from casing for easier soldering. Step 6 ~ Solder cables to the ESP pins. Because GND is hard to solder/access, I recommend to use the other side for GND: Result: Step 7 ~ Connect serial adapter and make a shortwire between Pin IO0 and GND during startup (for entering flashmode). Step 8 ~ Flash Tasmota. Step 9 ~ Setup Tasmota (wifi settings). Go to Configuration -> Configure Other and enter this template: {\"NAME\":\"SHP7 v2\",\"GPIO\":[18,158,56,131,134,132,0,0,17,57,21,0,22],\"FLAG\":0,\"BASE\":45} (I had to use v2 from https://templates.blakadder.com/blitzwolf_SHP7.html) Done !","title":"BlitzWolf SHP7"},{"location":"devices/BlitzWolf-SHP7/#serial-connection","text":"Please see the Hardware Preparation page for general instructions.","title":"Serial Connection"},{"location":"devices/BlitzWolf-SHP7/#step-1","text":"Disconnect device from power source!","title":"Step 1"},{"location":"devices/BlitzWolf-SHP7/#step-2","text":"Remove the two stickers on the front.","title":"Step 2"},{"location":"devices/BlitzWolf-SHP7/#step-3","text":"Undo 2 screws. PH1 screwdriver required.","title":"Step 3"},{"location":"devices/BlitzWolf-SHP7/#step-4","text":"Remove back with screwdriver","title":"Step 4"},{"location":"devices/BlitzWolf-SHP7/#step-4_1","text":"Undo 2 screws at the back. PH1 screwdriver required.","title":"Step 4"},{"location":"devices/BlitzWolf-SHP7/#step-5","text":"Remove PCB from casing for easier soldering.","title":"Step 5"},{"location":"devices/BlitzWolf-SHP7/#step-6","text":"Solder cables to the ESP pins. Because GND is hard to solder/access, I recommend to use the other side for GND: Result:","title":"Step 6"},{"location":"devices/BlitzWolf-SHP7/#step-7","text":"Connect serial adapter and make a shortwire between Pin IO0 and GND during startup (for entering flashmode).","title":"Step 7"},{"location":"devices/BlitzWolf-SHP7/#step-8","text":"Flash Tasmota.","title":"Step 8"},{"location":"devices/BlitzWolf-SHP7/#step-9","text":"Setup Tasmota (wifi settings). Go to Configuration -> Configure Other and enter this template: {\"NAME\":\"SHP7 v2\",\"GPIO\":[18,158,56,131,134,132,0,0,17,57,21,0,22],\"FLAG\":0,\"BASE\":45} (I had to use v2 from https://templates.blakadder.com/blitzwolf_SHP7.html) Done !","title":"Step 9"},{"location":"devices/Burnett-BN-K01/","text":"The Burnett Smart Socket. ~ Introduction ~ The Burnett Smart Socket BN-K01 is a smart socket that is small in size. The body is only 58mm * 48mm 34mm which can fit into smaller places. It is equipped with an ESP8285 which makes it possible to flash sonoff-tasmota. However, * you need to manually wire the Tx and Rx from the chip for flashing**. This guide provides details on how to prepare the socket for the initial flashing with sonoff-tasmota code. What is it? ~ As the other Sonoff's do, this smart socket uses EWeLink app to control. It\u2019s pretty well made and there is a shutter to close off the live socket holes when a plug is removed. Besides, it is pretty cheap in Taobao (it costs no more than USD 6). \ufffc Disassembly ~ * WARNING - Opening the unit potentially exposes mains voltages that can kill. You proceed beyond here entirely at your own risk. * * There are no screws. And unfortunately it is precisely glued, so to disassemble you need to find a thin yet strong tool to pull it open. \ufffcInside there is a main board with most of the components on the top. The Wi-Fi and control comes from a small daughter board, soldered on the left of the main board.\ufffc Unfortunately I cannot tear down the plastic around the main board, so I don't have a clear look for the back of the daughter board. Hookup ~ Unless you are just curious, there\u2019s no real need to unsolder the main board. You can get at everything you need to re-flash it on the top side of the daughter board. For flashing you need to solder the VCC and GND from the back. As shown in the picture, the GND is the top right pad while the VCC is the bottom left pad. While unfortunately, the Rx and Tx is not connected, so you have to wire directly to the ESP8285. It can be very hard if you are not familiar with soldering. The GPIO0 is connected to the button so no wiring is needed. Building Firmware ~ The process for building the firmware for the Burnett BN-K01 is basically the same as for the Sonoff with a few additional changes. You need to set the board to \"Generic ESP8285 Module\" The crystal frequency is 26MHz. Flash the Firmware ~ Hold the button when you connect the VCC and GND to make the ESP8285 boot into flash mode. After it boots, you no longer need to hold it. Configure ~ After you flashed and booted the Burnett BN-K01, just set config it as Sonoff S2x, then it will work.","title":"The Burnett Smart Socket."},{"location":"devices/Burnett-BN-K01/#the-burnett-smart-socket","text":"","title":"The Burnett Smart Socket."},{"location":"devices/Burnett-BN-K01/#introduction","text":"The Burnett Smart Socket BN-K01 is a smart socket that is small in size. The body is only 58mm * 48mm 34mm which can fit into smaller places. It is equipped with an ESP8285 which makes it possible to flash sonoff-tasmota. However, * you need to manually wire the Tx and Rx from the chip for flashing**. This guide provides details on how to prepare the socket for the initial flashing with sonoff-tasmota code.","title":"Introduction"},{"location":"devices/Burnett-BN-K01/#what-is-it","text":"As the other Sonoff's do, this smart socket uses EWeLink app to control. It\u2019s pretty well made and there is a shutter to close off the live socket holes when a plug is removed. Besides, it is pretty cheap in Taobao (it costs no more than USD 6). \ufffc","title":"What is it?"},{"location":"devices/Burnett-BN-K01/#disassembly","text":"* WARNING - Opening the unit potentially exposes mains voltages that can kill. You proceed beyond here entirely at your own risk. * * There are no screws. And unfortunately it is precisely glued, so to disassemble you need to find a thin yet strong tool to pull it open. \ufffcInside there is a main board with most of the components on the top. The Wi-Fi and control comes from a small daughter board, soldered on the left of the main board.\ufffc Unfortunately I cannot tear down the plastic around the main board, so I don't have a clear look for the back of the daughter board.","title":"Disassembly"},{"location":"devices/Burnett-BN-K01/#hookup","text":"Unless you are just curious, there\u2019s no real need to unsolder the main board. You can get at everything you need to re-flash it on the top side of the daughter board. For flashing you need to solder the VCC and GND from the back. As shown in the picture, the GND is the top right pad while the VCC is the bottom left pad. While unfortunately, the Rx and Tx is not connected, so you have to wire directly to the ESP8285. It can be very hard if you are not familiar with soldering. The GPIO0 is connected to the button so no wiring is needed.","title":"Hookup"},{"location":"devices/Burnett-BN-K01/#building-firmware","text":"The process for building the firmware for the Burnett BN-K01 is basically the same as for the Sonoff with a few additional changes. You need to set the board to \"Generic ESP8285 Module\" The crystal frequency is 26MHz.","title":"Building Firmware"},{"location":"devices/Burnett-BN-K01/#flash-the-firmware","text":"Hold the button when you connect the VCC and GND to make the ESP8285 boot into flash mode. After it boots, you no longer need to hold it.","title":"Flash the Firmware"},{"location":"devices/Burnett-BN-K01/#configure","text":"After you flashed and booted the Burnett BN-K01, just set config it as Sonoff S2x, then it will work.","title":"Configure"},{"location":"devices/CE-Smart-Home---LA-WF3-Wifi-Plug-%28TYWE2S%29/","text":"CE Smart Home - LA-WF3 Wifi Plug (TYWE2S) ~ Simple and compact Wifi Plug, based in ESP8266, internal module Tuya TYWE2S esptool log: Wifi module is an: TYWE2S: Detecting chip type... ESP8266 Chip is ESP8285 Features: WiFi, Embedded. Model purchased: https://www.costco.ca/Wi-Fi-Smart-Plug%2C-2-pack.product.100417575.html 24.99 CAD$ Product ~ Flashing ~ GPIO0 Needs to be grounded in order to get into flashing mode. 1. erase_flash 2. flash tasmota_minimal 3. flash tasmota_full Module Configuration ~","title":"CE Smart Home   LA WF3 Wifi Plug (TYWE2S)"},{"location":"devices/CE-Smart-Home---LA-WF3-Wifi-Plug-%28TYWE2S%29/#ce-smart-home-la-wf3-wifi-plug-tywe2s","text":"Simple and compact Wifi Plug, based in ESP8266, internal module Tuya TYWE2S esptool log: Wifi module is an: TYWE2S: Detecting chip type... ESP8266 Chip is ESP8285 Features: WiFi, Embedded. Model purchased: https://www.costco.ca/Wi-Fi-Smart-Plug%2C-2-pack.product.100417575.html 24.99 CAD$","title":"CE Smart Home - LA-WF3 Wifi Plug (TYWE2S)"},{"location":"devices/CE-Smart-Home---LA-WF3-Wifi-Plug-%28TYWE2S%29/#product","text":"","title":"Product"},{"location":"devices/CE-Smart-Home---LA-WF3-Wifi-Plug-%28TYWE2S%29/#flashing","text":"GPIO0 Needs to be grounded in order to get into flashing mode. 1. erase_flash 2. flash tasmota_minimal 3. flash tasmota_full","title":"Flashing"},{"location":"devices/CE-Smart-Home---LA-WF3-Wifi-Plug-%28TYWE2S%29/#module-configuration","text":"","title":"Module Configuration"},{"location":"devices/CE-Smart-Home%E2%84%A2-Garden-Power-Stake/","text":"Device Template ~ {\"NAME\":\"CE Power Stake\",\"GPIO\":[255,255,255,255,56,57,255,255,21,17,255,255,255],\"FLAG\":0,\"BASE\":18} Connection ~ This 6-outlet outdoor garden power stake is controlled by a standard ESP-12 chip connected to a single relay, meaning that all 6 outlets are on or off simultaneously. It also has a mains switch, a manual relay trigger button, and an LED indicator. Programmer Power Stake 3V3 VCC TX RX RX TX GND GND The button is not connected to D0 , so you will need to shunt D0 / GPIO0 to GND to enable programming mode. You may need to briefly shunt RESET to GND in order to initiate connections to the device. Internal Device Image ~ [[https://github.com/untergeek/shared_images/blob/master/devices/powerstake/powerstake_esp12s.jpg|alt=PowerStake Pinout]] Generic Module Config ~ [[https://github.com/untergeek/shared_images/blob/master/devices/powerstake/powerstake_tasmota_config.jpg|alt=Generic Module Config]] Additional Information ~ This device was found at Costco, and in fact appears to be made for Costco (see image below). The regular price was $13.97 USD, but was on sale for Christmas for $9.99 USD. [[https://github.com/untergeek/shared_images/blob/master/devices/powerstake/powerstake_front.jpg|alt=PowerStake Box Front]] [[https://github.com/untergeek/shared_images/blob/master/devices/powerstake/powerstake_rear.jpg|alt=PowerStake Box Rear]] [[https://github.com/untergeek/shared_images/blob/master/devices/powerstake/powerstake_side1.jpg|alt=PowerStake Box Side 1]] [[https://github.com/untergeek/shared_images/blob/master/devices/powerstake/powerstake_side2.jpg|alt=PowerStake Box Side 2]] [[https://github.com/untergeek/shared_images/blob/master/devices/esp12-pinout.png|alt=ESP12]]","title":"CE Smart Home\u2122 Garden Power Stake"},{"location":"devices/CE-Smart-Home%E2%84%A2-Garden-Power-Stake/#device-template","text":"{\"NAME\":\"CE Power Stake\",\"GPIO\":[255,255,255,255,56,57,255,255,21,17,255,255,255],\"FLAG\":0,\"BASE\":18}","title":"Device Template"},{"location":"devices/CE-Smart-Home%E2%84%A2-Garden-Power-Stake/#connection","text":"This 6-outlet outdoor garden power stake is controlled by a standard ESP-12 chip connected to a single relay, meaning that all 6 outlets are on or off simultaneously. It also has a mains switch, a manual relay trigger button, and an LED indicator. Programmer Power Stake 3V3 VCC TX RX RX TX GND GND The button is not connected to D0 , so you will need to shunt D0 / GPIO0 to GND to enable programming mode. You may need to briefly shunt RESET to GND in order to initiate connections to the device.","title":"Connection"},{"location":"devices/CE-Smart-Home%E2%84%A2-Garden-Power-Stake/#internal-device-image","text":"[[https://github.com/untergeek/shared_images/blob/master/devices/powerstake/powerstake_esp12s.jpg|alt=PowerStake Pinout]]","title":"Internal Device Image"},{"location":"devices/CE-Smart-Home%E2%84%A2-Garden-Power-Stake/#generic-module-config","text":"[[https://github.com/untergeek/shared_images/blob/master/devices/powerstake/powerstake_tasmota_config.jpg|alt=Generic Module Config]]","title":"Generic Module Config"},{"location":"devices/CE-Smart-Home%E2%84%A2-Garden-Power-Stake/#additional-information","text":"This device was found at Costco, and in fact appears to be made for Costco (see image below). The regular price was $13.97 USD, but was on sale for Christmas for $9.99 USD. [[https://github.com/untergeek/shared_images/blob/master/devices/powerstake/powerstake_front.jpg|alt=PowerStake Box Front]] [[https://github.com/untergeek/shared_images/blob/master/devices/powerstake/powerstake_rear.jpg|alt=PowerStake Box Rear]] [[https://github.com/untergeek/shared_images/blob/master/devices/powerstake/powerstake_side1.jpg|alt=PowerStake Box Side 1]] [[https://github.com/untergeek/shared_images/blob/master/devices/powerstake/powerstake_side2.jpg|alt=PowerStake Box Side 2]] [[https://github.com/untergeek/shared_images/blob/master/devices/esp12-pinout.png|alt=ESP12]]","title":"Additional Information"},{"location":"devices/CNSKOU---CNSANKOU-wall-switches/","text":"General ~ These CNSKOU / CNSANKOU wall switches (Chinese Sonoff clones) are sold on AliExpress and have a neutral design. They come in 1, 2 and 3 circuits and are easily mounted replacing your old wall switches. It measures 118mm wide by 72mm high, irrespective of the number of buttons, although it is also available in 86x86mm. The tempered glass front plate is available in white, black and gold colors. Despite it being advertised as a 'US' device, it will handle 90-250V AC input at 50/60Hz and is said to switch up to 10A per circuit. The same design is also available for use with a RF-remote, or as a traditional wall switch. There is a backlight indicator behind each button, which subtly shows green when the circuit is live and red when it is not. When physically pushing the button, there is an audio feedback. See here to view a video of the audio feedback. The one interesting for Tasmota is of course the WiFi version, which connects to 2.4GHz networks, up to 802.11n. The switch comes pre-loaded with ITEAD software and works well with the EWeLink app. Inside ~ When opening the package, easily done by turning a screwdriver under the two plastic lips at the lower side of the switch, the first thing we see are the capacitive touch sensors mounted on the back of the low-voltage board. The low-voltage board is connected through a 14-pin connector to the mains board, and contains an ESP8285 , piezo buzzer (should you wish to remove that audio feedback!) and a number of additional components. The ESP8285 is of course compatible with the ESP8266 albeit with only 1MB flash storage. The mains-voltage board contains the mains connection points, a TI ULN2003A relay driver and 1-3 relays and a tiny little board containing a power supply for the low-voltage bits. Flashing ~ The most interesting part is of course how we flash this device with Tasmota. To do this, do not connect the device to mains power and carefully remove the low-voltage board as this is all you'll need. Notice the 4 connection points just above the ESP8285, which is where you'll connect (from square pad up) 3v3, RX, TX and GND. I found that normal DuPont jumper wires provide a secure enough connection, but you may wish to solder on a few header pins. In order to get the ESP8285 into programming mode, you'll also need to connect GPIO0 to GND. There is no easily accessible connection point for GPIO0 and no buttons are provided on the board. I found the easiest way is to just use a normal jumper cable and manually hold it up against pin 10 (GPIO0) for a few seconds while the power is connected to the chip. Pin 10 is the second pin of the 'pin 9-16' row, on the right hand side of the chip in the image above. Use the usual method for flashing, undoubtedly documented better elsewhere than I ever could. Once Tasmota was up and running, I used the Sonoff T1 US module type.","title":"CNSKOU   CNSANKOU wall switches"},{"location":"devices/CNSKOU---CNSANKOU-wall-switches/#general","text":"These CNSKOU / CNSANKOU wall switches (Chinese Sonoff clones) are sold on AliExpress and have a neutral design. They come in 1, 2 and 3 circuits and are easily mounted replacing your old wall switches. It measures 118mm wide by 72mm high, irrespective of the number of buttons, although it is also available in 86x86mm. The tempered glass front plate is available in white, black and gold colors. Despite it being advertised as a 'US' device, it will handle 90-250V AC input at 50/60Hz and is said to switch up to 10A per circuit. The same design is also available for use with a RF-remote, or as a traditional wall switch. There is a backlight indicator behind each button, which subtly shows green when the circuit is live and red when it is not. When physically pushing the button, there is an audio feedback. See here to view a video of the audio feedback. The one interesting for Tasmota is of course the WiFi version, which connects to 2.4GHz networks, up to 802.11n. The switch comes pre-loaded with ITEAD software and works well with the EWeLink app.","title":"General"},{"location":"devices/CNSKOU---CNSANKOU-wall-switches/#inside","text":"When opening the package, easily done by turning a screwdriver under the two plastic lips at the lower side of the switch, the first thing we see are the capacitive touch sensors mounted on the back of the low-voltage board. The low-voltage board is connected through a 14-pin connector to the mains board, and contains an ESP8285 , piezo buzzer (should you wish to remove that audio feedback!) and a number of additional components. The ESP8285 is of course compatible with the ESP8266 albeit with only 1MB flash storage. The mains-voltage board contains the mains connection points, a TI ULN2003A relay driver and 1-3 relays and a tiny little board containing a power supply for the low-voltage bits.","title":"Inside"},{"location":"devices/CNSKOU---CNSANKOU-wall-switches/#flashing","text":"The most interesting part is of course how we flash this device with Tasmota. To do this, do not connect the device to mains power and carefully remove the low-voltage board as this is all you'll need. Notice the 4 connection points just above the ESP8285, which is where you'll connect (from square pad up) 3v3, RX, TX and GND. I found that normal DuPont jumper wires provide a secure enough connection, but you may wish to solder on a few header pins. In order to get the ESP8285 into programming mode, you'll also need to connect GPIO0 to GND. There is no easily accessible connection point for GPIO0 and no buttons are provided on the board. I found the easiest way is to just use a normal jumper cable and manually hold it up against pin 10 (GPIO0) for a few seconds while the power is connected to the chip. Pin 10 is the second pin of the 'pin 9-16' row, on the right hand side of the chip in the image above. Use the usual method for flashing, undoubtedly documented better elsewhere than I ever could. Once Tasmota was up and running, I used the Sonoff T1 US module type.","title":"Flashing"},{"location":"devices/CSL-%28aplic-WDP-303075%29/","text":"Connection ~ Vcc - 3,3V TX - RX RX - TX GND - GND For flashing you need to connect GPIO0 to GND Additional Information ~ Hardware details ~ ESP8266 - on TYWE2S Module HLW8012 - Power Monitor Chip SRU 5VDC SDA - Relais GPIO0 ~ You need to solder a wire to the test-point on the TYWE2S Module to be able to enter the flashmode. The Resest Pin has no function for that purpose. Device Images ~ GPIO Config ~ Power Monitoring will not work with that configuration... wait for software update in case you want to use it UPDATE: with Tasmota 6.3.0 you have fully monitoring support (Add support for CSL Aplic WDP 303075 Power Socket with Energy Monitoring (#3991, #3996))","title":"CSL (aplic WDP 303075)"},{"location":"devices/CSL-%28aplic-WDP-303075%29/#connection","text":"Vcc - 3,3V TX - RX RX - TX GND - GND For flashing you need to connect GPIO0 to GND","title":"Connection"},{"location":"devices/CSL-%28aplic-WDP-303075%29/#additional-information","text":"","title":"Additional Information"},{"location":"devices/CSL-%28aplic-WDP-303075%29/#hardware-details","text":"ESP8266 - on TYWE2S Module HLW8012 - Power Monitor Chip SRU 5VDC SDA - Relais","title":"Hardware details"},{"location":"devices/CSL-%28aplic-WDP-303075%29/#gpio0","text":"You need to solder a wire to the test-point on the TYWE2S Module to be able to enter the flashmode. The Resest Pin has no function for that purpose.","title":"GPIO0"},{"location":"devices/CSL-%28aplic-WDP-303075%29/#device-images","text":"","title":"Device Images"},{"location":"devices/CSL-%28aplic-WDP-303075%29/#gpio-config","text":"Power Monitoring will not work with that configuration... wait for software update in case you want to use it UPDATE: with Tasmota 6.3.0 you have fully monitoring support (Add support for CSL Aplic WDP 303075 Power Socket with Energy Monitoring (#3991, #3996))","title":"GPIO Config"},{"location":"devices/Canwing-CW001-WiFi-Smart-Switch/","text":"General: ~ Nice size and form factor - can be used as Sonoff Basic R2 There seems to be no unique name for the device in the market. The one I ordered for testing Tasmota was packaged by brand / model Canwing CW-001 . Let's use this naming for all similar devices. Operating the device under the original firmware by use of eWeLink-App shows \"Coolkit 0185\" as brand / model supported by ESP8285 . Source of supply was \"ebay.de\", seller \"globewin\", ordered 2019-01-12 for a price of 6,89 Euro , received in 14 calendar days. Additionally by name \u201eASHATA Intelligente WLAN Schalter\u201c this device is proposed by \"amazon.de\", seller \"Richer-R123\" for a price of 9,39 Euro. Aliexpress: Wi-Fi Smart Switch 5A Features of original device / firmware: ~ Remote control domestic appliances - a phone with 2.4G WiFi can remote control all domestic appliances through phone app. 1000W large power - adopting a 1000 W power to make operation powerful. Suitable for higher than Android 4.0. Flame retardant ABS shell ensures the safety. PCB equipped with serial standard interface (4 pins RX, TX, GND, Vcc / 3.3 V) and button / momentary switch dedicated to GPIO0. Specification: ~ Product type: WiFi Switch Module Wireless standard: WIFI 2.4 GHz IEEE 802.11 b/g/n Remote control mode: eWeLink phone app for Android/iOS or Tasmota Chip ESP 8266 / 8285 Maximum power: 1000 W / 5 A Package size: approx. 57 * 41 * 21 mm / 2.4 * 1.6 * 1.1 in Package weight: 35 g / 1.2 oz Package List: ~ 1 x WiFi Switch Controller 1 x User Manual (see end of this page) Photos of the case: ~ Photos of the PCB: ~ Magic moment \u2013 eWeLink slips away \u2013 Tasmota appears: ~ Result: ~ \u2003 Original users manual for eWeLink: ~","title":"Canwing CW001 WiFi Smart Switch"},{"location":"devices/Canwing-CW001-WiFi-Smart-Switch/#general","text":"Nice size and form factor - can be used as Sonoff Basic R2 There seems to be no unique name for the device in the market. The one I ordered for testing Tasmota was packaged by brand / model Canwing CW-001 . Let's use this naming for all similar devices. Operating the device under the original firmware by use of eWeLink-App shows \"Coolkit 0185\" as brand / model supported by ESP8285 . Source of supply was \"ebay.de\", seller \"globewin\", ordered 2019-01-12 for a price of 6,89 Euro , received in 14 calendar days. Additionally by name \u201eASHATA Intelligente WLAN Schalter\u201c this device is proposed by \"amazon.de\", seller \"Richer-R123\" for a price of 9,39 Euro. Aliexpress: Wi-Fi Smart Switch 5A","title":"General:"},{"location":"devices/Canwing-CW001-WiFi-Smart-Switch/#features-of-original-device-firmware","text":"Remote control domestic appliances - a phone with 2.4G WiFi can remote control all domestic appliances through phone app. 1000W large power - adopting a 1000 W power to make operation powerful. Suitable for higher than Android 4.0. Flame retardant ABS shell ensures the safety. PCB equipped with serial standard interface (4 pins RX, TX, GND, Vcc / 3.3 V) and button / momentary switch dedicated to GPIO0.","title":"Features of original device / firmware:"},{"location":"devices/Canwing-CW001-WiFi-Smart-Switch/#specification","text":"Product type: WiFi Switch Module Wireless standard: WIFI 2.4 GHz IEEE 802.11 b/g/n Remote control mode: eWeLink phone app for Android/iOS or Tasmota Chip ESP 8266 / 8285 Maximum power: 1000 W / 5 A Package size: approx. 57 * 41 * 21 mm / 2.4 * 1.6 * 1.1 in Package weight: 35 g / 1.2 oz","title":"Specification:"},{"location":"devices/Canwing-CW001-WiFi-Smart-Switch/#package-list","text":"1 x WiFi Switch Controller 1 x User Manual (see end of this page)","title":"Package List:"},{"location":"devices/Canwing-CW001-WiFi-Smart-Switch/#photos-of-the-case","text":"","title":"Photos of the case:"},{"location":"devices/Canwing-CW001-WiFi-Smart-Switch/#photos-of-the-pcb","text":"","title":"Photos of the PCB:"},{"location":"devices/Canwing-CW001-WiFi-Smart-Switch/#magic-moment-ewelink-slips-away-tasmota-appears","text":"","title":"Magic moment \u2013 eWeLink slips away \u2013 Tasmota appears:"},{"location":"devices/Canwing-CW001-WiFi-Smart-Switch/#result","text":"","title":"Result:"},{"location":"devices/Canwing-CW001-WiFi-Smart-Switch/#original-users-manual-for-ewelink","text":"","title":"Original users manual for eWeLink:"},{"location":"devices/Century-Aoke---Festnight-%28Sonoff-Basic-clone%29/","text":"Connection ~ Vcc - 3,3V TX - RX RX - TX GND - GND Additional Information ~ SmartHome is a cheap Sonoff Basic clone, but they still work with Tasmota. More Infos can be found here: #343 . Device Images ~ I'll try to upload the images later. Generic Module Config ~","title":"Century Aoke   Festnight (Sonoff Basic clone)"},{"location":"devices/Century-Aoke---Festnight-%28Sonoff-Basic-clone%29/#connection","text":"Vcc - 3,3V TX - RX RX - TX GND - GND","title":"Connection"},{"location":"devices/Century-Aoke---Festnight-%28Sonoff-Basic-clone%29/#additional-information","text":"SmartHome is a cheap Sonoff Basic clone, but they still work with Tasmota. More Infos can be found here: #343 .","title":"Additional Information"},{"location":"devices/Century-Aoke---Festnight-%28Sonoff-Basic-clone%29/#device-images","text":"I'll try to upload the images later.","title":"Device Images"},{"location":"devices/Century-Aoke---Festnight-%28Sonoff-Basic-clone%29/#generic-module-config","text":"","title":"Generic Module Config"},{"location":"devices/Digoo-DG-SP202/","text":"","title":"Digoo DG SP202"},{"location":"devices/Dimmer-switch-with-Nuvoton-chip/","text":"A generic touch dimmer flashed with Tasmota . On AliExpress you can buy a wifi dimmer for mains voltage (110 or 220V) It's a brandles dimmer, but can be found here: AliExpress page It comes in a couple of forms, but sinds I live in Holland, I chose the EU style, single gang, 220V, White edition. It has a glass front plate with 3 proximity/touch switches (On/Off, dimm up & dimm down) and a wifi indicator LED. The inside houses 2 PCB's; a power board and a control board: The control board: There are two main chips on board: An ESP8266 and a Nuvoton n76e003at20 The Nuvoton will do the switch side of it all, the ESP communication. The mains board: For flashing, we only need the control board. Solder small wires to the pads as marked on the picture: 3.3V GND RX TX Sw (gpio0) Solder 'Res1' to GND Note that the silkscreen on this board has TX and RX wrong. Now use a USB to serial adapter to connect the wires. Use a 3.3V board, NOT 5V, this will destroy the ESP chip on the board! Connect: GND to GND 3.3V to 3.3V RX to RX (due to the fact the silkscreen is wrong, otherwise, RX connects to TX and vice versa) TX to TX SW to GND -- only during power up, to put the ESP in programming mode. From here the upload is the same as for all other Tasmota devices. See the upload page for detailed info. Note: sonoff basic and classic variants do not support the serial bridge. To get this working you should use the standard tasmota.bin - NOT basic or classic. After the upload was successful, unplug the device from the serial adapter. You can now desolder all the connections you have made earlier. Also remove the wire between RES1 and GND. Then plug the board back in its housing. Be careful with the connector on the underside of the board. Line up the pins with te header and lightly press it in its place. Connecting to mains installation: ~ WARNING! THIS PROJECT INVOLVES WORKING WITH HIGH VOLTAGE AND YOU COULD KILL YOURSELF AND/OR SET YOUR HOUSE ON FIRE. Connect your light to the dimmer according the manual. Keep in mind, the dimmer itself needs a Neutral wire as well. If you replace an existing switch or dimmer, it can be that you need to run an extra neutral wire. First connection ~ When you first power up the dimmer switch, it comes up in AccessPoint mode. Follow the instructions here Set correct module type ~ Once you have all connected, you should go to the configuration page of the Tasmota Dimmer. Go to your browser and fill in the IP address. Then go to 'Configuration' and then to 'Configure Module'. From the drop down menu select module 58: PS-16-DZ. Then hit Save. The module will restart and you are done! You can now toggle the light and use the slider to dim the lights from the tasmota webpage. Or better, use your favorite domotica software to control it via MQTT.","title":"Dimmer switch with Nuvoton chip"},{"location":"devices/Dimmer-switch-with-Nuvoton-chip/#connecting-to-mains-installation","text":"WARNING! THIS PROJECT INVOLVES WORKING WITH HIGH VOLTAGE AND YOU COULD KILL YOURSELF AND/OR SET YOUR HOUSE ON FIRE. Connect your light to the dimmer according the manual. Keep in mind, the dimmer itself needs a Neutral wire as well. If you replace an existing switch or dimmer, it can be that you need to run an extra neutral wire.","title":"Connecting to mains installation:"},{"location":"devices/Dimmer-switch-with-Nuvoton-chip/#first-connection","text":"When you first power up the dimmer switch, it comes up in AccessPoint mode. Follow the instructions here","title":"First connection"},{"location":"devices/Dimmer-switch-with-Nuvoton-chip/#set-correct-module-type","text":"Once you have all connected, you should go to the configuration page of the Tasmota Dimmer. Go to your browser and fill in the IP address. Then go to 'Configuration' and then to 'Configure Module'. From the drop down menu select module 58: PS-16-DZ. Then hit Save. The module will restart and you are done! You can now toggle the light and use the slider to dim the lights from the tasmota webpage. Or better, use your favorite domotica software to control it via MQTT.","title":"Set correct module type"},{"location":"devices/ERC309-Kinetic-Switch/","text":"Discussed here Configuration Configure as a Tuya Dimmer (54) (support as a BASE module was introduced in 6.2.1.16). GPIO13 - Tuya Rx (108) GPIO15 - Tuya Tx (107) Template: {\"NAME\":\"Kinetic Switch\",\"GPIO\":[255,255,255,255,255,255,0,0,255,108,255,107,255],\"FLAG\":0,\"BASE\":54} Module Flashing This device uses a Tuya TYWE3S Wi-Fi PCB module. An easy soldering method is to take several Dupont style jumper wires, cut one end off, and apply a bit of solder to each stripped end. This will keep the wire flexible and prevent any circuit board pads from ripping off. Apply a bit of solder to each pad necessary to flash (double check your pin-outs). Once the wire and pad have solder simply put the two together and apply a bit of heat and they will join together. Attach the GPIO0 wire to ground during initial boot to flash. A 3-pin header bridged together works great with GPIO0, GND and the GND from the USB flasher attached (TX pin to RX pin and RX pin to TX pin on USB flash adapter). Verify that you are using 3.3volts to flash, NOT 5V! Two options: Remove the ESP PCB by desoldering. This makes it easier to get to the pins of the TYWE3S board. No PCB desoldering. You will have to connect the RESET pin of the MCU chip to GND. This requires a soldering iron with a thin tip. Product Link","title":"ERC309 Kinetic Switch"},{"location":"devices/EXS-2-Channel-Wifi-Dimmer-V4/","text":"Disclaimer ~ DANGER OF ELECTROCUTION You must de-solder ESP8266 pins from the PCB in order to flash Tasmota! You can't flash Tasmota over firmware from ex-store.de At the moment I can see no way to flash minimal.bin over the original firmware. How flash on assembled PCB Line TX and RX is directly wired from the dimmer to the MCU. Cut this 2 lines. For example desolder pin2 and pin3 from MCU. Solder cable on GPIO0, TX, RX (ESP8266) VCC and GND (See description on pcb). Connect cables with your USB adapter. Before you flash firmware connect the module with 230V (Solderpads \"230V IN\" and \"NULL\") since some USB adapters do not have enough power. Das Modul sollte nur geflasht werden wenn es sich nicht auf der Leiterplatte befindet! Die Firmware \"Tasmota\" kann nicht \u00fcber die Firmware von ex-store.de geflasht werden (OTA) Versuchen Sie es trotzdem ist das Modul unbrauchbar und muss ausgebaut werden und neu geflasht werden. Aufspielen der Tasmota Firmware mit dem Modul auf der Platine Die Leitungen TX und RX sind direkt mit der Dimm-MCU verdrahtet. Diese Leitungen m\u00fcssen getrennt werden. Zum Beispiel Pin2 und Pin3 von der MCU abl\u00f6ten (hochbiegen). L\u00f6ten Sie Kabel an GPIO0, TX, RX (ESP8266), VCC und GND (siehe Beschreibung auf der Platine). Verbinden Sie diese Kabel mit Ihrem USB Adapter. Bevor Sie die Firmware flashen, muss das Modul mit 230V (L\u00f6tpads \"230V IN\" und \"NULL\") verbunden werden. Einige USB-Adapter haben nicht gen\u00fcgend Strom um die Platine zu versorgen. 230V sind f\u00fcr Lebewesen Lebensgef\u00e4hrlich. Ein Stromschlag kann unter anderem Ihren Herzrythmus st\u00f6ren und zum Tode f\u00fchren. Dessen sollten Sie sich bewust sein wenn Sie an diesem Modul arbeiten. Schematic ~ Menu ~ Example setup with DHT22 ~ DHT wiring VCC - header VCC Ground - header GND Data line - to GPIO14","title":"EXS 2 Channel Wifi Dimmer V4"},{"location":"devices/EXS-2-Channel-Wifi-Dimmer-V4/#disclaimer","text":"DANGER OF ELECTROCUTION You must de-solder ESP8266 pins from the PCB in order to flash Tasmota! You can't flash Tasmota over firmware from ex-store.de At the moment I can see no way to flash minimal.bin over the original firmware. How flash on assembled PCB Line TX and RX is directly wired from the dimmer to the MCU. Cut this 2 lines. For example desolder pin2 and pin3 from MCU. Solder cable on GPIO0, TX, RX (ESP8266) VCC and GND (See description on pcb). Connect cables with your USB adapter. Before you flash firmware connect the module with 230V (Solderpads \"230V IN\" and \"NULL\") since some USB adapters do not have enough power. Das Modul sollte nur geflasht werden wenn es sich nicht auf der Leiterplatte befindet! Die Firmware \"Tasmota\" kann nicht \u00fcber die Firmware von ex-store.de geflasht werden (OTA) Versuchen Sie es trotzdem ist das Modul unbrauchbar und muss ausgebaut werden und neu geflasht werden. Aufspielen der Tasmota Firmware mit dem Modul auf der Platine Die Leitungen TX und RX sind direkt mit der Dimm-MCU verdrahtet. Diese Leitungen m\u00fcssen getrennt werden. Zum Beispiel Pin2 und Pin3 von der MCU abl\u00f6ten (hochbiegen). L\u00f6ten Sie Kabel an GPIO0, TX, RX (ESP8266), VCC und GND (siehe Beschreibung auf der Platine). Verbinden Sie diese Kabel mit Ihrem USB Adapter. Bevor Sie die Firmware flashen, muss das Modul mit 230V (L\u00f6tpads \"230V IN\" und \"NULL\") verbunden werden. Einige USB-Adapter haben nicht gen\u00fcgend Strom um die Platine zu versorgen. 230V sind f\u00fcr Lebewesen Lebensgef\u00e4hrlich. Ein Stromschlag kann unter anderem Ihren Herzrythmus st\u00f6ren und zum Tode f\u00fchren. Dessen sollten Sie sich bewust sein wenn Sie an diesem Modul arbeiten.","title":"Disclaimer"},{"location":"devices/EXS-2-Channel-Wifi-Dimmer-V4/#schematic","text":"","title":"Schematic"},{"location":"devices/EXS-2-Channel-Wifi-Dimmer-V4/#menu","text":"","title":"Menu"},{"location":"devices/EXS-2-Channel-Wifi-Dimmer-V4/#example-setup-with-dht22","text":"DHT wiring VCC - header VCC Ground - header GND Data line - to GPIO14","title":"Example setup with DHT22"},{"location":"devices/EXS-Relay-V3.1-%26-V5.1/","text":"Flush Wifi Moduls with latching Relays ~ V3.1 Relay ~ V5.0 Relay ~ V5.0 Relay (PCB Backside) ~ Pinouts: ~ V3.1 GPIO00 Module Pin 8 GPIO01 UART0_TXD Pin 2 GPIO02 Module Pin 7 GPIO03 UART0_RXD Pin 3 GPIO04 Module Pin 10 GPIO05 Module Pin 9 GPIO12 Relay1 (High = off) GPIO13 Relay1 (High = on ) V5.0 GPIO00 Module Pin 4 GPIO02 Module Pin 3 GPIO04 Module Pin 2 GPIO05 Module Pin 1 GPIO12 Relay1 ( High = Off) GPIO13 Relay1 ( High = On) GPIO14 Relay2 ( High = Off) GPIO15 LED1 GPIO16 Relay2 ( High = On) Serial Connection ~ The only way to flashing the moduls you must soldering 4 wires to the RX/TX/3V3/GND pins from the ESP. The PCB have no serial pinout connector. For connecting the ground (GND) on a V5.0 Modul you can use one of the 2 GND pinout connectors from the PCB. For flashing the moduls enable the flashmode of the ESP, connect PIN4 (GPIO00) to GND. !!! Don't flashing the modul when it connected to the main power. You brick the device and your computer or USB Port. Use only a 3.3V USB Adapter for flashing!!! Notes ~ For use the V5.0 Modul with the \"EXS Relay(s)\" profile you must change the \"Module parameters\" (see picture below) Now you see in device setup The output pins of the V5.0 are reversed on the PCB. You must use \"out1\" for Relay2 and \"out2\" for Relay1 !!! This is the only way for support both Moduls with Tasmota. (thanks for this Note to Theo Arends)","title":"EXS Relay V3.1 & V5.1"},{"location":"devices/EXS-Relay-V3.1-%26-V5.1/#flush-wifi-moduls-with-latching-relays","text":"","title":"Flush Wifi Moduls with latching Relays"},{"location":"devices/EXS-Relay-V3.1-%26-V5.1/#v31-relay","text":"","title":"V3.1 Relay"},{"location":"devices/EXS-Relay-V3.1-%26-V5.1/#v50-relay","text":"","title":"V5.0 Relay"},{"location":"devices/EXS-Relay-V3.1-%26-V5.1/#v50-relay-pcb-backside","text":"","title":"V5.0 Relay (PCB Backside)"},{"location":"devices/EXS-Relay-V3.1-%26-V5.1/#pinouts","text":"V3.1 GPIO00 Module Pin 8 GPIO01 UART0_TXD Pin 2 GPIO02 Module Pin 7 GPIO03 UART0_RXD Pin 3 GPIO04 Module Pin 10 GPIO05 Module Pin 9 GPIO12 Relay1 (High = off) GPIO13 Relay1 (High = on ) V5.0 GPIO00 Module Pin 4 GPIO02 Module Pin 3 GPIO04 Module Pin 2 GPIO05 Module Pin 1 GPIO12 Relay1 ( High = Off) GPIO13 Relay1 ( High = On) GPIO14 Relay2 ( High = Off) GPIO15 LED1 GPIO16 Relay2 ( High = On)","title":"Pinouts:"},{"location":"devices/EXS-Relay-V3.1-%26-V5.1/#serial-connection","text":"The only way to flashing the moduls you must soldering 4 wires to the RX/TX/3V3/GND pins from the ESP. The PCB have no serial pinout connector. For connecting the ground (GND) on a V5.0 Modul you can use one of the 2 GND pinout connectors from the PCB. For flashing the moduls enable the flashmode of the ESP, connect PIN4 (GPIO00) to GND. !!! Don't flashing the modul when it connected to the main power. You brick the device and your computer or USB Port. Use only a 3.3V USB Adapter for flashing!!!","title":"Serial Connection"},{"location":"devices/EXS-Relay-V3.1-%26-V5.1/#notes","text":"For use the V5.0 Modul with the \"EXS Relay(s)\" profile you must change the \"Module parameters\" (see picture below) Now you see in device setup The output pins of the V5.0 are reversed on the PCB. You must use \"out1\" for Relay2 and \"out2\" for Relay1 !!! This is the only way for support both Moduls with Tasmota. (thanks for this Note to Theo Arends)","title":"Notes"},{"location":"devices/Etekcity-Smart-WiFi-Light-Switch-ESWL01/","text":"Generic Config\\ GPIO5 Led1\\ GPIO13 Relay1\\ GPIO14 Switch1\\ Execute switchmode1 3 in console. To put unit into flashing mode, short GPIO0 with GND","title":"Etekcity Smart WiFi Light Switch ESWL01"},{"location":"devices/Geekcreit-Sonoff-2-Channel-Relay-%28AC-85V-250V%29/","text":"Geekcreit \"Sonoff\" 2 Channel Relay Bare PCB version: https://www.aliexpress.com/item/Sonoff-2CH-AC85-250V-Wireless-Switch-Timer-Smart-Wifi-Switch-Universal-Automation-Module-Remote-Control-for/32948157608.html Version with enclosure: https://www.banggood.com/Geekcreit-2-Channel-AC-85V-250V-APP-Remote-Control-WIFI-Wireless-Switch-Socket-For-Smart-Home-p-1114958.html?rmmds=search&cur_warehouse=CN The Geekcreit/\"Sonoff\" 2CH is based on the ESP8285 via the Itead PSF-B04. It is very similar to 4CH DIY, so this wiki page is based on the page for that device. More info here: https://github.com/arendst/Tasmota/issues/1970 Serial Connection ~ Geekcreit/\"Sonoff\" 2CH ~ Please see the Hardware Preparation page for general instructions. As always, you need to access the serial interface. The four serial pins (3V3, Rx, Tx, GND) can be seen in the picture. Unless you have a very steady hand soldering will be required for the TX and RX on the ESP chip. Programming the Geekcreit/\"Sonoff\" 2CH is easy. The bottom left on-board-button is connected to GPIO0 and as with all ESP8266/ESP8285 modules pulling GPIO0 to GND is needed to put the chip in programming mode. You need to hold this button when booting the device for flashing. Module parameters ~ Enable GPIO9 & GPIO10 ~ To use GPIO9 and GPIO10 of the ESP8285, open the console and enter => \"SetOption51 on\". Restart the module. Assign inputs and outputs ~ * Note: * The third button on this device is not connected to a GPIO. Instead it is used to cycle through some relay modes that are supported by the two external ICs. Only one of these modes works with Tasmota, so it is necessary to continue to press this button 3 until the relays can be controlled from the toggle buttons in the Tasmota web UI. Module Type => Generic (18) GPIO 1 => Button 1 (17) GPIO 9 => Button 2 (18) GPIO 10 => Button 3 (19) GPIO 14 => Button 4 (20) GPIO 12 => relay 1 (21) GPIO 5 => relay 2 (22) GPIO 13 => LED 1 (52) Restart the module.","title":"Geekcreit Sonoff 2 Channel Relay (AC 85V 250V)"},{"location":"devices/Geekcreit-Sonoff-2-Channel-Relay-%28AC-85V-250V%29/#serial-connection","text":"","title":"Serial Connection"},{"location":"devices/Geekcreit-Sonoff-2-Channel-Relay-%28AC-85V-250V%29/#geekcreitsonoff-2ch","text":"Please see the Hardware Preparation page for general instructions. As always, you need to access the serial interface. The four serial pins (3V3, Rx, Tx, GND) can be seen in the picture. Unless you have a very steady hand soldering will be required for the TX and RX on the ESP chip. Programming the Geekcreit/\"Sonoff\" 2CH is easy. The bottom left on-board-button is connected to GPIO0 and as with all ESP8266/ESP8285 modules pulling GPIO0 to GND is needed to put the chip in programming mode. You need to hold this button when booting the device for flashing.","title":"Geekcreit/\"Sonoff\" 2CH"},{"location":"devices/Geekcreit-Sonoff-2-Channel-Relay-%28AC-85V-250V%29/#module-parameters","text":"","title":"Module parameters"},{"location":"devices/Geekcreit-Sonoff-2-Channel-Relay-%28AC-85V-250V%29/#enable-gpio9-gpio10","text":"To use GPIO9 and GPIO10 of the ESP8285, open the console and enter => \"SetOption51 on\". Restart the module.","title":"Enable GPIO9 &amp; GPIO10"},{"location":"devices/Geekcreit-Sonoff-2-Channel-Relay-%28AC-85V-250V%29/#assign-inputs-and-outputs","text":"* Note: * The third button on this device is not connected to a GPIO. Instead it is used to cycle through some relay modes that are supported by the two external ICs. Only one of these modes works with Tasmota, so it is necessary to continue to press this button 3 until the relays can be controlled from the toggle buttons in the Tasmota web UI. Module Type => Generic (18) GPIO 1 => Button 1 (17) GPIO 9 => Button 2 (18) GPIO 10 => Button 3 (19) GPIO 14 => Button 4 (20) GPIO 12 => relay 1 (21) GPIO 5 => relay 2 (22) GPIO 13 => LED 1 (52) Restart the module.","title":"Assign inputs and outputs"},{"location":"devices/Gosund-SP1/","text":"Purchase There are several clones of this device -- use the Teckin device: Gosund SP1 (Version 2.3 and 2.4) To configure select Gosund SP1 v23 (55) or console command Module 55 BlitzWolf SHP2 (Version 2.3 and 2.4) Calibration ~ If you have another (better) volt and power meter, this procedure should increase the precision. Use an incandescent bulb or an iron. In the web UI Console, enter the (correct) readings using the following commands: Backlog VoltageSet <voltage>; CurrentSet <current>; PowerSet <wattage> Details ~ More pictures","title":"Gosund SP1"},{"location":"devices/Gosund-SP1/#calibration","text":"If you have another (better) volt and power meter, this procedure should increase the precision. Use an incandescent bulb or an iron. In the web UI Console, enter the (correct) readings using the following commands: Backlog VoltageSet <voltage>; CurrentSet <current>; PowerSet <wattage>","title":"Calibration"},{"location":"devices/Gosund-SP1/#details","text":"More pictures","title":"Details"},{"location":"devices/H801/","text":"It's not entirely clear where these devices come from originally, but they are available from AliExpress and eBay. AliExpress: https://www.aliexpress.com/wholesale?catId=0&SearchText=H801 eBay: https://www.ebay.co.uk/sch/items/?_nkw=h801 Hardware ~ The chip used on this board is the ESP8266EX . 5 PWM outputs are connected to DTU35N06 MOSFETs to drive the 5 output channels (RGB + W1 + W2). Function ESP8266 Pin Channel R GPIO 15 PWM1 G GPIO 13 PWM2 B GPIO 12 PWM3 W1 GPIO 14 PWM4 W2 GPIO 04 PWM5 LED D1(red) GPIO 05 LED D2 (green) GPIO 01 Serial Connection ~ Please see the Hardware Preparation page for general instructions. You need to access the serial interface. The unpopulated serial header (3V3, RX, TX, GND) are available in the middle of the PCB, right next to J3. Note: the RX and TX pins are labelled from the terminal's perspective, not from the perspective of the ESP chip. This means you should connect the RX and TX pins from your computer's UART to the RX and TX pins on the board respectively, not crossing them over! To place the board into flashing mode, you will need to short J3. This can remain shorted while flashing is in progress, but you will need to remove the short in order to boot the Tasmota firmware. First Boot ~ Most boards supported by the Tasmota firmware use GPIO 1 for serial TX. The H801, as shown in the image above, uses GPIO 2. As the serial RX is still the same as for other boards, it is possible for Tasmota to read from the serial connection but anything written will not be sent to your terminal. Blindly type the following command to set Tasmota to the H801 module type, and it will automatically switch to using GPIO 2 for serial TX allowing setup to proceed: module 20 See #2155 for more details. Please be aware that some of the H801 modules were sold with only 512kB of flash. You can check whether yours is affected by using esptool, with the flash_id command. If you only have 512kB of flash, you can still build your own firmware, but will have to remove components that you do not need, in order to reduce the size of the firmware binary. You will also have to use a linker script for the smaller flash. For an example, see this issue Known Issue ~ While powering up there is a short but bright light flash emitted from the strip.","title":"H801"},{"location":"devices/H801/#hardware","text":"The chip used on this board is the ESP8266EX . 5 PWM outputs are connected to DTU35N06 MOSFETs to drive the 5 output channels (RGB + W1 + W2). Function ESP8266 Pin Channel R GPIO 15 PWM1 G GPIO 13 PWM2 B GPIO 12 PWM3 W1 GPIO 14 PWM4 W2 GPIO 04 PWM5 LED D1(red) GPIO 05 LED D2 (green) GPIO 01","title":"Hardware"},{"location":"devices/H801/#serial-connection","text":"Please see the Hardware Preparation page for general instructions. You need to access the serial interface. The unpopulated serial header (3V3, RX, TX, GND) are available in the middle of the PCB, right next to J3. Note: the RX and TX pins are labelled from the terminal's perspective, not from the perspective of the ESP chip. This means you should connect the RX and TX pins from your computer's UART to the RX and TX pins on the board respectively, not crossing them over! To place the board into flashing mode, you will need to short J3. This can remain shorted while flashing is in progress, but you will need to remove the short in order to boot the Tasmota firmware.","title":"Serial Connection"},{"location":"devices/H801/#first-boot","text":"Most boards supported by the Tasmota firmware use GPIO 1 for serial TX. The H801, as shown in the image above, uses GPIO 2. As the serial RX is still the same as for other boards, it is possible for Tasmota to read from the serial connection but anything written will not be sent to your terminal. Blindly type the following command to set Tasmota to the H801 module type, and it will automatically switch to using GPIO 2 for serial TX allowing setup to proceed: module 20 See #2155 for more details. Please be aware that some of the H801 modules were sold with only 512kB of flash. You can check whether yours is affected by using esptool, with the flash_id command. If you only have 512kB of flash, you can still build your own firmware, but will have to remove components that you do not need, in order to reduce the size of the firmware binary. You will also have to use a linker script for the smaller flash. For an example, see this issue","title":"First Boot"},{"location":"devices/H801/#known-issue","text":"While powering up there is a short but bright light flash emitted from the strip.","title":"Known Issue"},{"location":"devices/Home-Awesome-Breathing-Light-Smart-Plug-Mini-TMRLIFE-%5B2-PACK%5D-WiFi-Smart-Plug/","text":"TMRLife Plug https://smile.amazon.com/gp/product/B0786L8TC1/ref=oh_aui_search_asin_title?ie=UTF8&psc=1 Home Awesome Plug https://smile.amazon.com/gp/product/B07HH29XNS/ref=ppx_yo_dt_b_asin_title_o02__o00_s00?ie=UTF8&psc=1 These are the same device. Easily flashed with OTA GPIO is as follows Io0=pwm1 Io2=pwm2 Io5=pwm3 Io13=button1n Io15=relay1 These make great night lights","title":"Home Awesome Breathing Light Smart Plug Mini TMRLIFE [2 PACK] WiFi Smart Plug"},{"location":"devices/Hompie-SWS1-%28Tuya-TYWE3S%29/","text":"Very cheap outlet with USB-charger functionality (supposed to deliver 2A, have to test this though) and real 16A relay: Winfuture price comparison Device Images 3.3V, GND and GPI00 are accessible on the main board. The used TYWE3S board unfortunately does not have easily reachable solderpads for TX/RX, but I managed to solder with a normal 60W iron between main board and TYWE3S board: Works perfectly with Tasmota 6.2.1 and the same configuration like SM-PW701E Socket Board: TYWE3S","title":"Hompie SWS1 (Tuya TYWE3S)"},{"location":"devices/HuaFan-Smart-Socket/","text":"The Huafan Wi-Fi Wireless Smart Socket/Plug. ~ Introduction ~ The HuaFan Wireless Wifi Smart Plug/Socket is a useful bit of kit that allows you to introduce home automation without getting into any mains re-wiring. As an added bonus, the device also provides energy monitoring functions (voltage, current, power) in much the same way as the Sonoff Pow module does. As you may have guessed, its 'smarts' come from an embedded ESP8266, which makes it a potential target for the excellent sonoff-tasmota code. This guide provides details on how to prepare the socket for the initial flashing with sonoff-tasmota code. What is it? ~ This smart socket comes with its own iPhone/Android App and is controllable from the HF Smart cloud service. As well as allowing on/off control, the plug/socket also measures current, voltage and power. It\u2019s pretty well made but almost certainly doesn\u2019t meet the full British electrical standards, as it doesn\u2019t have a shutter to close off the live socket holes when a plug is removed. This a rather a shame and would not be too tricky to implement and would only marginally increase the cost of these pretty cheap (~\u00a3UK 10) units. The provided software/service all seemed rather closed and proprietary and not able to talk to other stuff. So something had to change! The Name ~ I'm mostly calling this a 'Smart Socket' but it also is called a 'Smart Plug' in some places. As it's got both, I guess both are right. \ufffc Disassembly ~ * WARNING - Opening the unit potentially exposes mains voltages that can kill. You proceed beyond here entirely at your own risk. * * There are no screws; to disassemble you need to prise it open on each side. \ufffcInside there is a main board with most of the components on the reverse. The Wi-Fi and control comes from a small daughter board, soldered to the main board.\ufffc There\u2019s not a lot to see on the top apart from the mains relay, the button and the red/blue LEDs that illuminate it.\ufffc The main item of interest on the top is the daughter board. This has our trusty ESP8266EX and a 8Mbit SPI flash memory. You can also see the 40MHz crystal - more on this later\u2026 \ufffc The reverse of the daughter board is pretty bare - only the Vcc (3.3V) and GND are marked. In this view you can also see the red and blue LEDs and the push button. In its original configuration the red LED normally is set to the same state as the relay and the blue LED provides information on the state of connectivity. Another warning... What is marked as GND IS NOT GROUNDED , it\u2019s not even floating, GND IS CONNECTED TO THE NEUTRAL LINE OF THE MAINS . Do not connect any equipment or yourself to the board whilst it is plugged onto a mains socket - EVEN IF THAT SOCKET APPEARS TO BE SWITCHED OFF. Neutral is not 0V or Ground and should be treated as live (just in case it really is). Always completely disconnect your programming / serial interface before plugging the device into a mains socket. You need a hefty soldering iron to unsolder the board from the plug pins and on the reverse you see the main circuitry. Next door to the AMS1117 3.3V regulator for the ESP is a HLW8012 chip that does the current/voltage/power measurement. Conveniently, this is the same chip that's used in the Sonoff Pow module, so all the code to drive it is already in place. Below the two ICs is R12 it's R002 i.e. a 2mOhm resistor. This may be different to the one in the Sonoff, so expect to use different calibration settings. Hookup ~ Unless you are just curious, there\u2019s no real need to unsolder the main board. You can get at everything you need to re-flash it on the top side of the main board. \ufffc For programming you need to unplug the unit for any mains and make connections to GND, Vcc and Rx. That\u2019s 1, 2 and 4 on the back of the daughter board, counting from the right. The connection for Tx should have been on the back of the daughter board (all the circuit board tracks are in place on the daughter board). However, for some reason they didn\u2019t populate R5 (or removed it after programming) so the Tx signal does not appear on the rear of the board like it was clearly designed to do. Instead you have two options, either re-instate R5 with a very small piece of wire (or a teeny resistor if you have one) or solder a wire directly to the resistor pad/chip pin. As the connection should be temporary (subsequent flashes will be Over the Air) I initially went for the simpler but more fragile direct connection, mechanically secured with some insulating tape. If you do prefer to solder a small wire across R5 then you will need to cut the small links on the main board around pad 5, as the designers of the main board have connected this pad to the GND plane with two small links, one at the end and to the left side of the pad. Again, all this is on the top of the main board, you don\u2019t need to go delving underneath. On the front of the daughter board there is the GPIO0 pin (pad number 4, reading from the left). This needs to be manually connected to ground and then the power applied to the ESP8266 to put it in programming mode. You can solder something onto this, as shown, or pick it up where it connects to the blue LED with a small clip probe. Daughter board pinout ~ Viewed from above the main board Front Back GPIO14 - HLW8012 P pulse 1 |B| 1 0V (marked GND) GPIO12 - HLW8012 I/V pulse 2 |O| 2 3.3V (marked VCC) GPIO13 - HLW8012 I/V select 3 |A| 3 GPIO05 - Relay- GPIO00 - Blue LED- 4 |R| 4 GPIO03 (U0RxD) - Red LED- GPIO04 - Button- 5 |D| 5 Initially GND but ready for GPIO01 (U0TxD) Hookup - Solder Free Option ~ Adding to the great guide above ... So if soldering isn't your bag, there are a few connection points that you can get at with clip probes. There is a +5V and GND contact on the left side of the board and the right LED legs give access to the ESP's GPIO0 and RXD. The tricky bit is the ESP's TXD line which, as stated before, is only accessible on the daughter board via the chip's pin or an smd pad above and to the right. @jwrw, I am in awe of anyone that can solder onto this pad! As an alternative, try connecting an alligator clip to a sewing pin 8) to make a probe and holding it in place with your finger during firmware programming (hey, it only has to work once as from then on you use OTA). Powering via the pcb contacts requires more current than my FTDI was able to source so a seperate 5V power supply is required (a Raspberry Pi can provide the +5V/GND via it's GPIO header if you haven't got a dedicated power supply at hand). Building Firmware ~ The process for building the firmware for the HuaFan is basically the same as for the Sonoff but with a few additional steps. Firstly, make sure that you have installed release 5.5.0 of Tasmota or later and that you have completed all of the standard preparation tasks mentioned in the Wiki. Next, you should ensure that you have installed version 2.4.0-rc1 or later of ESP8266/Arduino core that includes support for the 40MHz crystal used by the HuaFan. Installation instructions can be found here but are essentially as follows: - Start Arduino and open Preferences window. - Swap the existing link for the stable ESP8266/Arduino core release with https://github.com/esp8266/Arduino/releases/download/2.4.0-rc1/package_esp8266com_index.json in Additional Board Manager URLs field.. - Open Boards Manager from Tools > Board menu and update esp8266 platform (check that it is using the RC version). Lastly, you need to edit the boards.txt file to allow selection of the 40MHz Crystal via the Arduino IDE Tools menu. Add the following lines into the section for the \"Generic ESP8266 Module\" and immediately after the \"generic.menu.CpuFrequency\" items: generic.menu.CrystalFreq.26=26 MHz` generic.menu.CrystalFreq.40=40 MHz` generic.menu.CrystalFreq.40.build.extra_flags=-DF_CRYSTAL=40000000","title":"The Huafan Wi-Fi Wireless Smart Socket/Plug."},{"location":"devices/HuaFan-Smart-Socket/#the-huafan-wi-fi-wireless-smart-socketplug","text":"","title":"The Huafan Wi-Fi Wireless Smart Socket/Plug."},{"location":"devices/HuaFan-Smart-Socket/#introduction","text":"The HuaFan Wireless Wifi Smart Plug/Socket is a useful bit of kit that allows you to introduce home automation without getting into any mains re-wiring. As an added bonus, the device also provides energy monitoring functions (voltage, current, power) in much the same way as the Sonoff Pow module does. As you may have guessed, its 'smarts' come from an embedded ESP8266, which makes it a potential target for the excellent sonoff-tasmota code. This guide provides details on how to prepare the socket for the initial flashing with sonoff-tasmota code.","title":"Introduction"},{"location":"devices/HuaFan-Smart-Socket/#what-is-it","text":"This smart socket comes with its own iPhone/Android App and is controllable from the HF Smart cloud service. As well as allowing on/off control, the plug/socket also measures current, voltage and power. It\u2019s pretty well made but almost certainly doesn\u2019t meet the full British electrical standards, as it doesn\u2019t have a shutter to close off the live socket holes when a plug is removed. This a rather a shame and would not be too tricky to implement and would only marginally increase the cost of these pretty cheap (~\u00a3UK 10) units. The provided software/service all seemed rather closed and proprietary and not able to talk to other stuff. So something had to change!","title":"What is it?"},{"location":"devices/HuaFan-Smart-Socket/#the-name","text":"I'm mostly calling this a 'Smart Socket' but it also is called a 'Smart Plug' in some places. As it's got both, I guess both are right. \ufffc","title":"The Name"},{"location":"devices/HuaFan-Smart-Socket/#disassembly","text":"* WARNING - Opening the unit potentially exposes mains voltages that can kill. You proceed beyond here entirely at your own risk. * * There are no screws; to disassemble you need to prise it open on each side. \ufffcInside there is a main board with most of the components on the reverse. The Wi-Fi and control comes from a small daughter board, soldered to the main board.\ufffc There\u2019s not a lot to see on the top apart from the mains relay, the button and the red/blue LEDs that illuminate it.\ufffc The main item of interest on the top is the daughter board. This has our trusty ESP8266EX and a 8Mbit SPI flash memory. You can also see the 40MHz crystal - more on this later\u2026 \ufffc The reverse of the daughter board is pretty bare - only the Vcc (3.3V) and GND are marked. In this view you can also see the red and blue LEDs and the push button. In its original configuration the red LED normally is set to the same state as the relay and the blue LED provides information on the state of connectivity. Another warning... What is marked as GND IS NOT GROUNDED , it\u2019s not even floating, GND IS CONNECTED TO THE NEUTRAL LINE OF THE MAINS . Do not connect any equipment or yourself to the board whilst it is plugged onto a mains socket - EVEN IF THAT SOCKET APPEARS TO BE SWITCHED OFF. Neutral is not 0V or Ground and should be treated as live (just in case it really is). Always completely disconnect your programming / serial interface before plugging the device into a mains socket. You need a hefty soldering iron to unsolder the board from the plug pins and on the reverse you see the main circuitry. Next door to the AMS1117 3.3V regulator for the ESP is a HLW8012 chip that does the current/voltage/power measurement. Conveniently, this is the same chip that's used in the Sonoff Pow module, so all the code to drive it is already in place. Below the two ICs is R12 it's R002 i.e. a 2mOhm resistor. This may be different to the one in the Sonoff, so expect to use different calibration settings.","title":"Disassembly"},{"location":"devices/HuaFan-Smart-Socket/#hookup","text":"Unless you are just curious, there\u2019s no real need to unsolder the main board. You can get at everything you need to re-flash it on the top side of the main board. \ufffc For programming you need to unplug the unit for any mains and make connections to GND, Vcc and Rx. That\u2019s 1, 2 and 4 on the back of the daughter board, counting from the right. The connection for Tx should have been on the back of the daughter board (all the circuit board tracks are in place on the daughter board). However, for some reason they didn\u2019t populate R5 (or removed it after programming) so the Tx signal does not appear on the rear of the board like it was clearly designed to do. Instead you have two options, either re-instate R5 with a very small piece of wire (or a teeny resistor if you have one) or solder a wire directly to the resistor pad/chip pin. As the connection should be temporary (subsequent flashes will be Over the Air) I initially went for the simpler but more fragile direct connection, mechanically secured with some insulating tape. If you do prefer to solder a small wire across R5 then you will need to cut the small links on the main board around pad 5, as the designers of the main board have connected this pad to the GND plane with two small links, one at the end and to the left side of the pad. Again, all this is on the top of the main board, you don\u2019t need to go delving underneath. On the front of the daughter board there is the GPIO0 pin (pad number 4, reading from the left). This needs to be manually connected to ground and then the power applied to the ESP8266 to put it in programming mode. You can solder something onto this, as shown, or pick it up where it connects to the blue LED with a small clip probe.","title":"Hookup"},{"location":"devices/HuaFan-Smart-Socket/#daughter-board-pinout","text":"Viewed from above the main board Front Back GPIO14 - HLW8012 P pulse 1 |B| 1 0V (marked GND) GPIO12 - HLW8012 I/V pulse 2 |O| 2 3.3V (marked VCC) GPIO13 - HLW8012 I/V select 3 |A| 3 GPIO05 - Relay- GPIO00 - Blue LED- 4 |R| 4 GPIO03 (U0RxD) - Red LED- GPIO04 - Button- 5 |D| 5 Initially GND but ready for GPIO01 (U0TxD)","title":"Daughter board pinout"},{"location":"devices/HuaFan-Smart-Socket/#hookup-solder-free-option","text":"Adding to the great guide above ... So if soldering isn't your bag, there are a few connection points that you can get at with clip probes. There is a +5V and GND contact on the left side of the board and the right LED legs give access to the ESP's GPIO0 and RXD. The tricky bit is the ESP's TXD line which, as stated before, is only accessible on the daughter board via the chip's pin or an smd pad above and to the right. @jwrw, I am in awe of anyone that can solder onto this pad! As an alternative, try connecting an alligator clip to a sewing pin 8) to make a probe and holding it in place with your finger during firmware programming (hey, it only has to work once as from then on you use OTA). Powering via the pcb contacts requires more current than my FTDI was able to source so a seperate 5V power supply is required (a Raspberry Pi can provide the +5V/GND via it's GPIO header if you haven't got a dedicated power supply at hand).","title":"Hookup - Solder Free Option"},{"location":"devices/HuaFan-Smart-Socket/#building-firmware","text":"The process for building the firmware for the HuaFan is basically the same as for the Sonoff but with a few additional steps. Firstly, make sure that you have installed release 5.5.0 of Tasmota or later and that you have completed all of the standard preparation tasks mentioned in the Wiki. Next, you should ensure that you have installed version 2.4.0-rc1 or later of ESP8266/Arduino core that includes support for the 40MHz crystal used by the HuaFan. Installation instructions can be found here but are essentially as follows: - Start Arduino and open Preferences window. - Swap the existing link for the stable ESP8266/Arduino core release with https://github.com/esp8266/Arduino/releases/download/2.4.0-rc1/package_esp8266com_index.json in Additional Board Manager URLs field.. - Open Boards Manager from Tools > Board menu and update esp8266 platform (check that it is using the RC version). Lastly, you need to edit the boards.txt file to allow selection of the 40MHz Crystal via the Arduino IDE Tools menu. Add the following lines into the section for the \"Generic ESP8266 Module\" and immediately after the \"generic.menu.CpuFrequency\" items: generic.menu.CrystalFreq.26=26 MHz` generic.menu.CrystalFreq.40=40 MHz` generic.menu.CrystalFreq.40.build.extra_flags=-DF_CRYSTAL=40000000","title":"Building Firmware"},{"location":"devices/Hyleton-313-Smart-Plug/","text":"Intro ~ Recently I bought a very nice and compact Smart Plug (UK variant) from Aliexpress - a Hyleton 313 . This was in fact the smallest smart plug device with UK plug I've ever seen - it is no bigger than an average USB/phone charger: Another good thing is that it is built around a ESP8266 module, which gives us the possibility to change its firmware and install Tasmota. Open the case ~ There are no visible screws, however it is not that difficult to open the case using some sharp plastic or metal pry tool and a heat gun (or hair dryer on max setting also works - hold on each side for about 20-30 seconds). Heat the edge of the plug a bit, then work your way slowly and pry from the middle of side with the button, slowly moving the tool towards the corners. Alternatively if you don't have a heat gun or hair dryer you can use a pry tool or something else thin to slowly \"saw\" away at the middle of the side with the button until you are through (about 2-3mm) . With or without a heat gun/hair drier it can be quite tough - be careful and keep your fingers away from the tool you are using! Once you have got through the layer of adhesive you can lever the case open to dislodge the adhesive on the other sides. Be careful not to accidentally knock off the PCB supports in each corner as these are crucial to safety. Once the case is open, the top side of the PCB will be exposed: The WiFi module is soldered vertically to the main PCB and sits right next to the relay. In order to get access to its pins, remove the screw from the centre of the PCB. After that the bottom plastic plate, which holds the three mains connector prongs, can be moved a bit to the side without desoldering anything (it is attached with short cables to the PCB, but cables' length is just enough to move it out of the way of the WiFi module's pins). Here's a view of the bottom side of the PCB: You can see the product labels (product code, date and board revision), as well as the UL number. WiFi module pins ~ Here is a close-up view of the module's pins as seen from the bottom of the main PCB: And this is how module pins numbers are mapped (I had to desolder the module looking for labels when I tried to identify it): Failed to identify the module, I had remove the metal shielding cap to find the routing of the ESP8266's pins, so I grabbed the multimeter and soon I had the following table: Module pin ESP8266 pin Pin name Pin name ESP8266 pin Module pin 1 7 Chip Enable Tout (ADC) 6 2 3 9 MTMS / GPIO14 MTDI / GPIO12 10 4 5 12 MTCK / GPIO13 MTDO / GPIO15 13 6 7 15 GPIO0 GPIO2 14 8 9 16 GPIO4 GPIO5 24 10 11 25 U0RXD U0TXD 26 12 13 Vdd - - GND 14 Serial Connection ~ For programming you need to solder 4 jumper wires to pins 11 , 12 , 13 and 14 : Pin Function 11 Rx 12 Tx 13 Vdd 14 Ground In this picture Yellow is Tx, Orange is Ground, Grey is Rx and White is Vdd: Connect the other end of the wires to your USB-to-serial adapter and make sure the supply voltage selected is 3.3V. Shorting pin 7 (GPIO0) to ground while plugging the serial adapter into the computer's USB port will bring the module into UART firmware upload mode. See devices/Esptool for details of how to flash the firmware when in firmware upload mode. Once you have flashed the firmware, leave the jumpers soldered to the pins and unplug & reinsert your USB-to-serial adapter - this will reset the unit and provide voltage to the ESP8266 which will then boot the new Tasmota firmware - you'll see a Wifi network called \"sonof-xxxx\" if it has flashed successfully worked (if you do not see the wifi, the flashing process might not have worked correctly and you'll need to try again). If you see the wifi network come up ok, you can de-solder the jumpers and reassemble the unit. Reassembly ~ Screw the PCB back to the housing, and place the PCB back into the other half of the socket. Apply a small 1mm bead of super glue around the edges and firmly clip the two halves back together again, and hold firmly for about 30 seconds to allow the glue to cure. Dangerous Failure Mode To Avoid ~ When reassembling the plug, be extremely careful to ensure that the resistor next to the PCB screw is not leaning towards the earth (top) pin! It is very easy to slightly bend it towards the earth pin when unscrewing. If the resistor is too close to the earth pin, the plastic shield for the earth pin on the upper-half of the case will press the resistor down onto the earth pin and when a plug is inserted it can short-out and trigger a small explosion: This will kill the socket, and maybe you too. Take extreme caution - mains electricity is dangerous. If you cannot neatly clip everything back into place (i.e. the two halves of the shell don't neatly sit together again, or there is a springiness) then you may have caught the resistor. If you accidentally broke off the PCB standoffs when opening the case, this is harder to detect (as the PCB may be pushed further down than usual) so be especially careful. Double & triple check. If you've done everything right you should have a fairly clean looking plug still with just a small amount of cosmetic scratches on the bottom side of the unit where you used the pry tool. Configuration ~ Enroll your plug back onto your wifi as usual for Tasmota (i.e. join the wifi network started by the plug, give it your wifi details, then restart it). Once Tasmota 's WebUI configuration interface is loaded in the browser, you need to configure the template type: Go to \"Configuration\" Go to \"Configure template\" Create a new template that looks like this one and save it: Once you have saved the template: Wait for the device to restart Go to \"Configuration\" Go to \"Configure module\" Select the new template you just created and save. Note on LEDs ~ Sonoff devices usually have a bi-colour LED, but just one of the colours can be controlled directly. The other colour is usually tied together with the relay, so it cannot be controlled independently. I think that is the reason why the Tasmota firmware by default controls just Led1 when a single relay is configured. In the configuration above, only the blue LED will be used (tied to GPIO2 ). But if you prefer the red LED, just change the values for Led1i and Led2i (select Led1i for GPIO0 and Led2i for GPIO2 ). Additional Details ~ If you want to read a detailed project log that uses this plug, you can do so at GitHub Blog page , although some of the information is now out of date.","title":"Hyleton 313 Smart Plug"},{"location":"devices/Hyleton-313-Smart-Plug/#intro","text":"Recently I bought a very nice and compact Smart Plug (UK variant) from Aliexpress - a Hyleton 313 . This was in fact the smallest smart plug device with UK plug I've ever seen - it is no bigger than an average USB/phone charger: Another good thing is that it is built around a ESP8266 module, which gives us the possibility to change its firmware and install Tasmota.","title":"Intro"},{"location":"devices/Hyleton-313-Smart-Plug/#open-the-case","text":"There are no visible screws, however it is not that difficult to open the case using some sharp plastic or metal pry tool and a heat gun (or hair dryer on max setting also works - hold on each side for about 20-30 seconds). Heat the edge of the plug a bit, then work your way slowly and pry from the middle of side with the button, slowly moving the tool towards the corners. Alternatively if you don't have a heat gun or hair dryer you can use a pry tool or something else thin to slowly \"saw\" away at the middle of the side with the button until you are through (about 2-3mm) . With or without a heat gun/hair drier it can be quite tough - be careful and keep your fingers away from the tool you are using! Once you have got through the layer of adhesive you can lever the case open to dislodge the adhesive on the other sides. Be careful not to accidentally knock off the PCB supports in each corner as these are crucial to safety. Once the case is open, the top side of the PCB will be exposed: The WiFi module is soldered vertically to the main PCB and sits right next to the relay. In order to get access to its pins, remove the screw from the centre of the PCB. After that the bottom plastic plate, which holds the three mains connector prongs, can be moved a bit to the side without desoldering anything (it is attached with short cables to the PCB, but cables' length is just enough to move it out of the way of the WiFi module's pins). Here's a view of the bottom side of the PCB: You can see the product labels (product code, date and board revision), as well as the UL number.","title":"Open the case"},{"location":"devices/Hyleton-313-Smart-Plug/#wifi-module-pins","text":"Here is a close-up view of the module's pins as seen from the bottom of the main PCB: And this is how module pins numbers are mapped (I had to desolder the module looking for labels when I tried to identify it): Failed to identify the module, I had remove the metal shielding cap to find the routing of the ESP8266's pins, so I grabbed the multimeter and soon I had the following table: Module pin ESP8266 pin Pin name Pin name ESP8266 pin Module pin 1 7 Chip Enable Tout (ADC) 6 2 3 9 MTMS / GPIO14 MTDI / GPIO12 10 4 5 12 MTCK / GPIO13 MTDO / GPIO15 13 6 7 15 GPIO0 GPIO2 14 8 9 16 GPIO4 GPIO5 24 10 11 25 U0RXD U0TXD 26 12 13 Vdd - - GND 14","title":"WiFi module pins"},{"location":"devices/Hyleton-313-Smart-Plug/#serial-connection","text":"For programming you need to solder 4 jumper wires to pins 11 , 12 , 13 and 14 : Pin Function 11 Rx 12 Tx 13 Vdd 14 Ground In this picture Yellow is Tx, Orange is Ground, Grey is Rx and White is Vdd: Connect the other end of the wires to your USB-to-serial adapter and make sure the supply voltage selected is 3.3V. Shorting pin 7 (GPIO0) to ground while plugging the serial adapter into the computer's USB port will bring the module into UART firmware upload mode. See devices/Esptool for details of how to flash the firmware when in firmware upload mode. Once you have flashed the firmware, leave the jumpers soldered to the pins and unplug & reinsert your USB-to-serial adapter - this will reset the unit and provide voltage to the ESP8266 which will then boot the new Tasmota firmware - you'll see a Wifi network called \"sonof-xxxx\" if it has flashed successfully worked (if you do not see the wifi, the flashing process might not have worked correctly and you'll need to try again). If you see the wifi network come up ok, you can de-solder the jumpers and reassemble the unit.","title":"Serial Connection"},{"location":"devices/Hyleton-313-Smart-Plug/#reassembly","text":"Screw the PCB back to the housing, and place the PCB back into the other half of the socket. Apply a small 1mm bead of super glue around the edges and firmly clip the two halves back together again, and hold firmly for about 30 seconds to allow the glue to cure.","title":"Reassembly"},{"location":"devices/Hyleton-313-Smart-Plug/#dangerous-failure-mode-to-avoid","text":"When reassembling the plug, be extremely careful to ensure that the resistor next to the PCB screw is not leaning towards the earth (top) pin! It is very easy to slightly bend it towards the earth pin when unscrewing. If the resistor is too close to the earth pin, the plastic shield for the earth pin on the upper-half of the case will press the resistor down onto the earth pin and when a plug is inserted it can short-out and trigger a small explosion: This will kill the socket, and maybe you too. Take extreme caution - mains electricity is dangerous. If you cannot neatly clip everything back into place (i.e. the two halves of the shell don't neatly sit together again, or there is a springiness) then you may have caught the resistor. If you accidentally broke off the PCB standoffs when opening the case, this is harder to detect (as the PCB may be pushed further down than usual) so be especially careful. Double & triple check. If you've done everything right you should have a fairly clean looking plug still with just a small amount of cosmetic scratches on the bottom side of the unit where you used the pry tool.","title":"Dangerous Failure Mode To Avoid"},{"location":"devices/Hyleton-313-Smart-Plug/#configuration","text":"Enroll your plug back onto your wifi as usual for Tasmota (i.e. join the wifi network started by the plug, give it your wifi details, then restart it). Once Tasmota 's WebUI configuration interface is loaded in the browser, you need to configure the template type: Go to \"Configuration\" Go to \"Configure template\" Create a new template that looks like this one and save it: Once you have saved the template: Wait for the device to restart Go to \"Configuration\" Go to \"Configure module\" Select the new template you just created and save.","title":"Configuration"},{"location":"devices/Hyleton-313-Smart-Plug/#note-on-leds","text":"Sonoff devices usually have a bi-colour LED, but just one of the colours can be controlled directly. The other colour is usually tied together with the relay, so it cannot be controlled independently. I think that is the reason why the Tasmota firmware by default controls just Led1 when a single relay is configured. In the configuration above, only the blue LED will be used (tied to GPIO2 ). But if you prefer the red LED, just change the values for Led1i and Led2i (select Led1i for GPIO0 and Led2i for GPIO2 ).","title":"Note on LEDs"},{"location":"devices/Hyleton-313-Smart-Plug/#additional-details","text":"If you want to read a detailed project log that uses this plug, you can do so at GitHub Blog page , although some of the information is now out of date.","title":"Additional Details"},{"location":"devices/KMC-70008-light-switch/","text":"Shopping Depending on the version of the firmware shipped on the device, you may be able to flash it using the Tuya-Convert OTA flashing tool . This tutorial shows how that tool works. If the OTA flash method does not work, you will have to solder leads to flash the device. Except for GPIO0, the programming pins are not broken out on the PCB. The module has the usual ESP-12 pin layout, so carefully solder right to the chip's pins. The device button is connected to GPIO0. You do not need to solder onto GPIO0. Just hold the button down when booting the device to get it into flash mode. Once you get the device flashed, set up the Wi-Fi configuration and connect to the device using a browser using its IP address. To keep the device from constantly rebooting, the first configuration step you should perform is to set the module type to Generic (18). Configuration: * Digiblur's Tasmota forked firmware * Generic (18) * GPIO0: Button1 * GPIO13: Led1i * GPIO14: Relay1 When the blue LED on GPIO 13 is set to LED1i the white light shines when the relay is off and the blue light illuminates then the relay is on. Further configuration and setup may be required as the blue LED constantly flashes.","title":"KMC 70008 light switch"},{"location":"devices/KS-602S-Switch/","text":"These Wi-Fi Smart Light Switches are essentially a sonoff basic in a decora wall switch. GPIO Map ~ GPIO 0 - Button1 - Button GPIO 12 - Relay1 - Red LED and Relay GPIO 13 - Led1 (not Led1i like the Sonoff Basic) Green LED * As of May 2019 there may be a modified version. This is the pinout. * * GPIO 0 - Button1 - Button * GPIO 14 - Relay1 - Relay * GPIO 16 - Led1/Led1i - Red LED * I couldn't find the green LED but it exists. Product Links ~ Amazon Link of KULED Branded Switches Unboxing ~ Some revisions of the switch have the header marked GND, RXD, TXD, 3V3. Some revisions do not. It has been reported that some boxes have mixed revisions. If you are ever in doubt, double check with a meter to determine your pins. Flashing process and hardware revision without the labels can be seen on the following video link . RXD is connected to Transmit on your programmer TXD is connected to Receive on your programmer Ground and 3.3vdc to power unit during flash. You do not need to solder a header to flash the board, an empty 4 pin header connected to 4 dupont jumper wires held into the empty header location works fine with a little pressure to ensure connectivity. Hold the button(GPIO0) and plug in programmer. Device works perfectly as a Sonoff Basic but the LED will be backwards as designed. The Red LED is hardwired to the relay and the green is controllable over GPIO pins. If you wish to change the functionality to have the green LED when the device is off, you can utilize or change the template to a generic device type and map the suggested names except you will choose Led1 instead of Led1i.","title":"KS 602S Switch"},{"location":"devices/KS-602S-Switch/#gpio-map","text":"GPIO 0 - Button1 - Button GPIO 12 - Relay1 - Red LED and Relay GPIO 13 - Led1 (not Led1i like the Sonoff Basic) Green LED * As of May 2019 there may be a modified version. This is the pinout. * * GPIO 0 - Button1 - Button * GPIO 14 - Relay1 - Relay * GPIO 16 - Led1/Led1i - Red LED * I couldn't find the green LED but it exists.","title":"GPIO Map"},{"location":"devices/KS-602S-Switch/#product-links","text":"Amazon Link of KULED Branded Switches","title":"Product Links"},{"location":"devices/KS-602S-Switch/#unboxing","text":"Some revisions of the switch have the header marked GND, RXD, TXD, 3V3. Some revisions do not. It has been reported that some boxes have mixed revisions. If you are ever in doubt, double check with a meter to determine your pins. Flashing process and hardware revision without the labels can be seen on the following video link . RXD is connected to Transmit on your programmer TXD is connected to Receive on your programmer Ground and 3.3vdc to power unit during flash. You do not need to solder a header to flash the board, an empty 4 pin header connected to 4 dupont jumper wires held into the empty header location works fine with a little pressure to ensure connectivity. Hold the button(GPIO0) and plug in programmer. Device works perfectly as a Sonoff Basic but the LED will be backwards as designed. The Red LED is hardwired to the relay and the green is controllable over GPIO pins. If you wish to change the functionality to have the green LED when the device is off, you can utilize or change the template to a generic device type and map the suggested names except you will choose Led1 instead of Led1i.","title":"Unboxing"},{"location":"devices/Kesen-KS-604S/","text":"This Tuya Wi-Fi module ESP8266 based device has a really attractive form factor and functionality (in-wall, single gang, dual outlet, USB port, each individually controllable). This device can be most easily flashed using using Tuya-Convert . Others have reported that flashing this device by attaching leads to the serial interface requires disassembling and unsoldering the internal AC components to get access to the needed contacts, however an AliBaba device was successfully flashed by connecting to the four terminals at the bottom of the back circuit board (3v3, Tx, Rx, G) and connecting pin D3 in block J7 to ground while booting and during the flashing process. Shopping ~ Ali Express Amazon Alibaba (10 minimum) Configuration ~ It appears that there are different versions of the KS-604S. The device that @DavinKD flashed (likely purchased from Amazon in early to mid March 2019) has a different GPIO configuration than devices purchased from Alibaba in late March. Rear Amazon Device ~ {\"NAME\":\"KS-604S\",\"GPIO\":[255,255,56,255,255,17,255,255,22,21,255,255,18],\"FLAG\":1,\"BASE\":18} GPIO Function Configuration 2 Device Status (Green) LED1i (56) 5 Top Button Button1 (17) 12 Bottom Receptacle Relay2 (22) 13 Top Receptacle Relay1 (21) 16 Bottom Button Button2 (18) The USB port on this variant is not switchable. Alibaba Device ~ {\"NAME\":\"KS-604S\",\"GPIO\":[158,255,255,17,56,18,255,255,22,21,57,23,255],\"FLAG\":0,\"BASE\":18} GPIO Function Configuration 0 Device Status (Green) LEDLinki (158) 3 Top Button Button1 (17) 4 Top LED (Orange) LED1i (56) 5 Bottom Button Button2 (18) 12 Bottom Receptacle Relay2 (22) 13 Top Receptacle Relay1 (21) 14 Bottom LED (Orange) LED2i (57) 15 USB Port Relay3 (23) This configuration requires the LedLinki Component (introduced in 6.5.0.12) to associate the GPIO to the status LED indicator. In order for the LED power indicators to follow the state of each receptacle relay, LedState must be set to show the power state on the LEDs. Select the desired power on state for the device's relays using PowerOnState and/or a System#Boot triggered rule. This device also requires SetOption63 (introduced in 6.5.0.9) in order to disable relay power feedback state scanning at restart. The following Console statements define the necessary settings and rules as described above. Backlog SerialLog 0; PowerOnState 0; SetOption63 1; LEDState 1 Rule1 ON System#Boot DO Power3 On ENDON # Turn the USB port on Rule1 1","title":"Kesen KS 604S"},{"location":"devices/Kesen-KS-604S/#shopping","text":"Ali Express Amazon Alibaba (10 minimum)","title":"Shopping"},{"location":"devices/Kesen-KS-604S/#configuration","text":"It appears that there are different versions of the KS-604S. The device that @DavinKD flashed (likely purchased from Amazon in early to mid March 2019) has a different GPIO configuration than devices purchased from Alibaba in late March. Rear","title":"Configuration"},{"location":"devices/Kesen-KS-604S/#amazon-device","text":"{\"NAME\":\"KS-604S\",\"GPIO\":[255,255,56,255,255,17,255,255,22,21,255,255,18],\"FLAG\":1,\"BASE\":18} GPIO Function Configuration 2 Device Status (Green) LED1i (56) 5 Top Button Button1 (17) 12 Bottom Receptacle Relay2 (22) 13 Top Receptacle Relay1 (21) 16 Bottom Button Button2 (18) The USB port on this variant is not switchable.","title":"Amazon Device"},{"location":"devices/Kesen-KS-604S/#alibaba-device","text":"{\"NAME\":\"KS-604S\",\"GPIO\":[158,255,255,17,56,18,255,255,22,21,57,23,255],\"FLAG\":0,\"BASE\":18} GPIO Function Configuration 0 Device Status (Green) LEDLinki (158) 3 Top Button Button1 (17) 4 Top LED (Orange) LED1i (56) 5 Bottom Button Button2 (18) 12 Bottom Receptacle Relay2 (22) 13 Top Receptacle Relay1 (21) 14 Bottom LED (Orange) LED2i (57) 15 USB Port Relay3 (23) This configuration requires the LedLinki Component (introduced in 6.5.0.12) to associate the GPIO to the status LED indicator. In order for the LED power indicators to follow the state of each receptacle relay, LedState must be set to show the power state on the LEDs. Select the desired power on state for the device's relays using PowerOnState and/or a System#Boot triggered rule. This device also requires SetOption63 (introduced in 6.5.0.9) in order to disable relay power feedback state scanning at restart. The following Console statements define the necessary settings and rules as described above. Backlog SerialLog 0; PowerOnState 0; SetOption63 1; LEDState 1 Rule1 ON System#Boot DO Power3 On ENDON # Turn the USB port on Rule1 1","title":"Alibaba Device"},{"location":"devices/KingArt/","text":"KingArt-N1 - Touch Light Light Switch ~ This is a relatively cheap Premium glass fronted touch panel, looks clean and minimal when installed too. Table Of Contents: * Device Features * * Breakdown * * Capacitive Touch IC * Re-Programming * * Tools * * Setup * * Programming Mode * Reference Device Features ~ ESP8285 micro Blue status LED (micro controlled) Separate touch IC controlled switch status indicators (blue and red) Confirmed 10A/250VAC mains relay -- Image: The 1 Gang Touch Panel, featuring the glass front (protective plastic film still on) Breakdown ~ Whats in the package... This looks like a reasonably simple setup. Removing the front glass panel you have access to the main control PCB. This holds the ESP8285 micro-controller and accompanying guff. I've worked through mapping most of the pins of interest - notes are in the images below. The control board runs off a 5V fed from the Power-Relay board at the read of the unit - a 3v3 reg is the control board for all the logic. The back of the control board has the touch controller and the 8way header to the Power-Relay board. There are only touch pads on the back of the control board as a means to interface with the microcontroller. There is no SonOff type programming header arrangement. , see Re-Programming . Control and Interface PCB Sorry for the horrible pics.. will replace Some Application-Interesting Pin Allocations *Trace for the King Art Switch with 2 (Touch-)Button is confirmed - works well with this Parameters The Power-Relay board is reasonably simple as well. This board, being a 1-gang switch, only has a single relay - but the PCB is set out for 3 (again, see images for trace and pin notes ). Power-Relay PCB Capacitive Touch IC ~ This board uses a dedicated capacitive touch control IC. Something interesting, that this IC manages touch switching as well a red and blue touch status LEDs for each of the touch pads that it services as the buttons. The IC illuminates a diffuser block over a 'button', indicating: * Blue : when Idle - button state is 'OFF' * Red+Blue : when Active - button state is 'ON' The TW8001 is also linked to a red error indicator led on the front of the Control Board - it is co-located above the EPS8285 microcontroller's Blue status indicator. This appears to be used by the Touch IC to indicate its own state information * eg, if the touch is held for +30s the touch shows an error state (red LED) and resets - useful if you replace the front panel and it needs to recalibrate. With regard to interfacing with the microcontroller, this device seems function with GPIO-friendly pin state for the capacitive button state reporting. Here is the only information I have been able to find on this device at the time of this investigation : TechWave - TW8001 . It does have much (or: any) in way of public datasheets. If anyone finds a datasheet please link it here! Re-Programming ~ Tools ~ You shall need something in way of the following: (or whatever works for you, this is just my setup) * A USB-TTL adapter (TTL, 3V3.. something also with a 3V3 source) * Some leads * A soldering iron (solder, bits.. etc) - I'm going to assume you know how/what to do with this. Setup ~ (This is my setup) USB-TTL | Lead | Board 3V3 Red 3v3 TXD White RX RXD Grey TX GND Black GND NNB : DO NOT USE or CONNECT THE 5V ever.. Programming Mode ~ Before you can program the board you have to start the ESP8285 micro in Programming Mode. This is important. Remember we soldered the blue lead to the board at (SW) - you will use this to force the micro to the required mode on startup. (you can only do this on startup) Entering Programming Mode: * Remove power from the board * Short the blue lead (SW) to ground (use a ground pad on the board or on your programmer) * NOW: Apply power. You can remove the short to ground after a second or two. So, Are we in Programming Mode? ... Test Failed - try again If the board has its factory firmware installed still it usually flashes the status LED on startup.. (ie: not in programming mode) Test Success If you have successfully put the micro into programming mode the ONLY the blue status illumination of the touch pad will be ON. -> Now you can access and upload to the device using your preferred tool (Atom IDE, ESPtool, Arduino.. etc) Remember that the flashing mode MUST BE DOUT as it is for ALL devices on which Tasmota is flashed! Reference ~ https://github.com/EphemeralPersistence/Sonoff-Tasmota/wiki","title":"KingArt-N1 - Touch Light Light Switch"},{"location":"devices/KingArt/#kingart-n1-touch-light-light-switch","text":"This is a relatively cheap Premium glass fronted touch panel, looks clean and minimal when installed too. Table Of Contents: * Device Features * * Breakdown * * Capacitive Touch IC * Re-Programming * * Tools * * Setup * * Programming Mode * Reference","title":"KingArt-N1 - Touch Light Light Switch"},{"location":"devices/KingArt/#device-features","text":"ESP8285 micro Blue status LED (micro controlled) Separate touch IC controlled switch status indicators (blue and red) Confirmed 10A/250VAC mains relay -- Image: The 1 Gang Touch Panel, featuring the glass front (protective plastic film still on)","title":"Device Features"},{"location":"devices/KingArt/#breakdown","text":"Whats in the package... This looks like a reasonably simple setup. Removing the front glass panel you have access to the main control PCB. This holds the ESP8285 micro-controller and accompanying guff. I've worked through mapping most of the pins of interest - notes are in the images below. The control board runs off a 5V fed from the Power-Relay board at the read of the unit - a 3v3 reg is the control board for all the logic. The back of the control board has the touch controller and the 8way header to the Power-Relay board. There are only touch pads on the back of the control board as a means to interface with the microcontroller. There is no SonOff type programming header arrangement. , see Re-Programming . Control and Interface PCB Sorry for the horrible pics.. will replace Some Application-Interesting Pin Allocations *Trace for the King Art Switch with 2 (Touch-)Button is confirmed - works well with this Parameters The Power-Relay board is reasonably simple as well. This board, being a 1-gang switch, only has a single relay - but the PCB is set out for 3 (again, see images for trace and pin notes ). Power-Relay PCB","title":"Breakdown"},{"location":"devices/KingArt/#capacitive-touch-ic","text":"This board uses a dedicated capacitive touch control IC. Something interesting, that this IC manages touch switching as well a red and blue touch status LEDs for each of the touch pads that it services as the buttons. The IC illuminates a diffuser block over a 'button', indicating: * Blue : when Idle - button state is 'OFF' * Red+Blue : when Active - button state is 'ON' The TW8001 is also linked to a red error indicator led on the front of the Control Board - it is co-located above the EPS8285 microcontroller's Blue status indicator. This appears to be used by the Touch IC to indicate its own state information * eg, if the touch is held for +30s the touch shows an error state (red LED) and resets - useful if you replace the front panel and it needs to recalibrate. With regard to interfacing with the microcontroller, this device seems function with GPIO-friendly pin state for the capacitive button state reporting. Here is the only information I have been able to find on this device at the time of this investigation : TechWave - TW8001 . It does have much (or: any) in way of public datasheets. If anyone finds a datasheet please link it here!","title":"Capacitive Touch IC"},{"location":"devices/KingArt/#re-programming","text":"","title":"Re-Programming"},{"location":"devices/KingArt/#tools","text":"You shall need something in way of the following: (or whatever works for you, this is just my setup) * A USB-TTL adapter (TTL, 3V3.. something also with a 3V3 source) * Some leads * A soldering iron (solder, bits.. etc) - I'm going to assume you know how/what to do with this.","title":"Tools"},{"location":"devices/KingArt/#setup","text":"(This is my setup) USB-TTL | Lead | Board 3V3 Red 3v3 TXD White RX RXD Grey TX GND Black GND NNB : DO NOT USE or CONNECT THE 5V ever..","title":"Setup"},{"location":"devices/KingArt/#programming-mode","text":"Before you can program the board you have to start the ESP8285 micro in Programming Mode. This is important. Remember we soldered the blue lead to the board at (SW) - you will use this to force the micro to the required mode on startup. (you can only do this on startup) Entering Programming Mode: * Remove power from the board * Short the blue lead (SW) to ground (use a ground pad on the board or on your programmer) * NOW: Apply power. You can remove the short to ground after a second or two.","title":"Programming Mode"},{"location":"devices/KingArt/#reference","text":"https://github.com/EphemeralPersistence/Sonoff-Tasmota/wiki","title":"Reference"},{"location":"devices/KingArts-touch-Dimmer-%281-gang%29/","text":"On AliExpress you can buy a wifi dimmer for mains voltage (110 or 220V) It's a brandles dimmer, but can be found here: AliExpress page It comes in a couple of forms, but sinds I live in Holland, I chose the EU style, single gang, 220V, White edition. It has a glass front plate with 3 proximity/touch switches (On/Off, dimm up & dimm down) and a wifi indicator LED. The inside houses 2 PCB's; a power board and a control board: The control board: There are two main chips on board: An ESP8266 and a Nuvoton n76e003at20 The Nuvoton will do the switch side of it all, the ESP communication. The mains board: For flashing, we only need the control board. Solder small wires to the pads as marked on the picture: 3.3V GND RX TX Sw (gpio0) Solder 'Res1' to GND Note that the silkscreen on this board has TX and RX wrong. Now use a USB to serial adapter to connect the wires. Use a 3.3V board, NOT 5V, this will destroy the ESP chip on the board! Connect: GND to GND 3.3V to 3.3V RX to RX (due to the fact the silkscreen is wrong, otherwise, RX connects to TX and vice versa) TX to TX SW to GND -- only durning power up, to put the ESP in programming mode. From here the upload is the same as for all other Tasmota devices. See the upload page for detailed info. After the upload was successful, unplug the device from the serial adapter. You can now desolder all the connections you have made earlier. Also remove the wire between RES1 and GND. Then plug the board back in its housing. Be careful with the connector on the underside of the board. Line up the pins with te header and lightly press it in its place. Connecting to mains installation: ~ WARNING! THIS PROJECT INVOLVES WORKING WITH HIGH VOLTAGE AND YOU COULD KILL YOURSELF AND/OR SET YOUR HOUSE ON FIRE. Connect your light to the dimmer according the manual. Keep in mind, the dimmer itself needs a Neutral wire as well. If you replace an existing switch or dimmer, it can be that you need to run an extra neutral wire. First connection ~ When you first power up the dimmer switch, it comes up in AccesPoint mode. Follow the instructions here Set correct module type ~ Once you have all connected, you should go to the configuration page of the Tasmota Dimmer. Go to your browser and fill in the IP address. Then go to 'Configuration' and then to 'Configure Module'. From the drop down menu select module 58: PS-16-DZ. Then hit Save. The module will restart and you are done! You can now toggle the light and use the slider to dimm the lights from the tasmota webpage. Or better, use your favorite domotica software to control it via MQTT.","title":"KingArts touch Dimmer (1 gang)"},{"location":"devices/KingArts-touch-Dimmer-%281-gang%29/#connecting-to-mains-installation","text":"WARNING! THIS PROJECT INVOLVES WORKING WITH HIGH VOLTAGE AND YOU COULD KILL YOURSELF AND/OR SET YOUR HOUSE ON FIRE. Connect your light to the dimmer according the manual. Keep in mind, the dimmer itself needs a Neutral wire as well. If you replace an existing switch or dimmer, it can be that you need to run an extra neutral wire.","title":"Connecting to mains installation:"},{"location":"devices/KingArts-touch-Dimmer-%281-gang%29/#first-connection","text":"When you first power up the dimmer switch, it comes up in AccesPoint mode. Follow the instructions here","title":"First connection"},{"location":"devices/KingArts-touch-Dimmer-%281-gang%29/#set-correct-module-type","text":"Once you have all connected, you should go to the configuration page of the Tasmota Dimmer. Go to your browser and fill in the IP address. Then go to 'Configuration' and then to 'Configure Module'. From the drop down menu select module 58: PS-16-DZ. Then hit Save. The module will restart and you are done! You can now toggle the light and use the slider to dimm the lights from the tasmota webpage. Or better, use your favorite domotica software to control it via MQTT.","title":"Set correct module type"},{"location":"devices/Kohree-VHP560-Smart-Light-Compatible%2C-RGBCW-Wi-Fi-LED-Bulb-A19/","text":"Kohree VHP560 Smart Light - A19 RGBCW Wi-Fi LED Bulb Easily flashed OTA using Tuya-Convert (OTA flashable as of Sept. 29, 2019, recent purchase). GPIO4 = PWM1 GPIO5 = PWM5 GPIO12 = PWM2 GPIO13 = PWM4 GPIO14 = PWM3","title":"Kohree VHP560 Smart Light Compatible, RGBCW Wi Fi LED Bulb A19"},{"location":"devices/LC-Technology-WiFi-Relay/","text":"LC Technology WiFi Relay - Single Relay ~ The LC Technology relay devices use GPIO1 and GPIO3 for the serial communications used to control the relays. You do not need to specify these in the template. SerialSend uses these standard serial communications GPIO by default. In order to use LC Technology WiFi Relay for 1 relay version: * Set module to Generic (18) (in module configuration and click save) * Set D3 GPIO0 as Relay1 (21) (in module configuration and click save) * Disable SerialLog (type seriallog 0 in the Tasmota console) * Add the following rules typing in the console: Rule1 on System#Boot do Backlog Baudrate 9600; SerialSend5 0 endon on Power1#State=1 do SerialSend5 A00101A2 endon on Power1#State=0 do SerialSend5 A00100A1 endon * Enable the rule (type rule1 1 in the Tasmota console) * Note: If you use LC Technology v1.2 and this rule does not work, try to use 115200 baudrate * Note: If that doesn't work for you, you may find that using Power1#Boot as the event to trigger the baud rate setting (instead of System#Boot ) works, as it did for me. So the alternate rule is: on Power1#Boot do Backlog Baudrate 9600; SerialSend5 0 endon on Power1#State=1 do SerialSend5 A00101A2 endon on Power1#State=0 do SerialSend5 A00100A1 endon LC Technology WiFi Relay - Dual Relay (note, older versions of this board used a baud rate of 9600, so if 115200 doesn't work, try 9600) ~ To configure an LC Technology ESP8266 Relay X2, use the following settings... Set module to Generic (in module configuration and click save) Set GPIO0 and GPIO2 as Relay1 and Relay 2 (in module configuration and click save) Disable SerialLog (type seriallog 0 in the Tasmota console) Add the following rules typing in the Tasmota console: Rule1 on System#Boot do Backlog Baudrate 9600; SerialSend5 0 endon on Power1#State=1 do SerialSend5 A00101A2 endon on Power1#State=0 do SerialSend5 A00100A1 endon on Power2#State=1 do SerialSend5 A00201A3 endon on Power2#State=0 do SerialSend5 A00200A2 endon Enable the rule (type rule1 1 in the Tasmota console) LC Technology WiFi Relay - Quad Relay (note, older versions of this board used a baud rate of 9600, so if 115200 doesn't work, try 9600) ~ Note: The template provided below did not work on an ESP-01 running Tasmota 8.1.0. It was necessary to manually enter the template in the Configure Template menu. In configuration open Configure Other paste this template and select activate {\"NAME\":\"LC Technology 4CH Relay\",\"GPIO\":[52,255,17,255,255,255,255,255,21,22,23,24,255],\"FLAG\":0,\"BASE\":18} Open Configure Module and set GPIO0, GPIO2, GPIO4 and GPIO5 as Relay1, Relay2, Relay3 and Relay4. Click Save. Disable SerialLog (type seriallog 0 in the Tasmota console) Enter this command in console (configure the 1st rule) Rule1 on System#Boot do Backlog Baudrate 9600; SerialSend5 0 endon on Power1#State=1 do SerialSend5 A00101A2 endon on Power1#State=0 do SerialSend5 A00100A1 endon on Power2#State=1 do SerialSend5 A00201A3 endon on Power2#State=0 do SerialSend5 A00200A2 endon on Power3#State=1 do SerialSend5 A00301A4 endon on Power3#State=0 do SerialSend5 A00300A3 endon on Power4#State=1 do SerialSend5 A00401A5 endon on Power4#State=0 do SerialSend5 A00400A4 endon Enable the rule (type rule1 1 in the Tasmota console) Beware of counterfeit modules ~ If your board just continuously flashes its led when powered on and no esp-01 is entered, the onboard STC15F104W needs to be programmed! For more details ( link ) Additionally, once programmed, you may also have to remove r4. Some issues exist where r3 and r4 are swapped, but just removing r4 works. Easier hardware fix ~ This is an easier fix for the ESP-01S relay v1.0 board, which does not require pcb cuts or resistor desoldering, just a 10K resistor soldered as in image: this mod prevents the relay flicker, and connects ch_pd, too How to use with up to 12V power supply ~ LC Technology WiFi Relay use CJT1117B linear regulator which support input power up to 12V. It is ok for ESP-01 and N76E003, but not for relay. Relay connected without any voltage regulator to input power directly. The easier way to replace existing relay. Part number for 12V relay is SRD-12VDC-SLC. You can use similar analogs for 6V and 9V.","title":"LC Technology WiFi Relay"},{"location":"devices/LC-Technology-WiFi-Relay/#lc-technology-wifi-relay-single-relay","text":"The LC Technology relay devices use GPIO1 and GPIO3 for the serial communications used to control the relays. You do not need to specify these in the template. SerialSend uses these standard serial communications GPIO by default. In order to use LC Technology WiFi Relay for 1 relay version: * Set module to Generic (18) (in module configuration and click save) * Set D3 GPIO0 as Relay1 (21) (in module configuration and click save) * Disable SerialLog (type seriallog 0 in the Tasmota console) * Add the following rules typing in the console: Rule1 on System#Boot do Backlog Baudrate 9600; SerialSend5 0 endon on Power1#State=1 do SerialSend5 A00101A2 endon on Power1#State=0 do SerialSend5 A00100A1 endon * Enable the rule (type rule1 1 in the Tasmota console) * Note: If you use LC Technology v1.2 and this rule does not work, try to use 115200 baudrate * Note: If that doesn't work for you, you may find that using Power1#Boot as the event to trigger the baud rate setting (instead of System#Boot ) works, as it did for me. So the alternate rule is: on Power1#Boot do Backlog Baudrate 9600; SerialSend5 0 endon on Power1#State=1 do SerialSend5 A00101A2 endon on Power1#State=0 do SerialSend5 A00100A1 endon","title":"LC Technology WiFi Relay - Single Relay"},{"location":"devices/LC-Technology-WiFi-Relay/#lc-technology-wifi-relay-dual-relay-note-older-versions-of-this-board-used-a-baud-rate-of-9600-so-if-115200-doesnt-work-try-9600","text":"To configure an LC Technology ESP8266 Relay X2, use the following settings... Set module to Generic (in module configuration and click save) Set GPIO0 and GPIO2 as Relay1 and Relay 2 (in module configuration and click save) Disable SerialLog (type seriallog 0 in the Tasmota console) Add the following rules typing in the Tasmota console: Rule1 on System#Boot do Backlog Baudrate 9600; SerialSend5 0 endon on Power1#State=1 do SerialSend5 A00101A2 endon on Power1#State=0 do SerialSend5 A00100A1 endon on Power2#State=1 do SerialSend5 A00201A3 endon on Power2#State=0 do SerialSend5 A00200A2 endon Enable the rule (type rule1 1 in the Tasmota console)","title":"LC Technology WiFi Relay - Dual Relay (note, older versions of this board used a baud rate of 9600, so if 115200 doesn't work, try 9600)"},{"location":"devices/LC-Technology-WiFi-Relay/#lc-technology-wifi-relay-quad-relay-note-older-versions-of-this-board-used-a-baud-rate-of-9600-so-if-115200-doesnt-work-try-9600","text":"Note: The template provided below did not work on an ESP-01 running Tasmota 8.1.0. It was necessary to manually enter the template in the Configure Template menu. In configuration open Configure Other paste this template and select activate {\"NAME\":\"LC Technology 4CH Relay\",\"GPIO\":[52,255,17,255,255,255,255,255,21,22,23,24,255],\"FLAG\":0,\"BASE\":18} Open Configure Module and set GPIO0, GPIO2, GPIO4 and GPIO5 as Relay1, Relay2, Relay3 and Relay4. Click Save. Disable SerialLog (type seriallog 0 in the Tasmota console) Enter this command in console (configure the 1st rule) Rule1 on System#Boot do Backlog Baudrate 9600; SerialSend5 0 endon on Power1#State=1 do SerialSend5 A00101A2 endon on Power1#State=0 do SerialSend5 A00100A1 endon on Power2#State=1 do SerialSend5 A00201A3 endon on Power2#State=0 do SerialSend5 A00200A2 endon on Power3#State=1 do SerialSend5 A00301A4 endon on Power3#State=0 do SerialSend5 A00300A3 endon on Power4#State=1 do SerialSend5 A00401A5 endon on Power4#State=0 do SerialSend5 A00400A4 endon Enable the rule (type rule1 1 in the Tasmota console)","title":"LC Technology WiFi Relay - Quad Relay (note, older versions of this board used a baud rate of 9600, so if 115200 doesn't work, try 9600)"},{"location":"devices/LC-Technology-WiFi-Relay/#beware-of-counterfeit-modules","text":"If your board just continuously flashes its led when powered on and no esp-01 is entered, the onboard STC15F104W needs to be programmed! For more details ( link ) Additionally, once programmed, you may also have to remove r4. Some issues exist where r3 and r4 are swapped, but just removing r4 works.","title":"Beware of counterfeit modules"},{"location":"devices/LC-Technology-WiFi-Relay/#easier-hardware-fix","text":"This is an easier fix for the ESP-01S relay v1.0 board, which does not require pcb cuts or resistor desoldering, just a 10K resistor soldered as in image: this mod prevents the relay flicker, and connects ch_pd, too","title":"Easier hardware fix"},{"location":"devices/LC-Technology-WiFi-Relay/#how-to-use-with-up-to-12v-power-supply","text":"LC Technology WiFi Relay use CJT1117B linear regulator which support input power up to 12V. It is ok for ESP-01 and N76E003, but not for relay. Relay connected without any voltage regulator to input power directly. The easier way to replace existing relay. Part number for 12V relay is SRD-12VDC-SLC. You can use similar analogs for 6V and 9V.","title":"How to use with up to 12V power supply"},{"location":"devices/LSC-Smart-Connect-Smart-Power-Plug/","text":"Simple somewhat compact WiFi controllable EU plug socket. Sold in the Netherlands by Action. Product ~ Internals ~ Inside the device is a Tuya TYWE2S. This device can be flashed using a software OTA hack using tuya-convert Flashing ~ Simply connect the (clearly labeled) 3v3, GND, TX, RX pins of the TYWE2S to the appropriate pins on your serial adapter and connect IO0 to GND to enter flashing mode. With the device connected and in flashing mode, create a backup of the factory firmware, erase the flash, and flash a tasmota firmware approximately as follows: esptool.py read_flash 0x000000 0x100000 image1M.bin esptool.py erase_flash esptool.py write_flash -fs 1MB -fm dout 0x0 tasmota-lite.bin` Configuration ~ \u26a0\ufe0f Warning! While the below configuration is correct and working, configuring a button on GPIO14 will make the device reset itself to the default Tasmota configuration after a number of seconds.","title":"LSC Smart Connect Smart Power Plug"},{"location":"devices/LSC-Smart-Connect-Smart-Power-Plug/#product","text":"","title":"Product"},{"location":"devices/LSC-Smart-Connect-Smart-Power-Plug/#internals","text":"Inside the device is a Tuya TYWE2S. This device can be flashed using a software OTA hack using tuya-convert","title":"Internals"},{"location":"devices/LSC-Smart-Connect-Smart-Power-Plug/#flashing","text":"Simply connect the (clearly labeled) 3v3, GND, TX, RX pins of the TYWE2S to the appropriate pins on your serial adapter and connect IO0 to GND to enter flashing mode. With the device connected and in flashing mode, create a backup of the factory firmware, erase the flash, and flash a tasmota firmware approximately as follows: esptool.py read_flash 0x000000 0x100000 image1M.bin esptool.py erase_flash esptool.py write_flash -fs 1MB -fm dout 0x0 tasmota-lite.bin`","title":"Flashing"},{"location":"devices/LSC-Smart-Connect-Smart-Power-Plug/#configuration","text":"\u26a0\ufe0f Warning! While the below configuration is correct and working, configuring a button on GPIO14 will make the device reset itself to the default Tasmota configuration after a number of seconds.","title":"Configuration"},{"location":"devices/LeFun-SK2-Smart-Power-Strip-%28Model-ZLD-44USA-W%29/","text":"The LeFun SK2 has 4 mains power and 4 USB ports. Each mains power is independently controlled and the USB group is controllable via a solid state relay. The ESP8266 module inside is likely a TYWE3S by Tuya but I didn't open the case and use the tuya-convert tool to flash.","title":"LeFun SK2 Smart Power Strip (Model ZLD 44USA W)"},{"location":"devices/Lingan-SWA1/","text":"Connection ~ Vcc - 3,3V TX - RX RX - TX GND - GND Additional Information ~ More Infos can be found here: Lingan SWA1 Plug in Wi-Fi Socket with MQTT (ESP8266) . Device Images ~ GPIO Config ~","title":"Lingan SWA1"},{"location":"devices/Lingan-SWA1/#connection","text":"Vcc - 3,3V TX - RX RX - TX GND - GND","title":"Connection"},{"location":"devices/Lingan-SWA1/#additional-information","text":"More Infos can be found here: Lingan SWA1 Plug in Wi-Fi Socket with MQTT (ESP8266) .","title":"Additional Information"},{"location":"devices/Lingan-SWA1/#device-images","text":"","title":"Device Images"},{"location":"devices/Lingan-SWA1/#gpio-config","text":"","title":"GPIO Config"},{"location":"devices/Luminea-ZX-2844-675-%28RGBW-LED-Controller%29/","text":"Luminea ZX-2844-* ~ also known as: * XS-RGBW-LedControl-V2.0.2 * JCD XS-RGBW sold by PEARL and amazon (i know know if they are available outside D-A-CH) * https://www.pearl.de/a-ZX2844-3103.shtml * https://www.amazon.de/Luminea-Zubeh%C3%B6r-Smarthome-LED-Strips-WLAN-Controller-spritzwassergesch%C3%BCtzt/dp/B074T11793 Hardware ~ There is a ESP8266EX sitting on the backside. 4 PWM outputs are connected to drive the 4 output channels (RGB + W). Red is on GPIO14 Green is on GPIO12 Blue is on GPIO5 White is on GPIO13 The pushbutton is GPIO13. Assign it to Button1 for local on/off control. You can configure it as a \"generic module\" And set the GPIO as follow: Function ESP8266 Pin Channel R GPIO 14 PWM1 G GPIO 12 PWM2 B GPIO 5 PWM3 W GPIO 0 PWM4 PushButton GPIO 13 Button1 There is an second version with a green PCB and different pinout: Function ESP8266 Pin Channel R GPIO 4 PWM1 G GPIO 12 PWM2 B GPIO 14 PWM3 W GPIO 5 PWM4 PushButton GPIO 0 Button1 Serial Connection ~ See the Hardware Preparation page for general instructions. The serial header (3.3V, RXD, TXD, GND) as well as GPIO0, GPIO2 and RESET (IO0, IO2, RST) are populated as test pads on the frontside of the PCB. You can easily add some solder to fix the wires during the flash process. To place the board into flashing mode, you will need to short IO0 to GND. This can remain shorted while flashing is in progress, but you will need to remove the short in order to boot the Tasmota firmware.","title":"Luminea ZX-2844-*"},{"location":"devices/Luminea-ZX-2844-675-%28RGBW-LED-Controller%29/#luminea-zx-2844-","text":"also known as: * XS-RGBW-LedControl-V2.0.2 * JCD XS-RGBW sold by PEARL and amazon (i know know if they are available outside D-A-CH) * https://www.pearl.de/a-ZX2844-3103.shtml * https://www.amazon.de/Luminea-Zubeh%C3%B6r-Smarthome-LED-Strips-WLAN-Controller-spritzwassergesch%C3%BCtzt/dp/B074T11793","title":"Luminea ZX-2844-*"},{"location":"devices/Luminea-ZX-2844-675-%28RGBW-LED-Controller%29/#hardware","text":"There is a ESP8266EX sitting on the backside. 4 PWM outputs are connected to drive the 4 output channels (RGB + W). Red is on GPIO14 Green is on GPIO12 Blue is on GPIO5 White is on GPIO13 The pushbutton is GPIO13. Assign it to Button1 for local on/off control. You can configure it as a \"generic module\" And set the GPIO as follow: Function ESP8266 Pin Channel R GPIO 14 PWM1 G GPIO 12 PWM2 B GPIO 5 PWM3 W GPIO 0 PWM4 PushButton GPIO 13 Button1 There is an second version with a green PCB and different pinout: Function ESP8266 Pin Channel R GPIO 4 PWM1 G GPIO 12 PWM2 B GPIO 14 PWM3 W GPIO 5 PWM4 PushButton GPIO 0 Button1","title":"Hardware"},{"location":"devices/Luminea-ZX-2844-675-%28RGBW-LED-Controller%29/#serial-connection","text":"See the Hardware Preparation page for general instructions. The serial header (3.3V, RXD, TXD, GND) as well as GPIO0, GPIO2 and RESET (IO0, IO2, RST) are populated as test pads on the frontside of the PCB. You can easily add some solder to fix the wires during the flash process. To place the board into flashing mode, you will need to short IO0 to GND. This can remain shorted while flashing is in progress, but you will need to remove the short in order to boot the Tasmota firmware.","title":"Serial Connection"},{"location":"devices/MagicHome-LED-strip-controller/","text":"MagicHome LED controllers (aka Flux-Led, aka Arilux AL-LC01) ~ Shopping Board is essentially a ESP-12S (or ESP-2M) with necessary voltage converters, little bit of flash, 3 or 4 MOSFETs to drive LED strip (depending on the model), connector for LED strip and optional IR receiver. Module is powered by 12V that is used to power LED strip as well. RGB models are declared as 144W, RGBW models as 192W. Module comes in (at least) 3 variants: - LC01: RGB, - LC02: RGBW and - LC03: RGB with IR receiver. - LC04: RGBW with IR receiver. - LC05: RGB with Screw-Headers. - LC06: RGBW/WW with Screw-Headers A different version of this controller with an ESP8285 is documented here Serial Connection ~ Board has RX, TX, GND and GPIO00 pads exposed on the bottom side of the PCB. You need to solder temporary wires those pads. You need to power the board while keeping it connected to the programmer. With all Sonoff boards that work with AC, this is a big no-no that will fry your programmer, your Sonoff and might even get you killed. In this case, you'd be dealing with 12V, so the only thing that matters is to connect the GND of your programmer to GND of the board before you supply the 12V. Not doing so might fry your board and/or programmer, but would definitely not hurt you. Steps used: 1. Connect your programmer to a breadboard and notice the locations of GND, TX and RX columns. 1. Open the MagicHome controller box and expose bottom side of PCB 1. Solder 4 jumper wires to 4 exposed pads. 1. FIRST connect GND to your programmer (and make sure they are connected well!) 1. Connect RX from the MagicHome to TX on the programmer. TX from the board goes to RX on the programmer. 1. Connect GPIO00 to GND (best to use same column on the breadboard) 1. Connect the 12V power supply to MagicHome. As GPIO00 is connected to GND, board will go into flash mode. Disconnect GPIO00 after few seconds. 1. Upload Tasmota like it would be any other board. 1. Once upload is complete, disconnect power from the MagicHome controller 1. Disconnect RX and TX and then only then GND. GND gets disconnected LAST. You can then connect the power back to the board and Tasmota should be running on it. Once you verify that board is up and you can access it over the Web, you can unsolder temporary wires and update subsequent firmware versions using OTA. Configuration ~ Some GPIO are preconfigured with the board: - GPIO05 - (PWM2) Green color on the led strip, first pin from the GND - GPIO14 - (PWM1) Red color on the LED strip, second pin from the GND - GPIO12 - (PWM3) Blue color on the LED strip, third pin from the GND For instructions to setup the 24 Button Remote visit the AL-LC04 device page Check this for Board Version 2.3 : #1867 Due to variants, you can configure: - GPIO04 - on non-IR boards, it's an open pin you can use for Onewire, button or something else. It might have pull-down resistor and/or bypass capacitor, so please take that into consideration. On IR-enabled boards, IR receiver is connected to this pin, so you can use IRRecv as functionality. - GPIO13 - This pin is not used on RGB board (so you'll leave it as \"None\"), but on RGBW, it's driving another channel (cold white or warm white) for LED strip. Variant without Rx/Tx pads: ~ - Using the IRrecv (IR Remote) feature ~ If you have a variant with an IR Remote (as per the opening picture), you can use the new rule command to make the remote buttons change the light levels. For example, this rule allows me to turn it on and off, change the brightness, and turn it on to full white: mosquitto_pub -t 'cmnd/light/rule1' -m 'on IrReceived#Data=0xFFF807 do power OFF endon on IrReceived#Data=0xFFB04F do WAKEUP endon on IrReceived#Data=0xFF906F do dimmer + endon on IrReceived#Data=0xFFB847 do dimmer - endon on IrReceived#Data=0xFFA857 do color #000000ff endon' Full Set of rules for IR remote ~ Each rule can only be 511 characters long, some of the colors below use the built in predefined shortcut color numbers. mosquitto_pub - t 'cmnd/light/rule1' - m 'on IrReceived#Data=0xFFF807 do power OFF endon on IrReceived#Data=0xFFB04F do WAKEUP endon on IrReceived#Data=0xFF906F do dimmer + endon on IrReceived#Data=0xFFB847 do dimmer - endon on IrReceived#Data=0xFFA857 do color 12 endon on IrReceived#Data=0xFF9867 do color 1 endon on IrReceived#Data=0xFFD827 do color 2 endon on IrReceived#Data=0xFF8877 do color 3 endon on IrReceived#Data=0xFF28D7 do color #007FFF endon on IrReceived#Data=0xFF38C7 do color 4 endon' mosquitto_pub - t 'cmnd/light/rule2' - m 'on IrReceived#Data=0xFFE817 do color #FF3F00 endon on IrReceived#Data=0xFF48B7 do color #00FF3F endon on IrReceived#Data=0xFF6897 do color #3F00FF endon on IrReceived#Data=0xFF02FD do color 4 endon on IrReceived#Data=0xFF32CD do color #00FFBF endon on IrReceived#Data=0xFF20DF do color #7F00FF endon on IrReceived#Data=0xFF50AF do color #FF7F00 endon on IrReceived#Data=0xFF7887 do color #00BFFF endon on IrReceived#Data=0xFF708F do color #FF00FF endon on IrReceived#Data=0xFFF00F do color #FF003F endon' mosquitto_pub - t 'cmnd/light/rule3' - m 'on IrReceived#Data=0xFF00FF do scheme 4 endon on IrReceived#Data=0xFF58A7 do scheme 3 endon on IrReceived#Data=0xFF30CF do scheme 2 endon on IrReceived#Data=0xFFB24D do backlog BlinkCount 600; Power 3 endon' After setting the rules you need to activate them with the following: mosquitto_pub -t 'cmnd/light/rule1' -m '1' mosquitto_pub -t 'cmnd/light/rule2' -m '1' mosquitto_pub -t 'cmnd/light/rule3' -m '1' The hex codes for the \"Data\" value come from the data tag when looking at the JSON sent via MQTT. You can also view this data on the Tasmota console screen. From here you can program it to do what ever you want. See here for more details: devices/Rules","title":"MagicHome LED strip controller"},{"location":"devices/MagicHome-LED-strip-controller/#magichome-led-controllers-aka-flux-led-aka-arilux-al-lc01","text":"Shopping Board is essentially a ESP-12S (or ESP-2M) with necessary voltage converters, little bit of flash, 3 or 4 MOSFETs to drive LED strip (depending on the model), connector for LED strip and optional IR receiver. Module is powered by 12V that is used to power LED strip as well. RGB models are declared as 144W, RGBW models as 192W. Module comes in (at least) 3 variants: - LC01: RGB, - LC02: RGBW and - LC03: RGB with IR receiver. - LC04: RGBW with IR receiver. - LC05: RGB with Screw-Headers. - LC06: RGBW/WW with Screw-Headers A different version of this controller with an ESP8285 is documented here","title":"MagicHome LED controllers (aka Flux-Led, aka Arilux AL-LC01)"},{"location":"devices/MagicHome-LED-strip-controller/#serial-connection","text":"Board has RX, TX, GND and GPIO00 pads exposed on the bottom side of the PCB. You need to solder temporary wires those pads. You need to power the board while keeping it connected to the programmer. With all Sonoff boards that work with AC, this is a big no-no that will fry your programmer, your Sonoff and might even get you killed. In this case, you'd be dealing with 12V, so the only thing that matters is to connect the GND of your programmer to GND of the board before you supply the 12V. Not doing so might fry your board and/or programmer, but would definitely not hurt you. Steps used: 1. Connect your programmer to a breadboard and notice the locations of GND, TX and RX columns. 1. Open the MagicHome controller box and expose bottom side of PCB 1. Solder 4 jumper wires to 4 exposed pads. 1. FIRST connect GND to your programmer (and make sure they are connected well!) 1. Connect RX from the MagicHome to TX on the programmer. TX from the board goes to RX on the programmer. 1. Connect GPIO00 to GND (best to use same column on the breadboard) 1. Connect the 12V power supply to MagicHome. As GPIO00 is connected to GND, board will go into flash mode. Disconnect GPIO00 after few seconds. 1. Upload Tasmota like it would be any other board. 1. Once upload is complete, disconnect power from the MagicHome controller 1. Disconnect RX and TX and then only then GND. GND gets disconnected LAST. You can then connect the power back to the board and Tasmota should be running on it. Once you verify that board is up and you can access it over the Web, you can unsolder temporary wires and update subsequent firmware versions using OTA.","title":"Serial Connection"},{"location":"devices/MagicHome-LED-strip-controller/#configuration","text":"Some GPIO are preconfigured with the board: - GPIO05 - (PWM2) Green color on the led strip, first pin from the GND - GPIO14 - (PWM1) Red color on the LED strip, second pin from the GND - GPIO12 - (PWM3) Blue color on the LED strip, third pin from the GND For instructions to setup the 24 Button Remote visit the AL-LC04 device page Check this for Board Version 2.3 : #1867 Due to variants, you can configure: - GPIO04 - on non-IR boards, it's an open pin you can use for Onewire, button or something else. It might have pull-down resistor and/or bypass capacitor, so please take that into consideration. On IR-enabled boards, IR receiver is connected to this pin, so you can use IRRecv as functionality. - GPIO13 - This pin is not used on RGB board (so you'll leave it as \"None\"), but on RGBW, it's driving another channel (cold white or warm white) for LED strip.","title":"Configuration"},{"location":"devices/MagicHome-LED-strip-controller/#variant-without-rxtx-pads","text":"-","title":"Variant without Rx/Tx pads:"},{"location":"devices/MagicHome-LED-strip-controller/#using-the-irrecv-ir-remote-feature","text":"If you have a variant with an IR Remote (as per the opening picture), you can use the new rule command to make the remote buttons change the light levels. For example, this rule allows me to turn it on and off, change the brightness, and turn it on to full white: mosquitto_pub -t 'cmnd/light/rule1' -m 'on IrReceived#Data=0xFFF807 do power OFF endon on IrReceived#Data=0xFFB04F do WAKEUP endon on IrReceived#Data=0xFF906F do dimmer + endon on IrReceived#Data=0xFFB847 do dimmer - endon on IrReceived#Data=0xFFA857 do color #000000ff endon'","title":"Using the IRrecv (IR Remote) feature"},{"location":"devices/MagicHome-LED-strip-controller/#full-set-of-rules-for-ir-remote","text":"Each rule can only be 511 characters long, some of the colors below use the built in predefined shortcut color numbers. mosquitto_pub - t 'cmnd/light/rule1' - m 'on IrReceived#Data=0xFFF807 do power OFF endon on IrReceived#Data=0xFFB04F do WAKEUP endon on IrReceived#Data=0xFF906F do dimmer + endon on IrReceived#Data=0xFFB847 do dimmer - endon on IrReceived#Data=0xFFA857 do color 12 endon on IrReceived#Data=0xFF9867 do color 1 endon on IrReceived#Data=0xFFD827 do color 2 endon on IrReceived#Data=0xFF8877 do color 3 endon on IrReceived#Data=0xFF28D7 do color #007FFF endon on IrReceived#Data=0xFF38C7 do color 4 endon' mosquitto_pub - t 'cmnd/light/rule2' - m 'on IrReceived#Data=0xFFE817 do color #FF3F00 endon on IrReceived#Data=0xFF48B7 do color #00FF3F endon on IrReceived#Data=0xFF6897 do color #3F00FF endon on IrReceived#Data=0xFF02FD do color 4 endon on IrReceived#Data=0xFF32CD do color #00FFBF endon on IrReceived#Data=0xFF20DF do color #7F00FF endon on IrReceived#Data=0xFF50AF do color #FF7F00 endon on IrReceived#Data=0xFF7887 do color #00BFFF endon on IrReceived#Data=0xFF708F do color #FF00FF endon on IrReceived#Data=0xFFF00F do color #FF003F endon' mosquitto_pub - t 'cmnd/light/rule3' - m 'on IrReceived#Data=0xFF00FF do scheme 4 endon on IrReceived#Data=0xFF58A7 do scheme 3 endon on IrReceived#Data=0xFF30CF do scheme 2 endon on IrReceived#Data=0xFFB24D do backlog BlinkCount 600; Power 3 endon' After setting the rules you need to activate them with the following: mosquitto_pub -t 'cmnd/light/rule1' -m '1' mosquitto_pub -t 'cmnd/light/rule2' -m '1' mosquitto_pub -t 'cmnd/light/rule3' -m '1' The hex codes for the \"Data\" value come from the data tag when looking at the JSON sent via MQTT. You can also view this data on the Tasmota console screen. From here you can program it to do what ever you want. See here for more details: devices/Rules","title":"Full Set of rules for IR remote"},{"location":"devices/MagicHome-with-ESP8285/","text":"Yet another MagicHome RGB controller. I specifically had this one . Aside from it going 9-28V, there are no other external model numbers etc, however opening it up revealed a very different configuration inside, using an ESP8285 chip directly on the board. (Right click and view the original image to see the full size image for all images below) Identifying this board ~ Looking closely you can see it's an ESP8285, on the main board, it has the part number: ZJ-WFMN-A V1.1 , ZJ-WFMN-B V1.1 , ZJ-WFMN-C V1.1 , or ZJ-WFMN-D V1.0 Arilux devices ~ The devices are similar to the Arilux devices. Here is an overview: Model Color Support Voltages (sometimes) Remote PCB part number Link LC01 RGB 5-28V None ZJ-WFMN-A V1.1 Banggood LC02 RGBW 9-12V (5-28V) None ZJ-WFMN-B V1.1 Banggood LC03 RGB 5-28V IR ZJ-WFMN-A V1.1 Banggood LC04 RGBW 9-12V (5-28V) IR ZJ-WFMN-A V1.1 Banggood LC08 RGBWW/RGBWC 5-28V None Banggood LC09 RGB 5-28V RF Banggood LC10 RGBW 9-28V RF Banggood LC11 RGBWW/RGBWC 9-28V RF ZJ-WFMN-D V1.0 Banggood Flashing ~ I found that on the back it has pads to solder to so you can flash it. The IO0 port is GPIO0 that needs to be pulled to ground when powered on for flashing (as per all ESP devices). I soldered cables to each of these. Note that some are very close to other pads, so be careful. If you want to avoid soldering, also pogo pins work well with the pads. Template configuration ~ Arilux LC01 (ZJ-WFMN-A V1.1) Automatic configuration: Field Value Function Module type 37 Arilux LC01 Module type Manual configuration: Field Value Function Module type 18 Generic Module type GPIO5 37 PWM1 RED GPIO12 38 PWM2 GREEN GPIO13 39 PWM3 BLUE Arilux LC02 (ZJ-WFMN-B V1.1) Field Value Module type 18 Generic GPIO5 38 PWM2 GPIO12 39 PWM3 GPIO13 40 PWM4 GPIO14 37 PWM1 Arilux LC03 (ZJ-WFMN-A V1.1) Field Value Function Module type 18 Generic Module type GPIO4 51 IRRecv IR Remote GPIO5 37 PWM1 RED GPIO12 38 PWM2 GREEN GPIO13 39 PWM3 BLUE Arilux LC04 (ZJ-WFMN-A V1.1) Field Value Function Module type 18 Generic Module type GPIO4 51 IRRecv IR Remote (optional, view console for debugging!) GPIO5 38 PWM2 BLUE GPIO12 37 PWM1 RED GPIO13 39 PWM3 GREEN GPIO15 40 PWM4 WHITE Arilux LC11 (ZJ-WFMN-D V1.0) Field Value Function Module type 18 Generic Module type GPIO4 147 ALux IrRcv GPIO5 40 PWM4 COLD WHITE GPIO12 38 PWM2 GREEN GPIO13 39 PWM3 BLUE GPIO14 37 PWM1 RED GPIO15 41 PWM5 WARM WHITE GPIO16 159 ALux IrSel With all that done, one of the critical things I needed to do so I could set the colors was to run the command to set SetOption15 1 . After that it is possible to test the lights functionality, e.g. with the command color #ff0000ff . RF control ~ If you have an RF variant, you will want to configure the GPIOs like this: { \"MagicHome RF\", // Magic Home RF (ESP8266) - (Arilux LC10) GPIO_USER, // GPIO00 Optional Button GPIO_USER, // GPIO01 Serial RXD and Optional sensor GPIO_LED1_INV, // GPIO02 Blue onboard LED (optional) GPIO_USER, // GPIO03 Serial TXD and Optional sensor0 GPIO_ARIRFRCV, // GPIO04 RF receiver input GPIO_PWM2, // GPIO05 RGB LED Green 0, 0, 0, 0, 0, 0, // Flash connection GPIO_PWM3, // GPIO12 RGB LED Blue GPIO_PWM4, // GPIO13 RGBW LED White GPIO_PWM1, // GPIO14 RGB LED Red GPIO_LED2_INV, // GPIO15 RF receiver control 0, 0 }, or like this: { \"MagicHome RF\", // Magic Home RF (ESP8285) - (IRrecv) GPIO_USER, // GPIO00 Optional Button GPIO_USER, // GPIO01 Serial RXD and Optional sensor GPIO_LED1_INV, // GPIO02 Blue onboard LED (not soldered) GPIO_USER, // GPIO03 Serial TXD and Optional sensor0 GPIO_IRRECV, // GPIO04 IR receiver input GPIO_PWM1, // GPIO05 RGB LED Green 0, 0, 0, 0, 0, 0, // Flash connection GPIO_PWM2, // GPIO12 RGB LED Blue GPIO_PWM3, // GPIO13 RGBW LED White 0, 0, 0 }, After choosing the correct module type in your Tasmota configuration, press a key on the remote after boot for the device to learn your code. Full Set of rules for IR remote ~ Each rule can only be 511 characters long, some of the colors below use the built in predefined shortcut color numbers. mosquitto_pub - t 'cmnd/RGBled/rule1' - m 'On IrReceived#Data=0x00FF906F Do Dimmer + EndOn On IrReceived#Data=0x00FF9867 Do Color2 1 EndOn On IrReceived#Data=0x00FFE817 Do HSBColor1 13 EndOn On IrReceived#Data=0x00FF02FD Do HSBColor1 23 EndOn On IrReceived#Data=0x00FF50AF Do HSBColor1 33 EndOn On IrReceived#Data=0x00FF38C7 Do HSBColor1 43 EndOn On IrReceived#Data=0x00FFB847 Do Dimmer - EndOn On IrReceived#Data=0x00FFD827 Do Color2 2 EndOn On IrReceived#Data=0x00FF48B7 Do HSBColor1 140 EndOn On IrReceived#Data=0x00FF32CD Do HSBColor1 160 EndOn' mosquitto_pub - t 'cmnd/RGBled/rule2' - m 'Rule2 On IrReceived#Data=0x00FF7887 Do HSBColor1 180 EndOn On IrReceived#Data=0x00FF28D7 Do HSBColor1 200 EndOn On IrReceived#Data=0x00FFF807 Do Power 0 EndOn On IrReceived#Data=0x00FF8877 Do Color2 3 EndOn On IrReceived#Data=0x00FF6897 Do HSBColor1 260 EndOn On IrReceived#Data=0x00FF20DF Do HSBColor1 280 EndOn On IrReceived#Data=0x00FF708F Do HSBColor1 300 EndOn On IrReceived#Data=0x00FFF00F Do HSBColor1 320 EndOn' mosquitto_pub - t 'cmnd/RGBled/rule3' - m 'Rule3 On IrReceived#Data=0x00FFB04F Do Power 1 EndOn On IrReceived#Data=0x00FFA857 Do Color2 12 EndOn On IrReceived#Data=0x00FFB24D Do Backlog Power 0; WakeupDuration 1; Dimmer 100; Wakeup EndOn On IrReceived#Data=0x00FF00FF Do Backlog Power 0; WakeupDuration 5; Wakeup EndOn On IrReceived#Data=0x00FF58A7 Do Backlog Scheme 2; Speed 1 EndOn On IrReceived#Data=0x00FF30CF Do Backlog Scheme 3; Speed 5 EndOn' A Google Sheets Document to edit the desired actions and create the three needed rules is linked here . After setting the rules you need to activate them with the following: mosquitto_pub -t 'cmnd/RGBled/rule1' -m 'ON' mosquitto_pub -t 'cmnd/RGBled/rule2' -m 'ON' mosquitto_pub -t 'cmnd/RGBled/rule3' -m 'ON' The hex codes for the \"Data\" value come from the data tag when looking at the JSON sent via MQTT. You can also view this data on the Tasmota console screen. From here you can program it to do whatever you want using Rules .","title":"MagicHome with ESP8285"},{"location":"devices/MagicHome-with-ESP8285/#identifying-this-board","text":"Looking closely you can see it's an ESP8285, on the main board, it has the part number: ZJ-WFMN-A V1.1 , ZJ-WFMN-B V1.1 , ZJ-WFMN-C V1.1 , or ZJ-WFMN-D V1.0","title":"Identifying this board"},{"location":"devices/MagicHome-with-ESP8285/#arilux-devices","text":"The devices are similar to the Arilux devices. Here is an overview: Model Color Support Voltages (sometimes) Remote PCB part number Link LC01 RGB 5-28V None ZJ-WFMN-A V1.1 Banggood LC02 RGBW 9-12V (5-28V) None ZJ-WFMN-B V1.1 Banggood LC03 RGB 5-28V IR ZJ-WFMN-A V1.1 Banggood LC04 RGBW 9-12V (5-28V) IR ZJ-WFMN-A V1.1 Banggood LC08 RGBWW/RGBWC 5-28V None Banggood LC09 RGB 5-28V RF Banggood LC10 RGBW 9-28V RF Banggood LC11 RGBWW/RGBWC 9-28V RF ZJ-WFMN-D V1.0 Banggood","title":"Arilux devices"},{"location":"devices/MagicHome-with-ESP8285/#flashing","text":"I found that on the back it has pads to solder to so you can flash it. The IO0 port is GPIO0 that needs to be pulled to ground when powered on for flashing (as per all ESP devices). I soldered cables to each of these. Note that some are very close to other pads, so be careful. If you want to avoid soldering, also pogo pins work well with the pads.","title":"Flashing"},{"location":"devices/MagicHome-with-ESP8285/#template-configuration","text":"Arilux LC01 (ZJ-WFMN-A V1.1) Automatic configuration: Field Value Function Module type 37 Arilux LC01 Module type Manual configuration: Field Value Function Module type 18 Generic Module type GPIO5 37 PWM1 RED GPIO12 38 PWM2 GREEN GPIO13 39 PWM3 BLUE Arilux LC02 (ZJ-WFMN-B V1.1) Field Value Module type 18 Generic GPIO5 38 PWM2 GPIO12 39 PWM3 GPIO13 40 PWM4 GPIO14 37 PWM1 Arilux LC03 (ZJ-WFMN-A V1.1) Field Value Function Module type 18 Generic Module type GPIO4 51 IRRecv IR Remote GPIO5 37 PWM1 RED GPIO12 38 PWM2 GREEN GPIO13 39 PWM3 BLUE Arilux LC04 (ZJ-WFMN-A V1.1) Field Value Function Module type 18 Generic Module type GPIO4 51 IRRecv IR Remote (optional, view console for debugging!) GPIO5 38 PWM2 BLUE GPIO12 37 PWM1 RED GPIO13 39 PWM3 GREEN GPIO15 40 PWM4 WHITE Arilux LC11 (ZJ-WFMN-D V1.0) Field Value Function Module type 18 Generic Module type GPIO4 147 ALux IrRcv GPIO5 40 PWM4 COLD WHITE GPIO12 38 PWM2 GREEN GPIO13 39 PWM3 BLUE GPIO14 37 PWM1 RED GPIO15 41 PWM5 WARM WHITE GPIO16 159 ALux IrSel With all that done, one of the critical things I needed to do so I could set the colors was to run the command to set SetOption15 1 . After that it is possible to test the lights functionality, e.g. with the command color #ff0000ff .","title":"Template configuration"},{"location":"devices/MagicHome-with-ESP8285/#rf-control","text":"If you have an RF variant, you will want to configure the GPIOs like this: { \"MagicHome RF\", // Magic Home RF (ESP8266) - (Arilux LC10) GPIO_USER, // GPIO00 Optional Button GPIO_USER, // GPIO01 Serial RXD and Optional sensor GPIO_LED1_INV, // GPIO02 Blue onboard LED (optional) GPIO_USER, // GPIO03 Serial TXD and Optional sensor0 GPIO_ARIRFRCV, // GPIO04 RF receiver input GPIO_PWM2, // GPIO05 RGB LED Green 0, 0, 0, 0, 0, 0, // Flash connection GPIO_PWM3, // GPIO12 RGB LED Blue GPIO_PWM4, // GPIO13 RGBW LED White GPIO_PWM1, // GPIO14 RGB LED Red GPIO_LED2_INV, // GPIO15 RF receiver control 0, 0 }, or like this: { \"MagicHome RF\", // Magic Home RF (ESP8285) - (IRrecv) GPIO_USER, // GPIO00 Optional Button GPIO_USER, // GPIO01 Serial RXD and Optional sensor GPIO_LED1_INV, // GPIO02 Blue onboard LED (not soldered) GPIO_USER, // GPIO03 Serial TXD and Optional sensor0 GPIO_IRRECV, // GPIO04 IR receiver input GPIO_PWM1, // GPIO05 RGB LED Green 0, 0, 0, 0, 0, 0, // Flash connection GPIO_PWM2, // GPIO12 RGB LED Blue GPIO_PWM3, // GPIO13 RGBW LED White 0, 0, 0 }, After choosing the correct module type in your Tasmota configuration, press a key on the remote after boot for the device to learn your code.","title":"RF control"},{"location":"devices/MagicHome-with-ESP8285/#full-set-of-rules-for-ir-remote","text":"Each rule can only be 511 characters long, some of the colors below use the built in predefined shortcut color numbers. mosquitto_pub - t 'cmnd/RGBled/rule1' - m 'On IrReceived#Data=0x00FF906F Do Dimmer + EndOn On IrReceived#Data=0x00FF9867 Do Color2 1 EndOn On IrReceived#Data=0x00FFE817 Do HSBColor1 13 EndOn On IrReceived#Data=0x00FF02FD Do HSBColor1 23 EndOn On IrReceived#Data=0x00FF50AF Do HSBColor1 33 EndOn On IrReceived#Data=0x00FF38C7 Do HSBColor1 43 EndOn On IrReceived#Data=0x00FFB847 Do Dimmer - EndOn On IrReceived#Data=0x00FFD827 Do Color2 2 EndOn On IrReceived#Data=0x00FF48B7 Do HSBColor1 140 EndOn On IrReceived#Data=0x00FF32CD Do HSBColor1 160 EndOn' mosquitto_pub - t 'cmnd/RGBled/rule2' - m 'Rule2 On IrReceived#Data=0x00FF7887 Do HSBColor1 180 EndOn On IrReceived#Data=0x00FF28D7 Do HSBColor1 200 EndOn On IrReceived#Data=0x00FFF807 Do Power 0 EndOn On IrReceived#Data=0x00FF8877 Do Color2 3 EndOn On IrReceived#Data=0x00FF6897 Do HSBColor1 260 EndOn On IrReceived#Data=0x00FF20DF Do HSBColor1 280 EndOn On IrReceived#Data=0x00FF708F Do HSBColor1 300 EndOn On IrReceived#Data=0x00FFF00F Do HSBColor1 320 EndOn' mosquitto_pub - t 'cmnd/RGBled/rule3' - m 'Rule3 On IrReceived#Data=0x00FFB04F Do Power 1 EndOn On IrReceived#Data=0x00FFA857 Do Color2 12 EndOn On IrReceived#Data=0x00FFB24D Do Backlog Power 0; WakeupDuration 1; Dimmer 100; Wakeup EndOn On IrReceived#Data=0x00FF00FF Do Backlog Power 0; WakeupDuration 5; Wakeup EndOn On IrReceived#Data=0x00FF58A7 Do Backlog Scheme 2; Speed 1 EndOn On IrReceived#Data=0x00FF30CF Do Backlog Scheme 3; Speed 5 EndOn' A Google Sheets Document to edit the desired actions and create the three needed rules is linked here . After setting the rules you need to activate them with the following: mosquitto_pub -t 'cmnd/RGBled/rule1' -m 'ON' mosquitto_pub -t 'cmnd/RGBled/rule2' -m 'ON' mosquitto_pub -t 'cmnd/RGBled/rule3' -m 'ON' The hex codes for the \"Data\" value come from the data tag when looking at the JSON sent via MQTT. You can also view this data on the Tasmota console screen. From here you can program it to do whatever you want using Rules .","title":"Full Set of rules for IR remote"},{"location":"devices/Martin-Jerry-MJ-S01/","text":"The chip inside is a Tuya TYWE3S which is based on the ESP8266. Template GPIO Pin Selection 4 D2 Led1i (56) 5 D1 Led2i (57) 12 D6 Relay1 (21) 13 D7 Button1 (17) All other component assignments should be set to None (0)","title":"Martin Jerry MJ S01"},{"location":"devices/Martin-Jerry-MJ-SD01/","text":"This model sells for about $20 on Amazon . Info on the Tuya ~ The chip inside is a Tuya TYWE3S. It replicates the capabilities of an ESP8266 plus some other functionality. NOTE: THE RIGHT SIDE IS THE BACK OF THE BOARD. RST IS ON THE TOP LEFT OF THE LEFT PICTURE, AS WELL AS THE TOP LEFT OF THE PICTURE BELOW. Here\u2019s a picture of the chip inside the switch: Pin 1 is labeled M1 in the silkscreen of the switch board. Here\u2019s the back, I desoldered it with my Quick 861DW: On the other side of the board is an apparent test/programming header labeled CN1: From top to bottom on CN1 above, they are: Pin Signal CN1-1 TXD CN1-2 RXD CN1-3 GPIO2 CN1-4 GPIO0 CN1-5 GROUND CN1-6 VCC See Tasmota Hardware Prep for more details I removed all the crappy lead-free solder and put on a little strip of female pin header: Now I can easily hook it all up to the breadboard! I erased the firmware using the instructions using a Raspberry Pi 3 Model B. I couldn\u2019t get the board into programming mode by grounding the reset pin through the breadboard, so I just held the UP1 button while connecting 3V3 and it worked fine. There\u2019s another 4-wire connector that goes to the AC board. The wires are as follows: Wire Description Black 3.3v consistent, probably to power the other side Purple Variable voltage tied to dimmer. Low to high it\u2019s: 360mV, 680mV, 1.32V, 1.94V, 2.57V, 3.20V White GPIO16 Red Ground The other side features an STC15W404AS chip. This is the closest information sheet I\u2019ve found so far. It\u2019s likely there\u2019s an ADC receiver on the other side receiving our variable voltage on the purple wire above and converting that to the AC dimmer signal. When probing with the oscilloscope I noticed a 3.3v 1Khz square wave on GPIO13. It turns out this is the PWM that controls the output of the purple wire. This is done using the positive duty cycle of the wave. Here\u2019s a state table: Setting Duty 1 (Min Setting) 20% Duty 2 40% Duty 3 60% Duty 4 80% Duty 5 (Max Setting) 100% Duty, constant 3.3v We should be able to generate this same wave with whatever duty cycle we want in Tasmota to get much better dimming resolution than the default firmware provides. The buttons are tied as follows: Button Description UP1 GPIO0 to GROUND when pushed DOWN1 TXD to GROUND when pushed ON/OFF 3.3v to GPIO15 when pushed RESET Wired through an LED and resistor to GPIO16, also goes to white wire (RESET for the STC?), ties to GROUND The LEDs are wired as follows: LED Description LED1 Passthrough to RESET, GPIO16, see above. LED2 GPIO14 LED3 GPIO12 LED4 GPIO5 LED5 RXD Added a new entry to the sonoff_template.h list and assigned all the pins. You can of course just do a generic load and set it up with the Web UI. Here's what I ended up with in the header: { \"MJ-SD01\" , // Martin Jerry Smart Dimmer Switch (ESP8266EX) GPIO_SWT3 , // GPIO00 UP1 Button, bright up GPIO_SWT2 , // GPIO01 Serial TXD and DOWN1 Button, bright down 0 , // GPIO02 GPIO_REL5 , // GPIO03 Serial RXD GPIO_REL1_INV , // GPIO04 Multi-LED RED GPIO_REL4_INV , // GPIO05 LED1 0 , 0 , 0 , 0 , 0 , 0 , // GPIO06-GPIO11 GPIO_REL3_INV , // GPIO12 LED3 GPIO_PWM1 , // GPIO13 PWM for dimmer GPIO_REL2_INV , // GPIO14 LED2 GPIO_SWT1 , // GPIO15 ON/OFF Button, ties to 3.3v when pushed GPIO_SWT4 , // GPIO16 RESET button, also goes to AC side and probably resets the STC chip, tied to LED1 0 // ADC0 Analog input } FADE ON: Makes the PWM movements smooth DIMMER +/-: Moves dimmer up and down SPEED 3: Slows down fade a little SETOPTION15 1: Sets DIMMER mode rather than PWM Now that you can have rules set on dimmer actions, changing the LEDs with dimmer settings should be easy. I tried to do this before that existed, and it wasn't possible.","title":"Martin Jerry MJ SD01"},{"location":"devices/Martin-Jerry-MJ-SD01/#info-on-the-tuya","text":"The chip inside is a Tuya TYWE3S. It replicates the capabilities of an ESP8266 plus some other functionality. NOTE: THE RIGHT SIDE IS THE BACK OF THE BOARD. RST IS ON THE TOP LEFT OF THE LEFT PICTURE, AS WELL AS THE TOP LEFT OF THE PICTURE BELOW. Here\u2019s a picture of the chip inside the switch: Pin 1 is labeled M1 in the silkscreen of the switch board. Here\u2019s the back, I desoldered it with my Quick 861DW: On the other side of the board is an apparent test/programming header labeled CN1: From top to bottom on CN1 above, they are: Pin Signal CN1-1 TXD CN1-2 RXD CN1-3 GPIO2 CN1-4 GPIO0 CN1-5 GROUND CN1-6 VCC See Tasmota Hardware Prep for more details I removed all the crappy lead-free solder and put on a little strip of female pin header: Now I can easily hook it all up to the breadboard! I erased the firmware using the instructions using a Raspberry Pi 3 Model B. I couldn\u2019t get the board into programming mode by grounding the reset pin through the breadboard, so I just held the UP1 button while connecting 3V3 and it worked fine. There\u2019s another 4-wire connector that goes to the AC board. The wires are as follows: Wire Description Black 3.3v consistent, probably to power the other side Purple Variable voltage tied to dimmer. Low to high it\u2019s: 360mV, 680mV, 1.32V, 1.94V, 2.57V, 3.20V White GPIO16 Red Ground The other side features an STC15W404AS chip. This is the closest information sheet I\u2019ve found so far. It\u2019s likely there\u2019s an ADC receiver on the other side receiving our variable voltage on the purple wire above and converting that to the AC dimmer signal. When probing with the oscilloscope I noticed a 3.3v 1Khz square wave on GPIO13. It turns out this is the PWM that controls the output of the purple wire. This is done using the positive duty cycle of the wave. Here\u2019s a state table: Setting Duty 1 (Min Setting) 20% Duty 2 40% Duty 3 60% Duty 4 80% Duty 5 (Max Setting) 100% Duty, constant 3.3v We should be able to generate this same wave with whatever duty cycle we want in Tasmota to get much better dimming resolution than the default firmware provides. The buttons are tied as follows: Button Description UP1 GPIO0 to GROUND when pushed DOWN1 TXD to GROUND when pushed ON/OFF 3.3v to GPIO15 when pushed RESET Wired through an LED and resistor to GPIO16, also goes to white wire (RESET for the STC?), ties to GROUND The LEDs are wired as follows: LED Description LED1 Passthrough to RESET, GPIO16, see above. LED2 GPIO14 LED3 GPIO12 LED4 GPIO5 LED5 RXD Added a new entry to the sonoff_template.h list and assigned all the pins. You can of course just do a generic load and set it up with the Web UI. Here's what I ended up with in the header: { \"MJ-SD01\" , // Martin Jerry Smart Dimmer Switch (ESP8266EX) GPIO_SWT3 , // GPIO00 UP1 Button, bright up GPIO_SWT2 , // GPIO01 Serial TXD and DOWN1 Button, bright down 0 , // GPIO02 GPIO_REL5 , // GPIO03 Serial RXD GPIO_REL1_INV , // GPIO04 Multi-LED RED GPIO_REL4_INV , // GPIO05 LED1 0 , 0 , 0 , 0 , 0 , 0 , // GPIO06-GPIO11 GPIO_REL3_INV , // GPIO12 LED3 GPIO_PWM1 , // GPIO13 PWM for dimmer GPIO_REL2_INV , // GPIO14 LED2 GPIO_SWT1 , // GPIO15 ON/OFF Button, ties to 3.3v when pushed GPIO_SWT4 , // GPIO16 RESET button, also goes to AC side and probably resets the STC chip, tied to LED1 0 // ADC0 Analog input } FADE ON: Makes the PWM movements smooth DIMMER +/-: Moves dimmer up and down SPEED 3: Slows down fade a little SETOPTION15 1: Sets DIMMER mode rather than PWM Now that you can have rules set on dimmer actions, changing the LEDs with dimmer settings should be easy. I tried to do this before that existed, and it wasn't possible.","title":"Info on the Tuya"},{"location":"devices/Mirabella-Genio-Bulb/","text":"Mirabella Genio Bulb ~ Mirabella have released a few smart bulbs. Here is a bit of a guide on how to flash them with Tasmota. There are two ways: Over the Air (OTA) or via Serial. Flashing Over the Air ~ Flashing over the air requires running a linux shell script called tuya-convert and hence requires a computer (I used a Raspberry PI 3) with a wifi adaptor that supports AP mode. There are options if you run Windows to use either a virtual machine (it is reported that KALI Linux running on VMWare has worked) or potentially a live usb (I haven't tested it). Follow this procedure . To get the bulb into config mode, have the bulb on for at least 10 seconds, then cycle it off and on 3 times via a physical light switch. The bulb should flash rapidly when its in config mode. Tasmota v6.4.1 basic build is included as part of the tuya-convert script. It will open an WiFi access point named sonoff-XXX on the bulb once flashed correctly. Flashing via Serial ~ Flashing via Serial requires disassembling the bulb and soldiering wires to the board. Note: modifying these bulbs is dangerous if you do not understand what you are doing, please do so at your own risk! Mirabella Bulbs Disassembling bulb ~ The 2 main outer parts of the bulb are stuck together with high temp silicone or something similar. Squeeze the outer of the bulb (the bit that looks like glass) as near to the join as possible, you can use a tool like a spudger or something if that helps to break the seal, being careful not to damage any internal parts or cut yourself! Once the outer (fake glass) is removed you will see this: Carefully cut / scrape away as much of the sealent on the outer edge of the round circut board then using some needle nose pliers and your spudger pry the round board out. If you are really good at soldering and have a fine tip on your iron you could possibly skip this step and jump straight to the next one. B22 Stand the bulb up and de-solder the 2 pads, and straighten the wires to remove the board. E27 Using a sharp strong blade carefully pry out the small terminal on the end of the bulb then straighten the wire in side This will allow you to pull the board out a little and get enough angle on it to make soldering easier. You should now have these parts (E27 bulb will be still partly assembled): B22 E27 (with wires added) Connect FTDI ~ Connect your FTDI up to these pins: Flash with your preferred method I use this one (remember to connect GPIO0 to GND when plugging in your FTDI this will force the ESP into firmware write mode, you may need to try it a couple of times. Module Settings ~ Once flashed I use termite (or you could use any serial command tool) to send my settings: Note: Change these to match your environment Backlog SSID1 YOUR_SSID_NAME; Password1 YOUR_WIFI_PASSWORD; MqttHost MQTT_INTERNAL_IP_ADDRESS; MqttUser MQTT_USER_NAME; MqttPassword MQTT_PASSWORD; module 38;topic bulb1; FriendlyName Bulb1 Or set manually from the web interface: Dimmable warm white or cool white bulbs ~ Tunable warm/cool white bulbs ~ I based these settings on the RGBW settings. I would have thought PWM1-3 were redundant, but have only had it work with all of these assigned as per below. The bulb is then tunable, with a brightness slider and a cool/warm slider. Module type => Generic D2 GPIO4 => PWM1 (37) D1 GPIO5 => PWM4 (40) D6 GPIO12 => PWM2\ufffc (38) D7 GPIO13 => PWM5 (41) D5 GPIO14 => PWM3\ufffc (39) RGBW colour bulbs ~ Module type = Generic D2 GPIO4 = PWM1 37 = Red D6 GPIO12 = PWM2 38 = Green D5 GPIO14 = PWM3 39 = Blue D1 GPIO5 = PWM4 = White Re-assembly ~ Re-assembly procedure is the reverse of the disassemble procedure!","title":"Mirabella Genio Bulb"},{"location":"devices/Mirabella-Genio-Bulb/#mirabella-genio-bulb","text":"Mirabella have released a few smart bulbs. Here is a bit of a guide on how to flash them with Tasmota. There are two ways: Over the Air (OTA) or via Serial.","title":"Mirabella Genio Bulb"},{"location":"devices/Mirabella-Genio-Bulb/#flashing-over-the-air","text":"Flashing over the air requires running a linux shell script called tuya-convert and hence requires a computer (I used a Raspberry PI 3) with a wifi adaptor that supports AP mode. There are options if you run Windows to use either a virtual machine (it is reported that KALI Linux running on VMWare has worked) or potentially a live usb (I haven't tested it). Follow this procedure . To get the bulb into config mode, have the bulb on for at least 10 seconds, then cycle it off and on 3 times via a physical light switch. The bulb should flash rapidly when its in config mode. Tasmota v6.4.1 basic build is included as part of the tuya-convert script. It will open an WiFi access point named sonoff-XXX on the bulb once flashed correctly.","title":"Flashing Over the Air"},{"location":"devices/Mirabella-Genio-Bulb/#flashing-via-serial","text":"Flashing via Serial requires disassembling the bulb and soldiering wires to the board. Note: modifying these bulbs is dangerous if you do not understand what you are doing, please do so at your own risk! Mirabella Bulbs","title":"Flashing via Serial"},{"location":"devices/Mirabella-Genio-Bulb/#disassembling-bulb","text":"The 2 main outer parts of the bulb are stuck together with high temp silicone or something similar. Squeeze the outer of the bulb (the bit that looks like glass) as near to the join as possible, you can use a tool like a spudger or something if that helps to break the seal, being careful not to damage any internal parts or cut yourself! Once the outer (fake glass) is removed you will see this: Carefully cut / scrape away as much of the sealent on the outer edge of the round circut board then using some needle nose pliers and your spudger pry the round board out. If you are really good at soldering and have a fine tip on your iron you could possibly skip this step and jump straight to the next one.","title":"Disassembling bulb"},{"location":"devices/Mirabella-Genio-Bulb/#connect-ftdi","text":"Connect your FTDI up to these pins: Flash with your preferred method I use this one (remember to connect GPIO0 to GND when plugging in your FTDI this will force the ESP into firmware write mode, you may need to try it a couple of times.","title":"Connect FTDI"},{"location":"devices/Mirabella-Genio-Bulb/#module-settings","text":"Once flashed I use termite (or you could use any serial command tool) to send my settings: Note: Change these to match your environment Backlog SSID1 YOUR_SSID_NAME; Password1 YOUR_WIFI_PASSWORD; MqttHost MQTT_INTERNAL_IP_ADDRESS; MqttUser MQTT_USER_NAME; MqttPassword MQTT_PASSWORD; module 38;topic bulb1; FriendlyName Bulb1 Or set manually from the web interface:","title":"Module Settings"},{"location":"devices/Mirabella-Genio-Bulb/#dimmable-warm-white-or-cool-white-bulbs","text":"","title":"Dimmable warm white or cool white bulbs"},{"location":"devices/Mirabella-Genio-Bulb/#tunable-warmcool-white-bulbs","text":"I based these settings on the RGBW settings. I would have thought PWM1-3 were redundant, but have only had it work with all of these assigned as per below. The bulb is then tunable, with a brightness slider and a cool/warm slider. Module type => Generic D2 GPIO4 => PWM1 (37) D1 GPIO5 => PWM4 (40) D6 GPIO12 => PWM2\ufffc (38) D7 GPIO13 => PWM5 (41) D5 GPIO14 => PWM3\ufffc (39)","title":"Tunable warm/cool white bulbs"},{"location":"devices/Mirabella-Genio-Bulb/#rgbw-colour-bulbs","text":"Module type = Generic D2 GPIO4 = PWM1 37 = Red D6 GPIO12 = PWM2 38 = Green D5 GPIO14 = PWM3 39 = Blue D1 GPIO5 = PWM4 = White","title":"RGBW colour bulbs"},{"location":"devices/Mirabella-Genio-Bulb/#re-assembly","text":"Re-assembly procedure is the reverse of the disassemble procedure!","title":"Re-assembly"},{"location":"devices/Mirabella-Genio-Smart-Plug/","text":"Mirabella Genio Smart Plug ~ This is a simple smart plug with the addition of a USB port, as far as I can see the USB port is 'always on' and is not access this from the ESP module. Opening up the device was easy, 2 screws then a small amount of gentle prying exposed the components, 2 more screws had it fully deconstructed. The ESP module is mounted on a pcb with all of the required pins exposed. I was able to flash by connecting GPIO0 to GND while connecting my Serial Adaptor and flashing as per any other ESP device Use the string below from the console of the device to configure everything (replace required data with your own SSID, Password, MQTT Settings etc.): Backlog SSID1 YOUR_SSID_NAME; Password1 YOUR_WIFI_PASSWORD; MqttHost MQTT_INTERNAL_IP_ADDRESS; MqttUser MQTT_USER_NAME; MqttPassword MQTT_PASSWORD; GPIO2 56; GPIO12 21; GPIO13 17;topic genio1; FriendlyName Genio1 my prefered flashing method Once flashed, the config should look like:","title":"Mirabella Genio Smart Plug"},{"location":"devices/Mirabella-Genio-Smart-Plug/#mirabella-genio-smart-plug","text":"This is a simple smart plug with the addition of a USB port, as far as I can see the USB port is 'always on' and is not access this from the ESP module. Opening up the device was easy, 2 screws then a small amount of gentle prying exposed the components, 2 more screws had it fully deconstructed. The ESP module is mounted on a pcb with all of the required pins exposed. I was able to flash by connecting GPIO0 to GND while connecting my Serial Adaptor and flashing as per any other ESP device Use the string below from the console of the device to configure everything (replace required data with your own SSID, Password, MQTT Settings etc.): Backlog SSID1 YOUR_SSID_NAME; Password1 YOUR_WIFI_PASSWORD; MqttHost MQTT_INTERNAL_IP_ADDRESS; MqttUser MQTT_USER_NAME; MqttPassword MQTT_PASSWORD; GPIO2 56; GPIO12 21; GPIO13 17;topic genio1; FriendlyName Genio1 my prefered flashing method Once flashed, the config should look like:","title":"Mirabella Genio Smart Plug"},{"location":"devices/Modify-KaKu-to-WKaKu-Power-Socket/","text":"The Dutch Klik Aan Klik Uit PAR-1000 434MHz Power socket might suffer from Capacitor degeneration. In effect the power needed to engage the relay is too low. Replacing the Yellow Capacitor often solves the problem. I have several of these lying around and they can be used very well with sonoff functionality. As the sonoff PCA is a bit too large I decided to design my own PCA using kicad. During Proof of Concept I used 5V power supplies from itead. After three units were built one crashed caused by debris on the PS PCA resulting in an AC short which in turn blew the large resistor. As the selected Songle relay has the control leads close to the AC leads I also changed the relay. I decided to select the HiLink 5V power supply as it was also favourable on other sites. The relay now has the same connections as the one used in sonoff. The parts used are: = HiLink 5V power supply HLK-PM01 (aliexpress) = 5V to 3V3 step down (aliexpress) = 5V relay OJE-SH-105DM (ebay) = ESP12-F (aliexpress) = Capacitors and led from kaku PCA = 2 x 1k and 1 x 10k Resistors The image on the right shows how I mounted the ESP12-F vertically. Notice the 10k resistor from GPIO15 to the board. The firmware used is sonoff without modification!","title":"Modify KaKu to WKaKu Power Socket"},{"location":"devices/NEO-COOLCAM-NAS-WR01W/","text":"I got NEO and managed install tasmota on it. https://www.amazon.de/dp/B07KJGHXCQ * IMPORTANT: * I checked PCB and it is not solid for long use and high power. All contact are very cheap, also there is no POW. I can recommend user other SmartPlug AISIRER, AVATAR (see on tasmota main page), 2 euro difference, but much more solid + onboard POW. All details are into Espurna page https://github.com/xoseperez/espurna/wiki/Hardware-NEO-COOLCAM-NAS-WR01W","title":"NEO COOLCAM NAS WR01W"},{"location":"devices/Nedis-WIFIP310FWT/","text":"ATTENTION! Verifying/updating this currently. This setup is not 100% accurate. 20190327 Template: {\"NAME\":\"Nedis WIFIP310\",\"GPIO\":[0,56,0,17,22,21,0,0,0,23,24,0,0],\"FLAG\":1,\"BASE\":18} Description: 3 port AC outlets (European Schucko Type F) + 4 USB power outlets Power input: 16 A - 230 VAC Max. Power: 3680 W Power output: USB: 5 VDC /2.4 A each Product page - Swedish Product page - English","title":"Nedis WIFIP310FWT"},{"location":"devices/Novostella-B22-RGB-LED-Colour-WiFi-Smart-Bulb/","text":"Novostella B22 RGB LED Colour WiFi Smart Bulb https://www.amazon.co.uk/gp/product/B07DN4NLKM?ref_=oh_aui_search_asin_title&psc=1&pldnSite=1 Easily flashed OTA. GPIO is as follows. GPIO4 = PWM1 GPIO5 = PWM5 GPIO12 = PWM2 GPIO13 = PWM4 GPIO14 = PWM3","title":"Novostella B22 RGB LED Colour WiFi Smart Bulb"},{"location":"devices/OBI-Socket-2/","text":"OBI Socket 2 ~ Supported since version 6.4.1.8 as OBI Socket 2 (61) Another cheap socket from the German Hardware Store, based on ESP-WROOM-02 with 2MB Flash. Smaller form factor as the first OBI Socket. \u26a0\ufe0f\ufe0f Special Attention \u26a0\ufe0f\ufe0f ~ DO NOT try to flash the module when it is connected to mains AC power. You WILL brick or destroy the device and your computer or USB Port and get electrocutes! Use only a 3.3V USB adapter for flashing DO NOT CONNECT ANYTHING TO THESE DEVICES!!! (No sensors, no switches, nothing) The OBI Socket 2 has no transformer to isolate the mains voltage. The entire circuit is at mains-level voltage! Only use the device as designed. One way to flash the module is soldering 4 wires to the RX/TX/3V3/GND pins from the ESP. The PCB has no serial pinout connector. For flashing the module enable the flash mode of the ESP, connect GPIO 0 to GND. Another way to flash is soldering 4 wires to the bottom side of the PCB as described on https://github.com/mattzzw/obi_socket/wiki/OBI-socket. If you follow that approach of powering the socket with 5V (which enables the relay coil allowing for acoustic feedback) you need to make sure to nevertheless use 3V3 for the actual serial interface to the module!!! This happens to work out very nicely with the popular cheap CH340 USB to Serial TTL adapters which come with a jumper to select between 5V and 3.3V. Setting the adapter to 3.3V by putting the jumper on the 3V3 and VCC pins leaves the 5V pin free. That pin is directly connected to the USB port. So you can just connect the four wires from the socket to the four free pins of the CH340 adapter :-) If you want the green Wi-Fi LED to work, please use version 6.4.1.8+. You can either use \"Obi Socket 2 Type (61)\" (with default behaviour \"Wi-Fi LED = off\" when connected) or use \"Generic (18)\" for manually override. See issue 4567 for details. PCB serial pinouts ~ PCB serial pinouts (back) ~ ( Note: Same PCB as OBI Socket IP44 (Black) )","title":"OBI Socket 2"},{"location":"devices/OBI-Socket-2/#obi-socket-2","text":"Supported since version 6.4.1.8 as OBI Socket 2 (61) Another cheap socket from the German Hardware Store, based on ESP-WROOM-02 with 2MB Flash. Smaller form factor as the first OBI Socket.","title":"OBI Socket 2"},{"location":"devices/OBI-Socket-2/#special-attention","text":"DO NOT try to flash the module when it is connected to mains AC power. You WILL brick or destroy the device and your computer or USB Port and get electrocutes! Use only a 3.3V USB adapter for flashing DO NOT CONNECT ANYTHING TO THESE DEVICES!!! (No sensors, no switches, nothing) The OBI Socket 2 has no transformer to isolate the mains voltage. The entire circuit is at mains-level voltage! Only use the device as designed. One way to flash the module is soldering 4 wires to the RX/TX/3V3/GND pins from the ESP. The PCB has no serial pinout connector. For flashing the module enable the flash mode of the ESP, connect GPIO 0 to GND. Another way to flash is soldering 4 wires to the bottom side of the PCB as described on https://github.com/mattzzw/obi_socket/wiki/OBI-socket. If you follow that approach of powering the socket with 5V (which enables the relay coil allowing for acoustic feedback) you need to make sure to nevertheless use 3V3 for the actual serial interface to the module!!! This happens to work out very nicely with the popular cheap CH340 USB to Serial TTL adapters which come with a jumper to select between 5V and 3.3V. Setting the adapter to 3.3V by putting the jumper on the 3V3 and VCC pins leaves the 5V pin free. That pin is directly connected to the USB port. So you can just connect the four wires from the socket to the four free pins of the CH340 adapter :-) If you want the green Wi-Fi LED to work, please use version 6.4.1.8+. You can either use \"Obi Socket 2 Type (61)\" (with default behaviour \"Wi-Fi LED = off\" when connected) or use \"Generic (18)\" for manually override. See issue 4567 for details.","title":"\u26a0\ufe0f\ufe0f  Special Attention   \u26a0\ufe0f\ufe0f"},{"location":"devices/OBI-Socket-2/#pcb-serial-pinouts","text":"","title":"PCB serial pinouts"},{"location":"devices/OBI-Socket-2/#pcb-serial-pinouts-back","text":"( Note: Same PCB as OBI Socket IP44 (Black) )","title":"PCB serial pinouts (back)"},{"location":"devices/OBI-WiFi-Socket-IP44/","text":"Overview ~ This WiFi socket is a cheap outdoor alternative to the popular low-cost indoor WiFi socket \"Wifi Stecker Schuko Wei\u00df\" from the German Diy-warehouse OBI. It is equipped with a ESP-WROOM-02 module. Sadly, there is no programming pin header and it can be kind of tricky to get the module into programming state (see below). You'll need some soldering skills to attach the programming wires. Where to buy ~ The Outdoor Wifi Socket is only available in the OBI Diy-Warehouse. It's \"official name\" is \"Wifi Stecker Schuko Schwarz\". It can also be bought in the OBI online-store Open the socket ~ Opening the socket is kind of difficult. The case is held together by two Tri-Wing screws, two tiny cross-head/PH screws, some sealing grease in the screw holes and some glue. First, you can remove the sealing grease out of the screw holes by using a matching drill. Drill out the sealing grease by turning it by hand, until you reach the screw head. After this, you can use the matching screw driver. The eventually remaining sealing grease will move aside. Tipp: Afterwards use normal cross screws to close the casing. After this its getting tricky: use a stable knife or a flat screw driver to carefully crack up the two halfs of the case. In any case, try to NOT cut up your hands! Connection ~ For convenient access to the programming pins, you can solder jump wires to the corresponding pads of the WROOM module. After successfully reprogramming the module, you can fold the wires into the socket in case of further tinkering. ( Note: Same PCB as OBI Socket 2 ! ) Entering programming mode ~ Connect GPIO0 to GND before connecting power to enable flash mode! GPIO Config ~","title":"OBI WiFi Socket IP44"},{"location":"devices/OBI-WiFi-Socket-IP44/#overview","text":"This WiFi socket is a cheap outdoor alternative to the popular low-cost indoor WiFi socket \"Wifi Stecker Schuko Wei\u00df\" from the German Diy-warehouse OBI. It is equipped with a ESP-WROOM-02 module. Sadly, there is no programming pin header and it can be kind of tricky to get the module into programming state (see below). You'll need some soldering skills to attach the programming wires.","title":"Overview"},{"location":"devices/OBI-WiFi-Socket-IP44/#where-to-buy","text":"The Outdoor Wifi Socket is only available in the OBI Diy-Warehouse. It's \"official name\" is \"Wifi Stecker Schuko Schwarz\". It can also be bought in the OBI online-store","title":"Where to buy"},{"location":"devices/OBI-WiFi-Socket-IP44/#open-the-socket","text":"Opening the socket is kind of difficult. The case is held together by two Tri-Wing screws, two tiny cross-head/PH screws, some sealing grease in the screw holes and some glue. First, you can remove the sealing grease out of the screw holes by using a matching drill. Drill out the sealing grease by turning it by hand, until you reach the screw head. After this, you can use the matching screw driver. The eventually remaining sealing grease will move aside. Tipp: Afterwards use normal cross screws to close the casing. After this its getting tricky: use a stable knife or a flat screw driver to carefully crack up the two halfs of the case. In any case, try to NOT cut up your hands!","title":"Open the socket"},{"location":"devices/OBI-WiFi-Socket-IP44/#connection","text":"For convenient access to the programming pins, you can solder jump wires to the corresponding pads of the WROOM module. After successfully reprogramming the module, you can fold the wires into the socket in case of further tinkering. ( Note: Same PCB as OBI Socket 2 ! )","title":"Connection"},{"location":"devices/OBI-WiFi-Socket-IP44/#entering-programming-mode","text":"Connect GPIO0 to GND before connecting power to enable flash mode!","title":"Entering programming mode"},{"location":"devices/OBI-WiFi-Socket-IP44/#gpio-config","text":"","title":"GPIO Config"},{"location":"devices/OBI-Wifi-Socket/","text":"Where to buy ~ As shown in the name the Wifi Socket is only available in the OBI Diy-Warehouse. It can also be bought in the OBI online-store Open the socket ~ Opening the socket is kind of difficult. If you have one of the Tri-Wing screwdrivers it is much more easier. If you haven't got use a normal head screwdriver. Be careful not damaging your hand with it. Tipp: Afterwards use normal cross screws to close the casing. Connection ~ ESP Programmer VCC 3V3 TX RX RX TX GND GND Connect GPIO0 to GND before connecting power to enable flash mode! Additional Information ~ A low pulse on GPIO12 switches the relay on, a low pulse on GPIO5 switches it off. I have solved the 'pulse issue' by setting GPIO12 to always 0 (as LED) and works fine. More Infos can be found here: #1988 . Initial Configuration ~ In the default configuration GPIO0 (which is also used to enable flash-mode) is setup as a Button. To enable AP-Mode and setup the correct GPIOs as described below, You can short GPIO0 to GND 4 times as if it was a button (see [[Button-usage]]) Using this method allows you to flash a precompiled binary Device Images ~ (images from https://github.com/martin-ger/ESP8266-WiFi-Socket) GPIO Config ~ UPDATE: with Tasmota 6.3.0 you have fully monitoring support (Add support for OBI Power Socket (#1988, #3944)) ** Beginning 6.3.0, no need to choose type 18 anymore, use type 51 Obi Socket *","title":"OBI Wifi Socket"},{"location":"devices/OBI-Wifi-Socket/#where-to-buy","text":"As shown in the name the Wifi Socket is only available in the OBI Diy-Warehouse. It can also be bought in the OBI online-store","title":"Where to buy"},{"location":"devices/OBI-Wifi-Socket/#open-the-socket","text":"Opening the socket is kind of difficult. If you have one of the Tri-Wing screwdrivers it is much more easier. If you haven't got use a normal head screwdriver. Be careful not damaging your hand with it. Tipp: Afterwards use normal cross screws to close the casing.","title":"Open the socket"},{"location":"devices/OBI-Wifi-Socket/#connection","text":"ESP Programmer VCC 3V3 TX RX RX TX GND GND Connect GPIO0 to GND before connecting power to enable flash mode!","title":"Connection"},{"location":"devices/OBI-Wifi-Socket/#additional-information","text":"A low pulse on GPIO12 switches the relay on, a low pulse on GPIO5 switches it off. I have solved the 'pulse issue' by setting GPIO12 to always 0 (as LED) and works fine. More Infos can be found here: #1988 .","title":"Additional Information"},{"location":"devices/OBI-Wifi-Socket/#initial-configuration","text":"In the default configuration GPIO0 (which is also used to enable flash-mode) is setup as a Button. To enable AP-Mode and setup the correct GPIOs as described below, You can short GPIO0 to GND 4 times as if it was a button (see [[Button-usage]]) Using this method allows you to flash a precompiled binary","title":"Initial Configuration"},{"location":"devices/OBI-Wifi-Socket/#device-images","text":"(images from https://github.com/martin-ger/ESP8266-WiFi-Socket)","title":"Device Images"},{"location":"devices/OBI-Wifi-Socket/#gpio-config","text":"UPDATE: with Tasmota 6.3.0 you have fully monitoring support (Add support for OBI Power Socket (#1988, #3944)) ** Beginning 6.3.0, no need to choose type 18 anymore, use type 51 Obi Socket *","title":"GPIO Config"},{"location":"devices/Oittm-Smart-Plug/","text":"Oittm Smart Plug ~ Oittm provides a relatively cheap Wifi smart plug with an ESP8266, too. To enable the flash mode of the ESP connect GPIO 0 to GND. The wires have to be soldered directly onto the ESP chip itself, it won't work otherwise. Opening the device ~ Remove the small plastics caps on the back and unscrew the first two screws and then again the next ones PCB layout ~ !!Make sure to flash with 3.3V and disconnect the power plug from the power outlet before!! Web configuration ~ If you want the blue LED instead of the red one, use Led2i","title":"Oittm Smart Plug"},{"location":"devices/Oittm-Smart-Plug/#oittm-smart-plug","text":"Oittm provides a relatively cheap Wifi smart plug with an ESP8266, too. To enable the flash mode of the ESP connect GPIO 0 to GND. The wires have to be soldered directly onto the ESP chip itself, it won't work otherwise.","title":"Oittm Smart Plug"},{"location":"devices/Oittm-Smart-Plug/#opening-the-device","text":"Remove the small plastics caps on the back and unscrew the first two screws and then again the next ones","title":"Opening the device"},{"location":"devices/Oittm-Smart-Plug/#pcb-layout","text":"!!Make sure to flash with 3.3V and disconnect the power plug from the power outlet before!!","title":"PCB layout"},{"location":"devices/Oittm-Smart-Plug/#web-configuration","text":"","title":"Web configuration"},{"location":"devices/Other-Devices/","text":"This page is here for archival purposes. For new devices use Tasmota Device Templates Repository ! New submissions here will not be approved. ~ Relays/Sonoff Basic Clones ~ WL-SW01_10 WiFi Smart Switch - Sonoff Basic in a different form factor Canwing CW001 5A LC Technology WiFi Relay EXS Relay V3.1 & V5.1 Ledunia and NodeMcu Plugs/Sockets ~ Lingan SWA1 Hyleton 313 Smart Plug Teckin SP23 LA-WF3 Wifi Plug (Tuya TYWE2S) - Costco No-Brand Smart Plug with Tuya-based ESP8266MOD and ESP-12F modules WiOn 50055 Indoor Wi-Fi Switch With USB (support for relay and switch only - no power monitoring yet. See status here #82 .) SM-SO301 4 mains Power Strip with 4 USB ports LeFun SK2 Smart Power Strip with 4 Mains + 4 USB meross MSS425 Smart Power Strip Gosund SP1 SWB1 Wi-Fi Smart Power Strip Kesen KS-604S Dual Outlet Oittm Smart Plug Mirabella Genio Smart Plug CE Smart Home\u2122 Garden Power Stake 4CH-Wifi-Socket-with-USB-Charger (Tuya TYWE2S) Anoopsyche JH-G01B1 RGB Smart Socket with Power Monitor 16A EU Supernight Dual Wifi Plug TMRLife Plug or Home Awesome Plug SmartPlug AISIRER, AVATAR with POW SmartPlug NEO COOLCAM NAS WR01W Slitinto NX SP202 Wall Switches/Dimmers ~ KS-602 based switches like GresaTek, Jesiya, NewRice, Lyasi etc Smart Light Switch - SS118-01K1 KMC 70008 Light Switch KS-602S Smart Wifi Light Switch Xenon SM-SW102-2 two-relay light switch Martin Jerry MJ-SD01 Smart Dimmer KingArt N1 - Other Sonoff T1 clone, flash works also on KingArt N2 (2 gangs) KingArt Dimmer Same as above, but a dimmer Lights/LED Controllers ~ SP108E LED strip controller WS03 LED Controller Luminea-ZX-2844-675 Mirabella Genio Smart Bulb Kohree VHP560 Smart Light Compatible, RGBCW Wi-Fi LED Bulb A19 Novostella B22 RGBW Smart Light Xiaomi Mi Desk Lamp Out of production devices ~ ITead Motor Clockwise/ Anticlockwise Running WiFi Wireless Switch PowStro - Sonoff Basic clone SmartHome - Sonoff Basic clone YUNTONG Smart - Sonoff Basic clone CSL (aplic WDP 303075) SM-PW701E Socket Board: (Tuya TYWE3S) WK30 (Tuya TYWE3S) Hompie-SWS1 (Tuya TYWE3S) Burnett BN K01 Smart Socket CNSKOU / CNSANKOU wall switches - Chinese Sonoff T1 clones","title":"Other Devices"},{"location":"devices/Other-Devices/#this-page-is-here-for-archival-purposes-for-new-devices-use-tasmota-device-templates-repository-new-submissions-here-will-not-be-approved","text":"","title":"This page is here for archival purposes. For new devices use Tasmota Device Templates Repository! New submissions here will not be approved."},{"location":"devices/Other-Devices/#relayssonoff-basic-clones","text":"WL-SW01_10 WiFi Smart Switch - Sonoff Basic in a different form factor Canwing CW001 5A LC Technology WiFi Relay EXS Relay V3.1 & V5.1 Ledunia and NodeMcu","title":"Relays/Sonoff Basic Clones"},{"location":"devices/Other-Devices/#plugssockets","text":"Lingan SWA1 Hyleton 313 Smart Plug Teckin SP23 LA-WF3 Wifi Plug (Tuya TYWE2S) - Costco No-Brand Smart Plug with Tuya-based ESP8266MOD and ESP-12F modules WiOn 50055 Indoor Wi-Fi Switch With USB (support for relay and switch only - no power monitoring yet. See status here #82 .) SM-SO301 4 mains Power Strip with 4 USB ports LeFun SK2 Smart Power Strip with 4 Mains + 4 USB meross MSS425 Smart Power Strip Gosund SP1 SWB1 Wi-Fi Smart Power Strip Kesen KS-604S Dual Outlet Oittm Smart Plug Mirabella Genio Smart Plug CE Smart Home\u2122 Garden Power Stake 4CH-Wifi-Socket-with-USB-Charger (Tuya TYWE2S) Anoopsyche JH-G01B1 RGB Smart Socket with Power Monitor 16A EU Supernight Dual Wifi Plug TMRLife Plug or Home Awesome Plug SmartPlug AISIRER, AVATAR with POW SmartPlug NEO COOLCAM NAS WR01W Slitinto NX SP202","title":"Plugs/Sockets"},{"location":"devices/Other-Devices/#wall-switchesdimmers","text":"KS-602 based switches like GresaTek, Jesiya, NewRice, Lyasi etc Smart Light Switch - SS118-01K1 KMC 70008 Light Switch KS-602S Smart Wifi Light Switch Xenon SM-SW102-2 two-relay light switch Martin Jerry MJ-SD01 Smart Dimmer KingArt N1 - Other Sonoff T1 clone, flash works also on KingArt N2 (2 gangs) KingArt Dimmer Same as above, but a dimmer","title":"Wall Switches/Dimmers"},{"location":"devices/Other-Devices/#lightsled-controllers","text":"SP108E LED strip controller WS03 LED Controller Luminea-ZX-2844-675 Mirabella Genio Smart Bulb Kohree VHP560 Smart Light Compatible, RGBCW Wi-Fi LED Bulb A19 Novostella B22 RGBW Smart Light Xiaomi Mi Desk Lamp","title":"Lights/LED Controllers"},{"location":"devices/Other-Devices/#out-of-production-devices","text":"ITead Motor Clockwise/ Anticlockwise Running WiFi Wireless Switch PowStro - Sonoff Basic clone SmartHome - Sonoff Basic clone YUNTONG Smart - Sonoff Basic clone CSL (aplic WDP 303075) SM-PW701E Socket Board: (Tuya TYWE3S) WK30 (Tuya TYWE3S) Hompie-SWS1 (Tuya TYWE3S) Burnett BN K01 Smart Socket CNSKOU / CNSANKOU wall switches - Chinese Sonoff T1 clones","title":"Out of production devices"},{"location":"devices/PS-16-DZ-Dimmer/","text":"PS-16-DZ Dimmer ~ The PS-16-DZ dimmer uses eWeLink app same as Sonoff devices. It's available from Amazon and Aliexpress . It may under different name, but the model number is PS-16-DZ. Pics ~ Opened it up, found a ESP8285 and a Nuvoton N76E003. Flash and GPIO pins ~ Remove the ESP8285 daughter card DLX-MKCK01 from the main board and flash Tasmota. pin1 RST -> N76E003 P0.5/PWM2 pin2 TXD -> N76E003 P0.7/RXD pin3 RXD -> N76E003 P0.6/TXD pin4 GPIO13/MTCK -> LED pin5 3.3V pin6 GND Communication between ESP8285 and N76E003 ~ It uses AT command to communicate between ESP8285 and N76E003 over UART at 19200 baud. Turn on the switch from ESP8266 : Send from ESP8266 AT + UPDATE = \"sequence\" : \"1528335040032\" , \"switch\" : \"on\" Receive from MCU AT + RESULT = \"sequence\" : 1528335040032 \" Send from ESP8266: AT+SEND=ok After 0.7s Receive from MCU AT+UPDATE=\" switch \":\" on \",\" bright \":44 Send from ESP8266: AT+SEND=ok Turn off the switch from ESP8266: Send from ESP8266 AT+UPDATE=\" sequence \":\" 1528335118327 \",\" switch \":\" off \" Receive from MCU AT+RESULT=\" sequence \":1528335118327\" Send from ESP8266 : AT + SEND = ok After 0 . 7 s Receive from MCU AT + UPDATE = \"switch\" : \"on\" , \"bright\" : 44 Send from ESP8266 : AT + SEND = ok Change brightness to 44 from ESP8266 : Send from ESP8266 : AT + UPDATE = \"sequence\" : \"1528335181502\" , \"bright\" : 44 Receive from MCU AT + RESULT = \"sequence\" : 1528335181502 \" Send from ESP8266: AT+SEND=ok After 0.7s Receive from MCU AT+UPDATE=\" switch \":\" on \",\" bright \":44 Send from ESP8266: AT+SEND=ok Turn on the switch with faceplate button: Received from MCU AT+UPDATE=\" switch \":\" on \",\" bright \":44 Send from ESP8266: AT+SEND=ok Turn off the switch with faceplate button: Received from MCU AT+UPDATE=\" switch \":\" off \",\" bright \":44 Send from ESP8266: AT+SEND=ok Change the brightness to 52 with faceplate button: Received from MCU AT+UPDATE=\" switch \":\" on \",\" bright \" : 52 Send from ESP8266 : AT + SEND = ok Holding the middle button on faceplate to reset the device : Received from MCU AT + SETTING = enterESPTOUCH Send from ESP8266 : AT + SETTING = enterESPTOUCH The sequence number is a 13 digits unix timestamp (in milliseconds). The data after \"bright\" is the brightness. The maximum of the brightness is 100 and the minimum is 10. There is one byte 0x1B at the end of each AT command.","title":"PS-16-DZ Dimmer"},{"location":"devices/PS-16-DZ-Dimmer/#ps-16-dz-dimmer","text":"The PS-16-DZ dimmer uses eWeLink app same as Sonoff devices. It's available from Amazon and Aliexpress . It may under different name, but the model number is PS-16-DZ.","title":"PS-16-DZ Dimmer"},{"location":"devices/PS-16-DZ-Dimmer/#pics","text":"Opened it up, found a ESP8285 and a Nuvoton N76E003.","title":"Pics"},{"location":"devices/PS-16-DZ-Dimmer/#flash-and-gpio-pins","text":"Remove the ESP8285 daughter card DLX-MKCK01 from the main board and flash Tasmota. pin1 RST -> N76E003 P0.5/PWM2 pin2 TXD -> N76E003 P0.7/RXD pin3 RXD -> N76E003 P0.6/TXD pin4 GPIO13/MTCK -> LED pin5 3.3V pin6 GND","title":"Flash and GPIO pins"},{"location":"devices/PS-16-DZ-Dimmer/#communication-between-esp8285-and-n76e003","text":"It uses AT command to communicate between ESP8285 and N76E003 over UART at 19200 baud. Turn on the switch from ESP8266 : Send from ESP8266 AT + UPDATE = \"sequence\" : \"1528335040032\" , \"switch\" : \"on\" Receive from MCU AT + RESULT = \"sequence\" : 1528335040032 \" Send from ESP8266: AT+SEND=ok After 0.7s Receive from MCU AT+UPDATE=\" switch \":\" on \",\" bright \":44 Send from ESP8266: AT+SEND=ok Turn off the switch from ESP8266: Send from ESP8266 AT+UPDATE=\" sequence \":\" 1528335118327 \",\" switch \":\" off \" Receive from MCU AT+RESULT=\" sequence \":1528335118327\" Send from ESP8266 : AT + SEND = ok After 0 . 7 s Receive from MCU AT + UPDATE = \"switch\" : \"on\" , \"bright\" : 44 Send from ESP8266 : AT + SEND = ok Change brightness to 44 from ESP8266 : Send from ESP8266 : AT + UPDATE = \"sequence\" : \"1528335181502\" , \"bright\" : 44 Receive from MCU AT + RESULT = \"sequence\" : 1528335181502 \" Send from ESP8266: AT+SEND=ok After 0.7s Receive from MCU AT+UPDATE=\" switch \":\" on \",\" bright \":44 Send from ESP8266: AT+SEND=ok Turn on the switch with faceplate button: Received from MCU AT+UPDATE=\" switch \":\" on \",\" bright \":44 Send from ESP8266: AT+SEND=ok Turn off the switch with faceplate button: Received from MCU AT+UPDATE=\" switch \":\" off \",\" bright \":44 Send from ESP8266: AT+SEND=ok Change the brightness to 52 with faceplate button: Received from MCU AT+UPDATE=\" switch \":\" on \",\" bright \" : 52 Send from ESP8266 : AT + SEND = ok Holding the middle button on faceplate to reset the device : Received from MCU AT + SETTING = enterESPTOUCH Send from ESP8266 : AT + SETTING = enterESPTOUCH The sequence number is a 13 digits unix timestamp (in milliseconds). The data after \"bright\" is the brightness. The maximum of the brightness is 100 and the minimum is 10. There is one byte 0x1B at the end of each AT command.","title":"Communication between ESP8285 and N76E003"},{"location":"devices/PowStro/","text":"Connection ~ Vcc - 3,3V TX - RX RX - TX GND - GND Additional Information ~ PowStro are fake Sonoff Basic, but they still work with Tasmota. More Infos can be found here: #1419 . Device Images ~ GPIO Config ~","title":"PowStro"},{"location":"devices/PowStro/#connection","text":"Vcc - 3,3V TX - RX RX - TX GND - GND","title":"Connection"},{"location":"devices/PowStro/#additional-information","text":"PowStro are fake Sonoff Basic, but they still work with Tasmota. More Infos can be found here: #1419 .","title":"Additional Information"},{"location":"devices/PowStro/#device-images","text":"","title":"Device Images"},{"location":"devices/PowStro/#gpio-config","text":"","title":"GPIO Config"},{"location":"devices/RGB-Smart-Plug-16A/","text":"* Aliexpress: Lonsonho Wifi Smart Socket Power Monitor EU 2 Pin * Aliexpress: RGB Smart Plug * amazon.de: Smart Steckdose, Wechsellicht 16A, WLAN Steckdose Wifi Stecker fernbedienbar, Stromverbrauch messen, funktioniert mit Alexa [Echo, Echo Dot] und Google Home, 4 Packs OTA flashing ~ DEVICE IS DIFFICULT TO DISASSEMBLE SO ANY ERRORS WITH FLASHING OR CONFIGURATION CAN EASILY BRICK IT. DO NOT CONNECT ANY SENSOR TO THESE DEVICES. Only use them as designed. AS ALWAYS, YOU DO ANY OF THIS AT YOUR OWN RISK. Device case is glued so recommended way to flash it is using tuya-convert This method worked for 3 devices that were shipped before December 2019, never paired with Tuya apps and never powered on near open WiFi APs. So they had no chance to download Tuya-Convert updates. It may not work for devices with newer firmware. Prerequisites ~ You'll need a Linux device with both WiFi capable of running in AP mode and ethernet connection Clone/download tuya-convert Run install_prereq.sh Ubuntu only On Ubuntu, it's also necessary to temporary disable WiFi from Network Manager and stop/disable systemd-resolved. Edit /etc/NetworkManager/NetworkManager.conf and add [keyfile] unmanaged-devices = interface-name:wlp2s0 Replace wlp2s0 with your WiFi interface name if neccessary. Then run sudo systemctl restart network-manager.service sudo systemctl disable systemd-resolved.service sudo systemctl stop systemd-resolved.service Don't forget to undo everything after flashing, DNS and WiFi won't work otherwise. Start flashing ~ Run start_flash.sh and follow the instructions Connect any WiFi device to vtrust-flash AP when it asks to and make sure that it gets an IP address. If it doesn't stop and check logs in scripts folder for clues Connect socket to mains and long-press the button to enter pairing mode Tasmota is included with tuya-convert, follow script's instruction to flash it After flashing device should reboot and you should see Tasmota's WiFi AP (Sonoff-xxx). Run stop_flash.sh to shutdown vtrust-flash AP on a machine you used for OTA. Configuration ~ Connect to Tasmota's AP It's extremely important to enter correct WiFi configuration. Button is not on GPIO0 so won't do anything for default Sonoff Basic device profile. It's recommended to temporary enter second WiFi with something easy like SSID: TEST Password: testtest so you could start that AP and re-configure the device if there are any issues with main WiFi connection. After it reboots and successfully connects to WiFi configure it as Blizwolf SHP module Now button and relay should work. Red and Blue LEDs will be used as status LEDs. RGB Light ~ Use this template to configure the device: {\"NAME\":\"RGB Smart Plug\",\"GPIO\":[37,0,39,0,38,134,0,0,131,17,132,21,0],\"FLAG\":0,\"BASE\":45} For older versions: Complete RGB support requires building slightly custom Tasmota. Edit sonoff/sonoff_template.h and replace \"BlitzWolf SHP\" configuration with the following: { \"BlitzWolf SHP\", // BlitzWolf BW-SHP2 and BW-SHP6 (ESP8285 - BL0937 or HJL-01 Energy Monitoring) // https://www.banggood.com/BlitzWolf-BW-SHP2-Smart-WIFI-Socket-EU-Plug-220V-16A-Work-with-Amazon-Alexa-Google-Assistant-p-1292899.html // https://www.amazon.de/Steckdose-Homecube-intelligente-Verbrauchsanzeige-funktioniert/dp/B076Q2LKHG/ref=sr_1_fkmr0_1 // https://www.amazon.de/Intelligente-Stromverbrauch-Fernsteurung-Schaltbare-Energieklasse/dp/B076WZQS4S/ref=sr_1_1 // https://www.aliexpress.com/store/product/BlitzWolf-BW-SHP6-EU-Plug-Metering-Version-WIFI-Smart-Socket-220V-240V-10A-Work-with-Amazon/1965360_32945504669.html GPIO_USER, // GPIO00 Red Led (1 = On, 0 = Off) GPIO_USER, // GPIO01 Serial RXD and Optional sensor GPIO_USER, // GPIO02 Blue Led (1 = On, 0 = Off) GPIO_USER, // GPIO03 Serial TXD and Optional sensor GPIO_USER, // GPIO04 GPIO_HJL_CF, // GPIO05 BL0937 or HJL-01 CF power 0, 0, 0, 0, 0, 0, // Flash connection GPIO_NRG_SEL_INV, // GPIO12 BL0937 or HJL-01 Sel output (0 = Voltage) GPIO_KEY1, // GPIO13 Button GPIO_NRG_CF1, // GPIO14 BL0937 or HJL-01 CF1 current / voltage GPIO_REL1, // GPIO15 Relay (0 = Off, 1 = On) 0, 0 }, Make sure that you don't have wrong WiFi configuration in user_config_override.h. Build and OTA flash it to the device using Tasmota. After it reboots configure as following: [[https://raw.githubusercontent.com/wiki/Astr0/Sonoff-Tasmota/images/lonsonho16a/config.png|Configuration]] RGB and dimming should work now. Disassembling the device ~ This is not recommended. Do it only if you have to or just buy a new one. The device is hard to open and may be damaged. Components inside may have mains charge and electrocute you even if powered off. Do it at your own risk. One of my devices had a hardware issue - constantly losing WiFi, rebooted when wiggled in power socket, rebooted every few seconds on 1250W load, sometimes just hanged and not responded even to the button. Since it wasn't usable at all I tried to fix it. The reason was broken steel input pole inside(what?? how?? WTF??) that was making weak contact, couldn't fix it reliably. Unbend earth connections on the bottom to make them straight. Use a sharp knife to slice through glue between RGB ring and the case. Requires quite a lot of force and time. RGB ring may break in places where glue is stronger than the plastic. Use a screwdriver to pry the case open. Remove button cap Desolder output connections, try not to melt any plastic. Remove support plastic with a screwdriver, it's held to the PCB by two clips. Desolder input poles. This is tricky since there's a lot of solder. I've removed as much of it as possible with desoldering pump, then melted the solder and rotated the poles with pliers while it cooled. Poles are made of steel and steel don't accept solder well. Remove the PCB by lifting it up. It's glued to the case on the bottom by the relay and held tight with input poles so it requires some force. Also, it's not easy to grab the PCB. I've used dip removing tweezers, holding PCB by holes for the earth connectors. I figured out the pinout for flashing the device: Before assembling it back remove as much solder as possible from input and output pole pads. The device fits together very tight, so everything should be perfectly in place. Don't forget to glue the case back. Few observations: * It has ESP8266EX with FM25F08 8Mbit flash. The module has lots of connections, some of them have only pads without tracks on the main board. High chances to find RX and TX there. Obviously, there should be VCC and GND to power up the module. * Uses HJL-01 with a shunt for power monitoring, so every mains power track that looks like it should be covered with solder but is not, probably should be covered with solder :) * It has 4 RGB LEDs. GPIO00-Red, GPIO02-Blue, GPIO04-Green * AFE BPD-SS-105DM 16A 250VAC relay * 16A SMD fuse for mains input * Something that's probably another fuse marked F1 for low-voltage circuitry power * Low-voltage part is not galvanically insulated from mains * There's \"QC Passed\" sticker on the relay","title":"RGB Smart Plug 16A"},{"location":"devices/RGB-Smart-Plug-16A/#ota-flashing","text":"DEVICE IS DIFFICULT TO DISASSEMBLE SO ANY ERRORS WITH FLASHING OR CONFIGURATION CAN EASILY BRICK IT. DO NOT CONNECT ANY SENSOR TO THESE DEVICES. Only use them as designed. AS ALWAYS, YOU DO ANY OF THIS AT YOUR OWN RISK. Device case is glued so recommended way to flash it is using tuya-convert This method worked for 3 devices that were shipped before December 2019, never paired with Tuya apps and never powered on near open WiFi APs. So they had no chance to download Tuya-Convert updates. It may not work for devices with newer firmware.","title":"OTA flashing"},{"location":"devices/RGB-Smart-Plug-16A/#prerequisites","text":"You'll need a Linux device with both WiFi capable of running in AP mode and ethernet connection Clone/download tuya-convert Run install_prereq.sh","title":"Prerequisites"},{"location":"devices/RGB-Smart-Plug-16A/#start-flashing","text":"Run start_flash.sh and follow the instructions Connect any WiFi device to vtrust-flash AP when it asks to and make sure that it gets an IP address. If it doesn't stop and check logs in scripts folder for clues Connect socket to mains and long-press the button to enter pairing mode Tasmota is included with tuya-convert, follow script's instruction to flash it After flashing device should reboot and you should see Tasmota's WiFi AP (Sonoff-xxx). Run stop_flash.sh to shutdown vtrust-flash AP on a machine you used for OTA.","title":"Start flashing"},{"location":"devices/RGB-Smart-Plug-16A/#configuration","text":"Connect to Tasmota's AP It's extremely important to enter correct WiFi configuration. Button is not on GPIO0 so won't do anything for default Sonoff Basic device profile. It's recommended to temporary enter second WiFi with something easy like SSID: TEST Password: testtest so you could start that AP and re-configure the device if there are any issues with main WiFi connection. After it reboots and successfully connects to WiFi configure it as Blizwolf SHP module Now button and relay should work. Red and Blue LEDs will be used as status LEDs.","title":"Configuration"},{"location":"devices/RGB-Smart-Plug-16A/#rgb-light","text":"Use this template to configure the device: {\"NAME\":\"RGB Smart Plug\",\"GPIO\":[37,0,39,0,38,134,0,0,131,17,132,21,0],\"FLAG\":0,\"BASE\":45} For older versions: Complete RGB support requires building slightly custom Tasmota. Edit sonoff/sonoff_template.h and replace \"BlitzWolf SHP\" configuration with the following: { \"BlitzWolf SHP\", // BlitzWolf BW-SHP2 and BW-SHP6 (ESP8285 - BL0937 or HJL-01 Energy Monitoring) // https://www.banggood.com/BlitzWolf-BW-SHP2-Smart-WIFI-Socket-EU-Plug-220V-16A-Work-with-Amazon-Alexa-Google-Assistant-p-1292899.html // https://www.amazon.de/Steckdose-Homecube-intelligente-Verbrauchsanzeige-funktioniert/dp/B076Q2LKHG/ref=sr_1_fkmr0_1 // https://www.amazon.de/Intelligente-Stromverbrauch-Fernsteurung-Schaltbare-Energieklasse/dp/B076WZQS4S/ref=sr_1_1 // https://www.aliexpress.com/store/product/BlitzWolf-BW-SHP6-EU-Plug-Metering-Version-WIFI-Smart-Socket-220V-240V-10A-Work-with-Amazon/1965360_32945504669.html GPIO_USER, // GPIO00 Red Led (1 = On, 0 = Off) GPIO_USER, // GPIO01 Serial RXD and Optional sensor GPIO_USER, // GPIO02 Blue Led (1 = On, 0 = Off) GPIO_USER, // GPIO03 Serial TXD and Optional sensor GPIO_USER, // GPIO04 GPIO_HJL_CF, // GPIO05 BL0937 or HJL-01 CF power 0, 0, 0, 0, 0, 0, // Flash connection GPIO_NRG_SEL_INV, // GPIO12 BL0937 or HJL-01 Sel output (0 = Voltage) GPIO_KEY1, // GPIO13 Button GPIO_NRG_CF1, // GPIO14 BL0937 or HJL-01 CF1 current / voltage GPIO_REL1, // GPIO15 Relay (0 = Off, 1 = On) 0, 0 }, Make sure that you don't have wrong WiFi configuration in user_config_override.h. Build and OTA flash it to the device using Tasmota. After it reboots configure as following: [[https://raw.githubusercontent.com/wiki/Astr0/Sonoff-Tasmota/images/lonsonho16a/config.png|Configuration]] RGB and dimming should work now.","title":"RGB Light"},{"location":"devices/RGB-Smart-Plug-16A/#disassembling-the-device","text":"This is not recommended. Do it only if you have to or just buy a new one. The device is hard to open and may be damaged. Components inside may have mains charge and electrocute you even if powered off. Do it at your own risk. One of my devices had a hardware issue - constantly losing WiFi, rebooted when wiggled in power socket, rebooted every few seconds on 1250W load, sometimes just hanged and not responded even to the button. Since it wasn't usable at all I tried to fix it. The reason was broken steel input pole inside(what?? how?? WTF??) that was making weak contact, couldn't fix it reliably. Unbend earth connections on the bottom to make them straight. Use a sharp knife to slice through glue between RGB ring and the case. Requires quite a lot of force and time. RGB ring may break in places where glue is stronger than the plastic. Use a screwdriver to pry the case open. Remove button cap Desolder output connections, try not to melt any plastic. Remove support plastic with a screwdriver, it's held to the PCB by two clips. Desolder input poles. This is tricky since there's a lot of solder. I've removed as much of it as possible with desoldering pump, then melted the solder and rotated the poles with pliers while it cooled. Poles are made of steel and steel don't accept solder well. Remove the PCB by lifting it up. It's glued to the case on the bottom by the relay and held tight with input poles so it requires some force. Also, it's not easy to grab the PCB. I've used dip removing tweezers, holding PCB by holes for the earth connectors. I figured out the pinout for flashing the device: Before assembling it back remove as much solder as possible from input and output pole pads. The device fits together very tight, so everything should be perfectly in place. Don't forget to glue the case back. Few observations: * It has ESP8266EX with FM25F08 8Mbit flash. The module has lots of connections, some of them have only pads without tracks on the main board. High chances to find RX and TX there. Obviously, there should be VCC and GND to power up the module. * Uses HJL-01 with a shunt for power monitoring, so every mains power track that looks like it should be covered with solder but is not, probably should be covered with solder :) * It has 4 RGB LEDs. GPIO00-Red, GPIO02-Blue, GPIO04-Green * AFE BPD-SS-105DM 16A 250VAC relay * 16A SMD fuse for mains input * Something that's probably another fuse marked F1 for low-voltage circuitry power * Low-voltage part is not galvanically insulated from mains * There's \"QC Passed\" sticker on the relay","title":"Disassembling the device"},{"location":"devices/S1-Series---Wifi-Socket-S120-%28EU-model%29-chipset-TYWE2S/","text":"Model ~ There's no brand on this one, I got it for 11\u20ac on ebay as \"Wifi Smart Sans Fil T\u00e9l\u00e9commande Prise de Courant Pour T\u00e9l\u00e9phone Prise EU Plug\" from this seller . Flashing ~ As chipset is a TYWE2S , you'll have to connect GPIO0 (marked IO0) manually to the ground. There's better images than mines here and here on the wiki. Configuration ~ GPIO5: Relay1 (21) GPIO12: Led1 (52) GPIO14: Button1 (17)","title":"S1 Series   Wifi Socket S120 (EU model) chipset TYWE2S"},{"location":"devices/S1-Series---Wifi-Socket-S120-%28EU-model%29-chipset-TYWE2S/#model","text":"There's no brand on this one, I got it for 11\u20ac on ebay as \"Wifi Smart Sans Fil T\u00e9l\u00e9commande Prise de Courant Pour T\u00e9l\u00e9phone Prise EU Plug\" from this seller .","title":"Model"},{"location":"devices/S1-Series---Wifi-Socket-S120-%28EU-model%29-chipset-TYWE2S/#flashing","text":"As chipset is a TYWE2S , you'll have to connect GPIO0 (marked IO0) manually to the ground. There's better images than mines here and here on the wiki.","title":"Flashing"},{"location":"devices/S1-Series---Wifi-Socket-S120-%28EU-model%29-chipset-TYWE2S/#configuration","text":"GPIO5: Relay1 (21) GPIO12: Led1 (52) GPIO14: Button1 (17)","title":"Configuration"},{"location":"devices/SK03-Outdoor-Smart-Plug/","text":"SK03 Outdoor Smart Plug which can be found as different brand names on Amazon. The ESP8266 module inside is a TYWE3S by Tuya. The power monitoring is a HLW8012 much like the original Sonoff POW and other power monitoring modules. Pull the four rubber pads off the bottom to expose the screws and the unit opens up. Unscrew the small screws from the board and it comes out of the case. The relay is close to the soldering points on the Tuya module but it can be done if you are careful. GPIO0 is the button on the underside so you do not need to solder to that point, just hold the button during boot for your flashing process like you would with a Sonoff Basic. digiblurDIY did a livestream showing this device, soldering and flashing process (split in two videos): https://www.youtube.com/watch?v=C5_BqptJA_w and https://www.youtube.com/watch?v=ca7P9TR9r68 As of firmware 6.3.0.11, the SK03 is available for use in the module configuration. Information regarding the standard soldering and pinouts for the TYWE3S module: { \"SK03 Outdoor\", // Outdoor smart plug with power monitoring HLW8012 chip - https://www.amazon.com/gp/product/B07CG7MBPV GPIO_KEY1, // GPIO00 Button 0, 0, 0, GPIO_HLW_CF, // GPIO04 HLW8012 CF power GPIO_NRG_CF1, // GPIO05 HLW8012 CF1 current / voltage 0, 0, 0, 0, 0, 0, // Flash connection GPIO_NRG_SEL_INV, // GPIO12 HLW8012 CF Sel output (0 = Voltage) GPIO_LED2_INV, // GPIO13 Red Led (0 = On, 1 = Off) GPIO_LED1_INV, // GPIO14 Blue Led (0 = On, 1 = Off) GPIO_REL1, // GPIO15 Relay (0 = Off, 1 = On) 0, 0 }","title":"SK03 Outdoor Smart Plug"},{"location":"devices/SM-SO301/","text":"SM-SO301 with an FCC ID of 2AJ5F-SM-SO3015 has 4 mains power and 4 USB ports. Each mains power is independently controlled and the USB group is controllable via a solid state relay. The ESP8266 module inside is a TYWE3S by Tuya. Model purchased SM-SO301 (it seems to change on Amazon and other places, search for the model#). Other resellers may sell the same unit with various mains voltages/plug types. Also sold under the Vivitar name model HA-1007-ACD (US version). There is also an HA-1007-AU (AUS version). Product ~ Flashing and Configuration Pictures ~ Hold/Attach the GPIO0 wire/pin to ground during initial boot to flash. (TX pin to RX pin and RX pin to TX pin on USB flash adapter)","title":"SM SO301"},{"location":"devices/SM-SO301/#product","text":"","title":"Product"},{"location":"devices/SM-SO301/#flashing-and-configuration-pictures","text":"Hold/Attach the GPIO0 wire/pin to ground during initial boot to flash. (TX pin to RX pin and RX pin to TX pin on USB flash adapter)","title":"Flashing and Configuration Pictures"},{"location":"devices/SP108E-HardwareAnalysis/","text":"So far I analyzed it is equipped with these chips: ESP-12F STM32F-030C8T (Cortex M0) Winbond 25Q32 (EEPROM) 74HC245 XL1509 3.3E1 (Step down regulator) RX/TX of STM is connected to ESP. 74HC245 buffers the outputs ESP is connected to the STM RX/TX pins. No other connections seen. We can assume there is some firmware in the STM that does the low level connection to the LEDs. Question is how does the ESP communicate with the STM and what exactly does the STM at all. But we can mod the hardware so the ESP can talk to the LEDs. I made some pictures with phone and microscope. PCB Open the housing, see the red marks for the holders) RX/TX connection ESP to STM STM32F0 EEPROM Pins lead to the STM32F0 (Firmware flash? Debug?) ESP-12 and its pins Buffer chip 74HC245 Traces on bottom side from STM to HC245 (actually R3 and R4) For the hardware mod to make it working without the STM32F0, there are several ways: 1. Cut traces and add wires ~ We need to break one of the traces on the bottom of the PCB. Then connect GPIO4 of ESP-12 with R4. Also RX/TX connection between STM32F0 and ESP-12 need to be broken up. 2. Hold STM32F0 in reset ~ This is the simpler method, no cuts on the PCB required, just two additional wires. - NRST of STM32F0 to GND - IO4 of ESP-12 to R4 See here for details. Flashing prohibited ~ Major problem right now is that IO0 is directly connected to VCC, so we cannot bring ESP-12 into flash mode. Working on a solution.","title":"SP108E HardwareAnalysis"},{"location":"devices/SP108E-HardwareAnalysis/#1-cut-traces-and-add-wires","text":"We need to break one of the traces on the bottom of the PCB. Then connect GPIO4 of ESP-12 with R4. Also RX/TX connection between STM32F0 and ESP-12 need to be broken up.","title":"1. Cut traces and add wires"},{"location":"devices/SP108E-HardwareAnalysis/#2-hold-stm32f0-in-reset","text":"This is the simpler method, no cuts on the PCB required, just two additional wires. - NRST of STM32F0 to GND - IO4 of ESP-12 to R4 See here for details.","title":"2. Hold STM32F0 in reset"},{"location":"devices/SP108E-HardwareAnalysis/#flashing-prohibited","text":"Major problem right now is that IO0 is directly connected to VCC, so we cannot bring ESP-12 into flash mode. Working on a solution.","title":"Flashing prohibited"},{"location":"devices/SP108E-HardwareMod/","text":"Below is correct, but IO0 is directly connected to VCC, so we cannot bring ESP-12 into flash mode. Will check for some OTA mode that can be used. With just two additional wires we can use Tasmota with the SP108E. Analysis of the hardware The trick is to hold the STM32F0 controller in reset. Then we do not need to cut any traces on the PCB because all pins of the STM32F0 are inputs. Another warning: I did not yet proof it actually works, this is work in progress. Wire 1 - NRST (pin 7) of STM32F0 to GND Wire 2 - IO4 of ESP-12 to R4","title":"SP108E HardwareMod"},{"location":"devices/SP108E-LED-strip-controller/","text":"This is a controller for the WS2812 and similar LED chips (stripes). Prize is 13..15\u20ac at ebay. It uses another controller (STM32F0) to control CLK and Data lines to the LEDs tripes. Warning: Construction zone. To run Tasmota on it, we need to modify the hardware. See here for details. Currently not working, see HardwareMod for details: \"Other than that, the normal flash instruction for Tasmota do apply.\" SP108E","title":"SP108E LED strip controller"},{"location":"devices/SWB1-Smart-Power-Strip/","text":"Product ~ SWB1 Wi-Fi smart power strip with 4 main ports. Each port can be controlled manually FCCID: 2AJK8-SWB1 This is a new device not using the Tuya PCB but is a esp8266ex based and works great with Tasmota The product can be purchased on amazon.ca (could be found on other amazon sites) Inside ~ Inside PCB The chip used WT8266-S1. The specs can be found on wireless-tags.com JTAG ~ Pins used. You can choose one of 3 GND to your liking. the RESET(RST) pin is also marked for those that use that pin to reset the chip while flashing TASMOTA CONFIGURATION ~","title":"SWB1 Smart Power Strip"},{"location":"devices/SWB1-Smart-Power-Strip/#product","text":"SWB1 Wi-Fi smart power strip with 4 main ports. Each port can be controlled manually FCCID: 2AJK8-SWB1 This is a new device not using the Tuya PCB but is a esp8266ex based and works great with Tasmota The product can be purchased on amazon.ca (could be found on other amazon sites)","title":"Product"},{"location":"devices/SWB1-Smart-Power-Strip/#inside","text":"Inside PCB The chip used WT8266-S1. The specs can be found on wireless-tags.com","title":"Inside"},{"location":"devices/SWB1-Smart-Power-Strip/#jtag","text":"Pins used. You can choose one of 3 GND to your liking. the RESET(RST) pin is also marked for those that use that pin to reset the chip while flashing","title":"JTAG"},{"location":"devices/SWB1-Smart-Power-Strip/#tasmota-configuration","text":"","title":"TASMOTA CONFIGURATION"},{"location":"devices/Shelly-1/","text":"The Shelly 1 is supported in Tasmota from version 6.2.1.7 Allterco Shelly 1 Product Page Allterco Shelly 1 Shop \u26a0\ufe0f\ufe0fSpecial Shelly Attention\u26a0\ufe0f\ufe0f ~ DO NOT CONNECT ANYTHING TO ANY GPIOs OF THESE DEVICES!!! (No sensors, no switches, nothing) The GPIOs on the Shelly are connected to AC power! Only use a Shelly as designed. Do not connect AC power and the serial connection at the same time The GND connection of the Shelly is connected to the live AC wire. Connecting serial with your PC will fry your PC. Check the correct jumper position before connecting AC power to Shelly 1. If the jumper is set to 12V you will destroy your Shelly! An ESP8266 with 2MB flash single relay device 42mm \"round\" in size. Serial Connection ~ Shelly1 comes with a partially exposed programming/debug header which can be used to flash Tasmota on the device. A serial-to-USB adapter is needed as well as a reliable 3.3V source with at least 350 mA drive capability. The following diagram shows the device pinout and power source voltage selection jumper. Flash mode ~ To be able to flash the Tasmota firmware you need to get into flash mode. Therefore connect a wire from GPIO0 to ground. For further information have a look at Hardware Preparation . \u26a0\ufe0f\ufe0fWARNING\u26a0\ufe0f\ufe0f ~ Please note what version of the Shelly 1 you have (V1, V2 or V3). The V2 user guide is incorrect . The mains connections are as shown in the image above for all versions of the switch. The labels on the V2 switches are WRONG! Video tutorial by digiblurDIY ~ Video tutorial by BurnsHA ~","title":"Shelly 1"},{"location":"devices/Shelly-1/#special-shelly-attention","text":"DO NOT CONNECT ANYTHING TO ANY GPIOs OF THESE DEVICES!!! (No sensors, no switches, nothing) The GPIOs on the Shelly are connected to AC power! Only use a Shelly as designed. Do not connect AC power and the serial connection at the same time The GND connection of the Shelly is connected to the live AC wire. Connecting serial with your PC will fry your PC. Check the correct jumper position before connecting AC power to Shelly 1. If the jumper is set to 12V you will destroy your Shelly! An ESP8266 with 2MB flash single relay device 42mm \"round\" in size.","title":"\u26a0\ufe0f\ufe0fSpecial Shelly Attention\u26a0\ufe0f\ufe0f"},{"location":"devices/Shelly-1/#serial-connection","text":"Shelly1 comes with a partially exposed programming/debug header which can be used to flash Tasmota on the device. A serial-to-USB adapter is needed as well as a reliable 3.3V source with at least 350 mA drive capability. The following diagram shows the device pinout and power source voltage selection jumper.","title":"Serial Connection"},{"location":"devices/Shelly-1/#flash-mode","text":"To be able to flash the Tasmota firmware you need to get into flash mode. Therefore connect a wire from GPIO0 to ground. For further information have a look at Hardware Preparation .","title":"Flash mode"},{"location":"devices/Shelly-1/#warning","text":"Please note what version of the Shelly 1 you have (V1, V2 or V3). The V2 user guide is incorrect . The mains connections are as shown in the image above for all versions of the switch. The labels on the V2 switches are WRONG!","title":"\u26a0\ufe0f\ufe0fWARNING\u26a0\ufe0f\ufe0f"},{"location":"devices/Shelly-1/#video-tutorial-by-digiblurdiy","text":"","title":"Video tutorial by digiblurDIY"},{"location":"devices/Shelly-1/#video-tutorial-by-burnsha","text":"","title":"Video tutorial by BurnsHA"},{"location":"devices/Shelly-1PM/","text":"The Shelly 1PM is supported from Tasmota 6.5.0.10 using a template. Allterco Shelly 1PM Product Page Allterco Shelly 1PM Shop \u26a0\ufe0f\ufe0fSpecial Shelly Attention\u26a0\ufe0f\ufe0f ~ DO NOT CONNECT ANYTHING TO ANY GPIOs OF THESE DEVICES!!! (No sensors, no switches, nothing) The GPIOs on the Shelly are connected to AC power! Only use a Shelly as designed. Do not connect AC power and the serial connection at the same time The GND connection of the Shelly is connected to the live AC wire. Connecting serial with your PC will fry your PC. An ESP8266 with 2MB flash single relay device 42mm \"round\" in size. Serial Flashing ~ Shelly 1PM comes with a partially exposed programming/debug header which can be used to flash Tasmota on the device. A USB-to-UART adapter is needed as well as a reliable 3.3V with at least 350 mA drive capability. The following diagram shows the device pinout. Template ~ {\"NAME\":\"Shelly 1PM\",\"GPIO\":[56,0,0,0,82,134,0,0,0,0,0,21,0],\"FLAG\":2,\"BASE\":18} Calibration ~ Tasmota will disable serial logging after a restart as the communication between Tasmota and the Energy Monitoring chip is using the same serial interface. Make sure not to enable SerialLog as it will interfere with the Energy Monitoring functionality. To calibrate the Energy monitoring feature connect a known load and execute the commands shown below. Assumed an AC voltage of 240V, a resistive load of 60W and a line frequency of 50Hz. With a load of 60W the current should be 60W / 240V = 0.25A. FrequencySet 50.000 PowerSet 60.00 VoltageSet 240.0 CurrentSet 250.0 Pause a few seconds between executing the commands as the communication between Tasmota and the Energy Monitoring chip is a serial interface which can take over a second to complete.","title":"Shelly 1PM"},{"location":"devices/Shelly-1PM/#special-shelly-attention","text":"DO NOT CONNECT ANYTHING TO ANY GPIOs OF THESE DEVICES!!! (No sensors, no switches, nothing) The GPIOs on the Shelly are connected to AC power! Only use a Shelly as designed. Do not connect AC power and the serial connection at the same time The GND connection of the Shelly is connected to the live AC wire. Connecting serial with your PC will fry your PC. An ESP8266 with 2MB flash single relay device 42mm \"round\" in size.","title":"\u26a0\ufe0f\ufe0fSpecial Shelly Attention\u26a0\ufe0f\ufe0f"},{"location":"devices/Shelly-1PM/#serial-flashing","text":"Shelly 1PM comes with a partially exposed programming/debug header which can be used to flash Tasmota on the device. A USB-to-UART adapter is needed as well as a reliable 3.3V with at least 350 mA drive capability. The following diagram shows the device pinout.","title":"Serial Flashing"},{"location":"devices/Shelly-1PM/#template","text":"{\"NAME\":\"Shelly 1PM\",\"GPIO\":[56,0,0,0,82,134,0,0,0,0,0,21,0],\"FLAG\":2,\"BASE\":18}","title":"Template"},{"location":"devices/Shelly-1PM/#calibration","text":"Tasmota will disable serial logging after a restart as the communication between Tasmota and the Energy Monitoring chip is using the same serial interface. Make sure not to enable SerialLog as it will interfere with the Energy Monitoring functionality. To calibrate the Energy monitoring feature connect a known load and execute the commands shown below. Assumed an AC voltage of 240V, a resistive load of 60W and a line frequency of 50Hz. With a load of 60W the current should be 60W / 240V = 0.25A. FrequencySet 50.000 PowerSet 60.00 VoltageSet 240.0 CurrentSet 250.0 Pause a few seconds between executing the commands as the communication between Tasmota and the Energy Monitoring chip is a serial interface which can take over a second to complete.","title":"Calibration"},{"location":"devices/Shelly-2.5/","text":"The Shelly 2.5 is supported from Tasmota 6.5.0.8 using a template. Allterco Shelly 2.5 Product Page Allterco Shelly 2.5 Shop Shelly 2.5 Initial issue \u26a0\ufe0f\ufe0fSpecial Shelly Attention\u26a0\ufe0f\ufe0f ~ DO NOT CONNECT ANYTHING TO ANY GPIOs OF THESE DEVICES!!! (No sensors, no switches, nothing) The GPIOs on the Shelly are connected to AC power! Only use a Shelly as designed. Do not connect AC power and the serial connection at the same time The GND connection of the Shelly is connected to the live AC wire. Connecting serial with your PC will fry your PC. Shelly 2.5 ~ [!WARNING] Warning (April 10, 2019): This appears to affect a percentage of their entire first run production. Check your device before powering it on. An ESP8266 with 2MB flash dual relay device with Energy Monitoring. Slightly smaller than the original Shelly 2. Serial Connection ~ The Shelly 2.5 model comes with a partially exposed programming/debug header which can be used to flash Tasmota on the device. A USB-to-UART adapter is needed as well as a reliable 3.3V with at least 350 mA drive capability. The following diagram shows the device pinout and power source voltage selection jumper. The onboard connector is 1.27mm raster with 1mm diameter holes. Normal Dupont cables won't fit. To avoid damaging the pcb, use either a stripped Ethernet cable and breadboard as an adapter, or female header socket legs (see image below). The legs of a female header socket fit nicely. Solder them to custom-crimped Dupont wires for use with your USB-to-UART adapter. These often come with Wemos D1 Mini boards in multiple lengths. Template ~ Tasmota 6.5.0.8 and higher supports Shelly 2.5 GPIO Component 0 LED1i 2 Button1 4 Relay1 5 Switch2n 12 I2C SDA 13 Switch1n 14 I2C SCL 15 Relay2 16 ADE7953 IRQ A0 Internal Temperature {\"NAME\":\"Shelly 2.5\",\"GPIO\":[56,0,17,0,21,83,0,0,6,82,5,22,156],\"FLAG\":2,\"BASE\":18} Energy metering is done by a ADE7953 chip connected via I2C and IRQ on GPIO16. If you connect momentary switches, use the following template: {\"NAME\":\"Shelly 2.5 (buttons)\",\"GPIO\":[56,0,19,0,21,127,0,0,6,126,5,22,156],\"FLAG\":2,\"BASE\":18} Button1 and Button2 are assigned to the SW1 and SW2 external inputs. Button3 is the button on the back of the device next to the pin header and you can optionally assign the behaviour you want using rules. If you want the buttons to respond instantly, go to the console and type SetOption13 1 . But, if you want press/double press/hold functionality, run instead Backlog SetOption1 1; SetOption11 1; SetOption32 20 to enable all three states and set hold time of 2 seconds. Use SetOption32 to set another hold time. If you want to see Voltage and Frequency also when the relays are off, use SetOption21 1 Flash mode ~ To be able to flash the Tasmota firmware you need to get into flash mode. Therefore connect a wire from GPIO0 to ground. For further information have a look at programming mode . Calibration ~ Tasmota will disable serial logging after a restart as the communication between Tasmota and the Energy Monitoring chip is using the same serial interface. Make sure not to enable SerialLog as it will interfere with the Energy Monitoring functionality. To calibrate the Energy monitoring feature connect a known load and execute the commands shown below. Assumed an AC voltage of 240V, a resistive load of 60W and a line frequency of 50Hz. With a load of 60W the current should be 60W / 240V = 0.25A. FrequencySet 50.000 PowerSet 60.00 VoltageSet 240.0 CurrentSet 250.0 Pause a few seconds between executing the commands as the communication between Tasmota and the energy monitoring chip is a serial interface which can take over a second to complete. Use rules to control shutter endpoints ~ As the Shelly 2.5 contains energy monitoring you can use rules to power off the shutter when too much current is drawn at the end point. This rule will power off both directions when the current becomes greater than 600mA. Before you activate the rule, let your shutter move and pay attention to the current value in the WebGUI. Note your value and add 0.050 to your value. After that, you change the value for the rule. Eg.: Your Value = 0.520 + 0.050 = 0.570 energy#current[X]>0.570 rule1 on energy#current[2]>0.600 do backlog power1 0;power2 0; endon on energy#current[1]>0.600 do backlog power1 0;power2 0 endon rule1 1 rule1 5 Use Shelly 2.5 device for Blinds and Shutters ~ Further Information: Blinds and Shutters Ghost switching ~ The Shelly 2.5 inputs appear to be notoriously susceptible to interference. Therefore ghost switching can happen if the wires are long (>1m / 3ft). If you experience this issue, you might want to experiment with the switch debounce delay. It is set to 50 milliseconds by default. Use command SwitchDebounce 100 to change it to a less sensitive value, which might work better. The value be set up to 1000 milliseconds. Some issues were reported for this topic - search query Overheating ~ Due to the built-in temperature sensor, it is possible to switch off the relays when a certain temperature is exceeded. The limit for the original Shelly firmware seems to be around 95 \u00b0 C. Source The ambient temperature according to the manufacturer is between: ?> - 40 \u00b0 C up to 40 \u00b0 C Note It is set to 90 \u00b0 C This can be changed via SetOption42 . [!WARNING]It is absolutely not recommended to increase the limit.","title":"Shelly 2.5"},{"location":"devices/Shelly-2.5/#special-shelly-attention","text":"DO NOT CONNECT ANYTHING TO ANY GPIOs OF THESE DEVICES!!! (No sensors, no switches, nothing) The GPIOs on the Shelly are connected to AC power! Only use a Shelly as designed. Do not connect AC power and the serial connection at the same time The GND connection of the Shelly is connected to the live AC wire. Connecting serial with your PC will fry your PC.","title":"\u26a0\ufe0f\ufe0fSpecial Shelly Attention\u26a0\ufe0f\ufe0f"},{"location":"devices/Shelly-2.5/#shelly-25","text":"[!WARNING] Warning (April 10, 2019): This appears to affect a percentage of their entire first run production. Check your device before powering it on. An ESP8266 with 2MB flash dual relay device with Energy Monitoring. Slightly smaller than the original Shelly 2.","title":"Shelly 2.5"},{"location":"devices/Shelly-2.5/#serial-connection","text":"The Shelly 2.5 model comes with a partially exposed programming/debug header which can be used to flash Tasmota on the device. A USB-to-UART adapter is needed as well as a reliable 3.3V with at least 350 mA drive capability. The following diagram shows the device pinout and power source voltage selection jumper. The onboard connector is 1.27mm raster with 1mm diameter holes. Normal Dupont cables won't fit. To avoid damaging the pcb, use either a stripped Ethernet cable and breadboard as an adapter, or female header socket legs (see image below). The legs of a female header socket fit nicely. Solder them to custom-crimped Dupont wires for use with your USB-to-UART adapter. These often come with Wemos D1 Mini boards in multiple lengths.","title":"Serial Connection"},{"location":"devices/Shelly-2.5/#template","text":"Tasmota 6.5.0.8 and higher supports Shelly 2.5 GPIO Component 0 LED1i 2 Button1 4 Relay1 5 Switch2n 12 I2C SDA 13 Switch1n 14 I2C SCL 15 Relay2 16 ADE7953 IRQ A0 Internal Temperature {\"NAME\":\"Shelly 2.5\",\"GPIO\":[56,0,17,0,21,83,0,0,6,82,5,22,156],\"FLAG\":2,\"BASE\":18} Energy metering is done by a ADE7953 chip connected via I2C and IRQ on GPIO16. If you connect momentary switches, use the following template: {\"NAME\":\"Shelly 2.5 (buttons)\",\"GPIO\":[56,0,19,0,21,127,0,0,6,126,5,22,156],\"FLAG\":2,\"BASE\":18} Button1 and Button2 are assigned to the SW1 and SW2 external inputs. Button3 is the button on the back of the device next to the pin header and you can optionally assign the behaviour you want using rules. If you want the buttons to respond instantly, go to the console and type SetOption13 1 . But, if you want press/double press/hold functionality, run instead Backlog SetOption1 1; SetOption11 1; SetOption32 20 to enable all three states and set hold time of 2 seconds. Use SetOption32 to set another hold time. If you want to see Voltage and Frequency also when the relays are off, use SetOption21 1","title":"Template"},{"location":"devices/Shelly-2.5/#flash-mode","text":"To be able to flash the Tasmota firmware you need to get into flash mode. Therefore connect a wire from GPIO0 to ground. For further information have a look at programming mode .","title":"Flash mode"},{"location":"devices/Shelly-2.5/#calibration","text":"Tasmota will disable serial logging after a restart as the communication between Tasmota and the Energy Monitoring chip is using the same serial interface. Make sure not to enable SerialLog as it will interfere with the Energy Monitoring functionality. To calibrate the Energy monitoring feature connect a known load and execute the commands shown below. Assumed an AC voltage of 240V, a resistive load of 60W and a line frequency of 50Hz. With a load of 60W the current should be 60W / 240V = 0.25A. FrequencySet 50.000 PowerSet 60.00 VoltageSet 240.0 CurrentSet 250.0 Pause a few seconds between executing the commands as the communication between Tasmota and the energy monitoring chip is a serial interface which can take over a second to complete.","title":"Calibration"},{"location":"devices/Shelly-2.5/#use-rules-to-control-shutter-endpoints","text":"As the Shelly 2.5 contains energy monitoring you can use rules to power off the shutter when too much current is drawn at the end point. This rule will power off both directions when the current becomes greater than 600mA. Before you activate the rule, let your shutter move and pay attention to the current value in the WebGUI. Note your value and add 0.050 to your value. After that, you change the value for the rule. Eg.: Your Value = 0.520 + 0.050 = 0.570 energy#current[X]>0.570 rule1 on energy#current[2]>0.600 do backlog power1 0;power2 0; endon on energy#current[1]>0.600 do backlog power1 0;power2 0 endon rule1 1 rule1 5","title":"Use rules to control shutter endpoints"},{"location":"devices/Shelly-2.5/#use-shelly-25-device-for-blinds-and-shutters","text":"Further Information: Blinds and Shutters","title":"Use Shelly 2.5 device for Blinds and Shutters"},{"location":"devices/Shelly-2.5/#ghost-switching","text":"The Shelly 2.5 inputs appear to be notoriously susceptible to interference. Therefore ghost switching can happen if the wires are long (>1m / 3ft). If you experience this issue, you might want to experiment with the switch debounce delay. It is set to 50 milliseconds by default. Use command SwitchDebounce 100 to change it to a less sensitive value, which might work better. The value be set up to 1000 milliseconds. Some issues were reported for this topic - search query","title":"Ghost switching"},{"location":"devices/Shelly-2.5/#overheating","text":"Due to the built-in temperature sensor, it is possible to switch off the relays when a certain temperature is exceeded. The limit for the original Shelly firmware seems to be around 95 \u00b0 C. Source The ambient temperature according to the manufacturer is between: ?> - 40 \u00b0 C up to 40 \u00b0 C Note It is set to 90 \u00b0 C This can be changed via SetOption42 . [!WARNING]It is absolutely not recommended to increase the limit.","title":"Overheating"},{"location":"devices/Shelly-2/","text":"Shelly 2 is discontinued and replaced by Shelly 2.5 The Shelly 2 is fully supported in Tasmota from version 6.2.1.7 \u26a0\ufe0f\ufe0fSpecial Shelly Attention\u26a0\ufe0f\ufe0f ~ DO NOT CONNECT ANYTHING TO ANY GPIOs OF THESE DEVICES!!! (No sensors, no switches, nothing) The GPIOs on the Shelly are connected to AC power! Only use a Shelly as designed. Do not connect AC power and the serial connection at the same time The GND connection of the Shelly is connected to the live AC wire. Connecting serial with your PC will fry your PC. Check the correct jumper position before connecting AC power to Shelly 1. If the jumper is set to 12V you will destroy your Shelly! Shelly 2 ~ An ESP8266 with 2MB flash dual relay device with Energy Monitoring the size of round 45mm. Templates as of v6.4.1.17 ~ The inbuilt template equals the following: {\"NAME\":\"Shelly 2\",\"GPIO\":[0,135,0,136,21,22,0,0,9,0,10,137,0],\"FLAG\":0,\"BASE\":47} An alternative template without switch pull-up is: {\"NAME\":\"Shelly 2n\",\"GPIO\":[0,135,0,136,21,22,0,0,82,0,83,137,0],\"FLAG\":0,\"BASE\":47} Pullup or no pullup ~ The shelly 2 inputs may or may not need pullups for SW1 and SW2 to work correctly. Default state is pullups enabled. To disable pullups either use command SetOption62 1 or select the option from the GUI. Refer to the following issue: https://github.com/arendst/Tasmota/issues/4841","title":"Shelly 2"},{"location":"devices/Shelly-2/#special-shelly-attention","text":"DO NOT CONNECT ANYTHING TO ANY GPIOs OF THESE DEVICES!!! (No sensors, no switches, nothing) The GPIOs on the Shelly are connected to AC power! Only use a Shelly as designed. Do not connect AC power and the serial connection at the same time The GND connection of the Shelly is connected to the live AC wire. Connecting serial with your PC will fry your PC. Check the correct jumper position before connecting AC power to Shelly 1. If the jumper is set to 12V you will destroy your Shelly!","title":"\u26a0\ufe0f\ufe0fSpecial Shelly Attention\u26a0\ufe0f\ufe0f"},{"location":"devices/Shelly-2/#shelly-2","text":"An ESP8266 with 2MB flash dual relay device with Energy Monitoring the size of round 45mm.","title":"Shelly 2"},{"location":"devices/Shelly-2/#templates-as-of-v64117","text":"The inbuilt template equals the following: {\"NAME\":\"Shelly 2\",\"GPIO\":[0,135,0,136,21,22,0,0,9,0,10,137,0],\"FLAG\":0,\"BASE\":47} An alternative template without switch pull-up is: {\"NAME\":\"Shelly 2n\",\"GPIO\":[0,135,0,136,21,22,0,0,82,0,83,137,0],\"FLAG\":0,\"BASE\":47}","title":"Templates as of v6.4.1.17"},{"location":"devices/Shelly-2/#pullup-or-no-pullup","text":"The shelly 2 inputs may or may not need pullups for SW1 and SW2 to work correctly. Default state is pullups enabled. To disable pullups either use command SetOption62 1 or select the option from the GUI. Refer to the following issue: https://github.com/arendst/Tasmota/issues/4841","title":"Pullup or no pullup"},{"location":"devices/Slitinto-NX-SP202/","text":"indirectly supported as configuration of Digoo NX-SP202 seems to work fine Device can switch 2 individual plugs. It has a builtin metering sensor which measures power consumption of the sum of both. My 2 devices I bought at Amazon have ROHS and CE signs and are officially valid for a maximum of 16A. You can buy it at Amazon According to the template configuration the device seems to be compatible with Digoo NX-SP202 Configuration ~ Currently Slitinto is not present as separate module but DIGOO NX-SP202 seems to work. I had to adjust voltage and current with the following commands in the console * command VoltageSet 233 // measured with a multimeter * command CurrentSet 171 // known milliampere of my reference (here lightbulb of 40watts) This calibration is potentially individual for every device so I would suggest to calibrate it with a known power consuming device like a good old light bulb where the wattage is well known. Flashing ~ Disassembly ~ The device has no screws but disassembling as not needed as you can flash it OTA using tuya-convert. Nevertheless one user described a method to \"crack\" it using a rubber hammer and then glue it together again with no visible defects. Pinout ~ Not known. Procedure ~ Here is described how to crack the device but also how to flash it OTA. Miscellaneous ~ I use metering capable devices to observe the power consumption and execute rule based behaviour on base of the consumption values. i.e.: if the power consumption is lower than 10W for 30min (checked every 60 seconds) then switch off. My script for this looks like this: * rule1 on Energy#Power>10 do backlog ruletimer1 1800; ruletimer2 60; rule1 off; endon * rule2 on rules#timer=1 do power2 off endon * rule3 on rules#timer=2 do rule1 on endon * rule1 on * rule2 on * rule3 on","title":"Slitinto NX SP202"},{"location":"devices/Slitinto-NX-SP202/#configuration","text":"Currently Slitinto is not present as separate module but DIGOO NX-SP202 seems to work. I had to adjust voltage and current with the following commands in the console * command VoltageSet 233 // measured with a multimeter * command CurrentSet 171 // known milliampere of my reference (here lightbulb of 40watts) This calibration is potentially individual for every device so I would suggest to calibrate it with a known power consuming device like a good old light bulb where the wattage is well known.","title":"Configuration"},{"location":"devices/Slitinto-NX-SP202/#flashing","text":"","title":"Flashing"},{"location":"devices/Slitinto-NX-SP202/#disassembly","text":"The device has no screws but disassembling as not needed as you can flash it OTA using tuya-convert. Nevertheless one user described a method to \"crack\" it using a rubber hammer and then glue it together again with no visible defects.","title":"Disassembly"},{"location":"devices/Slitinto-NX-SP202/#pinout","text":"Not known.","title":"Pinout"},{"location":"devices/Slitinto-NX-SP202/#procedure","text":"Here is described how to crack the device but also how to flash it OTA.","title":"Procedure"},{"location":"devices/Slitinto-NX-SP202/#miscellaneous","text":"I use metering capable devices to observe the power consumption and execute rule based behaviour on base of the consumption values. i.e.: if the power consumption is lower than 10W for 30min (checked every 60 seconds) then switch off. My script for this looks like this: * rule1 on Energy#Power>10 do backlog ruletimer1 1800; ruletimer2 60; rule1 off; endon * rule2 on rules#timer=1 do power2 off endon * rule3 on rules#timer=2 do rule1 on endon * rule1 on * rule2 on * rule3 on","title":"Miscellaneous"},{"location":"devices/Smart-Light-Switch--SS118-01K1/","text":"Generic Smart Light Switch from Amazon TYWE3S Model - In Canada ESP8266-S1 Model - August 2019 Product ~ Pins ~ Module Configuration ~ New Version - August 2019 Product ~ Pins ~ Module Configuration ~ GPIO Tasmota Component Device Function 0 LedLink (157) Red LED 2 Button1 (17) Button 12 LED1i (56) Green LED 15 Relay1 (21) Relay","title":"Smart Light Switch  SS118 01K1"},{"location":"devices/Smart-Light-Switch--SS118-01K1/#product","text":"","title":"Product"},{"location":"devices/Smart-Light-Switch--SS118-01K1/#pins","text":"","title":"Pins"},{"location":"devices/Smart-Light-Switch--SS118-01K1/#module-configuration","text":"New Version - August 2019","title":"Module Configuration"},{"location":"devices/Smart-Light-Switch--SS118-01K1/#product_1","text":"","title":"Product"},{"location":"devices/Smart-Light-Switch--SS118-01K1/#pins_1","text":"","title":"Pins"},{"location":"devices/Smart-Light-Switch--SS118-01K1/#module-configuration_1","text":"GPIO Tasmota Component Device Function 0 LedLink (157) Red LED 2 Button1 (17) Button 12 LED1i (56) Green LED 15 Relay1 (21) Relay","title":"Module Configuration"},{"location":"devices/SmartHome/","text":"Connection ~ Vcc - 3,3V TX - RX RX - TX GND - GND Additional Information ~ SmartHome is a cheap Sonoff Basic clone, but they still work with Tasmota. More Infos can be found here: #1474 . Device Images ~ Generic Module Config ~ ESP Module ~ The module being used in this device is the esp8266-s3","title":"SmartHome"},{"location":"devices/SmartHome/#connection","text":"Vcc - 3,3V TX - RX RX - TX GND - GND","title":"Connection"},{"location":"devices/SmartHome/#additional-information","text":"SmartHome is a cheap Sonoff Basic clone, but they still work with Tasmota. More Infos can be found here: #1474 .","title":"Additional Information"},{"location":"devices/SmartHome/#device-images","text":"","title":"Device Images"},{"location":"devices/SmartHome/#generic-module-config","text":"","title":"Generic Module Config"},{"location":"devices/SmartHome/#esp-module","text":"The module being used in this device is the esp8266-s3","title":"ESP Module"},{"location":"devices/SmartPlug-with-POW-%28AISIRER%2C-AVATAR%29/","text":"Smart Plugs from Amazon with same internal parts: - AISIRER - AVATAR Device: ~ solid design with 16A Relays 8 MB memory chip 2 LEDs POW function (unfortunately did not test yet, need help) very small size, easy to disassemble no need to disassemble PCBs test mode works with 5 or 3.3 V (relays also works) Disassemble * take off the lead with 2 screws * put small cross screwdriver inside 220V plug connector, there are 2 screws * free the antenna from plastic (no need to disconnect) * pull of PCB from the case Important build flags. * in Platformio for Tasmota flag change from 1MB to 8MB is needed, otherwise flash fails. build_flags = ${esp82xx_defaults.build_flags} -Wl,-Teagle.flash.8m.ld * in Arduino IDE: board selected - \"Node MCU 1.0\", standard Found how some of PINS are linked to main PCB and are easy to connect for flashing PCB Flashing: ~ I've decided to use 5V - there is a painted pad on the PCB, clean it and attach 5V (see image) * Connect GPIO0 to GND * Connect RX, TX * Connect 5V and GND * Connect USB to PC, start flashing Tasmota WEB config (Generic) * GPIO0 - Led1i * GPIO2 - Led2i * GPIO5 - HLW8012 CF * GPIO12 - HLWBLSELi * GPIO13 - Button1 * GPIO14 - HLWBL CF1 * GPIO15- Relais1 webconfig IMPORTANT: in order to have an accurate measurement of Voltage/Current/Power, you have to calibrate the internal meter with a well know load (like lamp or hair dryer) using this detailed procedure . Update from my side ~ I managed to flash two Aisirer plugs using pre-compiled tasmota.binaries, since my plugs had only 1M flash. I used 3.3V connected directly to the ESP board. I had some trouble with WLAN connectivity which caused the relays to pulse, so I switched to 2.3.0 core, which seems default again since a few releases. This runs quite well. Configure as BlitzWolf SHP(45) Module and also the power measurement is working. Update from nos86 ~ I have updated the guide in order to interface Tasmota with the power meter inside smart plug (tested only on AISIRER) and added the link for the power monitoring calibration","title":"SmartPlug with POW (AISIRER, AVATAR)"},{"location":"devices/SmartPlug-with-POW-%28AISIRER%2C-AVATAR%29/#device","text":"solid design with 16A Relays 8 MB memory chip 2 LEDs POW function (unfortunately did not test yet, need help) very small size, easy to disassemble no need to disassemble PCBs test mode works with 5 or 3.3 V (relays also works) Disassemble * take off the lead with 2 screws * put small cross screwdriver inside 220V plug connector, there are 2 screws * free the antenna from plastic (no need to disconnect) * pull of PCB from the case Important build flags. * in Platformio for Tasmota flag change from 1MB to 8MB is needed, otherwise flash fails. build_flags = ${esp82xx_defaults.build_flags} -Wl,-Teagle.flash.8m.ld * in Arduino IDE: board selected - \"Node MCU 1.0\", standard Found how some of PINS are linked to main PCB and are easy to connect for flashing PCB","title":"Device:"},{"location":"devices/SmartPlug-with-POW-%28AISIRER%2C-AVATAR%29/#flashing","text":"I've decided to use 5V - there is a painted pad on the PCB, clean it and attach 5V (see image) * Connect GPIO0 to GND * Connect RX, TX * Connect 5V and GND * Connect USB to PC, start flashing Tasmota WEB config (Generic) * GPIO0 - Led1i * GPIO2 - Led2i * GPIO5 - HLW8012 CF * GPIO12 - HLWBLSELi * GPIO13 - Button1 * GPIO14 - HLWBL CF1 * GPIO15- Relais1 webconfig IMPORTANT: in order to have an accurate measurement of Voltage/Current/Power, you have to calibrate the internal meter with a well know load (like lamp or hair dryer) using this detailed procedure .","title":"Flashing:"},{"location":"devices/SmartPlug-with-POW-%28AISIRER%2C-AVATAR%29/#update-from-my-side","text":"I managed to flash two Aisirer plugs using pre-compiled tasmota.binaries, since my plugs had only 1M flash. I used 3.3V connected directly to the ESP board. I had some trouble with WLAN connectivity which caused the relays to pulse, so I switched to 2.3.0 core, which seems default again since a few releases. This runs quite well. Configure as BlitzWolf SHP(45) Module and also the power measurement is working.","title":"Update from my side"},{"location":"devices/SmartPlug-with-POW-%28AISIRER%2C-AVATAR%29/#update-from-nos86","text":"I have updated the guide in order to interface Tasmota with the power meter inside smart plug (tested only on AISIRER) and added the link for the power monitoring calibration","title":"Update from nos86"},{"location":"devices/Sonoff-4CH-DIY/","text":"Sonoff 4CH DIY Itead Shop: https://www.itead.cc/psf-b85.html Itead Wiki: https://www.itead.cc/wiki/PSF-B85 The Sonoff 4CH DIY is based on the ESP8285. Serial Connection ~ Sonoff 4CH DIY ~ Please see the Hardware Preparation page for general instructions. As always, you need to access the serial interface. The four serial pins (3V3, Rx, Tx, GND) can be seen in the picture. Programming the Sonoff 4CH DIY is a breeze although the on-board-button is not connected to GPIO0. As with all ESP8266/ESP8285 modules pulling GPIO0 to GND is needed to put the chip in programming mode. You need to connect GPIO0 and GND during power up. Luckily both GND and GPIO0 (as KEY 1) are available on the header. A simple jumper between GND and KEY 1 while programming will do. Module parameters ~ Type ~ Module Type => Generic (18) Restart the module. GPIO9 & GPIO10 ~ To use GPIO9 and GPIO10 of the ESP8285, open the consol and enter => \"SetOption51 on\". Restart the module. Assign inputs and outputs ~ GPIO 1 => Button 1 (17) GPIO 9 => Button 2 (18) GPIO 10 => Button 3 (19) GPIO 14 => Button 4 (20) GPIO 12 => relay 1 (21) GPIO 5 => relay 2 (22) GPIO 4 => relay 3 (23) GPIO 15 => relay 4 (24) GPIO 13 => LED 1 (52)","title":"Sonoff 4CH DIY"},{"location":"devices/Sonoff-4CH-DIY/#serial-connection","text":"","title":"Serial Connection"},{"location":"devices/Sonoff-4CH-DIY/#sonoff-4ch-diy","text":"Please see the Hardware Preparation page for general instructions. As always, you need to access the serial interface. The four serial pins (3V3, Rx, Tx, GND) can be seen in the picture. Programming the Sonoff 4CH DIY is a breeze although the on-board-button is not connected to GPIO0. As with all ESP8266/ESP8285 modules pulling GPIO0 to GND is needed to put the chip in programming mode. You need to connect GPIO0 and GND during power up. Luckily both GND and GPIO0 (as KEY 1) are available on the header. A simple jumper between GND and KEY 1 while programming will do.","title":"Sonoff 4CH DIY"},{"location":"devices/Sonoff-4CH-DIY/#module-parameters","text":"","title":"Module parameters"},{"location":"devices/Sonoff-4CH-DIY/#type","text":"Module Type => Generic (18) Restart the module.","title":"Type"},{"location":"devices/Sonoff-4CH-DIY/#gpio9-gpio10","text":"To use GPIO9 and GPIO10 of the ESP8285, open the consol and enter => \"SetOption51 on\". Restart the module.","title":"GPIO9 &amp; GPIO10"},{"location":"devices/Sonoff-4CH-DIY/#assign-inputs-and-outputs","text":"GPIO 1 => Button 1 (17) GPIO 9 => Button 2 (18) GPIO 10 => Button 3 (19) GPIO 14 => Button 4 (20) GPIO 12 => relay 1 (21) GPIO 5 => relay 2 (22) GPIO 4 => relay 3 (23) GPIO 15 => relay 4 (24) GPIO 13 => LED 1 (52)","title":"Assign inputs and outputs"},{"location":"devices/Sonoff-4CH-Pro/","text":"Compared to the 4CH the main differences/improvements of the 4CH Pro are: Relays are isolated from mains and can each switch their own circuit (mains or low voltage). With stock firmware special modes are supported (stand-alone schedules, inching, interlocking). RF receiver (optional key fob or Sonoff RF Bridge 433 required). Dual microcontroller, both a ESP8285 and a STM32. Serial Flashing ~ Sonoff 4CH Pro ~ The \"FW/IO0\" button (Switch 1) is not directly connected to GPIO0 of the ESP module. A different method has to be used to program this board. To program the ESP chip disconnect power from the board, connect a cable from any Ground (GND) pin to the GPIO0 pin on the ESP (be careful not to touch any of the other pins). This is the second pin to the right on the top row of pins (see picture). While holding the pin connected power on the board. The board does not respond to any button pressed when in programming mode and LED 1, 2 and 3 are on (might differ per board). Use the ESP programming header as described in the picture to upload the firmware and follow regular programming procedure. Sonoff 4CH Pro R2 ~ On the R2 module the GPIO0 pin is broken out to a small pad to the right of the ESP package : Solving Sonoff 4CH Pro programing issues ~ If you have problems to program the 4CH Pro, you might find below tips useful: * Use the ESP program header and ensure that the right port is set in the Arduino IDE. * TX/RX are printed correctly on the pro version => TX goes to RX PIN and RX to TX. * GPIO0 needs to be connected to ground the first 3 seconds during reboot (or longer)! If not you can not program it. * On 4CH Pro R2 try switch S6 to 0 before connecting power to enter flash mode. Reset to 1 (default) after finished flashing. If you use Windows7+, check in the device manager if the port is not added/removed all 2 seconds. If yes then your USB port does not deliver enough ampere. And/Or reduce upload speed to 57600 in Arduino IDE. Use an active USB HUB if your computer delivers not enough ampere External power source will stabilize the 4CH-pro and you can increase upload speed back to 115200. Using a Laptop instead of a Desktop Tower might also do the trick as Laptops have a battery to deliver more ampere. you can not flash it with tasmota-minimal.bin, you need to flash it with tasmota.bin ! Using esptool following commands might be usefull (you need to change com port) to clear: esptool.exe -cp COM6 -cb 115200 -ce -v to program: esptool.exe -cp COM6 -bm dout -cf tasmota.bin -v 4CH Pro DIPSwitch Configuration ~ Most special modes of the 4CH Pro are controlled by DIP switch panels on the board. Please refer to the back of the board or the Sonoff documentation for more details. For normal operation with Tasmota the following settings are recommended: S6: 1 K5: all 1 K6: all 0 (0 and 1 are printed onto the board next to the switch names) Changing these switches for operations like inching and interlocking are also supported with Tasmota. Official Sources ~ Itead Product Page Itead Shop Itead Wiki","title":"Sonoff 4CH Pro"},{"location":"devices/Sonoff-4CH-Pro/#serial-flashing","text":"","title":"Serial Flashing"},{"location":"devices/Sonoff-4CH-Pro/#sonoff-4ch-pro","text":"The \"FW/IO0\" button (Switch 1) is not directly connected to GPIO0 of the ESP module. A different method has to be used to program this board. To program the ESP chip disconnect power from the board, connect a cable from any Ground (GND) pin to the GPIO0 pin on the ESP (be careful not to touch any of the other pins). This is the second pin to the right on the top row of pins (see picture). While holding the pin connected power on the board. The board does not respond to any button pressed when in programming mode and LED 1, 2 and 3 are on (might differ per board). Use the ESP programming header as described in the picture to upload the firmware and follow regular programming procedure.","title":"Sonoff 4CH Pro"},{"location":"devices/Sonoff-4CH-Pro/#sonoff-4ch-pro-r2","text":"On the R2 module the GPIO0 pin is broken out to a small pad to the right of the ESP package :","title":"Sonoff 4CH Pro R2"},{"location":"devices/Sonoff-4CH-Pro/#solving-sonoff-4ch-pro-programing-issues","text":"If you have problems to program the 4CH Pro, you might find below tips useful: * Use the ESP program header and ensure that the right port is set in the Arduino IDE. * TX/RX are printed correctly on the pro version => TX goes to RX PIN and RX to TX. * GPIO0 needs to be connected to ground the first 3 seconds during reboot (or longer)! If not you can not program it. * On 4CH Pro R2 try switch S6 to 0 before connecting power to enter flash mode. Reset to 1 (default) after finished flashing. If you use Windows7+, check in the device manager if the port is not added/removed all 2 seconds. If yes then your USB port does not deliver enough ampere. And/Or reduce upload speed to 57600 in Arduino IDE. Use an active USB HUB if your computer delivers not enough ampere External power source will stabilize the 4CH-pro and you can increase upload speed back to 115200. Using a Laptop instead of a Desktop Tower might also do the trick as Laptops have a battery to deliver more ampere. you can not flash it with tasmota-minimal.bin, you need to flash it with tasmota.bin ! Using esptool following commands might be usefull (you need to change com port) to clear: esptool.exe -cp COM6 -cb 115200 -ce -v to program: esptool.exe -cp COM6 -bm dout -cf tasmota.bin -v","title":"Solving Sonoff 4CH Pro programing issues"},{"location":"devices/Sonoff-4CH-Pro/#4ch-pro-dipswitch-configuration","text":"Most special modes of the 4CH Pro are controlled by DIP switch panels on the board. Please refer to the back of the board or the Sonoff documentation for more details. For normal operation with Tasmota the following settings are recommended: S6: 1 K5: all 1 K6: all 0 (0 and 1 are printed onto the board next to the switch names) Changing these switches for operations like inching and interlocking are also supported with Tasmota.","title":"4CH Pro DIPSwitch Configuration"},{"location":"devices/Sonoff-4CH-Pro/#official-sources","text":"Itead Product Page Itead Shop Itead Wiki","title":"Official Sources"},{"location":"devices/Sonoff-4CH-and-4CH-Pro/","text":"Sonoff 4CH moved here! Sonoff 4CH Pro moved here!","title":"Sonoff 4CH and 4CH Pro"},{"location":"devices/Sonoff-4CH/","text":"Serial Flashing ~ Please see the Hardware Preparation page for general instructions. Sonoff 4CH and Sonoff 4CH R2 use the same configuration but have slightly different boards. Check which version you own before proceeding. Sonoff 4CH ~ Attention: The printed labels on the PCB for RX and TX may be incorrectly swapped as can be seen on the image. Regardless of the labels, the pin next to VCC33 is RX. The Sonoff 4CH features four hardware buttons. Button marked FW/IO0 is connected to GPIO0 and can be used to bring the module into flash mode. Sonoff 4CH R2 ~ Board is labelled Sonoff 4CH R2 V1.0. The RX and TX pins are correctly labelled on this PCB revision. The button labelled IO0 is connected to GPIO0 and can be used to bring the module into flash mode. Official Sources ~ Itead Product Page Itead Shop Itead Wiki","title":"Sonoff 4CH"},{"location":"devices/Sonoff-4CH/#serial-flashing","text":"Please see the Hardware Preparation page for general instructions. Sonoff 4CH and Sonoff 4CH R2 use the same configuration but have slightly different boards. Check which version you own before proceeding.","title":"Serial Flashing"},{"location":"devices/Sonoff-4CH/#sonoff-4ch","text":"Attention: The printed labels on the PCB for RX and TX may be incorrectly swapped as can be seen on the image. Regardless of the labels, the pin next to VCC33 is RX. The Sonoff 4CH features four hardware buttons. Button marked FW/IO0 is connected to GPIO0 and can be used to bring the module into flash mode.","title":"Sonoff 4CH"},{"location":"devices/Sonoff-4CH/#sonoff-4ch-r2","text":"Board is labelled Sonoff 4CH R2 V1.0. The RX and TX pins are correctly labelled on this PCB revision. The button labelled IO0 is connected to GPIO0 and can be used to bring the module into flash mode.","title":"Sonoff 4CH R2"},{"location":"devices/Sonoff-4CH/#official-sources","text":"Itead Product Page Itead Shop Itead Wiki","title":"Official Sources"},{"location":"devices/Sonoff-B1-and-B1-R2/","text":"PAGE MOVED!","title":"Sonoff B1 and B1 R2"},{"location":"devices/Sonoff-B1/","text":"Sonoff B1 R2 is the replacement for Sonoff B1 and can be programmed the same way as the B1. See here for more background information. Serial Flashing ~ Please see the Hardware Preparation page for general instructions. As always, you need to access the serial interface. First pop up the top part of the bulb with controlled force. The PCB as shown in the image will become visible. The four serial pins (3V3, RX, TX, GND) as well as the GPIO0 signal line are available as test points and clearly marked. Solder wires to those or use pogo pins as you prefer. As with all modules pulling GPIO0 to GND is needed to put the chip in programming mode. You need to connect GPIO0 and GND during power up. An additional GND pad is available in the middle of the PCB. NOTE: If experiencing trouble getting the B1 R2 into flash mode, try pulling GPIO to GND during power up and holding it for 20 to 25 seconds before release. LED HEX10 Color Codes ~ The Sonoff B1 uses a TEN charter HEX code for all colors. Colors tested with firmware 5.9.1 20171107: * 00000000A0 = WARM * 000000A000 = COOL * 0000A00000 = BLUE * FF14500000 = PURPLE * 551A8B0000 = DARK PURPLE * A300000000 = RED * 00ff000000 = GREEN Official Sources ~ Itead Product Page: http://sonoff.itead.cc/en/products/residential/sonoff-b1 Itead Shop: https://www.itead.cc/sonoff-b1.html Itead Wiki: (not available)","title":"Sonoff B1"},{"location":"devices/Sonoff-B1/#serial-flashing","text":"Please see the Hardware Preparation page for general instructions. As always, you need to access the serial interface. First pop up the top part of the bulb with controlled force. The PCB as shown in the image will become visible. The four serial pins (3V3, RX, TX, GND) as well as the GPIO0 signal line are available as test points and clearly marked. Solder wires to those or use pogo pins as you prefer. As with all modules pulling GPIO0 to GND is needed to put the chip in programming mode. You need to connect GPIO0 and GND during power up. An additional GND pad is available in the middle of the PCB. NOTE: If experiencing trouble getting the B1 R2 into flash mode, try pulling GPIO to GND during power up and holding it for 20 to 25 seconds before release.","title":"Serial Flashing"},{"location":"devices/Sonoff-B1/#led-hex10-color-codes","text":"The Sonoff B1 uses a TEN charter HEX code for all colors. Colors tested with firmware 5.9.1 20171107: * 00000000A0 = WARM * 000000A000 = COOL * 0000A00000 = BLUE * FF14500000 = PURPLE * 551A8B0000 = DARK PURPLE * A300000000 = RED * 00ff000000 = GREEN","title":"LED HEX10 Color Codes"},{"location":"devices/Sonoff-B1/#official-sources","text":"Itead Product Page: http://sonoff.itead.cc/en/products/residential/sonoff-b1 Itead Shop: https://www.itead.cc/sonoff-b1.html Itead Wiki: (not available)","title":"Official Sources"},{"location":"devices/Sonoff-Basic-and-BME280/","text":"\"BME280 sensor, an environmental sensor with temperature, barometric pressure and humidity\", see Datasheet. Connect BME280 to Sonoff-Basic based on the GPIO locations ~ BME280-3.3V -> Sonoff-3.3V BME280-GND -> Sonoff-GND BME280-SCL -> Sonoff-TX BME280-SDA -> Sonoff-RX NOTE: YOU NEED TO DISABLE SERIAL LOG COMPLETELY TO ALLOW SENSORS ON TX/RX PINS On the Tasmota web interface go to Configuration->Configure Module and set","title":"Sonoff Basic and BME280"},{"location":"devices/Sonoff-Basic-and-BME280/#connect-bme280-to-sonoff-basic-based-on-the-gpio-locations","text":"BME280-3.3V -> Sonoff-3.3V BME280-GND -> Sonoff-GND BME280-SCL -> Sonoff-TX BME280-SDA -> Sonoff-RX NOTE: YOU NEED TO DISABLE SERIAL LOG COMPLETELY TO ALLOW SENSORS ON TX/RX PINS On the Tasmota web interface go to Configuration->Configure Module and set","title":"Connect BME280 to Sonoff-Basic based on the GPIO locations"},{"location":"devices/Sonoff-Basic/","text":"Sonoff Basic - the one that started it all! Serial Flashing ~ Please see the Hardware Preparation page for general instructions. You need to access the serial interface. The four serial pins (3V3, Rx, Tx, GND) are available in the middle of the PCB, right next to the on-board button. Newer versions of the Sonoff Basic device provide five pins below the button, ignore the pin furthest away from the Button (GPIO14 or I02) if available. The square pin right next to the button is the 3.3V line. For flashing the Sonoff Basic, hold the button while connecting the 3.3V power. The LED remains off until the flashing process is done and the board is rebooted. If your switch is powering up but is showing a solid-blink-reset pattern see this FAQ entry for advice . GPIO00 - BUTTON GPIO12 - RELAY GPIO13 - LED1 GPIO03 - RX PIN GPIO01 - TX PIN Sonoff Basic R3 ~ This is the board layout for the third design iteration of the Sonoff Basic. The Sonoff Basic R3 uses the ESP8255 chip. With this version, the mains power reverts to solder rails directly on the PCB. It also moves the Wi-Fi module to a separate PCB mounted on the main PCB. It makes access to the underside of the serial interface contacts quite difficult. This version of the device supports the new Itead DIY architecture which allows OTA firmware upload . The device was reviewed by DigiblurDIY in this video . The serial interface pins are broken out on the PCB making flashing using a serial adapter as well. Since the underside of the contacts is not easily reachable, use a solderless solution (i.e., friction) to maintain contact with the pins to flash the device. Sonoff Basic R2 ~ Around November 2018, Itead changed the layout of the Sonoff Basic ( issue #4515 ). The new board is labeled as Sonoff RF R2 POWER V1.0 . It is easily discerned from previous revisions since it uses wires instead of thick solder traces for mains power. The new version of the Sonoff Basic smart switch uses an ESP8285 SoC with the 1MB flash integrated into the same SoC chip. GPIO14 is no longer broken out to a contact on the PCB. Instead, GPIO02 (no pullup) is broken out. It is labeled as IO2 on the board. To use GPIO02, take care that it is not being pulled low when the device is booting . Otherwise, the device will not boot into its regular operational mode. Alternatively, you can use use GPIO03 (Rx) which does not have any boot function restrictions. However, both of these GPIO are pulled high momentarily after boot. This means that any connected device may \"blink\" when the Sonoff is powering up. Unlike GPIO03, the GPIO02 PCB contact is not prepared for a pin. You will need to solder your cable directly on the board. Be careful. Too high a temperature or long heating can damage the contact and its connectivity. You should also make sure that there is no tension on the cable. Affix the cable with a cable tie and perhaps some hot glue. GPIO02 as a user configurable input is implemented in the Sonoff Basic module (introduced in 6.3.0.15). If you use GPIO03, you must use a device template (rather than selecting the Sonoff Basic module), and also disable serial logging ( SerialLog 0 ). You can remove the thick wires from the PCB to use the screw connection on the output side for low voltage. Then add a screw terminal next to the relay for the LINE OUT. This keeps all high voltage on one side of the board Sonoff Basic R1 ~ This is the board layout for the first board version of the Sonoff Basic. (Image re-used from https://www.instructables.com/id/Use-Homie-Firmware-to-Drive-Sonoff-Switch-Module-E/ Thanks @amayii0) Usable GPIO: - GPIO14 is broken out on the PCB adjacent to the GND pin. - GPIO13 - You must remove the bi-colour LED - GPIO04 - You must solder wire to pin on ESP chip Official Sources ~ Itead Product Page Itead Shop Itead Wiki","title":"Sonoff Basic"},{"location":"devices/Sonoff-Basic/#serial-flashing","text":"Please see the Hardware Preparation page for general instructions. You need to access the serial interface. The four serial pins (3V3, Rx, Tx, GND) are available in the middle of the PCB, right next to the on-board button. Newer versions of the Sonoff Basic device provide five pins below the button, ignore the pin furthest away from the Button (GPIO14 or I02) if available. The square pin right next to the button is the 3.3V line. For flashing the Sonoff Basic, hold the button while connecting the 3.3V power. The LED remains off until the flashing process is done and the board is rebooted. If your switch is powering up but is showing a solid-blink-reset pattern see this FAQ entry for advice . GPIO00 - BUTTON GPIO12 - RELAY GPIO13 - LED1 GPIO03 - RX PIN GPIO01 - TX PIN","title":"Serial Flashing"},{"location":"devices/Sonoff-Basic/#sonoff-basic-r3","text":"This is the board layout for the third design iteration of the Sonoff Basic. The Sonoff Basic R3 uses the ESP8255 chip. With this version, the mains power reverts to solder rails directly on the PCB. It also moves the Wi-Fi module to a separate PCB mounted on the main PCB. It makes access to the underside of the serial interface contacts quite difficult. This version of the device supports the new Itead DIY architecture which allows OTA firmware upload . The device was reviewed by DigiblurDIY in this video . The serial interface pins are broken out on the PCB making flashing using a serial adapter as well. Since the underside of the contacts is not easily reachable, use a solderless solution (i.e., friction) to maintain contact with the pins to flash the device.","title":"Sonoff Basic R3"},{"location":"devices/Sonoff-Basic/#sonoff-basic-r2","text":"Around November 2018, Itead changed the layout of the Sonoff Basic ( issue #4515 ). The new board is labeled as Sonoff RF R2 POWER V1.0 . It is easily discerned from previous revisions since it uses wires instead of thick solder traces for mains power. The new version of the Sonoff Basic smart switch uses an ESP8285 SoC with the 1MB flash integrated into the same SoC chip. GPIO14 is no longer broken out to a contact on the PCB. Instead, GPIO02 (no pullup) is broken out. It is labeled as IO2 on the board. To use GPIO02, take care that it is not being pulled low when the device is booting . Otherwise, the device will not boot into its regular operational mode. Alternatively, you can use use GPIO03 (Rx) which does not have any boot function restrictions. However, both of these GPIO are pulled high momentarily after boot. This means that any connected device may \"blink\" when the Sonoff is powering up. Unlike GPIO03, the GPIO02 PCB contact is not prepared for a pin. You will need to solder your cable directly on the board. Be careful. Too high a temperature or long heating can damage the contact and its connectivity. You should also make sure that there is no tension on the cable. Affix the cable with a cable tie and perhaps some hot glue. GPIO02 as a user configurable input is implemented in the Sonoff Basic module (introduced in 6.3.0.15). If you use GPIO03, you must use a device template (rather than selecting the Sonoff Basic module), and also disable serial logging ( SerialLog 0 ). You can remove the thick wires from the PCB to use the screw connection on the output side for low voltage. Then add a screw terminal next to the relay for the LINE OUT. This keeps all high voltage on one side of the board","title":"Sonoff Basic R2"},{"location":"devices/Sonoff-Basic/#sonoff-basic-r1","text":"This is the board layout for the first board version of the Sonoff Basic. (Image re-used from https://www.instructables.com/id/Use-Homie-Firmware-to-Drive-Sonoff-Switch-Module-E/ Thanks @amayii0) Usable GPIO: - GPIO14 is broken out on the PCB adjacent to the GND pin. - GPIO13 - You must remove the bi-colour LED - GPIO04 - You must solder wire to pin on ESP chip","title":"Sonoff Basic R1"},{"location":"devices/Sonoff-Basic/#official-sources","text":"Itead Product Page Itead Shop Itead Wiki","title":"Official Sources"},{"location":"devices/Sonoff-Dual-R2/","text":"Sonoff Dual R2 is the replacement for Sonoff Dual. Compared to the Dual the main differences/improvements for R2 are: * As the second microcontroller has been removed both relays are now controlled directly by an ESP8285 * The button is now directly connected to the ESP8285 * The header connector is now supported in Tasmota Serial Flashing (Sonoff Dual R2) ~ Please see the Hardware Preparation page for general instructions. As always, you need to access the serial interface. VCC, RX, TX and GND are available at the bottom left end of the PCB in the image below. Programming the Sonoff Dual R2 is a breeze although the on-board-button is not connected to GPIO0. As with all ESP8266/ESP8285 modules pulling GPIO0 to GND is needed to put the chip in programming mode. You need to connect GPIO0 and GND during power up. Luckily both GND and GPIO0 (as BUTTON 0) are available on the second header. A simple jumper between GND and BUTTON 0 while powering on will do. For a video on how to flash the Sonoff Dual R2 with Tasmota, take a look here . Use external switches ~ The relays can be controlled by external push buttons or switches connected to the header at the designated positions. BUTTON 0 (on GPIO0) connected to GND controls Relay1 and BUTTON 1 (on GPIO9) connected to GND controls Relay2. See the image on the right how to configure this functionality in Tasmota as Switch1 and Switch2. NOTE Make sure not to use a switch that keeps the connection between GND and BUTTON 0 active while power is re-applied as the device will start in programming mode. Note 2: GPIO9 and 10 can be safely used with an external switch (even rebooting with the contacts closed), and configured as such using a template. GPIO9 is available in the header, and GPIO10 is the board's button (you only need to solder a wire to the GPIO10 side of the button, no need to remove it). Sonoff Dual ( not R2) ~ Serial Connection ~ Please see the Hardware Preparation page for general instructions. As always, you need to access the serial interface. The four serial pins (3V3, Rx, Tx, GND) are available at the short end of the PCB and can be seen on the left side of the first image and are labeled in red on the second image. For the v2.0 version of the board you need to cross-over the serial interface, see troubleshooting . Programming the Sonoff Dual is more difficult because the on-board-button is not connected to GPIO0. As with all ESP8266 modules pulling GPIO0 to GND is needed to put the chip in programming mode. You need to connect GPIO0 and GND during power up. GND can be found on all three headers. GPIO0 can be accessed two ways: 1. Unscrew the Sonoff Dual from the housing and access the underside of the PCB You can find GPIO0 on one side of a resistor as shown in the second image. 2. GPIO0 can be found on the small inter layer via pointed at in the first image. Attention: If the via is covered by silk screen (green) you need to expose the underlying conductive (copper) by careful scratching it off. Restricted Button Functionality ~ Please be aware, that the button on the Sonoff Dual will initially not have any functionality! Other than on most Sonoff module the button is not connected to the normal button pin (GPIO0). After freshly flashing Tasmota (with the default module setting \"Sonoff Basic\"), the button will not act as described in the Buttons and Switches article. You will not be able to switch power or activate the special WiFi modes. You will need to configure wifi credentials connecting directly to the wifi AP your Dual will broadcast or configure the module firmware config beforehand via user_config_override.h . After configuring the device as a \"Sonoff Dual\", the button will regain normal functionality. GPIO Locations ~ GPIO4 => red, GPIO14 => orange Solving intermittent relay switch errors ~ Where most Sonoff's use GPIO to control one or more relays the Sonoff Dual and 4 Channel Inching Relay Assy do use the standard SERIAL interface to control the relays. Commands are send from the ESP8266 via a 19200 baud serial connection to a dedicated chip that controls the relays. It is therefore important to disable any serial communication to and from the device once you have debugged any anomalies. To assist easy installation serial logging is enabled by default in user_config_override.h for all Sonoffs. Once in production it's wise to turn it off for all Sonoffs. For the Dual it is almost mandatory to turn it off. Execute command seriallog 0 once to turn all communication on the serial port off. If within 10 minutes no input is received serial communication is turned off too. Another reason for intermittent switching errors can be Power Saving. Make sure it is disabled by executing the command sleep 0 . Official Sources ~ Itead Product Page: http://sonoff.itead.cc/en/products/sonoff/sonoff-dual Itead Shop: https://www.itead.cc/sonoff-dual.html Itead Wiki: https://www.itead.cc/wiki/Sonoff_Dual","title":"Sonoff Dual R2"},{"location":"devices/Sonoff-Dual-R2/#serial-flashing-sonoff-dual-r2","text":"Please see the Hardware Preparation page for general instructions. As always, you need to access the serial interface. VCC, RX, TX and GND are available at the bottom left end of the PCB in the image below. Programming the Sonoff Dual R2 is a breeze although the on-board-button is not connected to GPIO0. As with all ESP8266/ESP8285 modules pulling GPIO0 to GND is needed to put the chip in programming mode. You need to connect GPIO0 and GND during power up. Luckily both GND and GPIO0 (as BUTTON 0) are available on the second header. A simple jumper between GND and BUTTON 0 while powering on will do. For a video on how to flash the Sonoff Dual R2 with Tasmota, take a look here .","title":"Serial Flashing (Sonoff Dual R2)"},{"location":"devices/Sonoff-Dual-R2/#use-external-switches","text":"The relays can be controlled by external push buttons or switches connected to the header at the designated positions. BUTTON 0 (on GPIO0) connected to GND controls Relay1 and BUTTON 1 (on GPIO9) connected to GND controls Relay2. See the image on the right how to configure this functionality in Tasmota as Switch1 and Switch2. NOTE Make sure not to use a switch that keeps the connection between GND and BUTTON 0 active while power is re-applied as the device will start in programming mode. Note 2: GPIO9 and 10 can be safely used with an external switch (even rebooting with the contacts closed), and configured as such using a template. GPIO9 is available in the header, and GPIO10 is the board's button (you only need to solder a wire to the GPIO10 side of the button, no need to remove it).","title":"Use external switches"},{"location":"devices/Sonoff-Dual-R2/#sonoff-dual-not-r2","text":"","title":"Sonoff Dual (not R2)"},{"location":"devices/Sonoff-Dual-R2/#serial-connection","text":"Please see the Hardware Preparation page for general instructions. As always, you need to access the serial interface. The four serial pins (3V3, Rx, Tx, GND) are available at the short end of the PCB and can be seen on the left side of the first image and are labeled in red on the second image. For the v2.0 version of the board you need to cross-over the serial interface, see troubleshooting . Programming the Sonoff Dual is more difficult because the on-board-button is not connected to GPIO0. As with all ESP8266 modules pulling GPIO0 to GND is needed to put the chip in programming mode. You need to connect GPIO0 and GND during power up. GND can be found on all three headers. GPIO0 can be accessed two ways: 1. Unscrew the Sonoff Dual from the housing and access the underside of the PCB You can find GPIO0 on one side of a resistor as shown in the second image. 2. GPIO0 can be found on the small inter layer via pointed at in the first image. Attention: If the via is covered by silk screen (green) you need to expose the underlying conductive (copper) by careful scratching it off.","title":"Serial Connection"},{"location":"devices/Sonoff-Dual-R2/#restricted-button-functionality","text":"Please be aware, that the button on the Sonoff Dual will initially not have any functionality! Other than on most Sonoff module the button is not connected to the normal button pin (GPIO0). After freshly flashing Tasmota (with the default module setting \"Sonoff Basic\"), the button will not act as described in the Buttons and Switches article. You will not be able to switch power or activate the special WiFi modes. You will need to configure wifi credentials connecting directly to the wifi AP your Dual will broadcast or configure the module firmware config beforehand via user_config_override.h . After configuring the device as a \"Sonoff Dual\", the button will regain normal functionality.","title":"Restricted Button Functionality"},{"location":"devices/Sonoff-Dual-R2/#gpio-locations","text":"GPIO4 => red, GPIO14 => orange","title":"GPIO Locations"},{"location":"devices/Sonoff-Dual-R2/#solving-intermittent-relay-switch-errors","text":"Where most Sonoff's use GPIO to control one or more relays the Sonoff Dual and 4 Channel Inching Relay Assy do use the standard SERIAL interface to control the relays. Commands are send from the ESP8266 via a 19200 baud serial connection to a dedicated chip that controls the relays. It is therefore important to disable any serial communication to and from the device once you have debugged any anomalies. To assist easy installation serial logging is enabled by default in user_config_override.h for all Sonoffs. Once in production it's wise to turn it off for all Sonoffs. For the Dual it is almost mandatory to turn it off. Execute command seriallog 0 once to turn all communication on the serial port off. If within 10 minutes no input is received serial communication is turned off too. Another reason for intermittent switching errors can be Power Saving. Make sure it is disabled by executing the command sleep 0 .","title":"Solving intermittent relay switch errors"},{"location":"devices/Sonoff-Dual-R2/#official-sources","text":"Itead Product Page: http://sonoff.itead.cc/en/products/sonoff/sonoff-dual Itead Shop: https://www.itead.cc/sonoff-dual.html Itead Wiki: https://www.itead.cc/wiki/Sonoff_Dual","title":"Official Sources"},{"location":"devices/Sonoff-Dual-and-Dual-R2/","text":"Sonoff Dual moved here! Sonoff Dual R2 moved here!","title":"Sonoff Dual and Dual R2"},{"location":"devices/Sonoff-Dual/","text":"Sonoff Dual has been obsoleted by Sonoff Dual R2 . Before configuring your device check which revision you have since there are significant differences in how they operate. Serial Flashing ~ Please see the Hardware Preparation page for general instructions. As always, you need to access the serial interface. The four serial pins (3V3, Rx, Tx, GND) are available at the short end of the PCB and can be seen on the left side of the first image and are labeled in red on the second image. Alternative GPIO locations Programming the Sonoff Dual is more difficult because the on-board-button is not connected to GPIO0. As with all ESP8266 modules pulling GPIO0 to GND is needed to put the chip in programming mode. You need to connect GPIO0 and GND during power up. GND can be found on all three headers. GPIO0 can be accessed in two ways: 1. Unscrew the Sonoff Dual from the housing and access the underside of the PCB. You can find GPIO0 on one side of a resistor as shown in the second image. 2. GPIO0 can be found on the small inter layer via pointed at in the first image. Attention: If the via is covered by silk screen (green) you need to expose the underlying conductive (copper) by carefully scratching it off. Restricted Button Functionality ~ Please be aware, that the button on the Sonoff Dual will initially not have any functionality! The button is not connected to the normal button pin (GPIO0). After freshly flashing Tasmota (with the default module setting \"Sonoff Basic\"), the button will not act as described in the Buttons and Switches article. You will not be able to switch power or activate the special WiFi modes. After configuring the device as \"Sonoff Dual (5)\", the button will regain normal functionality. GPIO Locations ~ GPIO4 = red, GPIO14 = orange Solving intermittent relay switch errors ~ Where most Sonoff's use GPIO to control one or more relays the Sonoff Dual uses the serial interface to control the relays. Commands are send from the ESP8266 via a 19200 baud serial connection to a dedicated chip that controls the relays. It is therefore important to disable any serial communication to and from the device once you have debugged any anomalies. To assist easy installation serial logging is enabled by default in Tasmota. For the Dual it is mandatory to turn it off withe SerialLog 0 comand. Another reason for intermittent switching errors can be Power Saving. Make sure it is disabled by executing the command sleep 0 . Official Sources ~ Itead Product Page: http://sonoff.itead.cc/en/products/sonoff/sonoff-dual Itead Shop: https://www.itead.cc/sonoff-dual.html Itead Wiki: https://www.itead.cc/wiki/Sonoff_Dual","title":"Sonoff Dual"},{"location":"devices/Sonoff-Dual/#serial-flashing","text":"Please see the Hardware Preparation page for general instructions. As always, you need to access the serial interface. The four serial pins (3V3, Rx, Tx, GND) are available at the short end of the PCB and can be seen on the left side of the first image and are labeled in red on the second image. Alternative GPIO locations Programming the Sonoff Dual is more difficult because the on-board-button is not connected to GPIO0. As with all ESP8266 modules pulling GPIO0 to GND is needed to put the chip in programming mode. You need to connect GPIO0 and GND during power up. GND can be found on all three headers. GPIO0 can be accessed in two ways: 1. Unscrew the Sonoff Dual from the housing and access the underside of the PCB. You can find GPIO0 on one side of a resistor as shown in the second image. 2. GPIO0 can be found on the small inter layer via pointed at in the first image. Attention: If the via is covered by silk screen (green) you need to expose the underlying conductive (copper) by carefully scratching it off.","title":"Serial Flashing"},{"location":"devices/Sonoff-Dual/#restricted-button-functionality","text":"Please be aware, that the button on the Sonoff Dual will initially not have any functionality! The button is not connected to the normal button pin (GPIO0). After freshly flashing Tasmota (with the default module setting \"Sonoff Basic\"), the button will not act as described in the Buttons and Switches article. You will not be able to switch power or activate the special WiFi modes. After configuring the device as \"Sonoff Dual (5)\", the button will regain normal functionality.","title":"Restricted Button Functionality"},{"location":"devices/Sonoff-Dual/#gpio-locations","text":"GPIO4 = red, GPIO14 = orange","title":"GPIO Locations"},{"location":"devices/Sonoff-Dual/#solving-intermittent-relay-switch-errors","text":"Where most Sonoff's use GPIO to control one or more relays the Sonoff Dual uses the serial interface to control the relays. Commands are send from the ESP8266 via a 19200 baud serial connection to a dedicated chip that controls the relays. It is therefore important to disable any serial communication to and from the device once you have debugged any anomalies. To assist easy installation serial logging is enabled by default in Tasmota. For the Dual it is mandatory to turn it off withe SerialLog 0 comand. Another reason for intermittent switching errors can be Power Saving. Make sure it is disabled by executing the command sleep 0 .","title":"Solving intermittent relay switch errors"},{"location":"devices/Sonoff-Dual/#official-sources","text":"Itead Product Page: http://sonoff.itead.cc/en/products/sonoff/sonoff-dual Itead Shop: https://www.itead.cc/sonoff-dual.html Itead Wiki: https://www.itead.cc/wiki/Sonoff_Dual","title":"Official Sources"},{"location":"devices/Sonoff-Mini/","text":"The Sonoff Mini is, as the name implies, a very small device, designed to be hidden where there's only supposed to be cables. Since it's not supposed to be visible, it's also designed to easily attach an external button. Tasmota can be flashed on this device via OTA using the Sonoff DIY feature. Several free GPIO are available. The OTA jumper pin is the most accessible and very easy to use on a pin header. GPIO Description 0 Button 1 TX 2 Available 3 RX 4 S2 (external switch input) 12 Relay and red LED 13 Blue LED 16 OTA jumper pin GND S1 (external switch input)","title":"Sonoff Mini"},{"location":"devices/Sonoff-PSA/","text":"itead page","title":"Sonoff PSA"},{"location":"devices/Sonoff-Pow-R2/","text":"\u26a0\ufe0f\ufe0fSpecial Attention \u26a0\ufe0f\ufe0f ~ Do not connect AC power and the serial connection at the same time The GND connection of the Pow is connected to the live AC wire. Connecting serial with your PC will fry your PC and will electrocute you. DO NOT CONNECT ANYTHING TO ANY GPIOs OF THESE DEVICES!!! (No sensors, no switches, nothing) The GPIOs on the Pow are connected to AC power! Only use a POW R2 as designed. The AC connection between Pow and Pow R2 is different , please check exactly which version you have. - Pow R2 : Lo-E-E-Li-N-N = LineOut-EarthOut-EarthIn-LineIn-NeutralOut-NeutralIn - Pow : Lo-E-E-N-N-Li = LineOut-EarthOut-EarthIn-NeutralOut-NeutralIn-LineIn Serial Flashing ~ Please see the Hardware Preparation page for general instructions. 3V3, RX, TX and GND pins are available at the rear/short end of the PCB. To enter flash mode , press down on the button while powering the device. Note - After the module type is changed to \"Sonoff Pow R2\", the serial port is no longer available for entering configuration commands because the serial port is used to communicate to the power measurement chip. Make sure you have set up your network connection before doing this. Serial logging ~ Serial logging is disabled by the Tasmota code for this module. Serial communication is used by the device to transfer the data from the energy monitoring chip to the ESP chip. Do not enable serial logging ( SerialLog 0 ) on this device. It can cause the device software to crash. Be sure to leave it disabled. Video tutorial by alsolh ~ Power Monitoring Calibration ~ Sonoff Pow R2 might need calibration as correct measurements are influenced by hardware and timing differences. See Power Monitoring Calibration Telemetry ~ The Sonoff Pow R2 can provide Energy, Power, Voltage and Current information in different ways. The preffered way is using the periodic telemetry data. Default setting TelePeriod 300 will send telemetry data every 5 minutes. If the setting PowerDelta (new since version 5.12.0e) is not 0 (default 80%), telemetry will be sent on power change too. tele/pow1/SENSOR = {\"Time\":\"2018-02-15T17:37:10\",\"ENERGY\":{\"TotalStartTime\":\"2018-11-14T18:39:40\",\"Total\":6.294,\"Yesterday\":5.340,\"Today\":0.954,\"Period\":217,\"Power\":2635,\"ApparentPower\":2650,\"ReactivePower\":282,\"Factor\":0.99,\"Voltage\":227,\"Current\":11.661}} To request information you can use command Status 8 . stat/pow1/STATUS8 = {\"StatusSNS\":{\"Time\":\"2018-11-15T08:54:18\",\"ENERGY\":{\"TotalStartTime\":\"2018-11-14T18:39:40\",\"Total\":6.404,\"Yesterday\":5.340,\"Today\":1.064,\"Power\":2629,\"ApparentPower\":2645,\"ReactivePower\":288,\"Factor\":0.99,\"Voltage\":226,\"Current\":11.677}}} The presented information has the following meaning: Message | Unit | Description ---------------|------|----------------------------------------------------- TotalStartTime | Date | DateTime of calculation for Total Total | kWh | Total Energy usage including Today Yesterday | kWh | Total Energy usage between 00:00 and 24:00 yesterday Today | kWh | Total Energy usage today from 00:00 until now Period | Wh | Energy usage between previous message and now Power | W | Current effective power load ApparentPower | W | Power load on the cable = sqrt(Power^2 + | | ReactivePower^2) ReactivePower | W | Reactive load Factor | | The ratio of the real power flowing to the load to | | the apparent power in the circuit Voltage | V | Current line voltage Current | A | Current line current Official Sources ~ Itead Product Page Itead Shop (R2) Itead Wiki","title":"Sonoff Pow R2"},{"location":"devices/Sonoff-Pow-R2/#special-attention","text":"Do not connect AC power and the serial connection at the same time The GND connection of the Pow is connected to the live AC wire. Connecting serial with your PC will fry your PC and will electrocute you. DO NOT CONNECT ANYTHING TO ANY GPIOs OF THESE DEVICES!!! (No sensors, no switches, nothing) The GPIOs on the Pow are connected to AC power! Only use a POW R2 as designed. The AC connection between Pow and Pow R2 is different , please check exactly which version you have. - Pow R2 : Lo-E-E-Li-N-N = LineOut-EarthOut-EarthIn-LineIn-NeutralOut-NeutralIn - Pow : Lo-E-E-N-N-Li = LineOut-EarthOut-EarthIn-NeutralOut-NeutralIn-LineIn","title":"\u26a0\ufe0f\ufe0fSpecial Attention   \u26a0\ufe0f\ufe0f"},{"location":"devices/Sonoff-Pow-R2/#serial-flashing","text":"Please see the Hardware Preparation page for general instructions. 3V3, RX, TX and GND pins are available at the rear/short end of the PCB. To enter flash mode , press down on the button while powering the device. Note - After the module type is changed to \"Sonoff Pow R2\", the serial port is no longer available for entering configuration commands because the serial port is used to communicate to the power measurement chip. Make sure you have set up your network connection before doing this.","title":"Serial Flashing"},{"location":"devices/Sonoff-Pow-R2/#serial-logging","text":"Serial logging is disabled by the Tasmota code for this module. Serial communication is used by the device to transfer the data from the energy monitoring chip to the ESP chip. Do not enable serial logging ( SerialLog 0 ) on this device. It can cause the device software to crash. Be sure to leave it disabled.","title":"Serial logging"},{"location":"devices/Sonoff-Pow-R2/#video-tutorial-by-alsolh","text":"","title":"Video tutorial by alsolh"},{"location":"devices/Sonoff-Pow-R2/#power-monitoring-calibration","text":"Sonoff Pow R2 might need calibration as correct measurements are influenced by hardware and timing differences. See Power Monitoring Calibration","title":"Power Monitoring Calibration"},{"location":"devices/Sonoff-Pow-R2/#telemetry","text":"The Sonoff Pow R2 can provide Energy, Power, Voltage and Current information in different ways. The preffered way is using the periodic telemetry data. Default setting TelePeriod 300 will send telemetry data every 5 minutes. If the setting PowerDelta (new since version 5.12.0e) is not 0 (default 80%), telemetry will be sent on power change too. tele/pow1/SENSOR = {\"Time\":\"2018-02-15T17:37:10\",\"ENERGY\":{\"TotalStartTime\":\"2018-11-14T18:39:40\",\"Total\":6.294,\"Yesterday\":5.340,\"Today\":0.954,\"Period\":217,\"Power\":2635,\"ApparentPower\":2650,\"ReactivePower\":282,\"Factor\":0.99,\"Voltage\":227,\"Current\":11.661}} To request information you can use command Status 8 . stat/pow1/STATUS8 = {\"StatusSNS\":{\"Time\":\"2018-11-15T08:54:18\",\"ENERGY\":{\"TotalStartTime\":\"2018-11-14T18:39:40\",\"Total\":6.404,\"Yesterday\":5.340,\"Today\":1.064,\"Power\":2629,\"ApparentPower\":2645,\"ReactivePower\":288,\"Factor\":0.99,\"Voltage\":226,\"Current\":11.677}}} The presented information has the following meaning: Message | Unit | Description ---------------|------|----------------------------------------------------- TotalStartTime | Date | DateTime of calculation for Total Total | kWh | Total Energy usage including Today Yesterday | kWh | Total Energy usage between 00:00 and 24:00 yesterday Today | kWh | Total Energy usage today from 00:00 until now Period | Wh | Energy usage between previous message and now Power | W | Current effective power load ApparentPower | W | Power load on the cable = sqrt(Power^2 + | | ReactivePower^2) ReactivePower | W | Reactive load Factor | | The ratio of the real power flowing to the load to | | the apparent power in the circuit Voltage | V | Current line voltage Current | A | Current line current","title":"Telemetry"},{"location":"devices/Sonoff-Pow-R2/#official-sources","text":"Itead Product Page Itead Shop (R2) Itead Wiki","title":"Official Sources"},{"location":"devices/Sonoff-Pow/","text":"Sonoff Pow has been obsoleted with Sonoff Pow R2 . Before configuring your device check which revision you have. \u26a0\ufe0f\ufe0fSpecial Attention \u26a0\ufe0f\ufe0f ~ Do not connect AC power and the serial connection at the same time The GND connection of the Pow is connected to the live AC wire. Connecting serial with your PC will fry your PC and will electrocute you. DO NOT CONNECT ANYTHING TO THESE DEVICES!!! (No sensors, no switches, nothing) The GPIOs on the Pow are connected to AC power! Only use a POW as designed. The AC connection between Pow and Pow R2 is different , please check exactly which version you have. - Pow R2 : Lo-E-E-Li-N-N = LineOut-EarthOut-EarthIn-LineIn-NeutralOut-NeutralIn - Pow : Lo-E-E-N-N-Li = LineOut-EarthOut-EarthIn-NeutralOut-NeutralIn-LineIn Serial Connection ~ Please see the Hardware Preparation page for general instructions. 3V3, RX, TX and GND pins are available at the rear end of the PCB. To enter flash mode , press down on the button while powering the device. Power Monitoring Calibration ~ Sonoff Pow might need calibration as correct measurements are influenced by hardware and timing differences. See Power Monitoring Calibration Telemetry ~ The Sonoff Pow can provide Energy, Power, Voltage and Current information in different ways. The preferred way is using the periodic telemetry data. Default setting TelePeriod 300 will send telemetry data every 5 minutes. If the setting PowerDelta (new since version 5.12.0e) is not 0 (default 80%), telemetry will be sent on power change too. tele/pow1/SENSOR = {\"Time\":\"2018-02-15T17:37:10\",\"ENERGY\":{\"TotalStartTime\":\"2018-11-14T18:39:40\",\"Total\":6.294,\"Yesterday\":5.340,\"Today\":0.954,\"Period\":217,\"Power\":2635,\"ApparentPower\":2650,\"ReactivePower\":282,\"Factor\":0.99,\"Voltage\":227,\"Current\":11.661}} To request information you can use command Status 8 . stat/pow1/STATUS8 = {\"StatusSNS\":{\"Time\":\"2018-11-15T08:54:18\",\"ENERGY\":{\"TotalStartTime\":\"2018-11-14T18:39:40\",\"Total\":6.404,\"Yesterday\":5.340,\"Today\":1.064,\"Power\":2629,\"ApparentPower\":2645,\"ReactivePower\":288,\"Factor\":0.99,\"Voltage\":226,\"Current\":11.677}}} The presented information has the following meaning: Message | Unit | Description ---------------|------|----------------------------------------------------- TotalStartTime | Date | DateTime of calculation for Total Total | kWh | Total Energy usage including Today Yesterday | kWh | Total Energy usage between 00:00 and 24:00 yesterday Today | kWh | Total Energy usage today from 00:00 until now Period | Wh | Energy usage between previous message and now Power | W | Current effective power load ApparentPower | W | Power load on the cable = sqrt(Power^2 + | | ReactivePower^2) ReactivePower | W | Reactive load Factor | | The ratio of the real power flowing to the load to | | the apparent power in the circuit Voltage | V | Current line voltage Current | A | Current line current Self Protection for Sonoff Pow ~ ITEAD published a recall notice for the Sonoff Pow on March 1st 2017. Some units produced in december 2016 and january 2017 are not well suited for 16A. If you have one of these units you can decide to use them anyway by limiting the maximum current in software. It is, in fact, possible to set a Maximum Power Threshold for the Sonoff Pow. If the power measured by the device exceeds the threshold set by the command MaxPower for a number of seconds set by the command MaxPowerHold the device will remain switched off for MaxPowerWindow seconds (to let it cool down, for example). For all details see issue #218 Official Sources ~ Itead Product Page Itead Shop Itead Wiki","title":"Sonoff Pow"},{"location":"devices/Sonoff-Pow/#special-attention","text":"Do not connect AC power and the serial connection at the same time The GND connection of the Pow is connected to the live AC wire. Connecting serial with your PC will fry your PC and will electrocute you. DO NOT CONNECT ANYTHING TO THESE DEVICES!!! (No sensors, no switches, nothing) The GPIOs on the Pow are connected to AC power! Only use a POW as designed. The AC connection between Pow and Pow R2 is different , please check exactly which version you have. - Pow R2 : Lo-E-E-Li-N-N = LineOut-EarthOut-EarthIn-LineIn-NeutralOut-NeutralIn - Pow : Lo-E-E-N-N-Li = LineOut-EarthOut-EarthIn-NeutralOut-NeutralIn-LineIn","title":"\u26a0\ufe0f\ufe0fSpecial Attention   \u26a0\ufe0f\ufe0f"},{"location":"devices/Sonoff-Pow/#serial-connection","text":"Please see the Hardware Preparation page for general instructions. 3V3, RX, TX and GND pins are available at the rear end of the PCB. To enter flash mode , press down on the button while powering the device.","title":"Serial Connection"},{"location":"devices/Sonoff-Pow/#power-monitoring-calibration","text":"Sonoff Pow might need calibration as correct measurements are influenced by hardware and timing differences. See Power Monitoring Calibration","title":"Power Monitoring Calibration"},{"location":"devices/Sonoff-Pow/#telemetry","text":"The Sonoff Pow can provide Energy, Power, Voltage and Current information in different ways. The preferred way is using the periodic telemetry data. Default setting TelePeriod 300 will send telemetry data every 5 minutes. If the setting PowerDelta (new since version 5.12.0e) is not 0 (default 80%), telemetry will be sent on power change too. tele/pow1/SENSOR = {\"Time\":\"2018-02-15T17:37:10\",\"ENERGY\":{\"TotalStartTime\":\"2018-11-14T18:39:40\",\"Total\":6.294,\"Yesterday\":5.340,\"Today\":0.954,\"Period\":217,\"Power\":2635,\"ApparentPower\":2650,\"ReactivePower\":282,\"Factor\":0.99,\"Voltage\":227,\"Current\":11.661}} To request information you can use command Status 8 . stat/pow1/STATUS8 = {\"StatusSNS\":{\"Time\":\"2018-11-15T08:54:18\",\"ENERGY\":{\"TotalStartTime\":\"2018-11-14T18:39:40\",\"Total\":6.404,\"Yesterday\":5.340,\"Today\":1.064,\"Power\":2629,\"ApparentPower\":2645,\"ReactivePower\":288,\"Factor\":0.99,\"Voltage\":226,\"Current\":11.677}}} The presented information has the following meaning: Message | Unit | Description ---------------|------|----------------------------------------------------- TotalStartTime | Date | DateTime of calculation for Total Total | kWh | Total Energy usage including Today Yesterday | kWh | Total Energy usage between 00:00 and 24:00 yesterday Today | kWh | Total Energy usage today from 00:00 until now Period | Wh | Energy usage between previous message and now Power | W | Current effective power load ApparentPower | W | Power load on the cable = sqrt(Power^2 + | | ReactivePower^2) ReactivePower | W | Reactive load Factor | | The ratio of the real power flowing to the load to | | the apparent power in the circuit Voltage | V | Current line voltage Current | A | Current line current","title":"Telemetry"},{"location":"devices/Sonoff-Pow/#self-protection-for-sonoff-pow","text":"ITEAD published a recall notice for the Sonoff Pow on March 1st 2017. Some units produced in december 2016 and january 2017 are not well suited for 16A. If you have one of these units you can decide to use them anyway by limiting the maximum current in software. It is, in fact, possible to set a Maximum Power Threshold for the Sonoff Pow. If the power measured by the device exceeds the threshold set by the command MaxPower for a number of seconds set by the command MaxPowerHold the device will remain switched off for MaxPowerWindow seconds (to let it cool down, for example). For all details see issue #218","title":"Self Protection for Sonoff Pow"},{"location":"devices/Sonoff-Pow/#official-sources","text":"Itead Product Page Itead Shop Itead Wiki","title":"Official Sources"},{"location":"devices/Sonoff-RF-Bridge-433/","text":"The Sonoff RF Bridge has two separate chips to handle the Wi-Fi (ESP8285) and RF (EFM8BB1) communications respectively. It is used to send and receive codes with 433.9MHz frequency RF devices. Codes received from RF devices such as remote controls is passed to the onboard ESP8285 via the serial interface. The code data is relayed via MQTT. Similarly, the Bridge receives commands over Wi-Fi and sends the encoded data to the RF chip to control an RF device. Thus, the Sonoff RF Bridge \"bridges\" communications between RF and Wi-Fi. Flash Tasmota ~ Please see for flashing details and the Hardware Preparation article for general flashing instructions. Access the serial interface available on the 5-pin header next to the switch as can be seen in the image. To flash the ESP8285, first move the switch position towards the 5-pin header. Connect the serial-to-USB adapter and press the button on the edge while powering the device in order to put the ESP8285 into programming mode in order to upload the Tasmota firmware. After flashing the ESP8285, be sure to move the switch position away from the 5-pin header to restore the connection to the RF microcontroller. Configure the device as usual and select module Sonoff Bridge (25) . During normal operation the serial interface is used at 19200 baud to communicate with the RF microcontroller. Therefore serial logging ( SerialLog 0 ) must be disabled. IMPORTANT: In the Module configuration GPIO4 and GPIO5 must be left as 00 None On R2 versions of the Sonoff RF Bridge, a hardware modification is required in order to use these GPIO. Video tutorial by alsolh ~ RF Firmware ~ The RF chip has its own firmware. The device is shipped with Itead firmware which supports a limited set of RF devices limited to mostly just Sonoff devices (a single 24-bit RF protocol). Some later versions of the factory firmware will only relay received RF data once the transmitting device stops. This is fine for remote controls or devices such as door sensors. But for devices such as smoke detectors, this behavior is not acceptable. Custom firmware is available for the RF chip which is commonly referred to as 'Portisch'. By updating the firmware on the RF chip, new types of devices and new features become usable. It also relays the RF data when the data is received rather than waiting until the transmitter stops. Tasmota supports the original Sonoff RF firmware and the Portisch firmware . RF Firmware Upgrade ~ The RF upgrade requires wiring the bridge and then flashing the firmware via the Tasmota web UI. **Attention \u26a0\ufe0f\ufe0f\u26a0\ufe0f\ufe0f\u26a0\ufe0f\ufe0f There are 2 versions of the Sonoff RF Bridge 433 : the R1 and the R2 V1.0 . R1 R2 V1.0 RF firmware flashing: Hardware Preparation This section applies only to the R2 revision of the Sonoff RF Bridge Apply this modification only if you intend to use USB for powering the device during flash process or if you want to use GPIO4 or GPIO5 for other purposes with the RF Bridge. The R2 revision boards connect the GPIO4 and GPIO5 pins to the USB data lines of the power connector. Compliant USB chargers/power supplies are expected to short the two pins together, which is a problem. These lines are not used by the original firmware, nor by Tasmota. The traces toward the USB power connector need to be cut to avoid interference by the USB wiring. Removing these connections does not interfere with the normal Bridge functionality. Flashing RF Firmware Make sure you have previously flashed a Tasmota binary built with RF_FLASH . Refer to the builds table for pre-compiled binaries which include this feature. Otherwise the \"Magic byte is not 0xE9\" error will occur. Set the module type to Sonoff Bridge (25) Connect two wires (this will be different depending on the Sonoff RF Bridge 433 hardware version): For R1 : Connect GPIO4 to C2Ck and GPIO5 to C2D . For R2 : Connect GPIO4 to C2D and GPIO5 to C2Ck . ( The text on the R2 PCB silkscreen is switched. Therefore this is the same wiring as on the R1) Switch the ON/OFF switch on the board to 'OFF' to turn off the RF. Power up the bridge via the 3.3V & GND pins. (See below if you need to power the device through the USB power port) Obtain the Portisch firmware file: (Clicking on the file link on the GitHub web site does not work since this will download the GitHub preview/content of the file rather than the raw file contents) Download the entire contents of the Tasmota GitHub project project via the green Clone or Download button to ensure that the firmware hex files are downloaded properly. The firmware files are located in the ./tools/fw_efm8bb1/ folder. Select the newest available hex file. Otherwise you may get error \"Magic byte is not 0xE9\" . As an alternative use wget/curl to download the raw file (https://github.com/arendst/Tasmota/tree/master/tools/fw_efm8bb1) directly. Select the newest available hex file. Otherwise you may get error \"Magic byte is not 0xE9\" . PowerShell example: wget https://github.com/arendst/Tasmota/raw/master/tools/fw_efm8bb1/RF-Bridge-EFM8BB1-XXXXXXXX.hex -OutFile .\\RF-Bridge-EFM8BB1-XXXXXXXX.hex Go to the Web UI Firmware Upgrade > Upgrade by File Upload (introduced in v6.0.0a) In the file selection dialog, navigate to the folder on your computer where you saved the hex file from step 6. Click Start Upgrade . The flashing should complete within 60 seconds. Device will restart after upgrade completes. Disconnect wiring and put the ON/OFF switch on the board back to 'ON' to enable the RF again. Operation ~ The Sonoff RF Bridge is able to learn up to 16 different fixed code remote control commands as provided by PT2260, PT2262, PT2264 and EV1527 transmitters. It was not able to recognize the latest Klik Aan Klik Uit (KaKu) remote control signals but some people managed to use the fixed code KaKu devices like PAR-1000 receiver and PAT-103 transmitter. Tasmota provides default remote control commands to all 16 keys so you can start using the bridge with a Sonoff 4Ch Pro or Sonoff RF device without having the bridge have to learn remote control commands. See RF Bridge commands. Portisch Firmware Specific Usage ~ These sections only apply to the custom Portisch firmware. Learning Commands with Portisch Firmware ~ In order to learn Buttons from your remote, go to the Console of your RF Bridge. There, enter rfraw 177 and push the buttons on your remote. Repeat each button 2-3 times, as the signal may be different for each try. This will give you a so called B1 code of your button, which needs to be converted to a B0 code (see below). Sending Commands with Portisch Firmware ~ The commands learned with Portisch Firmware cannot be stored in device memory. Instead, they must be sent as a command. Example using MQTT: cmnd/sonoffRFBridge/Backlog RfRaw AAB0210314016703F924180101011001100110010101100110011001010110010101100255; RfRaw 0 Refer to issue #3973 for further information. B1 to B0 Conversion Tools ~ After learning how bitbucket works from the Portisch wiki , use one of these tools to help convert received B1 sniffing messages to the right 'B0' format to send in the 'RfRaw' command. Online Process: Enter rfraw 177 in the Sonoff Bridge web UI Console Press a function (each Button 2-3 times) on your remote control Copy the JSON payload output from the Console and paste it in the online converter and click Convert e.g., {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0124 37DC 010101010101101001010101101010100102 55\"}} The utility will return the resulting B0 string to use in setting up commands in the RF Bridge e.g., AA B0 1A 03 08 07F9 0124 37DC 010101010101101001010101101010100102 55 CLI (rename file from BitBucketConverter.txt to BitBucketConverter.py ) In the command line give the B1 message string and the retries value (in decimal): e.g., BitBucketConverter.py \"AA B1 04 07EB 0157 00FD 3EBC 010101010101101001010101101010100103 55\" 20 Command Line : \"AA B1 04 07EB 0157 00FD 3EBC 010101010101101001010101101010100103 55\" 20 Result: RfRaw AAB01C041407EB015700FD3EBC01010101010110100101010110101010010355 Batch Process: Enter rfraw 177 in the Sonoff Bridge web UI Console Press each function (each Button 2-3 times) on your remote control Save everything from the console that happened after rfraw 177 to a text file Run bitbuckedconverter.py -f console.txt Each line of console.txt will be converted into a B0 string and displayed Run bitbuckedconverter.py -f console.txt -e Each line of console.txt will be converted into a B0 string and sent to the Bridge Then: * If the device reacted as expected, you can enter a name of the button (e.g., \"light\") * Else enter nothing to try the next * Repeat this until all lines have been tried * The tool will create a list of buttons and their B0 codes that have worked (i.e. for which you have specified a name) * In the end you can test all of these codes \"Raw sniffing\" As suggested by the Portisch firmware, perform the following: In the web UI Console, send RfRaw AAB155 This will result in two consecutive messages: 1. The first one tells you that you are using one of the new firmware commands 22:58:44 MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":\"ON\"} The second one tells that the EFM8BB1 RF chip new firmware accepts the command and enters raw sniffing mode ('A0' means 'ACK') 22:58:44 MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AAA055\"}} After that keep pushing one of the buttons on the remote. MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AAA055\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 04 07F0 0128 00F2 3822 010101010101101001010101101010100103 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0124 37DC 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0124 37DC 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F4 0126 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F5 0127 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F7 0125 37DC 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0125 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F4 0123 37C8 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0124 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07FC 011E 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F8 0125 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F8 0124 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0125 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F8 0122 37C8 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F1 012D 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F4 0123 37C8 010101010101101001010101101010100102 55\"}}` MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F8 0128 37C8 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0124 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F4 0124 37C8 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0124 37C8 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F4 0123 37D2 010101010101101001010101101010100102 55\"}} Notice that this sequence of messages all start with 'AA' then 'B1' and the last byte '55' The reason for pushing the remote button for several seconds is to get enough 'AA B1 ...... 55' sequences to select the best one to be transmitted back. Then discard the sequences with 'data values' not equal. In the example 'data values' are the 010101010101101001010101101010100102 string. Notice that before that 'data values' string there are several 2 byte values (they are called 'buckets'); they are time values in microseconds. The number of 'buckets' is indicated in a previous byte (in the example a 3 or a 4). In the example, discard the first message (it contains 4 buckets, whereas the rest have only 3 buckets). Examine the values on the buckets in order to choose the message where more buckets are 'similar'. For example messages with ' 37D2 ' in the third bucket are good candidates. Messages with ' 0124 ' in the second bucket are also good candidates. First bucket values are very similar; ' 07F8 ' can be a good one. Official Sources ~ Itead Product Page Itead Shop Itead Wiki How to Flash the RF Bridge RF Bridge 433 R2 Information","title":"Sonoff RF Bridge 433"},{"location":"devices/Sonoff-RF-Bridge-433/#flash-tasmota","text":"Please see for flashing details and the Hardware Preparation article for general flashing instructions. Access the serial interface available on the 5-pin header next to the switch as can be seen in the image. To flash the ESP8285, first move the switch position towards the 5-pin header. Connect the serial-to-USB adapter and press the button on the edge while powering the device in order to put the ESP8285 into programming mode in order to upload the Tasmota firmware. After flashing the ESP8285, be sure to move the switch position away from the 5-pin header to restore the connection to the RF microcontroller. Configure the device as usual and select module Sonoff Bridge (25) . During normal operation the serial interface is used at 19200 baud to communicate with the RF microcontroller. Therefore serial logging ( SerialLog 0 ) must be disabled. IMPORTANT: In the Module configuration GPIO4 and GPIO5 must be left as 00 None On R2 versions of the Sonoff RF Bridge, a hardware modification is required in order to use these GPIO.","title":"Flash Tasmota"},{"location":"devices/Sonoff-RF-Bridge-433/#video-tutorial-by-alsolh","text":"","title":"Video tutorial by alsolh"},{"location":"devices/Sonoff-RF-Bridge-433/#rf-firmware","text":"The RF chip has its own firmware. The device is shipped with Itead firmware which supports a limited set of RF devices limited to mostly just Sonoff devices (a single 24-bit RF protocol). Some later versions of the factory firmware will only relay received RF data once the transmitting device stops. This is fine for remote controls or devices such as door sensors. But for devices such as smoke detectors, this behavior is not acceptable. Custom firmware is available for the RF chip which is commonly referred to as 'Portisch'. By updating the firmware on the RF chip, new types of devices and new features become usable. It also relays the RF data when the data is received rather than waiting until the transmitter stops. Tasmota supports the original Sonoff RF firmware and the Portisch firmware .","title":"RF Firmware"},{"location":"devices/Sonoff-RF-Bridge-433/#rf-firmware-upgrade","text":"The RF upgrade requires wiring the bridge and then flashing the firmware via the Tasmota web UI. **Attention \u26a0\ufe0f\ufe0f\u26a0\ufe0f\ufe0f\u26a0\ufe0f\ufe0f There are 2 versions of the Sonoff RF Bridge 433 : the R1 and the R2 V1.0 . R1 R2 V1.0 RF firmware flashing:","title":"RF Firmware Upgrade"},{"location":"devices/Sonoff-RF-Bridge-433/#operation","text":"The Sonoff RF Bridge is able to learn up to 16 different fixed code remote control commands as provided by PT2260, PT2262, PT2264 and EV1527 transmitters. It was not able to recognize the latest Klik Aan Klik Uit (KaKu) remote control signals but some people managed to use the fixed code KaKu devices like PAR-1000 receiver and PAT-103 transmitter. Tasmota provides default remote control commands to all 16 keys so you can start using the bridge with a Sonoff 4Ch Pro or Sonoff RF device without having the bridge have to learn remote control commands. See RF Bridge commands.","title":"Operation"},{"location":"devices/Sonoff-RF-Bridge-433/#portisch-firmware-specific-usage","text":"These sections only apply to the custom Portisch firmware.","title":"Portisch Firmware Specific Usage"},{"location":"devices/Sonoff-RF-Bridge-433/#learning-commands-with-portisch-firmware","text":"In order to learn Buttons from your remote, go to the Console of your RF Bridge. There, enter rfraw 177 and push the buttons on your remote. Repeat each button 2-3 times, as the signal may be different for each try. This will give you a so called B1 code of your button, which needs to be converted to a B0 code (see below).","title":"Learning Commands with Portisch Firmware"},{"location":"devices/Sonoff-RF-Bridge-433/#sending-commands-with-portisch-firmware","text":"The commands learned with Portisch Firmware cannot be stored in device memory. Instead, they must be sent as a command. Example using MQTT: cmnd/sonoffRFBridge/Backlog RfRaw AAB0210314016703F924180101011001100110010101100110011001010110010101100255; RfRaw 0 Refer to issue #3973 for further information.","title":"Sending Commands with Portisch Firmware"},{"location":"devices/Sonoff-RF-Bridge-433/#b1-to-b0-conversion-tools","text":"After learning how bitbucket works from the Portisch wiki , use one of these tools to help convert received B1 sniffing messages to the right 'B0' format to send in the 'RfRaw' command. Online Process: Enter rfraw 177 in the Sonoff Bridge web UI Console Press a function (each Button 2-3 times) on your remote control Copy the JSON payload output from the Console and paste it in the online converter and click Convert e.g., {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0124 37DC 010101010101101001010101101010100102 55\"}} The utility will return the resulting B0 string to use in setting up commands in the RF Bridge e.g., AA B0 1A 03 08 07F9 0124 37DC 010101010101101001010101101010100102 55 CLI (rename file from BitBucketConverter.txt to BitBucketConverter.py ) In the command line give the B1 message string and the retries value (in decimal): e.g., BitBucketConverter.py \"AA B1 04 07EB 0157 00FD 3EBC 010101010101101001010101101010100103 55\" 20 Command Line : \"AA B1 04 07EB 0157 00FD 3EBC 010101010101101001010101101010100103 55\" 20 Result: RfRaw AAB01C041407EB015700FD3EBC01010101010110100101010110101010010355 Batch Process: Enter rfraw 177 in the Sonoff Bridge web UI Console Press each function (each Button 2-3 times) on your remote control Save everything from the console that happened after rfraw 177 to a text file Run bitbuckedconverter.py -f console.txt Each line of console.txt will be converted into a B0 string and displayed Run bitbuckedconverter.py -f console.txt -e Each line of console.txt will be converted into a B0 string and sent to the Bridge Then: * If the device reacted as expected, you can enter a name of the button (e.g., \"light\") * Else enter nothing to try the next * Repeat this until all lines have been tried * The tool will create a list of buttons and their B0 codes that have worked (i.e. for which you have specified a name) * In the end you can test all of these codes \"Raw sniffing\" As suggested by the Portisch firmware, perform the following: In the web UI Console, send RfRaw AAB155 This will result in two consecutive messages: 1. The first one tells you that you are using one of the new firmware commands 22:58:44 MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":\"ON\"} The second one tells that the EFM8BB1 RF chip new firmware accepts the command and enters raw sniffing mode ('A0' means 'ACK') 22:58:44 MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AAA055\"}} After that keep pushing one of the buttons on the remote. MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AAA055\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 04 07F0 0128 00F2 3822 010101010101101001010101101010100103 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0124 37DC 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0124 37DC 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F4 0126 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F5 0127 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F7 0125 37DC 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0125 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F4 0123 37C8 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0124 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07FC 011E 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F8 0125 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F8 0124 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0125 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F8 0122 37C8 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F1 012D 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F4 0123 37C8 010101010101101001010101101010100102 55\"}}` MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F8 0128 37C8 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0124 37D2 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F4 0124 37C8 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F9 0124 37C8 010101010101101001010101101010100102 55\"}} MQT: tele/sonoffRFbridge/RESULT = {\"RfRaw\":{\"Data\":\"AA B1 03 07F4 0123 37D2 010101010101101001010101101010100102 55\"}} Notice that this sequence of messages all start with 'AA' then 'B1' and the last byte '55' The reason for pushing the remote button for several seconds is to get enough 'AA B1 ...... 55' sequences to select the best one to be transmitted back. Then discard the sequences with 'data values' not equal. In the example 'data values' are the 010101010101101001010101101010100102 string. Notice that before that 'data values' string there are several 2 byte values (they are called 'buckets'); they are time values in microseconds. The number of 'buckets' is indicated in a previous byte (in the example a 3 or a 4). In the example, discard the first message (it contains 4 buckets, whereas the rest have only 3 buckets). Examine the values on the buckets in order to choose the message where more buckets are 'similar'. For example messages with ' 37D2 ' in the third bucket are good candidates. Messages with ' 0124 ' in the second bucket are also good candidates. First bucket values are very similar; ' 07F8 ' can be a good one.","title":"B1 to B0 Conversion Tools"},{"location":"devices/Sonoff-RF-Bridge-433/#official-sources","text":"Itead Product Page Itead Shop Itead Wiki How to Flash the RF Bridge RF Bridge 433 R2 Information","title":"Official Sources"},{"location":"devices/Sonoff-RF-R3/","text":"See Sonoff DIY for flashing instructions","title":"Sonoff RF R3"},{"location":"devices/Sonoff-RF/","text":"Serial Flashing ~ The Sonoff RF needs some tweaking as the connection needed during programming between the button and GPIO0 might not be present. This connection must be removed after the conversion to Tasmota or a button press will send the device in an ON/OFF loop. This can be achieved by shorting both solder pads of R21 with a small screwdriver while holding down the button during programming. This can be a bit fiddly, and ideally you should check the bootloader output over serial to see whether you managed to get it into programming mode. Alternatively, Phalox installed a jumper wire (explained in the picture below). Remember to remove it after programming. The R2 V1.0 version of the Sonoff RF uses an ESP8285 which is covered by a horizontally orientated RF expansion board. Entering flash ready mode can be achieved by grounding K_P (which is connected to GPIO0) to the neighbouring GND pin on the RF board during power on. Pairing the iTead RF remote controller is the same as with the original iTead software: - two short button presses will blink a red led shortly and start RF signal recognition. Three longer blinks signal RF reception. - three short button presses will keep the red led on for some seconds and erase the known RF code. I was unable to pair the Sonoff RF 434MHz receiver with my KaKu switches but the iTead provided remote control works just fine. Pairing a RF remote control ~ During programming a connection for R21 is needed in order to use a button press to ground GPIO0. To pair a RF remote control with the Sonoff RF it is important that there is NO connection made for R21. User gadjet installed a jumper in place of R21 allowing easy programming (jumper in), pairing (jumper out) and normal use (jumper out). The Slampher RF Revision 2.0 can have the same modification applied, but it requires its jumper across R3. Pairing Instructions ~ Pairing the iTead RF remote controller is the same as with the original iTead software: - two short button presses will blink a red led shortly and start RF signal recognition. Three longer blinks signal RF reception. - three short button presses will keep the red led on for some seconds and erase the known RF code. I was unable to pair the Sonoff RF 434MHz receiver with my KaKu switches but the iTead provided remote control works just fine. Version 2 Pairing Instructions ~ RF units produced after 6/2018 use a different procedure for pairing. Press and hold the button for 3-seconds until the red light flashes once, then press then button on your remote to program. Press and hold for button for 5-seconds until the red light flashes twice to clear remote programming.","title":"Sonoff RF"},{"location":"devices/Sonoff-RF/#serial-flashing","text":"The Sonoff RF needs some tweaking as the connection needed during programming between the button and GPIO0 might not be present. This connection must be removed after the conversion to Tasmota or a button press will send the device in an ON/OFF loop. This can be achieved by shorting both solder pads of R21 with a small screwdriver while holding down the button during programming. This can be a bit fiddly, and ideally you should check the bootloader output over serial to see whether you managed to get it into programming mode. Alternatively, Phalox installed a jumper wire (explained in the picture below). Remember to remove it after programming. The R2 V1.0 version of the Sonoff RF uses an ESP8285 which is covered by a horizontally orientated RF expansion board. Entering flash ready mode can be achieved by grounding K_P (which is connected to GPIO0) to the neighbouring GND pin on the RF board during power on. Pairing the iTead RF remote controller is the same as with the original iTead software: - two short button presses will blink a red led shortly and start RF signal recognition. Three longer blinks signal RF reception. - three short button presses will keep the red led on for some seconds and erase the known RF code. I was unable to pair the Sonoff RF 434MHz receiver with my KaKu switches but the iTead provided remote control works just fine.","title":"Serial Flashing"},{"location":"devices/Sonoff-RF/#pairing-a-rf-remote-control","text":"During programming a connection for R21 is needed in order to use a button press to ground GPIO0. To pair a RF remote control with the Sonoff RF it is important that there is NO connection made for R21. User gadjet installed a jumper in place of R21 allowing easy programming (jumper in), pairing (jumper out) and normal use (jumper out). The Slampher RF Revision 2.0 can have the same modification applied, but it requires its jumper across R3.","title":"Pairing a RF remote control"},{"location":"devices/Sonoff-RF/#pairing-instructions","text":"Pairing the iTead RF remote controller is the same as with the original iTead software: - two short button presses will blink a red led shortly and start RF signal recognition. Three longer blinks signal RF reception. - three short button presses will keep the red led on for some seconds and erase the known RF code. I was unable to pair the Sonoff RF 434MHz receiver with my KaKu switches but the iTead provided remote control works just fine.","title":"Pairing Instructions"},{"location":"devices/Sonoff-RF/#version-2-pairing-instructions","text":"RF units produced after 6/2018 use a different procedure for pairing. Press and hold the button for 3-seconds until the red light flashes once, then press then button on your remote to program. Press and hold for button for 5-seconds until the red light flashes twice to clear remote programming.","title":"Version 2 Pairing Instructions"},{"location":"devices/Sonoff-S20/","text":"Sonoff S20 comes in 4 different plug type variations. Flashing process will be the same for each type. Serial Connection ~ Please see the Hardware Preparation page for general instructions. The picture shows how to program the S20 Smart Socket powered by the serial-to-USB converter. With newer US sockets, either use a right-angle header, or remove the header after flashing. Otherwise,the pushbutton may rub against a pin and get stuck. Be sure it is NOT plugged in mains! Remove the \"hidden\" screw. (optional) Remove the board from the plastic shell to have better access to serial pins. There are 2 screws at the red and blue wire. Be careful not to damage the soldered connection! Connect the jumper wires. From top to bottom (see image below): - Vcc (3,3V) - RXD - TXD - GND Connected? Hold the little button pressed while connecting the serial-to-USB adapter to your computer. After about 2 seconds let go of the button. It is now in flashing mode and ready to be flashed with Tasmota. Video tutorial by Don't It Yourself ~ Official Sources ~ Itead Product Page: http://sonoff.itead.cc/en/products/residential/s20-socket Itead Wiki: https://www.itead.cc/wiki/S20_Smart_Socket OpenHab Configuration ~ sonoff.items: Switch S20_1 \"Coffee S20-1 Powerplug\" (LR,gLight) { mqtt=\">[broker:cmnd/sonoff-S20-1/POWER:command:*:default], <[broker:stat/sonoff-S20-1/POWER:state:default], <[broker:stat/sonoff-S20-1/RESULT:state:JSONPATH($.POWER)], <[broker:tele/sonoff-S20-1/STATE:state:JSONPATH($.POWER)] \"} Switch S20_1_Reachable \"S20-1 reachable\" <contact> (gReachable) { mqtt=\"<[broker:tele/sonoff-S20-1/LWT:state:MAP(reachable.map)], <[broker:stat/sonoff-S20-1/RESULT:state:ON], <[broker:stat/sonoff-S20-1/POWER:state:ON], <[broker:tele/sonoff-S20-1/STATE:state:ON] \" } default.sitemap: Switch item=S20_1 labelcolor=[S20_1_Reachable == \"ON\" = \"green\",S20_1_Reachable == \"OFF\" = \"red\"] Configuration ~ Once set up and connected, you can set the module type to Sonoff S2X (8) in Configure module .","title":"Sonoff S20"},{"location":"devices/Sonoff-S20/#serial-connection","text":"Please see the Hardware Preparation page for general instructions. The picture shows how to program the S20 Smart Socket powered by the serial-to-USB converter. With newer US sockets, either use a right-angle header, or remove the header after flashing. Otherwise,the pushbutton may rub against a pin and get stuck. Be sure it is NOT plugged in mains! Remove the \"hidden\" screw. (optional) Remove the board from the plastic shell to have better access to serial pins. There are 2 screws at the red and blue wire. Be careful not to damage the soldered connection! Connect the jumper wires. From top to bottom (see image below): - Vcc (3,3V) - RXD - TXD - GND Connected? Hold the little button pressed while connecting the serial-to-USB adapter to your computer. After about 2 seconds let go of the button. It is now in flashing mode and ready to be flashed with Tasmota.","title":"Serial Connection"},{"location":"devices/Sonoff-S20/#video-tutorial-by-dont-it-yourself","text":"","title":"Video tutorial by Don't It Yourself"},{"location":"devices/Sonoff-S20/#official-sources","text":"Itead Product Page: http://sonoff.itead.cc/en/products/residential/s20-socket Itead Wiki: https://www.itead.cc/wiki/S20_Smart_Socket","title":"Official Sources"},{"location":"devices/Sonoff-S20/#openhab-configuration","text":"sonoff.items: Switch S20_1 \"Coffee S20-1 Powerplug\" (LR,gLight) { mqtt=\">[broker:cmnd/sonoff-S20-1/POWER:command:*:default], <[broker:stat/sonoff-S20-1/POWER:state:default], <[broker:stat/sonoff-S20-1/RESULT:state:JSONPATH($.POWER)], <[broker:tele/sonoff-S20-1/STATE:state:JSONPATH($.POWER)] \"} Switch S20_1_Reachable \"S20-1 reachable\" <contact> (gReachable) { mqtt=\"<[broker:tele/sonoff-S20-1/LWT:state:MAP(reachable.map)], <[broker:stat/sonoff-S20-1/RESULT:state:ON], <[broker:stat/sonoff-S20-1/POWER:state:ON], <[broker:tele/sonoff-S20-1/STATE:state:ON] \" } default.sitemap: Switch item=S20_1 labelcolor=[S20_1_Reachable == \"ON\" = \"green\",S20_1_Reachable == \"OFF\" = \"red\"]","title":"OpenHab Configuration"},{"location":"devices/Sonoff-S20/#configuration","text":"Once set up and connected, you can set the module type to Sonoff S2X (8) in Configure module .","title":"Configuration"},{"location":"devices/Sonoff-S26-Smart-Socket/","text":"Itead Product Page: http://sonoff.itead.cc/en/products/residential/sonoff-s26-smart-plug Itead Shop: https://www.itead.cc/sonoff-s26-wifi-smart-plug.html Serial Connection ~ Please see the Hardware Preparation page for general instructions. LED State ~ The S26 has a red LED connected to GPIO12 along with the relay so it's not possible to disable the power button LED entirely. Setting LedState 0 disables the blue LED when the relay is turned on and reserves it for Wi-Fi/MQTT state only. Soldering guide ~ Apply rosin to shaved wires. Solder tin to the flats on the module.(First put solder tip to flat and apply tin). Gently solder the wires. Alternative solder points available for 3V3, GND and RX on the underside of the mainboard. Jumper Pin J1 3V3 J2 GND J3 GPIO-12 J4 GPIO-0 J5 GPIO-13 J10 RX Bringing the Module into Flash Mode ~ Disconnect serial programmer and power Press and hold the on-board button - Note: The Button on the main board is not very sensitive and must be pressed firmly. Connect the serial programmer (VCC, RX, TX, GND) Release the on-board button The blue LED should NOT be blinking when in Flash mode. Storage/Memory ~ Running Tasmota 6.1.1 the unit reports: Flash Size 1024kB Program Flash Size 1024kB Program Size 536kB Free Program Space 464kB Free Memory 16kB More information ~ See issue #2808 for user information","title":"Sonoff S26 Smart Socket"},{"location":"devices/Sonoff-S26-Smart-Socket/#serial-connection","text":"Please see the Hardware Preparation page for general instructions.","title":"Serial Connection"},{"location":"devices/Sonoff-S26-Smart-Socket/#led-state","text":"The S26 has a red LED connected to GPIO12 along with the relay so it's not possible to disable the power button LED entirely. Setting LedState 0 disables the blue LED when the relay is turned on and reserves it for Wi-Fi/MQTT state only.","title":"LED State"},{"location":"devices/Sonoff-S26-Smart-Socket/#soldering-guide","text":"Apply rosin to shaved wires. Solder tin to the flats on the module.(First put solder tip to flat and apply tin). Gently solder the wires. Alternative solder points available for 3V3, GND and RX on the underside of the mainboard. Jumper Pin J1 3V3 J2 GND J3 GPIO-12 J4 GPIO-0 J5 GPIO-13 J10 RX","title":"Soldering guide"},{"location":"devices/Sonoff-S26-Smart-Socket/#bringing-the-module-into-flash-mode","text":"Disconnect serial programmer and power Press and hold the on-board button - Note: The Button on the main board is not very sensitive and must be pressed firmly. Connect the serial programmer (VCC, RX, TX, GND) Release the on-board button The blue LED should NOT be blinking when in Flash mode.","title":"Bringing the Module into Flash Mode"},{"location":"devices/Sonoff-S26-Smart-Socket/#storagememory","text":"Running Tasmota 6.1.1 the unit reports: Flash Size 1024kB Program Flash Size 1024kB Program Size 536kB Free Program Space 464kB Free Memory 16kB","title":"Storage/Memory"},{"location":"devices/Sonoff-S26-Smart-Socket/#more-information","text":"See issue #2808 for user information","title":"More information"},{"location":"devices/Sonoff-S31/","text":"\u26a0\ufe0f\ufe0f\ufe0f Do not connect AC power and the serial connection at the same time \ufe0f\ufe0f\ufe0f\u26a0\ufe0f\ufe0f\ufe0f The GND connection of the S31 is connected to the live AC wire. Connecting serial with your PC will fry your PC and will electrocute you. DO NOT CONNECT ANY SENSOR TO THESE DEVICES. Only use them as designed. The GPIOs on this device are connected to AC power , therefore it is not possible to safely add sensors or displays to it. Serial Flashing ~ The S31 is pretty easy to take apart. 1. Pry off the gray cover on the end. 1. Slide off the two rounded corner pieces to reveal the 3 screws. 1. Unscrew the 3 screws. 1. Lift off the cover. 1. There are no through holes. You can solder a piece of header or you can fabricate something using pogo pins and just hold it for the duration of the flashing process. But, be aware that can get tiring if you need to do it multiple times. 1. The pads are labeled, you need VCC, RX, TX, GND. There are two others that also have RX and TX on them. The ones next to the GND pin are not used for flashing. 1. Connect to your serial converter and 3V3. 1. You need to press the switch (GPIO0) before applying power to put into bootloader mode. For exact energy monitoring you might need to calibrate the device . Tinkerman's review of Sonoff S31 Video tutorial by BK Hobby ~","title":"Sonoff S31"},{"location":"devices/Sonoff-S31/#serial-flashing","text":"The S31 is pretty easy to take apart. 1. Pry off the gray cover on the end. 1. Slide off the two rounded corner pieces to reveal the 3 screws. 1. Unscrew the 3 screws. 1. Lift off the cover. 1. There are no through holes. You can solder a piece of header or you can fabricate something using pogo pins and just hold it for the duration of the flashing process. But, be aware that can get tiring if you need to do it multiple times. 1. The pads are labeled, you need VCC, RX, TX, GND. There are two others that also have RX and TX on them. The ones next to the GND pin are not used for flashing. 1. Connect to your serial converter and 3V3. 1. You need to press the switch (GPIO0) before applying power to put into bootloader mode. For exact energy monitoring you might need to calibrate the device . Tinkerman's review of Sonoff S31","title":"Serial Flashing"},{"location":"devices/Sonoff-S31/#video-tutorial-by-bk-hobby","text":"","title":"Video tutorial by BK Hobby"},{"location":"devices/Sonoff-SC/","text":"Serial Connection / Flashing ~ Please see the Hardware Preparation page for general instructions. Flashing the ESP8266 Remove the 4 screws on the bottom. The button is connected to GPIO0. You will have to remove the TX jumper in the board to avoid the ATMega328P to interfere in the upload process. Press and hold the button while powering the board to set the ESP8266 into flashing mode. Note! After flashing you need to set the baudrate to 19200. Don't forget to reconnect the TX jumper after flashing ;)","title":"Sonoff SC"},{"location":"devices/Sonoff-SC/#serial-connection-flashing","text":"Please see the Hardware Preparation page for general instructions. Flashing the ESP8266 Remove the 4 screws on the bottom. The button is connected to GPIO0. You will have to remove the TX jumper in the board to avoid the ATMega328P to interfere in the upload process. Press and hold the button while powering the board to set the ESP8266 into flashing mode. Note! After flashing you need to set the baudrate to 19200. Don't forget to reconnect the TX jumper after flashing ;)","title":"Serial Connection / Flashing"},{"location":"devices/Sonoff-SV/","text":"Sonoff Safe Voltage is almost the same as Sonoff Basic R1. These are the differences between the two: * It can be powered by DC voltage * It has more usable GPIO pins - GPIO4 - GPIO5 - GPIO14 * It has two LED status lights (RED and GREEN) * The traces on the bottom aren't soldered * The GND, TX, RX and 3v3 pins are labeled \u26a0\ufe0f What can the unit handle \u26a0\ufe0f ~ The trace is 2 mm wide. By assuming the PCB trace thickness is 1 oz/ft^2 you can calculate the current: 2A If you are using more than 2A be sure to put more solder on the solder traces. Using Sonoff SV ~ You can use the Sonoff SV in three different ways: 1. Variable DC voltage between 5-24 V By not having the jumper connected in the far left. the voltage regulator is used for the relay. 2. Solid DC voltage 5 V By bridging the two pins you are connecting the 5 V input directly to the relay so you are bypassing the regulator so the relay still gets 5 V 3. \u26a0\ufe0f With AC voltage \u26a0\ufe0f \u26a0\ufe0f \u26a1\ufe0f WARNING ONLY DO THIS WHEN YOU KNOW WHAT YOU ARE DOING. \u26a1\ufe0f \u26a0\ufe0f By removing the two 0 ohm SMD resistors next to the jumper you are disconnecting the voltage input from the logic. By doing this you can switch AC again like the Sonoff Basic. Than You can use the jumpers labeled 5~12 V as your DC voltage for the ESP and relay. Official Sources ~ Itead Product Page: Itead Shop: https://www.itead.cc/sonoff-sv.html Itead Wiki: https://www.itead.cc/wiki/Sonoff_SV","title":"Sonoff SV"},{"location":"devices/Sonoff-SV/#what-can-the-unit-handle","text":"The trace is 2 mm wide. By assuming the PCB trace thickness is 1 oz/ft^2 you can calculate the current: 2A If you are using more than 2A be sure to put more solder on the solder traces.","title":"\u26a0\ufe0f What can the unit handle \u26a0\ufe0f"},{"location":"devices/Sonoff-SV/#using-sonoff-sv","text":"You can use the Sonoff SV in three different ways:","title":"Using Sonoff SV"},{"location":"devices/Sonoff-SV/#official-sources","text":"Itead Product Page: Itead Shop: https://www.itead.cc/sonoff-sv.html Itead Wiki: https://www.itead.cc/wiki/Sonoff_SV","title":"Official Sources"},{"location":"devices/Sonoff-Slampher/","text":"","title":"Sonoff Slampher"},{"location":"devices/Sonoff-T1/","text":"Sonoff-T1 seems to be an evolution of Sonoff Touch and exists in one, two or three button variations and contains a 433MHz receiver. Based on the ESP8285, but using a Silabs EFM8BB1 microcontroller to extend the number of IOs needed to control 3 buttons, with separate relays and LEDs together with the radio. SYN470R is used as 433Mhz Radio. The chip for touch is unlabeled. EFM8BB1 Data Sheet ESP8285 Data Sheet SYN470R Data Sheet Read before flashing ~ Tasmota has functionality to perform special actions on multiple button presses and long press for 40 seconds resets firmware to default. This will cause the T1 board to reset if relay board is not connected, because long press on Button1 will be detected. To avoid this, use command SetOption13 1 immediately after flashing Tasmota. When powered solely with 3.3v from the serial-to-USB adapter long press will be detected by Tasmota on Button1. When powered solely with 3.3v from the serial-to-USB adapter RF functions do not work. If you can't flash succesfully lower the baud rate, most likely to 74880 . Serial Flashing ~ Sonoff T1 UK ~ The front circuit board should be disconnected from the rear relay board to prevent power draw upsetting the flashing process. The unit must be powered up before attempting to enter programming mode. If touch Button1 is held while power is connected, the device will not go enter flash mode. The touch IC does not have time to recognise the key-press before the device boots. Touch Board VER:1 ~ The following board layouts are from the 3 variants of the Sonoff T1 UK variant and are marked Sonoff T1 R2 UK Touch Board, Ver 1.0. Entering Flashing mode varies between the 1, 2 and 3 channel versions. See the above picture for button nomenclature used. (The variations between the 3 versions appear to be managed by the touch IC rather than in the ESP). To enter flashing mode the unit should be powered and connected to the programmer of choice. Touch Button 1 should then be held while the reset button (4) is pressed. When the device reboots, Button 1 can be released. OR Double-press the reset-button Try option 1 OR option 2. This will cause the unit to reboot into flash mode. This is confirmed on a serial console (74880 baud) by the boot mode displaying (1,x) indicating that we are booted to the bootloader and not the flash. You can also confirm booted to flash without a serial console, the main led should be off and the backlight LEDs lit dimly. There is no longer a need to solder anything to GPIO0 or to ground it while powering up for Ver1.0; this step is replaced by the above button sequence. However, GPIO0 to GND is the only way for Ver1.1 boards. Touch Board Ver:1.1 ~ Notes: 1. There is not enough room with this version to solder header pins to the programming port and still close the case. One possibility is to slightly bend the pins of a 4-way header and push it into the holes, removing it after programming. 2. GPIO0 is connected to the helper chip on this version, so the only way to get Ver1.1 of the board into flash mode is to solder a lead onto the resistor R19 from pin 15 on the ESP chip (GPIO0) and connect this lead to GND on power up; the device will set all the touch pads to dim and the WiFi LED D3 will NOT be on at all. 3. The connection marked 'LOG' on the J3 header is GPIO2. WARNING!! Do not attempt to power the device from your serial-to-USB adapter when connected to the relay board. This draws too much power and will cause the ESP to reboot frequently and reset all the configured settings. Sonoff T1 EU ~ For most devices, the UK version flashing guide may work. Sonoff T1 EU 1CH (2018-06-04) ~ All the flashing pins are in the front top right corner (sorry about covering them with the wires). From top to bottom: - LOG (GPIO2 not used) - GND - TXD - RXD - VCC To flash simply connect GND, TXD, RXD, and VCC as any regular ESP. Hold the touch button, press reset at once, then it boots into flash mode (no blinking WiFi LED, dimmed touch button). If this does not work, try shorting R19 to GND as shown in \"Touch Board VER:1.1\" * Stock baud rate: 74880 * Relay pin: 0 Sonoff T1 EU 2CH (v1.0) ~ For 2 Channel board version 1.0 , you need to solder (or otherwise permanently connect) GPIO0 (R19) to GND before powering the board and only disconnect them once the flashing is complete. After having connected GPIO0 and GND, power the board - it will boot directly to flashing mode. Flash your firmware and disconnect the board. Sonoff T1 EU 3CH (2018-10-03) ~ There are two pin headers (J1 and J3) and no reset button. J3 is used for flashing. GPIO0 is exposed on the back as test point (TP2/GPIO0). Connecting it to any ground such as the ground from J1 when powering up puts the ESP8255 into flash mode. Baud rate for flashing is 74880. Sonoff T1 US ~ It appears that SonOTA may work again with Sonoff firmware v2.0.1 or greater . This needs to be verified for this specific device. To get it working you can simply plug it to mains, once it's powered up, press and hold the button that's closer to the Wi-Fi logo (you'll hear a beep sound). Keep holding it until you hear that beep for the second time. Now let go. The Wi-Fi light should blink in pairs of 3. Now repeat the procedure (Press and hold until you hear the beep 2 times). Now you should be seeing the Wi-Fi logo flashing rapidly. You can proceed to try and flash with SonOTA now. US Model of 3-button T1, received direct from Sonoff China 2018-05-12 ~ Front photo (Google photos) Rear photo (Google photos) (Sorry about the tape smudges). The header labels on J3 are accurate (apparently some boards have TX and RX reversed; this doesn't seem to suffer that). Flashed with SonOTA . Above method of getting into flash mode doesn't seem to work. UPDATE: I did flash it with the FTDI method. To put then in flash mode press 2 times quickly the internal switch S1. UPDATE 2: Confirmed by another user that flashed with SonOTA works as described on \"Preparing\" Sonoff T1 US 3 Gang ~ The jump-wire method to enter the flash mode: * Jump the wire as attached picture * While keeping the wire connected then plug the serial-to-USB adapter to the computer * Wait for 1 to 2 seconds then release the jump-wire * You can start flashing the Sonoff T1 US 3C. Sonoff TX US 2/3 Gang ~ The PCB layout for the TX/T0 model (vertical, black or white face-plate with squared-off, LED-lit buttons) is different again from the original T1. There is no TP2/GPIO0 test point on the back of the PCB and R19 has moved. The basic instructions for flashing the T1 (with a USB adapter) still work. ~ It seems that Sonoff is trying to seal off the ESP using some glue see image: 433MHz remote ~ The Tasmota firmware is compatible with the RF remote feature built in to the T1 modules. Pairing a new remote is the same procedure as a stock Sonoff, i.e., hold the desired button on your sonoff until you are given 1 beep (approx 7 seconds), press the button on your RF remote. The Sonoff will beep to confirm the pairing. To unpair a remote, press until you are given 2 beeps, press the button on your RF remote. The Sonoff will beep to confirm the unpairing. Circuit ~ ESP8285 GPIO0 EFM8BB1 P1,3 Switch 1 input (Goes low when first touch button is pressed) GPIO04 is connected to the small (soft) reset button on the front. GPIO09 EFM8BB1 P1,4 - Switch 3 input (Goes low when third touch button is pressed) GPIO10 EFM8BB1 P1,5 - Switch 2 input GPIO13 is connected to status LED D3. GPIO12 Relay 1 GPIO5 Relay 2 GPIO4 Relay 3 GPIO2 is connected on J3 pin 5 (LOG) On the EFM8BB1 (QFN20 package) P0,0 Relay 1 P0,1 Relay 2 P0,2 Relay 3 P0,3 Button 1 P0,4 Button 2 P0,5 Button 3 P0,6 SYN470R Data Out P0,7 Buzzer P1,0 Led button 1 P1,1 Led button 2 P1,2 Led button 3 P1,3 ESP8285 GPIO0 P1,4 ESP8285 GPIO09 P1,5 ESP8285 GPIO10 P1,6 ESP8285 EXT_RSTB (RESET) Ghost Switching ~ Some of these devices are prone to hardware ghost switching. You may need to experiment with ButtonDebounce and SetOption40 to reduce or eliminate these issues. Also, during the flashing process, you may have soldered a lead to GPIO0 in order to connect it to GND for putting the ESP into programming mode. If there are any random oscillations on GPIO0, this can trigger the relay. The contacts on the PCB are very close together. Check that you don't have any stray solder to another contact. Even if there isn't contact, over time heat and humidity can cause any residual flux to become resistive and allow conductivity. Be sure to clean everything after removing any leads. Known so far ~ When pushing a button, the touch chip lift the power high to the EFM8BB1, and the EFM8BB1 chip ties the signal line for each button low, for the full duration of the keypress. Debouncing is not needed. 433MHz remotes are compatible with the Tasmota firmware DO NOT attempt to power the device from your programmer when connected to the relay board. This draws too much power and will cause the ESP to reboot frequently and will reset all the configured settings. The relays state can be set on the GPIO's 12, 5 and 4. The switch status can be read on GPIO's 0, 10 and 9. Push button active low. Unknown so far ~ Where GPIO15 is connected? Over R18 10kOhm pull-down only? Official Sources ~ Sonoff T1 UK ~ Itead Product Page Itead Shop The Sonoff T1 UK with 1 to 3 gang is fully supported by Tasmota starting with version 5.6.1. Sonoff T1 EU ~ Itead Product Page Itead Shop The Sonoff T1 EU with 1 to 3 gang is fully supported by Tasmota starting with version 5.6.1. Sonoff T1 US ~ Itead Product Page Itead Shop The Sonoff T1 US with 1 to 3 gang was launched March 2018. Sonoff TX US ~ Itead Product Page Itead Shop","title":"Sonoff T1"},{"location":"devices/Sonoff-T1/#read-before-flashing","text":"Tasmota has functionality to perform special actions on multiple button presses and long press for 40 seconds resets firmware to default. This will cause the T1 board to reset if relay board is not connected, because long press on Button1 will be detected. To avoid this, use command SetOption13 1 immediately after flashing Tasmota. When powered solely with 3.3v from the serial-to-USB adapter long press will be detected by Tasmota on Button1. When powered solely with 3.3v from the serial-to-USB adapter RF functions do not work. If you can't flash succesfully lower the baud rate, most likely to 74880 .","title":"Read before flashing"},{"location":"devices/Sonoff-T1/#serial-flashing","text":"","title":"Serial Flashing"},{"location":"devices/Sonoff-T1/#sonoff-t1-uk","text":"The front circuit board should be disconnected from the rear relay board to prevent power draw upsetting the flashing process. The unit must be powered up before attempting to enter programming mode. If touch Button1 is held while power is connected, the device will not go enter flash mode. The touch IC does not have time to recognise the key-press before the device boots.","title":"Sonoff T1 UK"},{"location":"devices/Sonoff-T1/#touch-board-ver1","text":"The following board layouts are from the 3 variants of the Sonoff T1 UK variant and are marked Sonoff T1 R2 UK Touch Board, Ver 1.0. Entering Flashing mode varies between the 1, 2 and 3 channel versions. See the above picture for button nomenclature used. (The variations between the 3 versions appear to be managed by the touch IC rather than in the ESP). To enter flashing mode the unit should be powered and connected to the programmer of choice. Touch Button 1 should then be held while the reset button (4) is pressed. When the device reboots, Button 1 can be released. OR Double-press the reset-button Try option 1 OR option 2. This will cause the unit to reboot into flash mode. This is confirmed on a serial console (74880 baud) by the boot mode displaying (1,x) indicating that we are booted to the bootloader and not the flash. You can also confirm booted to flash without a serial console, the main led should be off and the backlight LEDs lit dimly. There is no longer a need to solder anything to GPIO0 or to ground it while powering up for Ver1.0; this step is replaced by the above button sequence. However, GPIO0 to GND is the only way for Ver1.1 boards.","title":"Touch Board VER:1"},{"location":"devices/Sonoff-T1/#touch-board-ver11","text":"Notes: 1. There is not enough room with this version to solder header pins to the programming port and still close the case. One possibility is to slightly bend the pins of a 4-way header and push it into the holes, removing it after programming. 2. GPIO0 is connected to the helper chip on this version, so the only way to get Ver1.1 of the board into flash mode is to solder a lead onto the resistor R19 from pin 15 on the ESP chip (GPIO0) and connect this lead to GND on power up; the device will set all the touch pads to dim and the WiFi LED D3 will NOT be on at all. 3. The connection marked 'LOG' on the J3 header is GPIO2. WARNING!! Do not attempt to power the device from your serial-to-USB adapter when connected to the relay board. This draws too much power and will cause the ESP to reboot frequently and reset all the configured settings.","title":"Touch Board Ver:1.1"},{"location":"devices/Sonoff-T1/#sonoff-t1-eu","text":"For most devices, the UK version flashing guide may work.","title":"Sonoff T1 EU"},{"location":"devices/Sonoff-T1/#sonoff-t1-eu-1ch-2018-06-04","text":"All the flashing pins are in the front top right corner (sorry about covering them with the wires). From top to bottom: - LOG (GPIO2 not used) - GND - TXD - RXD - VCC To flash simply connect GND, TXD, RXD, and VCC as any regular ESP. Hold the touch button, press reset at once, then it boots into flash mode (no blinking WiFi LED, dimmed touch button). If this does not work, try shorting R19 to GND as shown in \"Touch Board VER:1.1\" * Stock baud rate: 74880 * Relay pin: 0","title":"Sonoff T1 EU 1CH (2018-06-04)"},{"location":"devices/Sonoff-T1/#sonoff-t1-eu-2ch-v10","text":"For 2 Channel board version 1.0 , you need to solder (or otherwise permanently connect) GPIO0 (R19) to GND before powering the board and only disconnect them once the flashing is complete. After having connected GPIO0 and GND, power the board - it will boot directly to flashing mode. Flash your firmware and disconnect the board.","title":"Sonoff T1 EU 2CH (v1.0)"},{"location":"devices/Sonoff-T1/#sonoff-t1-eu-3ch-2018-10-03","text":"There are two pin headers (J1 and J3) and no reset button. J3 is used for flashing. GPIO0 is exposed on the back as test point (TP2/GPIO0). Connecting it to any ground such as the ground from J1 when powering up puts the ESP8255 into flash mode. Baud rate for flashing is 74880.","title":"Sonoff T1 EU 3CH (2018-10-03)"},{"location":"devices/Sonoff-T1/#sonoff-t1-us","text":"It appears that SonOTA may work again with Sonoff firmware v2.0.1 or greater . This needs to be verified for this specific device. To get it working you can simply plug it to mains, once it's powered up, press and hold the button that's closer to the Wi-Fi logo (you'll hear a beep sound). Keep holding it until you hear that beep for the second time. Now let go. The Wi-Fi light should blink in pairs of 3. Now repeat the procedure (Press and hold until you hear the beep 2 times). Now you should be seeing the Wi-Fi logo flashing rapidly. You can proceed to try and flash with SonOTA now.","title":"Sonoff T1 US"},{"location":"devices/Sonoff-T1/#us-model-of-3-button-t1-received-direct-from-sonoff-china-2018-05-12","text":"Front photo (Google photos) Rear photo (Google photos) (Sorry about the tape smudges). The header labels on J3 are accurate (apparently some boards have TX and RX reversed; this doesn't seem to suffer that). Flashed with SonOTA . Above method of getting into flash mode doesn't seem to work. UPDATE: I did flash it with the FTDI method. To put then in flash mode press 2 times quickly the internal switch S1. UPDATE 2: Confirmed by another user that flashed with SonOTA works as described on \"Preparing\"","title":"US Model of 3-button T1, received direct from Sonoff China 2018-05-12"},{"location":"devices/Sonoff-T1/#sonoff-t1-us-3-gang","text":"The jump-wire method to enter the flash mode: * Jump the wire as attached picture * While keeping the wire connected then plug the serial-to-USB adapter to the computer * Wait for 1 to 2 seconds then release the jump-wire * You can start flashing the Sonoff T1 US 3C.","title":"Sonoff T1 US 3 Gang"},{"location":"devices/Sonoff-T1/#sonoff-tx-us-23-gang","text":"The PCB layout for the TX/T0 model (vertical, black or white face-plate with squared-off, LED-lit buttons) is different again from the original T1. There is no TP2/GPIO0 test point on the back of the PCB and R19 has moved. The basic instructions for flashing the T1 (with a USB adapter) still work.","title":"Sonoff TX US 2/3 Gang"},{"location":"devices/Sonoff-T1/#_1","text":"It seems that Sonoff is trying to seal off the ESP using some glue see image:","title":""},{"location":"devices/Sonoff-T1/#433mhz-remote","text":"The Tasmota firmware is compatible with the RF remote feature built in to the T1 modules. Pairing a new remote is the same procedure as a stock Sonoff, i.e., hold the desired button on your sonoff until you are given 1 beep (approx 7 seconds), press the button on your RF remote. The Sonoff will beep to confirm the pairing. To unpair a remote, press until you are given 2 beeps, press the button on your RF remote. The Sonoff will beep to confirm the unpairing.","title":"433MHz remote"},{"location":"devices/Sonoff-T1/#circuit","text":"ESP8285 GPIO0 EFM8BB1 P1,3 Switch 1 input (Goes low when first touch button is pressed) GPIO04 is connected to the small (soft) reset button on the front. GPIO09 EFM8BB1 P1,4 - Switch 3 input (Goes low when third touch button is pressed) GPIO10 EFM8BB1 P1,5 - Switch 2 input GPIO13 is connected to status LED D3. GPIO12 Relay 1 GPIO5 Relay 2 GPIO4 Relay 3 GPIO2 is connected on J3 pin 5 (LOG) On the EFM8BB1 (QFN20 package) P0,0 Relay 1 P0,1 Relay 2 P0,2 Relay 3 P0,3 Button 1 P0,4 Button 2 P0,5 Button 3 P0,6 SYN470R Data Out P0,7 Buzzer P1,0 Led button 1 P1,1 Led button 2 P1,2 Led button 3 P1,3 ESP8285 GPIO0 P1,4 ESP8285 GPIO09 P1,5 ESP8285 GPIO10 P1,6 ESP8285 EXT_RSTB (RESET)","title":"Circuit"},{"location":"devices/Sonoff-T1/#ghost-switching","text":"Some of these devices are prone to hardware ghost switching. You may need to experiment with ButtonDebounce and SetOption40 to reduce or eliminate these issues. Also, during the flashing process, you may have soldered a lead to GPIO0 in order to connect it to GND for putting the ESP into programming mode. If there are any random oscillations on GPIO0, this can trigger the relay. The contacts on the PCB are very close together. Check that you don't have any stray solder to another contact. Even if there isn't contact, over time heat and humidity can cause any residual flux to become resistive and allow conductivity. Be sure to clean everything after removing any leads.","title":"Ghost Switching"},{"location":"devices/Sonoff-T1/#known-so-far","text":"When pushing a button, the touch chip lift the power high to the EFM8BB1, and the EFM8BB1 chip ties the signal line for each button low, for the full duration of the keypress. Debouncing is not needed. 433MHz remotes are compatible with the Tasmota firmware DO NOT attempt to power the device from your programmer when connected to the relay board. This draws too much power and will cause the ESP to reboot frequently and will reset all the configured settings. The relays state can be set on the GPIO's 12, 5 and 4. The switch status can be read on GPIO's 0, 10 and 9. Push button active low.","title":"Known so far"},{"location":"devices/Sonoff-T1/#unknown-so-far","text":"Where GPIO15 is connected? Over R18 10kOhm pull-down only?","title":"Unknown so far"},{"location":"devices/Sonoff-T1/#official-sources","text":"","title":"Official Sources"},{"location":"devices/Sonoff-T1/#sonoff-t1-uk_1","text":"Itead Product Page Itead Shop The Sonoff T1 UK with 1 to 3 gang is fully supported by Tasmota starting with version 5.6.1.","title":"Sonoff T1 UK"},{"location":"devices/Sonoff-T1/#sonoff-t1-eu_1","text":"Itead Product Page Itead Shop The Sonoff T1 EU with 1 to 3 gang is fully supported by Tasmota starting with version 5.6.1.","title":"Sonoff T1 EU"},{"location":"devices/Sonoff-T1/#sonoff-t1-us_1","text":"Itead Product Page Itead Shop The Sonoff T1 US with 1 to 3 gang was launched March 2018.","title":"Sonoff T1 US"},{"location":"devices/Sonoff-T1/#sonoff-tx-us","text":"Itead Product Page Itead Shop","title":"Sonoff TX US"},{"location":"devices/Sonoff-TH/","text":"Sonoff TH10 or TH16 / Ver 2.0 (year 2017/2018/2019) based on ESP8266. TH10 has a relay rated to 10 amps and TH16 to 16 amps (Input voltage: 90~ 250V AC). Serial Flashing ~ The 2.5mm jack socket connects to GPIO14. In PCB Ver 2.1 you can find a fifth pin next to the serial pins, labeled EXP-LOG . You can use this as GPIO2 to any generic purpose. Currently should make a custom template for it. Sonoff sensors with 2.5mm jack ~ Sonoff sells 3 sensors with 2.5mm jack to use with the Sonoff TH. 1. Sonoff TH Sensor Si7021 2. Sonoff TH Sensor AM2301 3. Sonoff Temp Sensor DS18B20 Length of the wire is approximately 47cm apart from DS18b20 sensor that comes with approximately 1m long wire. Can be extended with a Sonoff 5m sensor extension cable. NOTE!!! Normally a Si7021 sensor is an I 2 C device. The Sonoff labelled Si7021 sensor is BASED on an Si7021, but, to make this sensor plug'n'play on a Sonoff TH an 8-bit MCU is added on the board. This changes the I 2 C communication of an Si7021 sensor to one-wire communication! That is why a \"Sonoff SI7021 sensor\" doesn't work in combination with a I 2 C library. Tasmota supports Sonoff TH with all three Sonoff sensors. Just select module Sonoff TH (4) and under GPIO14 configure the sensor you have connected. NOT SUPPORTED ~ Si7021 sensor contains an integrated resistive heating element that may be used to drive off condensation. It's recommended enabling the heater when the humidity readings are above 80%. Humidity readings above 80% become very unreliable. If the \"Sonoff Si7021 sensor\" is used at the dew point and condensation occurs on the sensor, the on-chip heater could be activated to dry the sensor and restore operation once the sensor is above the dew point. Turning on the heater will also reduce the tendency of the humidity sensor to accumulate an offset due to \"memory\" of sustained high humidity conditions. Six different power levels are available. The maximum source current of a GPIO pin on an ESP8266 is about 12mA. So the first power level of 3.09mA and second power level of 9.18mA would be theoretically usable. Keep that in mind if you use this \"Sonoff Si7021 sensor\" outdoors! Si7021 Datasheet Official Sources ~ Itead Product Page Itead Shop Itead Wiki","title":"Sonoff TH"},{"location":"devices/Sonoff-TH/#serial-flashing","text":"The 2.5mm jack socket connects to GPIO14. In PCB Ver 2.1 you can find a fifth pin next to the serial pins, labeled EXP-LOG . You can use this as GPIO2 to any generic purpose. Currently should make a custom template for it.","title":"Serial Flashing"},{"location":"devices/Sonoff-TH/#sonoff-sensors-with-25mm-jack","text":"Sonoff sells 3 sensors with 2.5mm jack to use with the Sonoff TH. 1. Sonoff TH Sensor Si7021 2. Sonoff TH Sensor AM2301 3. Sonoff Temp Sensor DS18B20 Length of the wire is approximately 47cm apart from DS18b20 sensor that comes with approximately 1m long wire. Can be extended with a Sonoff 5m sensor extension cable. NOTE!!! Normally a Si7021 sensor is an I 2 C device. The Sonoff labelled Si7021 sensor is BASED on an Si7021, but, to make this sensor plug'n'play on a Sonoff TH an 8-bit MCU is added on the board. This changes the I 2 C communication of an Si7021 sensor to one-wire communication! That is why a \"Sonoff SI7021 sensor\" doesn't work in combination with a I 2 C library. Tasmota supports Sonoff TH with all three Sonoff sensors. Just select module Sonoff TH (4) and under GPIO14 configure the sensor you have connected.","title":"Sonoff sensors with 2.5mm jack"},{"location":"devices/Sonoff-TH/#not-supported","text":"Si7021 sensor contains an integrated resistive heating element that may be used to drive off condensation. It's recommended enabling the heater when the humidity readings are above 80%. Humidity readings above 80% become very unreliable. If the \"Sonoff Si7021 sensor\" is used at the dew point and condensation occurs on the sensor, the on-chip heater could be activated to dry the sensor and restore operation once the sensor is above the dew point. Turning on the heater will also reduce the tendency of the humidity sensor to accumulate an offset due to \"memory\" of sustained high humidity conditions. Six different power levels are available. The maximum source current of a GPIO pin on an ESP8266 is about 12mA. So the first power level of 3.09mA and second power level of 9.18mA would be theoretically usable. Keep that in mind if you use this \"Sonoff Si7021 sensor\" outdoors! Si7021 Datasheet","title":"NOT SUPPORTED"},{"location":"devices/Sonoff-TH/#official-sources","text":"Itead Product Page Itead Shop Itead Wiki","title":"Official Sources"},{"location":"devices/Sonoff-TX-Series/","text":"The sonoff TX Series comes with 4 versions T0, T1, T2, T3 The boards are the same for all the series with only a difference in the T0 which has no RF chip Flashing ~ The flashing steps are the same than for the older T1 switch but holding switch 1 does not put the board into flashing mode and there is no reset button on the board So to put a T1 Touch v1.0 board into flash mode you need to ground GPIO 0 which is exposed on the back of the board and plug the board to USB Here is an image of the wiring Legend: * Yellow => 3.3v * Purple => GND * Green => TX FTDI to RX sonoff * Blue => RX FTDI to TX sonoff If the manipulation is done correctly the Wifi led will not blink when the device is powered, this means you are in flash mode and you can follow the other guide","title":"Sonoff TX Series"},{"location":"devices/Sonoff-TX-Series/#flashing","text":"The flashing steps are the same than for the older T1 switch but holding switch 1 does not put the board into flashing mode and there is no reset button on the board So to put a T1 Touch v1.0 board into flash mode you need to ground GPIO 0 which is exposed on the back of the board and plug the board to USB Here is an image of the wiring Legend: * Yellow => 3.3v * Purple => GND * Green => TX FTDI to RX sonoff * Blue => RX FTDI to TX sonoff If the manipulation is done correctly the Wifi led will not blink when the device is powered, this means you are in flash mode and you can follow the other guide","title":"Flashing"},{"location":"devices/Sonoff-TX-T0-Touch-1CH-2CH-3CH----US/","text":"June 2019 - Devices delivered with Sonoff v3.3.0 stock firmware. Product page Banggood Serial flashing works for this device. You may wish to check whether the Sonoff DIY flashing method works if this device is upgraded to v3.3.1. Board label: T0US TOUCH v1.0 2008.11.15 TX T0 US, 1-3CH boards are physically the same. Only need the \"top board\" to flash (not the bottom relay part) -- don't power with mains (you can't if you only use top anyway) R19 is tied to GPIO 0 to enter flash mode, just like on T1 but in a different spot for t0 (or US?). Find the C2 (j1) pins and look directly up about half inch for r19 Ensure that you select 3.3v and not 5v! to flash the board. ESP8285 - 1M - DOUT - erase flash - 115200 baud Like the T1, this does not have enough room to solder a header on. Use a piece of thick cardboard to lay your top board on. Firmly press some jumpers through the serial holes into the cardboard. If you push these through at an angle will be good enough to make contact to connect to your serial adaptor, trial and error but is not hard. See photo below. Regular flashing steps apply: connect Ground, Vcc TX, RX to your serial adaptor. Pay attention to TX/RX! For flash mode, use another jumper through the ground hole on the C2 pins (left of the serial and label J1). Same as above, push the jumper through cardboard to secure it. While powered off hold the other end of jumper to R19 and then power up (plug in your USB serial adaptor). Hold it for 3-5 seconds after it powers up before removing it. You should not see the network status led flash anymore, then you know you're in flash mode. If its flashing power off and try again. Using the TX T1 1-3 device template will work. A new T0 template is forthcoming. Start-to-Finish Flashing Guide ~ Flashing ~ Connect the device's serial interface pins to the Serial-to-USB adapter . Be sure that your adapter is set to supply 3.3v . Place a jumper wire from GND to the side of R19 nearest the screw hole cutout - this is connected to GPIO0. Download tasmota.bin from http://thehackbox.org/tasmota Have Tasmota PyFlasher running with the correct settings. Be sure to select DOUT and Erase flash - yes . Select the right COM port for your serial-to-USB adapter and select tasmota.bin from the folder where you downloaded the file. Plug the serial adapter into the USB port and click the Flash button on Tasmota PyFlasher . When you get the flash complete, remove the GND jumper wire from GPIO0. Cycle power on your device by disconnecting the serial adapter from the USB port for a couple of seconds and plugging it back in. IP Configuration ~ Using a mobile device, scan for Wi-Fi networks and connect to the sonoff-xxxx access point. When it connects to the network, you may get a warning that there is no Internet connection and be prompted to connect to a different network. Do not allow the mobile device to select a different network . Open the browser on your mobile device and navigate to http://192.168.4.1. In the Tasmota web UI, scan wifi networks and select the network for your home. Then enter the network's password ( click the checkbox to see the password you enter to ensure that it is correct and that your mobile device has not inadvertently capitalized the first letter if it is supposed to be lower case nor autocorrected what you entered ). When you save the settings, the device will restart and connect to your home network. The sonoff-xxxx network will not longer be present. Therefore your mobile device will automatically be disconnected and should connect back to its data network. Check in your router or use an IP scanner to ensure that the device is connected to your home network. Make not of the IP address assigned to your device. MQTT Configuration ~ Go to new IP address (http:// IP ) in a browser. Click Configuration->Configure MQTT-> MQTT Host: Enter the address (192.168.xx.yy or Hostname) of your MQTT broker. If you use the Home Assistant embedded broker, this will be your HA server. User: Enter the username for your MQTT broker Password: Enter the password for your MQTT broker Topic: Enter the unique MQTT topic for your device Save your settings. The device will restart Device Configuration ~ Click Configuration->Configure Module->Module Type->Sonoff T1 3CH (30) (the appropriate module for your device model) and save. The device will restart. Test the operation of the switches from the web UI. You should hear the relays click. Click Console If you use Home Assistant, enter SetOption19 1 to enable device auto-discovery. Check the log for any errors. Reassemble the switch and connect it to mains power. Check in your router or use an IP scanner to ensure that the device is connected to your home network. Also use the Tasmota web UI to ensure the switch is operating as expected. Home Assistant Configuration ~ Open TasmoAdmin via Hassio and Autoscan In Name1->Name3 enter switch position names again (note: understand orientation of switch) Go to \u2018Devices List\u2019 and check/test buttons click Click Cog configuration and enter names again and save Click Cog configuration, go to MQTT and change Group Topic to swtheatre and save Go to Devices List again and the circle arrows to restart the device Go to Integrations->MQTT and find the new switch and rename/locate items accordingly","title":"Sonoff TX T0 Touch 1CH 2CH 3CH    US"},{"location":"devices/Sonoff-TX-T0-Touch-1CH-2CH-3CH----US/#start-to-finish-flashing-guide","text":"","title":"Start-to-Finish Flashing Guide"},{"location":"devices/Sonoff-TX-T0-Touch-1CH-2CH-3CH----US/#flashing","text":"Connect the device's serial interface pins to the Serial-to-USB adapter . Be sure that your adapter is set to supply 3.3v . Place a jumper wire from GND to the side of R19 nearest the screw hole cutout - this is connected to GPIO0. Download tasmota.bin from http://thehackbox.org/tasmota Have Tasmota PyFlasher running with the correct settings. Be sure to select DOUT and Erase flash - yes . Select the right COM port for your serial-to-USB adapter and select tasmota.bin from the folder where you downloaded the file. Plug the serial adapter into the USB port and click the Flash button on Tasmota PyFlasher . When you get the flash complete, remove the GND jumper wire from GPIO0. Cycle power on your device by disconnecting the serial adapter from the USB port for a couple of seconds and plugging it back in.","title":"Flashing"},{"location":"devices/Sonoff-TX-T0-Touch-1CH-2CH-3CH----US/#ip-configuration","text":"Using a mobile device, scan for Wi-Fi networks and connect to the sonoff-xxxx access point. When it connects to the network, you may get a warning that there is no Internet connection and be prompted to connect to a different network. Do not allow the mobile device to select a different network . Open the browser on your mobile device and navigate to http://192.168.4.1. In the Tasmota web UI, scan wifi networks and select the network for your home. Then enter the network's password ( click the checkbox to see the password you enter to ensure that it is correct and that your mobile device has not inadvertently capitalized the first letter if it is supposed to be lower case nor autocorrected what you entered ). When you save the settings, the device will restart and connect to your home network. The sonoff-xxxx network will not longer be present. Therefore your mobile device will automatically be disconnected and should connect back to its data network. Check in your router or use an IP scanner to ensure that the device is connected to your home network. Make not of the IP address assigned to your device.","title":"IP Configuration"},{"location":"devices/Sonoff-TX-T0-Touch-1CH-2CH-3CH----US/#mqtt-configuration","text":"Go to new IP address (http:// IP ) in a browser. Click Configuration->Configure MQTT-> MQTT Host: Enter the address (192.168.xx.yy or Hostname) of your MQTT broker. If you use the Home Assistant embedded broker, this will be your HA server. User: Enter the username for your MQTT broker Password: Enter the password for your MQTT broker Topic: Enter the unique MQTT topic for your device Save your settings. The device will restart","title":"MQTT Configuration"},{"location":"devices/Sonoff-TX-T0-Touch-1CH-2CH-3CH----US/#device-configuration","text":"Click Configuration->Configure Module->Module Type->Sonoff T1 3CH (30) (the appropriate module for your device model) and save. The device will restart. Test the operation of the switches from the web UI. You should hear the relays click. Click Console If you use Home Assistant, enter SetOption19 1 to enable device auto-discovery. Check the log for any errors. Reassemble the switch and connect it to mains power. Check in your router or use an IP scanner to ensure that the device is connected to your home network. Also use the Tasmota web UI to ensure the switch is operating as expected.","title":"Device Configuration"},{"location":"devices/Sonoff-TX-T0-Touch-1CH-2CH-3CH----US/#home-assistant-configuration","text":"Open TasmoAdmin via Hassio and Autoscan In Name1->Name3 enter switch position names again (note: understand orientation of switch) Go to \u2018Devices List\u2019 and check/test buttons click Click Cog configuration and enter names again and save Click Cog configuration, go to MQTT and change Group Topic to swtheatre and save Go to Devices List again and the circle arrows to restart the device Go to Integrations->MQTT and find the new switch and rename/locate items accordingly","title":"Home Assistant Configuration"},{"location":"devices/Sonoff-Touch/","text":"Itead Product Page Itead Shop Itead Wiki: (n/a) Unlike most Sonoff modules, the Sonoff Touch is based on the ESP8285 rather than the ESP8266. The actual chip inside may be a PSF-A85 . Serial Connection ~ Please see the Hardware Preparation page for general instructions. As always, you need to access the serial interface. Carefully remove the top PCB from the assembly. The hidden underside of the PCB contains the ESP8285 as shown in the pictures. The four serial pins (3V3, Rx, Tx, GND) can be seen in the pictures for the US version (left) and the EU version (right) of the module PCB. Be careful while removing and reassembling the top PCB. The touch sensor should be back in its intended place. Be sure to not touch it directly during the modifications. The Sonoff Touch button is not connected to GPIO0 and hence cannot be used to bring the module into Programming Mode . A connection between GPIO0 and GND needs to be made manually. GPIO0 can be found on the right side of the ESP8285 and is the second pin from the bottom, as can be seen on the pictures. Note: Even if you have the PSF-A85 chip inside instead of a default ESP8285, the GPIO0 pin is in the same location. Pay attention to the corner of the chip with three unused solder contacts. That is where the external antenna connector is located in the images above. The PSF-A85 in the Sonoff Touch does not have the external antenna connector soldered on. Control ON/OFF Leds on Sonoff Touch solution ~ Solder the switch LED where the Wi-Fi LED is and then you can control the LED by using the command LedPower ON . The Switch LED is on all the time, even when the switch is off so you can easily find the switch in the dark. Alternatively, you can solder the switch LED on 3.3v and ground but then you can't control the LED, it is always on and very bright.","title":"Sonoff Touch"},{"location":"devices/Sonoff-Touch/#serial-connection","text":"Please see the Hardware Preparation page for general instructions. As always, you need to access the serial interface. Carefully remove the top PCB from the assembly. The hidden underside of the PCB contains the ESP8285 as shown in the pictures. The four serial pins (3V3, Rx, Tx, GND) can be seen in the pictures for the US version (left) and the EU version (right) of the module PCB. Be careful while removing and reassembling the top PCB. The touch sensor should be back in its intended place. Be sure to not touch it directly during the modifications. The Sonoff Touch button is not connected to GPIO0 and hence cannot be used to bring the module into Programming Mode . A connection between GPIO0 and GND needs to be made manually. GPIO0 can be found on the right side of the ESP8285 and is the second pin from the bottom, as can be seen on the pictures. Note: Even if you have the PSF-A85 chip inside instead of a default ESP8285, the GPIO0 pin is in the same location. Pay attention to the corner of the chip with three unused solder contacts. That is where the external antenna connector is located in the images above. The PSF-A85 in the Sonoff Touch does not have the external antenna connector soldered on.","title":"Serial Connection"},{"location":"devices/Sonoff-Touch/#control-onoff-leds-on-sonoff-touch-solution","text":"Solder the switch LED where the Wi-Fi LED is and then you can control the LED by using the command LedPower ON . The Switch LED is on all the time, even when the switch is off so you can easily find the switch in the dark. Alternatively, you can solder the switch LED on 3.3v and ground but then you can't control the LED, it is always on and very bright.","title":"Control ON/OFF Leds on Sonoff Touch solution"},{"location":"devices/Sonoff-iFan02/","text":"The Sonoff iFan02 is supported in Tasmota from version 6.0.0b Itead Product Page Itead Shop Itead iFan02 Schematics Serial Flashing ~ Please see the Hardware Preparation page for general instructions. Flashing using only a USB to serial converter will not work as the unit draws too much current as can be observed by a flashing blue led on the PCA and a lot of serial gibberish. As AC is not connected to Gnd I used the available power supply of the unit and connecting the USB to serial converter to J3 pins Gnd, Tx and Rx. The button is not connected to GPIO0 so flashing the unit requires some extra work. I managed to flash the iFan02 by soldering a wire to TP16 (GPIO00) on the bottom of the PCA. Keep this wire connected to Gnd during the power-on or reset process (pressing the button) and the unit will be in firmware upgrade mode. If you've soldered the gpio0 connection don't forget to unsolder before booting normally. Connect RX -> TX | 3.3 -> 3.3 | TX -> RX | GND -> GND and connect TP16 to GND (as used in the TTL). Press and hold the button while connecting to power. If you have an Arduino you may be able to flash without providing an additional power source. I have successfully flashed using an Arduino Duemilanove with the atmel chip pulled out (basically using it for FTDI and 3.3v power regulation). Rx on Arduino goes to Rx on iFan02, Tx to Tx (no crossover like with FTDI). I did not have to press the button, only to ground TP16 while initiating the flash in Arduino IDE. The Arduino provides enough power to flash, however it will not boot into Tasmota unless you plug in to external power (it boot loops after flashing is complete). Additonal information ~ See issue #2839 for user information See issue #3412 light on after restore power Functioning iFan02 in Tasmota WebUI iFan02 PCA with TP16 Two users report the TP16 pad lifting after soldering a wire to ground as shown in picture. This renders it useless. It may be better to use a pogo pin contact, bare wire or solder and then epoxy/glue the wire in place, leaving it permanently. Board Top Showing ESP8285 ESP8285 Pinout Using hard wired push button switch attached to iFan02 GPIO to cycle speeds ~ If anyone wants to setup a single push button switch attached to the GPIO3 Serial + ground In that will cycle through the speeds and turn off - after setting it in the configuration (GPIO3 to 11 Switch3) the console code is: rule1 on switch3#state do FanSpeed + endon Alternate Power Supply Schematic ~","title":"Sonoff iFan02"},{"location":"devices/Sonoff-iFan02/#serial-flashing","text":"Please see the Hardware Preparation page for general instructions. Flashing using only a USB to serial converter will not work as the unit draws too much current as can be observed by a flashing blue led on the PCA and a lot of serial gibberish. As AC is not connected to Gnd I used the available power supply of the unit and connecting the USB to serial converter to J3 pins Gnd, Tx and Rx. The button is not connected to GPIO0 so flashing the unit requires some extra work. I managed to flash the iFan02 by soldering a wire to TP16 (GPIO00) on the bottom of the PCA. Keep this wire connected to Gnd during the power-on or reset process (pressing the button) and the unit will be in firmware upgrade mode. If you've soldered the gpio0 connection don't forget to unsolder before booting normally. Connect RX -> TX | 3.3 -> 3.3 | TX -> RX | GND -> GND and connect TP16 to GND (as used in the TTL). Press and hold the button while connecting to power. If you have an Arduino you may be able to flash without providing an additional power source. I have successfully flashed using an Arduino Duemilanove with the atmel chip pulled out (basically using it for FTDI and 3.3v power regulation). Rx on Arduino goes to Rx on iFan02, Tx to Tx (no crossover like with FTDI). I did not have to press the button, only to ground TP16 while initiating the flash in Arduino IDE. The Arduino provides enough power to flash, however it will not boot into Tasmota unless you plug in to external power (it boot loops after flashing is complete).","title":"Serial Flashing"},{"location":"devices/Sonoff-iFan02/#additonal-information","text":"See issue #2839 for user information See issue #3412 light on after restore power Functioning iFan02 in Tasmota WebUI iFan02 PCA with TP16 Two users report the TP16 pad lifting after soldering a wire to ground as shown in picture. This renders it useless. It may be better to use a pogo pin contact, bare wire or solder and then epoxy/glue the wire in place, leaving it permanently. Board Top Showing ESP8285 ESP8285 Pinout","title":"Additonal information"},{"location":"devices/Sonoff-iFan02/#using-hard-wired-push-button-switch-attached-to-ifan02-gpio-to-cycle-speeds","text":"If anyone wants to setup a single push button switch attached to the GPIO3 Serial + ground In that will cycle through the speeds and turn off - after setting it in the configuration (GPIO3 to 11 Switch3) the console code is: rule1 on switch3#state do FanSpeed + endon","title":"Using hard wired push button switch attached to iFan02 GPIO to cycle speeds"},{"location":"devices/Sonoff-iFan02/#alternate-power-supply-schematic","text":"","title":"Alternate Power Supply Schematic"},{"location":"devices/Sonoff-iFan03/","text":"(For information on the iFan02 please see here - iFan02 ) Serial Flashing ~ Please see the Hardware Preparation page for general instructions. Next, please see the Flashing page for general information on the flashing process. Flash the latest version of tasmota.bin : Connect your serial flashing device pins to the iFan03 (for connection locations see the pin out on the left hand side of the picture below). When you are ready to flash your device, hold down the large white tipped button on the iFan03 while connecting the serial adapter to your computer. This will power the serial adapter as well as the iFan03. Usually, you can release the button on the iFan03 once it has fully booted - after 3-5 seconds once the lights have flashed. If the device does not enter programming mode successfully, cycle power but this time continue to hold the button during the entire firmware upload process (i.e., step 4 below). Using Tasmota PyFlasher (recommended): Select the firmware file that you want to flash Set the COM port for your serial programming adapter Ensure that flash mode Dual Output (DOUT) , and baud rate of 115200 is selected If you are flashing Tasmota for the first time, also select yes, wipes all data . Click on the \"Flash NodeMCU\" button and wait until the flashing process is completed. Cycle power on the serial adapter by unplugging and plugging it back in from the USB port. Do not hold down the iFan03 button. Wait for the iFan03 to reboot. If this is the first time you have flashed Tasmota on the device, connect to the iFan03 sonoff-xxxx Wi-Fi access point and configure your Wi-Fi credentials by opening 192.168.4.1 in a browser. Wait for the iFan03 to reboot. Find the IP address of the iFan03 and navigate to that IP address in any browser. Select \"Configure Module\" from the \"Configuration\" menu and select Sonoff iFan03 (71) from the drop down list. Wait for the iFan03 to restart and then continue any other required or desired configuration. US Ceiling Fans ~ The capacitors in the iFan03 do not set the speed of US fans correctly. To correct the speeds for US ceiling fans, you need to remove the existing capacitors from the iFan03 and replace them with equivalently electrically rated 5uF (microfarad) capacitors. Do NOT do this if you are not comfortable using a soldering iron as improperly performing this action could increase the risk of bodily injury or property damage. RF Remote Control Pairing ~ To pair the remote control after the device has been flashed with the new firmware, the device needs to be powered from mains voltage (not from the USB serial flashing device). Be careful dealing with mains voltages. Ensure that all connections are correctly made and that the iFan03 covers are properly re-assembled. To pair the remote control, hold down any button on the remote control and apply power to the iFan03. Once the device boots up you should hear a series of clicks as the internal relays operate. Once completed you can test the remote and it should all be operational.","title":"Sonoff iFan03"},{"location":"devices/Sonoff-iFan03/#serial-flashing","text":"Please see the Hardware Preparation page for general instructions. Next, please see the Flashing page for general information on the flashing process. Flash the latest version of tasmota.bin : Connect your serial flashing device pins to the iFan03 (for connection locations see the pin out on the left hand side of the picture below). When you are ready to flash your device, hold down the large white tipped button on the iFan03 while connecting the serial adapter to your computer. This will power the serial adapter as well as the iFan03. Usually, you can release the button on the iFan03 once it has fully booted - after 3-5 seconds once the lights have flashed. If the device does not enter programming mode successfully, cycle power but this time continue to hold the button during the entire firmware upload process (i.e., step 4 below). Using Tasmota PyFlasher (recommended): Select the firmware file that you want to flash Set the COM port for your serial programming adapter Ensure that flash mode Dual Output (DOUT) , and baud rate of 115200 is selected If you are flashing Tasmota for the first time, also select yes, wipes all data . Click on the \"Flash NodeMCU\" button and wait until the flashing process is completed. Cycle power on the serial adapter by unplugging and plugging it back in from the USB port. Do not hold down the iFan03 button. Wait for the iFan03 to reboot. If this is the first time you have flashed Tasmota on the device, connect to the iFan03 sonoff-xxxx Wi-Fi access point and configure your Wi-Fi credentials by opening 192.168.4.1 in a browser. Wait for the iFan03 to reboot. Find the IP address of the iFan03 and navigate to that IP address in any browser. Select \"Configure Module\" from the \"Configuration\" menu and select Sonoff iFan03 (71) from the drop down list. Wait for the iFan03 to restart and then continue any other required or desired configuration.","title":"Serial Flashing"},{"location":"devices/Sonoff-iFan03/#us-ceiling-fans","text":"The capacitors in the iFan03 do not set the speed of US fans correctly. To correct the speeds for US ceiling fans, you need to remove the existing capacitors from the iFan03 and replace them with equivalently electrically rated 5uF (microfarad) capacitors. Do NOT do this if you are not comfortable using a soldering iron as improperly performing this action could increase the risk of bodily injury or property damage.","title":"US Ceiling Fans"},{"location":"devices/Sonoff-iFan03/#rf-remote-control-pairing","text":"To pair the remote control after the device has been flashed with the new firmware, the device needs to be powered from mains voltage (not from the USB serial flashing device). Be careful dealing with mains voltages. Ensure that all connections are correctly made and that the iFan03 covers are properly re-assembled. To pair the remote control, hold down any button on the remote control and apply power to the iFan03. Once the device boots up you should hear a series of clicks as the internal relays operate. Once completed you can test the remote and it should all be operational.","title":"RF Remote Control Pairing"},{"location":"devices/Supernight-dual-wifi-plug/","text":"Received these in a 2 pack. flashing with OTA was no issue. I quickly figured out most of the IO. GPIO1 = Left Socket Button GPIO3 = Left Socket Relay GPIO12 = Right Socket Relay GPIO14 = Red LED for both buttons The \"night light\" seems to be tied to the light sensor only and cannot be turned off. This makes the plug a no-go for me. Also, I could not figure out the right socket button. I ended up destroying one of the two plugs to see what was inside. There are 2 circuit boards. One with the Wifi and esp module and another with the buttons and the night lights. On the button board, the trace for the right button is purposely notched for that button so that it doesn't connect to the header leading to the second circuit board with the esp chip. I'm really wishing I verified that button before flashing as I don't intend to buy more to test it. Found this on the issues tracker Just a quick update. I've still not figured out the second button, but I do have energy monitoring working now. My current pinout is... * GPIO1 = Left Socket Button * GPIO3 = Left Socket Relay * GPIO4 = HLW8012/Voltage (HLWBL CF1) * GPIO5 = HLW8012 CF Power (HLW8012 CF) * GPIO12 = Right Socket Relay * GPIO13 = HLW8012 Output (HLWBL SEL) * GPIO14 = Red LED for both buttons Pins 6,7,8 and 11 cause hard resets when I try to set them to switches or buttons. If you have tasmota >= 6.4.1.14 then here is a template based on the above. {\"NAME\":\"SuperNight Dua\",\"GPIO\":[255,17,255,21,132,133,255,255,22,130,58,255,255],\"FLAG\":1,\"BASE\":18}","title":"Supernight dual wifi plug"},{"location":"devices/TYWE3S/","text":"Connection ~ Vcc - 3.3V TX - RX RX - TX GND - GND TYWE3S - Flashing Jig Additional Information ~ More information can be found here: #1190 . For Switches and dimmers with additional MCU check guide here Device Images ~ Configuration ~ GPIO Component Description 4 LED1i (56) Blue LED 12 Relay1 (21) Relay & Red LED 13 Button1 (17) Button","title":"TYWE3S"},{"location":"devices/TYWE3S/#connection","text":"Vcc - 3.3V TX - RX RX - TX GND - GND TYWE3S - Flashing Jig","title":"Connection"},{"location":"devices/TYWE3S/#additional-information","text":"More information can be found here: #1190 . For Switches and dimmers with additional MCU check guide here","title":"Additional Information"},{"location":"devices/TYWE3S/#device-images","text":"","title":"Device Images"},{"location":"devices/TYWE3S/#configuration","text":"GPIO Component Description 4 LED1i (56) Blue LED 12 Relay1 (21) Relay & Red LED 13 Button1 (17) Button","title":"Configuration"},{"location":"devices/Teckin-SP22/","text":"The BlitzWolf BW-SHP2 , HomeCube SP1, and Teckin SP22 are basically the same device barring the branding. Warning ~ There are at least two Versions of the SP22 out. An old one with a TYWE2S WiFi module and ESP... chip. This version is compatible with Tasmota. A new one with a WR2 WiFi module and RTL8710BN chip. This one is not compatible with Tasmota.","title":"Teckin SP22"},{"location":"devices/Teckin-SP22/#warning","text":"There are at least two Versions of the SP22 out. An old one with a TYWE2S WiFi module and ESP... chip. This version is compatible with Tasmota. A new one with a WR2 WiFi module and RTL8710BN chip. This one is not compatible with Tasmota.","title":"Warning"},{"location":"devices/Teckin-SP23/","text":"The Teckin SP23 is wifi enabled smart plug with the ability to remotely monitor power consumption and turn devices on and off. Details: ~ The Teckin SP23 appears to be a clone of the BlitzWolf SHP2 hardware with Tuya firmware. It uses an ESP8266EX and is capable of switching up to 16 amps at 250 VAC. Two Teckin SP23s (marked V1.2) purchased from Amazon UK (January 2019) have been flashed successfully and use BlitzWolf SHP2 Sonoff configuration. Voltage calibration may be required for accurate power monitoring. Two additional Teckin SP23s were purchased from Amazon UK (July 2019) and successfully flashed using Tuya-Convert. Upgrading to Tasmota 6.6 and using BlitzWolf SHP configuration was problematic - LED's did not show power status - but downgrading to 6.3 and using BlitzWolf SHP2 as above gave perfect performance. The units were not disassembled so there was no way of determining board version. A set of 4 Teckin SP23s were purchased from Amazon UK (Sept 2019) and they flashed without issues using Tuya-Convert. This device functions properly with tasmota.bin 6.6.0 (LED flashing blue when ON) with the template in the repository . Two devices purchased on Amazon ES were already patched, but have been successfully flashed with the new-sdk branch of kueblc's tuya-convert fork . How to flash ~ OTA Flashing ~ No hardware preparation is required to flash if you are confident about having the same version and can easily be flashed using Tuya-Convert methods. This results in a fully functional device when using the BlitzWolf SHP2 template. The ability to OTA flash the device may not work in the future . Tuya has patched their firmware to block the OTA flashing tools. If the manufacturer updates the firmware shipped with the device to the latest Tuya version, OTA flashing will cease to be an option. As of August 2019, devices purchased from Amazon (link above) were still able to be OTA flashed (via Tuya-Convert). Flashing via serial ~ Video Tutorial by Marcus Bennett Configuration ~ After flashing and configuring the Wi-Fi parameters, use the Tasmota web UI Configure Template. Set Based on to BlitzWolf SHP (45) and then change GPIO2 from Led1i (56) to Led2i (57) for the LED to operate properly. How to disassemble if desired ~ If you wish to confirm you have the same hardware the Teckin SP23 can be opened by hitting each side of the plug at the lip with a rubber mallet or similar. This will leave a visually unblemished enclosure which can be resecured with superglue or similar. Full album Home Automation Hub Integration ~ openHAB ~ sonoff.items: Switch BlitzwoIFSHP2 \"Switch\" { mqtt=\">[broker:cmnd/BlitzwoIFSHP2/POWER:command:*:default],<[broker:stat/BlitzwoIFSHP2/POWER:state:default]\" } Number Power_Total \"Total: [%.3f kWh]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Total)]\" } Number Power_Today \"Today: [%.3f kWh]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Today)]\" } Number Power_Yesterday \"Yesterday: [%.3f kWh]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Yesterday)]\" } Number Power \"Power: [%.1f Watt]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Power)]\" } Number Voltage \"Voltage: [%.0f V]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Voltage)]\" } Number Current \"Current: [%.3f A]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Current)]\" } Number Factor \"Factor: [%.2f]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Factor)]\" } default.sitemap: Switch item=BlitzwoIFSHP2 label=\"BlitzWoIF SHP2\" icon=\"socket\" mappings=[OFF=\"Off\",ON=\"On\"] Text item=Power label=\"Power: [%.1f Watt]\" icon=\"energy\" Text item=Voltage label=\"Voltage: [%.0f V]\" icon=\"energy\" Text item=Current label=\"Current: [%.3f A]\" icon=\"energy\" Text item=Factor label=\"Factor: [%.2f]\" icon=\"energy\" Text item=Power_Total label=\"Power Total: [%.3f kWh]\" icon=\"energy\" Text item=Power_Today label=\"Power Today: [%.3f kWh]\" icon=\"energy\" Text item=iPower_Yesterday label=\"Power Yesterday: [%.3f kWh]\" icon=\"energy\" Home Assistant ~ switch : - platform : mqtt name : \"Blitzwolf\" state_topic : \"stat/blitzwolf/POWER\" command_topic : \"cmnd/blitzwolf/POWER\" payload_on : \"ON\" payload_off : \"OFF\" retain : false sensor : - platform : mqtt name : \"Blitzwolf Energy Today\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Today\"] }}' unit_of_measurement : \"kWh\" - platform : mqtt name : \"Blitzwolf Energy Yesterday\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Yesterday\"] }}' unit_of_measurement : \"kWh\" - platform : mqtt name : \"Blitzwolf Energy Total\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Total\"] }}' unit_of_measurement : \"kWh\" - platform : mqtt name : \"Blitzwolf Power\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Power\"] }}' unit_of_measurement : \"W\" - platform : mqtt name : \"Blitzwolf Voltage\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Voltage\"] }}' unit_of_measurement : \"V\" - platform : mqtt name : \"Blitzwolf Power Factor\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Factor\"] }}'","title":"Teckin SP23"},{"location":"devices/Teckin-SP23/#details","text":"The Teckin SP23 appears to be a clone of the BlitzWolf SHP2 hardware with Tuya firmware. It uses an ESP8266EX and is capable of switching up to 16 amps at 250 VAC. Two Teckin SP23s (marked V1.2) purchased from Amazon UK (January 2019) have been flashed successfully and use BlitzWolf SHP2 Sonoff configuration. Voltage calibration may be required for accurate power monitoring. Two additional Teckin SP23s were purchased from Amazon UK (July 2019) and successfully flashed using Tuya-Convert. Upgrading to Tasmota 6.6 and using BlitzWolf SHP configuration was problematic - LED's did not show power status - but downgrading to 6.3 and using BlitzWolf SHP2 as above gave perfect performance. The units were not disassembled so there was no way of determining board version. A set of 4 Teckin SP23s were purchased from Amazon UK (Sept 2019) and they flashed without issues using Tuya-Convert. This device functions properly with tasmota.bin 6.6.0 (LED flashing blue when ON) with the template in the repository . Two devices purchased on Amazon ES were already patched, but have been successfully flashed with the new-sdk branch of kueblc's tuya-convert fork .","title":"Details:"},{"location":"devices/Teckin-SP23/#how-to-flash","text":"","title":"How to flash"},{"location":"devices/Teckin-SP23/#ota-flashing","text":"No hardware preparation is required to flash if you are confident about having the same version and can easily be flashed using Tuya-Convert methods. This results in a fully functional device when using the BlitzWolf SHP2 template. The ability to OTA flash the device may not work in the future . Tuya has patched their firmware to block the OTA flashing tools. If the manufacturer updates the firmware shipped with the device to the latest Tuya version, OTA flashing will cease to be an option. As of August 2019, devices purchased from Amazon (link above) were still able to be OTA flashed (via Tuya-Convert).","title":"OTA Flashing"},{"location":"devices/Teckin-SP23/#flashing-via-serial","text":"Video Tutorial by Marcus Bennett","title":"Flashing via serial"},{"location":"devices/Teckin-SP23/#configuration","text":"After flashing and configuring the Wi-Fi parameters, use the Tasmota web UI Configure Template. Set Based on to BlitzWolf SHP (45) and then change GPIO2 from Led1i (56) to Led2i (57) for the LED to operate properly.","title":"Configuration"},{"location":"devices/Teckin-SP23/#how-to-disassemble-if-desired","text":"If you wish to confirm you have the same hardware the Teckin SP23 can be opened by hitting each side of the plug at the lip with a rubber mallet or similar. This will leave a visually unblemished enclosure which can be resecured with superglue or similar. Full album","title":"How to disassemble if desired"},{"location":"devices/Teckin-SP23/#home-automation-hub-integration","text":"","title":"Home Automation Hub Integration"},{"location":"devices/Teckin-SP23/#openhab","text":"sonoff.items: Switch BlitzwoIFSHP2 \"Switch\" { mqtt=\">[broker:cmnd/BlitzwoIFSHP2/POWER:command:*:default],<[broker:stat/BlitzwoIFSHP2/POWER:state:default]\" } Number Power_Total \"Total: [%.3f kWh]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Total)]\" } Number Power_Today \"Today: [%.3f kWh]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Today)]\" } Number Power_Yesterday \"Yesterday: [%.3f kWh]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Yesterday)]\" } Number Power \"Power: [%.1f Watt]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Power)]\" } Number Voltage \"Voltage: [%.0f V]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Voltage)]\" } Number Current \"Current: [%.3f A]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Current)]\" } Number Factor \"Factor: [%.2f]\" { mqtt=\"<[broker:tele/BlitzwoIFSHP2/SENSOR:state:JSONPATH($.ENERGY.Factor)]\" } default.sitemap: Switch item=BlitzwoIFSHP2 label=\"BlitzWoIF SHP2\" icon=\"socket\" mappings=[OFF=\"Off\",ON=\"On\"] Text item=Power label=\"Power: [%.1f Watt]\" icon=\"energy\" Text item=Voltage label=\"Voltage: [%.0f V]\" icon=\"energy\" Text item=Current label=\"Current: [%.3f A]\" icon=\"energy\" Text item=Factor label=\"Factor: [%.2f]\" icon=\"energy\" Text item=Power_Total label=\"Power Total: [%.3f kWh]\" icon=\"energy\" Text item=Power_Today label=\"Power Today: [%.3f kWh]\" icon=\"energy\" Text item=iPower_Yesterday label=\"Power Yesterday: [%.3f kWh]\" icon=\"energy\"","title":"openHAB"},{"location":"devices/Teckin-SP23/#home-assistant","text":"switch : - platform : mqtt name : \"Blitzwolf\" state_topic : \"stat/blitzwolf/POWER\" command_topic : \"cmnd/blitzwolf/POWER\" payload_on : \"ON\" payload_off : \"OFF\" retain : false sensor : - platform : mqtt name : \"Blitzwolf Energy Today\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Today\"] }}' unit_of_measurement : \"kWh\" - platform : mqtt name : \"Blitzwolf Energy Yesterday\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Yesterday\"] }}' unit_of_measurement : \"kWh\" - platform : mqtt name : \"Blitzwolf Energy Total\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Total\"] }}' unit_of_measurement : \"kWh\" - platform : mqtt name : \"Blitzwolf Power\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Power\"] }}' unit_of_measurement : \"W\" - platform : mqtt name : \"Blitzwolf Voltage\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Voltage\"] }}' unit_of_measurement : \"V\" - platform : mqtt name : \"Blitzwolf Power Factor\" state_topic : \"tele/blitzwolf/SENSOR\" value_template : '{{ value_json[\"ENERGY\"][\"Factor\"] }}'","title":"Home Assistant"},{"location":"devices/Teckin-sp10/","text":"so I got a couple of these guys given to me teckin sp10 on amazon.ca follow some great info here I found the esp8266 as expected in here I was able to identify the module at a esp8266-s3 spec sheet @znanev did most of the work already the uk version of this plug as noted by Znanev it took a great deal of time to confirm that I did indeed have the same pin outs as this UK plug I stumbled apon what I think is the original manufacturer of these but we will probably never know plug maker I am going to now shamelessly steal from @znanev as he wrote this much better than I could have WiFi module pins ~ Here is a close-up view of the module's pins as seen from the bottom of the main PCB: And this is how module pins numbers are mapped (I had to desolder the module looking for labels when I tried to identify it): Failed to identify the module, I had remove the metal shielding cap to find the routing of the ESP8266's pins, so I grabbed the multimeter and soon I had the following table: Module pin ESP8266 pin Pin name Pin name ESP8266 pin Module pin 1 7 Chip Enable Tout (ADC) 6 2 3 9 MTMS / GPIO14 MTDI / GPIO12 10 4 5 12 MTCK / GPIO13 MTDO / GPIO15 13 6 7 15 GPIO0 GPIO2 14 8 9 16 GPIO4 GPIO5 24 10 11 25 U0RXD U0TXD 26 12 13 Vdd - - GND 14 Serial Connection ~ For programming you need to solder 4 jumper wires to pins 11 , 12 , 13 and 14 ( Rx , Tx , Vdd and GND ). Connect the other end of the wires to your USB-to-serial adapter and make sure the supply voltage selected is 3.3V. Shorting pin 7 (GPIO0) to ground while plugging the serial adapter into the computer's USB port will bring the module into UART firmware upload mode. Configuration ~ Once Tasmota 's WebUI configuration interface is loaded in the browser, you can change many settings using the menu options. Console window is where you can change almost all configuration parameters. Head straight to the Configure Module menu, selected 'Generic' for 'Module type' . Here are the settings that I selected on that screen: Sonoff devices usually have a bi-colour LED, but just one of the colours can be controlled directly. The other colour is usually tied together with the relay, so it cannot be controlled independently. I think that is the reason why the Tasmota firmware by default controls just Led1 when a single relay is configured. In the configuration above, only the blue LED will be used (tied to GPIO2 ). But if you prefer the red LED, just change the values for Led1i and Led2i (select Led1i for GPIO0 and Led2i for GPIO2 ). end quote if you care led 2 is blue and led 1 is red I flashed the standard tasmota.bin file to it with out any problems with both the esptools and with arduino the one benefit to using arduino is that I was able to configure my wifi in advance I hope to update this and clean it up but I thought I should get it up here as I found nothing about this plug before I forget to post and I can't remember any details. Note: I have a newer version of this, labelled C7 HYS-X5-SOCKET_V1.2. The connectors for the ESP8266 board seem different. Still mapping them, but beware of following these instructions unless you know you have the same version. Update: looks like I actually destroyed the ESP8266 board somehow, using the software-only tuya-convert technique. After failing to get it to update, I opened up the case by putting it between two dowels in my vise, and tightening until it cracked open. There was zero resistance between pins 13 and 14. I fed it power at 3.3 volts to 1 amp, before giving up. An identical second plug updated without incident.","title":"Teckin sp10"},{"location":"devices/Teckin-sp10/#wifi-module-pins","text":"Here is a close-up view of the module's pins as seen from the bottom of the main PCB: And this is how module pins numbers are mapped (I had to desolder the module looking for labels when I tried to identify it): Failed to identify the module, I had remove the metal shielding cap to find the routing of the ESP8266's pins, so I grabbed the multimeter and soon I had the following table: Module pin ESP8266 pin Pin name Pin name ESP8266 pin Module pin 1 7 Chip Enable Tout (ADC) 6 2 3 9 MTMS / GPIO14 MTDI / GPIO12 10 4 5 12 MTCK / GPIO13 MTDO / GPIO15 13 6 7 15 GPIO0 GPIO2 14 8 9 16 GPIO4 GPIO5 24 10 11 25 U0RXD U0TXD 26 12 13 Vdd - - GND 14","title":"WiFi module pins"},{"location":"devices/Teckin-sp10/#serial-connection","text":"For programming you need to solder 4 jumper wires to pins 11 , 12 , 13 and 14 ( Rx , Tx , Vdd and GND ). Connect the other end of the wires to your USB-to-serial adapter and make sure the supply voltage selected is 3.3V. Shorting pin 7 (GPIO0) to ground while plugging the serial adapter into the computer's USB port will bring the module into UART firmware upload mode.","title":"Serial Connection"},{"location":"devices/Teckin-sp10/#configuration","text":"Once Tasmota 's WebUI configuration interface is loaded in the browser, you can change many settings using the menu options. Console window is where you can change almost all configuration parameters. Head straight to the Configure Module menu, selected 'Generic' for 'Module type' . Here are the settings that I selected on that screen: Sonoff devices usually have a bi-colour LED, but just one of the colours can be controlled directly. The other colour is usually tied together with the relay, so it cannot be controlled independently. I think that is the reason why the Tasmota firmware by default controls just Led1 when a single relay is configured. In the configuration above, only the blue LED will be used (tied to GPIO2 ). But if you prefer the red LED, just change the values for Led1i and Led2i (select Led1i for GPIO0 and Led2i for GPIO2 ). end quote if you care led 2 is blue and led 1 is red I flashed the standard tasmota.bin file to it with out any problems with both the esptools and with arduino the one benefit to using arduino is that I was able to configure my wifi in advance I hope to update this and clean it up but I thought I should get it up here as I found nothing about this plug before I forget to post and I can't remember any details. Note: I have a newer version of this, labelled C7 HYS-X5-SOCKET_V1.2. The connectors for the ESP8266 board seem different. Still mapping them, but beware of following these instructions unless you know you have the same version. Update: looks like I actually destroyed the ESP8266 board somehow, using the software-only tuya-convert technique. After failing to get it to update, I opened up the case by putting it between two dowels in my vise, and tightening until it cracked open. There was zero resistance between pins 13 and 14. I fed it power at 3.3 volts to 1 amp, before giving up. An identical second plug updated without incident.","title":"Configuration"},{"location":"devices/Tuya-Smart-Plug-Models-ESP8266MOD-by-AI-THINKER-and-ESP-12F-by-TUYA-LN-0026/","text":"These are simple, No-Name smart plugs (I bought these at AliExpress). One of them has ESP8266MOD chip (by AI-THINKER), other one has ESP-12F chip (by TUYA L/N 0026). Both are actually same chips and are flashed the same way. You need to solder 5 wires: 1. VCC (3.3V) 2. GND (GROUND) 3. Rx 4. Tx 5. GPIO0 To put this chips into flash mode, we need to jump wire GPIO0 and GROUND, before you plug your USB adapter into computer. Release jump wire after couple of seconds. Red LED (bottom one) should slightly lit up. Now you can start flashing process. When flashing process is complete, you can unplug USB adapter. Your TUYA smart plug is TASMOTIZED. THIS IS OPTIONAL!!! You can now use Termite app, to load your router WiFi SSID and password using below commands: (just copy and paste all of it, but put your details in). In Termite settings, check your COM number, where adapter is plugged in and select 115200. Backlog SSID1 YOUR_SSID_NAME; Password1 YOUR_WIFI_PASSWORD; MqttHost MQTT_INTERNAL_IP_ADDRESS; MqttUser MQTT_USER_NAME; MqttPassword MQTT_PASSWORD; GPIO2 56; GPIO12 21; GPIO13 17 After that, Termite should tell you, what IP address was assigned to your smart plug. Put that IP address in your browser and you should see Tasmota GUI. Go into Configuration > Configure Module > Change to Generic (and click Save). After restart, go into Configuration > Configure Module and change GPIO's as on screen below. You can change between D4 GPIO2 56 LED1i and D4 GPIO2 52 LED1 (Blue led on when device is on, or blue led on when device is off) That's it, now your smart plug will flash both red and blue leds and smart plug button should respond to presses. Special thanks to Travis Griggs for his help with flashing process (I based this tutorial on his own: LINK )","title":"Tuya Smart Plug Models ESP8266MOD by AI THINKER and ESP 12F by TUYA LN 0026"},{"location":"devices/WL-SW01_10-WiFi-Smart-Switch/","text":"Manufactured by Blue50 as WL-SW01_10 and also sold as TISHRIC . Sonoff Basic in a different form factor with the same features. It contains an ESP8285 chip on a vertical breakout board with all the needed GPIOs broken out and labeled. There are also a couple pads on the board to solder VCC and G. Use template {\"NAME\":\"WL-SW01_10\",\"GPIO\":[17,149,0,148,0,0,0,0,21,56,0,0,0],\"FLAG\":0,\"BASE\":1} If your Tasmota version doesn't support templates select module Sonoff Basic (1) .","title":"WL SW01 10 WiFi Smart Switch"},{"location":"devices/WS03-%28WS01-WS05%29-LED-Controller/","text":"WS03-Led Controller (from Aliexpress) ~ The WS01 LED-Controller uses an ESP8266-S1 Module (16MBit Flash) Alle required Pins for programming are available, as well as additional GPIO4 and GPIO2. Outside Images PCB Image with pinout GPIO2 & GPIO4 are working for I 2 C (2=SDA 4=SCL). (Tested with DS3231 Module ) The device uses an additional CD4050 at the pins used for PWM.","title":"WS03-Led Controller (from Aliexpress)"},{"location":"devices/WS03-%28WS01-WS05%29-LED-Controller/#ws03-led-controller-from-aliexpress","text":"The WS01 LED-Controller uses an ESP8266-S1 Module (16MBit Flash) Alle required Pins for programming are available, as well as additional GPIO4 and GPIO2. Outside Images PCB Image with pinout GPIO2 & GPIO4 are working for I 2 C (2=SDA 4=SCL). (Tested with DS3231 Module ) The device uses an additional CD4050 at the pins used for PWM.","title":"WS03-Led Controller (from Aliexpress)"},{"location":"devices/Wemos-D1-Mini/","text":"Flashing Wemos with Tasmota ~ Flashing a Wemos D1 Mini with Tasmota firmware is nearly the same as for every other device. Just connect Wemos D1 mini via USB. No action required to enter Flashmode! Configure Tasmota for Wemos ~ Generic Module ~ In the Configuration -> Configure Module page, select Module Type: \"18 Generic\" . After Saving the settings, the WEMOS reboots with the Generic configuration. The first time you switch to \"18 Generic\" you will NOT see all the options as seen in the picture below YET. You have to save \"18 Generic\" first and when you go there again after the reboot you get the long table where you can change all the pin's parameters. These steps are confirmed to also work with the Wemos D1 mini PRO v2.0.0. Link to Wemos hardware & documentation ~ DOCS dot WEMOS dot CC","title":"Wemos D1 Mini"},{"location":"devices/Wemos-D1-Mini/#flashing-wemos-with-tasmota","text":"Flashing a Wemos D1 Mini with Tasmota firmware is nearly the same as for every other device. Just connect Wemos D1 mini via USB. No action required to enter Flashmode!","title":"Flashing Wemos with Tasmota"},{"location":"devices/Wemos-D1-Mini/#configure-tasmota-for-wemos","text":"","title":"Configure Tasmota for Wemos"},{"location":"devices/Wemos-D1-Mini/#generic-module","text":"In the Configuration -> Configure Module page, select Module Type: \"18 Generic\" . After Saving the settings, the WEMOS reboots with the Generic configuration. The first time you switch to \"18 Generic\" you will NOT see all the options as seen in the picture below YET. You have to save \"18 Generic\" first and when you go there again after the reboot you get the long table where you can change all the pin's parameters. These steps are confirmed to also work with the Wemos D1 mini PRO v2.0.0.","title":"Generic Module"},{"location":"devices/Wemos-D1-Mini/#link-to-wemos-hardware-documentation","text":"DOCS dot WEMOS dot CC","title":"Link to Wemos hardware &amp; documentation"},{"location":"devices/Wemos-D1-R1-%26-R2/","text":"Wemos D1 Release 1 (R1) and Release 2 (R2) ~ Here you can find information for the big brother of the Wemos D1 mini which can be found here . R1 vs. R2 - The Difference ~ When you take a look at the figure 1 you will see it with one blink of the eye thet the old Wemos is different against the new verion R2. The old version has an ESP8266 12B or 12E model. The new one has a ESP8266 12F model on the pcb board. You see this in the defference of the Wifi antenna. Here is a Wiki link to the different ESP8266 modules. The next part for R2 are the 2x4 solder pins for the serial and I2C interface which is not on the old model R1. The techncal data/specifiactions are the same. SO as you see they look like an Arduino UNO inculding the stacks to mount different shields. Later i will give more information over shields which i have tested and there are a lot of them. Figure 1: WeMos D1 R1 vs. WeMos D1 R2 Settings in Arduino IDE (v1.8.7): ~ Both releases First we will check that the right json index file is chosen. For that open File -> Preferences. Search for \"Additional Boards Manager URLs:\" (Figure 2). There you have an input filed. If that field is empty add this to it via copy&paste: http://arduino.esp8266.com/stable/package_esp8266com_index.json . Then close that window by hitting the OK button. If you have more then one link in that input field you have to use a comma after every link. So as done in Figure 2. Figure 2: Additional Boards Manager URLs Second we will look at the Boards Manager of Arduino IDE. As you can see in Figure 3 that the following things has to be installed. Possibile you have done this already together with the first installtion. Open Tools -> Board Selection -> Boards Manager , then search for esp8266 by ESP8266 Community . If you have fund it you will the same as in Figure 3. On the right side of that text you have searched for you can see the installed verion. Here in the sample it is 2.4.2. It is not installed you can make a choice under Select Version . If you start a new installation you can use the version 2.4.2. It works very well with both releases of Wemos D1. Figure 3: Boards Manager Settings to Flash a firmware on R1: Open Tools -> Board and select the WeMos D1 R1 board. For the settings of release R1 see Figure 4. Don't forget to select the right COM port so far your USB/Serial adapter is connected. Otherwise you can change this later after you have verified your code and you are ready to compile and flash. Then you have to connect your adapter and after the typical PING under Windows you can set your COM port. Figure 4: Arduino Settings Wemos D1 R1 Settings to Flash a firmware on R2: Open Tools -> Board and select the LOLIN(WEMOS) D1 R2 & mini board. And for the settings of release R2 see Figure 5, please. Don't forget to set your COM port. Figure 5: As you can see the settings are the same only the name of the board is different. Internal there some different settings but we dont need to know that. Arduino IDE does the work for you. Module Selection for Tasmota: ~ ... Housing: ~ ... Shields: ~ ...","title":"Wemos D1 R1 & R2"},{"location":"devices/Wemos-D1-R1-%26-R2/#wemos-d1-release-1-r1-and-release-2-r2","text":"Here you can find information for the big brother of the Wemos D1 mini which can be found here .","title":"Wemos D1 Release 1 (R1) and Release 2 (R2)"},{"location":"devices/Wemos-D1-R1-%26-R2/#r1-vs-r2-the-difference","text":"When you take a look at the figure 1 you will see it with one blink of the eye thet the old Wemos is different against the new verion R2. The old version has an ESP8266 12B or 12E model. The new one has a ESP8266 12F model on the pcb board. You see this in the defference of the Wifi antenna. Here is a Wiki link to the different ESP8266 modules. The next part for R2 are the 2x4 solder pins for the serial and I2C interface which is not on the old model R1. The techncal data/specifiactions are the same. SO as you see they look like an Arduino UNO inculding the stacks to mount different shields. Later i will give more information over shields which i have tested and there are a lot of them. Figure 1: WeMos D1 R1 vs. WeMos D1 R2","title":"R1 vs. R2 - The Difference"},{"location":"devices/Wemos-D1-R1-%26-R2/#settings-in-arduino-ide-v187","text":"Both releases First we will check that the right json index file is chosen. For that open File -> Preferences. Search for \"Additional Boards Manager URLs:\" (Figure 2). There you have an input filed. If that field is empty add this to it via copy&paste: http://arduino.esp8266.com/stable/package_esp8266com_index.json . Then close that window by hitting the OK button. If you have more then one link in that input field you have to use a comma after every link. So as done in Figure 2. Figure 2: Additional Boards Manager URLs Second we will look at the Boards Manager of Arduino IDE. As you can see in Figure 3 that the following things has to be installed. Possibile you have done this already together with the first installtion. Open Tools -> Board Selection -> Boards Manager , then search for esp8266 by ESP8266 Community . If you have fund it you will the same as in Figure 3. On the right side of that text you have searched for you can see the installed verion. Here in the sample it is 2.4.2. It is not installed you can make a choice under Select Version . If you start a new installation you can use the version 2.4.2. It works very well with both releases of Wemos D1. Figure 3: Boards Manager Settings to Flash a firmware on R1: Open Tools -> Board and select the WeMos D1 R1 board. For the settings of release R1 see Figure 4. Don't forget to select the right COM port so far your USB/Serial adapter is connected. Otherwise you can change this later after you have verified your code and you are ready to compile and flash. Then you have to connect your adapter and after the typical PING under Windows you can set your COM port. Figure 4: Arduino Settings Wemos D1 R1 Settings to Flash a firmware on R2: Open Tools -> Board and select the LOLIN(WEMOS) D1 R2 & mini board. And for the settings of release R2 see Figure 5, please. Don't forget to set your COM port. Figure 5: As you can see the settings are the same only the name of the board is different. Internal there some different settings but we dont need to know that. Arduino IDE does the work for you.","title":"Settings in Arduino IDE (v1.8.7):"},{"location":"devices/Wemos-D1-R1-%26-R2/#module-selection-for-tasmota","text":"...","title":"Module Selection for Tasmota:"},{"location":"devices/Wemos-D1-R1-%26-R2/#housing","text":"...","title":"Housing:"},{"location":"devices/Wemos-D1-R1-%26-R2/#shields","text":"...","title":"Shields:"},{"location":"devices/Xenon-SM-SW102-2-two-relay-light-switch/","text":"Amazon Link: https://www.amazon.com/Tempered-Controlled-Separately-Standard-Compatible/dp/B0719Q5G5B/ref=sr_1_3?ie=UTF8&qid=1540511385&sr=8-3&keywords=xenon+light+switch&dpID=21PWx5MUrEL&preST= SY300_QL70 &dpSrc=srch Also sold as the Mojocraft Wireless Smart Wall Switch 2 Gang: https://www.amazon.com/Mojocraft-Wireless-Sensitive-Compatible-Required/dp/B072JCWH23/ref=sr_1_3?ie=UTF8&qid=1540858092&sr=8-3&keywords=Mojocraft I didn't spot any headers, but device has a sub-board with an ESP-12 module on it. Solder right to the 3.3V, Ground, TX, RX, and GPIO pins and flash away. I set the device up as a generic device with the following assignments. GPIO 3 is button 2 GPIO 4 is relay 2 GPIO 12 is button 1 GPIO 13 is relay 1","title":"Xenon SM SW102 2 two relay light switch"},{"location":"devices/Xiaomi-Mi-Desk-Lamp/","text":"Supported in Development since 2019-01-15 Mi Desk Lamp is a cold+warm white led lamp, which has a rotary knob that also acts as a push-button: - pushing it turns the lamp on/off - rotating it controls the brightness - rotating it while pushed controls the color temperature At the bottom of the lamp stand there is also a 'Reset' button, which can be pressed by a hairpin/toothpick/etc only. Manufacturer Link Configuration ~ Tasmota supports it directly as Module \"Mi Desk Lamp\" . This module is deactivated by default. You must add #define ROTARY_V1 in your user_config_override.h and compile the firmware for this module to be available as a selection option. To configure it as Generic , here is the GPIO assignment: - GPIO02: Button ( GPIO_KEY1 ) - GPIO04: Cold White ( GPIO_PWM1 ) - GPIO05: Warm White ( GPIO_PWM2 ) - GPIO12: Rotary switch A pin ( GPIO_ROT_A ) - GPIO13: Rotary switch B pin ( GPIO_ROT_B ) NOTE: The operation of the rotary switch depends on the module type being MI_DESK_LAMP , so full functionality cannot be achieved with the Generic config. Flashing ~ This lamp is based on a YeeLight LXU 1.7 module, that contains: - an ESP8266 - 2 MB flash Disassembly ~ First of all, remove the knob by pushing some soft and flat tool underneath it and gently pry away from the stand. Then remove the bottom of the stand, held by 3 screws underneath the rubber strips: Underneath you find a small board for the power input and the reset button, and the controller board: The test points (8 vertical, 2 horizontal) are connected to the module pins 7..14 and 17..18 (see below). As GPIO0 is not among them, they aren't enough for flashing, so the board must be removed anyway. NOTE: You need to remove the knob before you can remove this controller board. The controller board contains - a 3.3V converter on the side of the white power wires - two LED drivers on the side of the red/blue/black LED wires - the rotary button - the Yeelight module Pinout ~ Left side: - Pin 1: ADC (N.C.) - Pin 2: GPIO15 (N.C.) - Pin 3: GND - Pin 4: GPIO0 - Pin 5: GND - Pin 6: GND Bottom: - Pin 7: GND - Pin 8: Vcc (3.3V) - Pin 9: GPIO14 (Reset button) - Pin 10: GPIO2 (Rotary button) - Pin 11: GPIO13 (Rotary B) - Pin 12: GPIO12 (Rotary A) - Pin 13: GPIO4 (Cold white) - Pin 14: GPIO5 (Warm white) Right side: - Pin 15: GND - Pin 16: GND - Pin 17: RxD (N.C.) - Pin 18: TxD (N.C.) - Pin 19: GND (N.C.) - Pin 20: GND (N.C.) Three pins (ADC, GPIO0 and GPIO15) are not used by the lamp, they are available for hacking :). Procedure ~ For serial flashing we need 2 power wires (GND, Vcc), 2 serial wires (RxD, TxD) and the boot mode button (GPIO0): As there is plenty of free space in the lamp stand, I left the wires long enough to reach some empty area and soldered solo pin head sockets on them. This way they will be available if/when I decide to add something on those 3 extra pins :). The rest of the serial flashing process is as usual , but if you want to make a backup of the original firmware, keep in mind that the flash size is 2 MBs . If you are re-flashing the original firmware, the flash size must be explicitly set to '2MB-c1', the auto-detected '2MB' doesn't work , so: esptool.py write_flash --flash_size 2MB-c1 0x00000 xiaomi_desk_lamp.orig.bin Serial logging ~ A bonus feature for debugging/logging: The lamp has an external DC12V power supply, so there is no shock hazard. Nonetheless, accidental 12V can still cause damage to a 3.3V serial converter, so be cautious if you do serial logging on a live lamp. The original firmware sets the USART to the same 74880 baud as the ESP boot loader, and it dumps some details as well: ets Jan 8 2013 , rst cause : 1 , boot mode :( 3 , 7 ) load 0 x60000020 , len 4 , room 16 phy ver : 1055 _1 , pp ver : 10 . 7 rf cal sector : 507 tcpip_task_hdl : 3 fff2958 , prio : 10 , stack : 512 idle_task_hdl : 3 fff29f8 , prio : 0 , stack : 384 tim_task_hdl : 3 fff5188 , prio : 2 , stack : 512 pwm version : 1 . 0 . 2 mcu version : 1 . 3 . 0 _0055 prod : yeelink . light . lamp1 data : 0 x3ffe8000 ~ 0 x3ffe91f4 , len : 4596 rodata : 0 x3ffe9310 ~ 0 x3ffeaa7c , len : 5996 bss : 0 x3ffeaa80 ~ 0 x3fff27d8 , len : 32088 heap : 0 x3fff27d8 ~ 0 x40000000 , len : 55336 BUILD TIME : May 25 2018 , 07 : 01 : 12 ESP SDK VER : 1 . 5 . 0 - dev ( c6beda8 ) did is 65282142 mac addr 7811 dc06cfd9 reset reason : 0 current flash flag is 0 , current user bin addr 0 x101000 mode : softAP ( 7 a : 11 : dc : 06 : cf : d9 ) dhcp server start :( ip : 192 . 168 . 4 . 1 , mask : 255 . 255 . 255 . 0 , gw : 192 . 168 . 4 . 1 ) add if1 bcn 100 Hacking ~ The lamp has 3 pins that aren't used in normal operation: ADC, GPIO0 and GPIO15. GPIO15 is and must be pulled up for boot selection, so its usability is somewhat limited. On the other hand, if you already soldered wires to VCC, GND and GPIO0 for serial flashing, they are perfect for a DHT11 or DHT22 temperature+humidity sensor! As the lamp has external power supply, and the LEDs are in the upper part of the lamp, the temperature of the base is the same as of the ambient, and by its nature the lamp is situated on your desk, so it's a perfect place for temp+humidity measurements. If you want to place the sensor inside the lamp base, then you may need to remove some material from one of the weight panels, and if you choose to place it on the outside (e.g., near the base), then a convenient and relatively hidden path for the 3 wires is above the power jack, just enlarge the hole by 2 mm-s with a file.","title":"Xiaomi Mi Desk Lamp"},{"location":"devices/Xiaomi-Mi-Desk-Lamp/#configuration","text":"Tasmota supports it directly as Module \"Mi Desk Lamp\" . This module is deactivated by default. You must add #define ROTARY_V1 in your user_config_override.h and compile the firmware for this module to be available as a selection option. To configure it as Generic , here is the GPIO assignment: - GPIO02: Button ( GPIO_KEY1 ) - GPIO04: Cold White ( GPIO_PWM1 ) - GPIO05: Warm White ( GPIO_PWM2 ) - GPIO12: Rotary switch A pin ( GPIO_ROT_A ) - GPIO13: Rotary switch B pin ( GPIO_ROT_B ) NOTE: The operation of the rotary switch depends on the module type being MI_DESK_LAMP , so full functionality cannot be achieved with the Generic config.","title":"Configuration"},{"location":"devices/Xiaomi-Mi-Desk-Lamp/#flashing","text":"This lamp is based on a YeeLight LXU 1.7 module, that contains: - an ESP8266 - 2 MB flash","title":"Flashing"},{"location":"devices/Xiaomi-Mi-Desk-Lamp/#disassembly","text":"First of all, remove the knob by pushing some soft and flat tool underneath it and gently pry away from the stand. Then remove the bottom of the stand, held by 3 screws underneath the rubber strips: Underneath you find a small board for the power input and the reset button, and the controller board: The test points (8 vertical, 2 horizontal) are connected to the module pins 7..14 and 17..18 (see below). As GPIO0 is not among them, they aren't enough for flashing, so the board must be removed anyway. NOTE: You need to remove the knob before you can remove this controller board. The controller board contains - a 3.3V converter on the side of the white power wires - two LED drivers on the side of the red/blue/black LED wires - the rotary button - the Yeelight module","title":"Disassembly"},{"location":"devices/Xiaomi-Mi-Desk-Lamp/#pinout","text":"Left side: - Pin 1: ADC (N.C.) - Pin 2: GPIO15 (N.C.) - Pin 3: GND - Pin 4: GPIO0 - Pin 5: GND - Pin 6: GND Bottom: - Pin 7: GND - Pin 8: Vcc (3.3V) - Pin 9: GPIO14 (Reset button) - Pin 10: GPIO2 (Rotary button) - Pin 11: GPIO13 (Rotary B) - Pin 12: GPIO12 (Rotary A) - Pin 13: GPIO4 (Cold white) - Pin 14: GPIO5 (Warm white) Right side: - Pin 15: GND - Pin 16: GND - Pin 17: RxD (N.C.) - Pin 18: TxD (N.C.) - Pin 19: GND (N.C.) - Pin 20: GND (N.C.) Three pins (ADC, GPIO0 and GPIO15) are not used by the lamp, they are available for hacking :).","title":"Pinout"},{"location":"devices/Xiaomi-Mi-Desk-Lamp/#procedure","text":"For serial flashing we need 2 power wires (GND, Vcc), 2 serial wires (RxD, TxD) and the boot mode button (GPIO0): As there is plenty of free space in the lamp stand, I left the wires long enough to reach some empty area and soldered solo pin head sockets on them. This way they will be available if/when I decide to add something on those 3 extra pins :). The rest of the serial flashing process is as usual , but if you want to make a backup of the original firmware, keep in mind that the flash size is 2 MBs . If you are re-flashing the original firmware, the flash size must be explicitly set to '2MB-c1', the auto-detected '2MB' doesn't work , so: esptool.py write_flash --flash_size 2MB-c1 0x00000 xiaomi_desk_lamp.orig.bin","title":"Procedure"},{"location":"devices/Xiaomi-Mi-Desk-Lamp/#serial-logging","text":"A bonus feature for debugging/logging: The lamp has an external DC12V power supply, so there is no shock hazard. Nonetheless, accidental 12V can still cause damage to a 3.3V serial converter, so be cautious if you do serial logging on a live lamp. The original firmware sets the USART to the same 74880 baud as the ESP boot loader, and it dumps some details as well: ets Jan 8 2013 , rst cause : 1 , boot mode :( 3 , 7 ) load 0 x60000020 , len 4 , room 16 phy ver : 1055 _1 , pp ver : 10 . 7 rf cal sector : 507 tcpip_task_hdl : 3 fff2958 , prio : 10 , stack : 512 idle_task_hdl : 3 fff29f8 , prio : 0 , stack : 384 tim_task_hdl : 3 fff5188 , prio : 2 , stack : 512 pwm version : 1 . 0 . 2 mcu version : 1 . 3 . 0 _0055 prod : yeelink . light . lamp1 data : 0 x3ffe8000 ~ 0 x3ffe91f4 , len : 4596 rodata : 0 x3ffe9310 ~ 0 x3ffeaa7c , len : 5996 bss : 0 x3ffeaa80 ~ 0 x3fff27d8 , len : 32088 heap : 0 x3fff27d8 ~ 0 x40000000 , len : 55336 BUILD TIME : May 25 2018 , 07 : 01 : 12 ESP SDK VER : 1 . 5 . 0 - dev ( c6beda8 ) did is 65282142 mac addr 7811 dc06cfd9 reset reason : 0 current flash flag is 0 , current user bin addr 0 x101000 mode : softAP ( 7 a : 11 : dc : 06 : cf : d9 ) dhcp server start :( ip : 192 . 168 . 4 . 1 , mask : 255 . 255 . 255 . 0 , gw : 192 . 168 . 4 . 1 ) add if1 bcn 100","title":"Serial logging"},{"location":"devices/Xiaomi-Mi-Desk-Lamp/#hacking","text":"The lamp has 3 pins that aren't used in normal operation: ADC, GPIO0 and GPIO15. GPIO15 is and must be pulled up for boot selection, so its usability is somewhat limited. On the other hand, if you already soldered wires to VCC, GND and GPIO0 for serial flashing, they are perfect for a DHT11 or DHT22 temperature+humidity sensor! As the lamp has external power supply, and the LEDs are in the upper part of the lamp, the temperature of the base is the same as of the ambient, and by its nature the lamp is situated on your desk, so it's a perfect place for temp+humidity measurements. If you want to place the sensor inside the lamp base, then you may need to remove some material from one of the weight panels, and if you choose to place it on the outside (e.g., near the base), then a convenient and relatively hidden path for the 3 wires is above the power jack, just enlarge the hole by 2 mm-s with a file.","title":"Hacking"},{"location":"devices/YTF-IR-Bridge/","text":"YTF BaKEN - Identical to the YTF Tuya Flashing ~ OTA flashing ~ This device is based on a Tuya Wi-Fi module and may still be flashable with Tuya-Convert . Serial flashing ~ Like most devices, GPIO0 has to be held low during power up to get into flash mode. In the picture below, notice the red jumper wire between IO0 and GND. I soldered it in such a way I could hold it during power on, but release later (basically acts as a button), since it can not be held low if you want normal operation. Configuration ~ Introduced in version 6.4.1.8 as YTF IR Bridge (62) GPIO Component Description 04 LED1i (52) Blue LED - Link status 05 IRrecv (51) IR Receiver 13 Button1 (17) Button 14 IRsend (8) IR Transmitter IR Codes ~ IR Code List","title":"YTF IR Bridge"},{"location":"devices/YTF-IR-Bridge/#flashing","text":"","title":"Flashing"},{"location":"devices/YTF-IR-Bridge/#ota-flashing","text":"This device is based on a Tuya Wi-Fi module and may still be flashable with Tuya-Convert .","title":"OTA flashing"},{"location":"devices/YTF-IR-Bridge/#serial-flashing","text":"Like most devices, GPIO0 has to be held low during power up to get into flash mode. In the picture below, notice the red jumper wire between IO0 and GND. I soldered it in such a way I could hold it during power on, but release later (basically acts as a button), since it can not be held low if you want normal operation.","title":"Serial flashing"},{"location":"devices/YTF-IR-Bridge/#configuration","text":"Introduced in version 6.4.1.8 as YTF IR Bridge (62) GPIO Component Description 04 LED1i (52) Blue LED - Link status 05 IRrecv (51) IR Receiver 13 Button1 (17) Button 14 IRsend (8) IR Transmitter","title":"Configuration"},{"location":"devices/YTF-IR-Bridge/#ir-codes","text":"IR Code List","title":"IR Codes"},{"location":"devices/YUNTONG-Smart/","text":"Sonoff Basic Clone can be flashed to Tasmota PIN assignment: PCB Antenna End: * TOP Layer - Bottom Layer * EN - TOUT * IO14 - IO12 * IO13 - IO15 * IO0 - IO2 * IO4 - IO5 * RX - TX * VCC - GND The clone are based on the ESP-03S - User manual","title":"YUNTONG Smart"},{"location":"devices/ZEOOTA-Wifi-Smart-Power-Strip-4-EU-outlets-with-4-USB-ports/","text":"This power strip has Tuya TYWE2S module (ESP8285 chip). Successfully flashed Tasmota on it. 4 power outlets are individually controlled. USB ports have just one relay to switch all ports on/off. Model purchased: https://www.aliexpress.com/item/Wifi-Smart-Power-Strip-4-EU-Outlets-Plug-Socket-with-USB-4-Charging-Port-App-Voice/32864686078.html Used this connection for flashing (just connect GPIO0 on the back side of the module to GND before USB connection to enter flash mode): Module configuration:","title":"ZEOOTA Wifi Smart Power Strip 4 EU outlets with 4 USB ports"},{"location":"devices/leegoal-plug/","text":"Description ~ Very nice and cheap plug :) https://www.amazon.de/gp/product/B07FD971T9/ Features: ~ 3800 W switchi ng USB port 5V 2.1A for charging Power monitor Tuya compatible Model description ~ FLHS ZN04 Configuration ~ Tasmota template based on BlitzWolf (45) {\"NAME\":\"Plug\",\"GPIO\":[57,0,56,0,0,134,0,0,131,17,132,21,0],\"FLAG\":0,\"BASE\":45} Flashing ~ It is possible to flash over OTA. But, it seems flashing via OTA may leave remains of old firmware because it wasn't fully erased before flashing Tasmota. So the device can fail after feature updates. (I have 3 devices originally flashed via OTA bricked after update later). So if you flashed via OTA it better to not update FW anymore. Unfortunately I bricked one of my plugs (probably by typing wrong Wifi name), so I needed to flash manually. Manual flash should be done exactly as shown here: * https://github.com/arendst/Tasmota/issues/3950#issuecomment-436074625 * devices/Hyleton-313-Smart-Plug Access to the internals is easy. Casing is held by 3 torx screws (no glue anywhere). Chip info ~ Detecting chip type... ESP8266 Chip is ESP8266EX Features: WiFi MAC: Manufacturer: a1 Device: 4014 Detected flash size: 1MB","title":"Description"},{"location":"devices/leegoal-plug/#description","text":"Very nice and cheap plug :) https://www.amazon.de/gp/product/B07FD971T9/","title":"Description"},{"location":"devices/leegoal-plug/#features","text":"3800 W switchi ng USB port 5V 2.1A for charging Power monitor Tuya compatible","title":"Features:"},{"location":"devices/leegoal-plug/#model-description","text":"FLHS ZN04","title":"Model description"},{"location":"devices/leegoal-plug/#configuration","text":"Tasmota template based on BlitzWolf (45) {\"NAME\":\"Plug\",\"GPIO\":[57,0,56,0,0,134,0,0,131,17,132,21,0],\"FLAG\":0,\"BASE\":45}","title":"Configuration"},{"location":"devices/leegoal-plug/#flashing","text":"It is possible to flash over OTA. But, it seems flashing via OTA may leave remains of old firmware because it wasn't fully erased before flashing Tasmota. So the device can fail after feature updates. (I have 3 devices originally flashed via OTA bricked after update later). So if you flashed via OTA it better to not update FW anymore. Unfortunately I bricked one of my plugs (probably by typing wrong Wifi name), so I needed to flash manually. Manual flash should be done exactly as shown here: * https://github.com/arendst/Tasmota/issues/3950#issuecomment-436074625 * devices/Hyleton-313-Smart-Plug Access to the internals is easy. Casing is held by 3 torx screws (no glue anywhere).","title":"Flashing"},{"location":"devices/leegoal-plug/#chip-info","text":"Detecting chip type... ESP8266 Chip is ESP8266EX Features: WiFi MAC: Manufacturer: a1 Device: 4014 Detected flash size: 1MB","title":"Chip info"},{"location":"devices/meross-MSS425/","text":"Be Aware ~ There are different versions of this power strip. An MSS425EEU-R purchased in August 2019 was based on the Mediatek Wi-Fi chip and not on an ESP82xx! Tasmota is only suitable for ESP82xx based devices. meross Power Strip ~ This power strip was selling on Amazon for about $17 when I bought it. The ESP module is mounted on the side vertically on board. It's another Tuya TYWE3S, 1MB. For more information on the Tuya TYWE3S, see this page . I soldered pins on and bent them down to get everything back in the case. To open, 4 screws are under the soft foot pads. They take a size 2.0 triangle bit; make sure you have a large collection of small screwdriver bits around. The programming header is directly on the Tuya module and is silkscreened with the labels for the pins. Solder onto those and program just like any other Tuya. There's unfortunately no button to get into firmware mode that I could find, so you have to ground the pin yourself. If you're using an external power source for the board and another power source for your TXD/RXD, make sure to tie the grounds together or else it won't talk. I burned on the generic tasmota release and set it up like so: Relays 1-3 are the AC plugs Relays 4,5 are the USBs The button only turns off the first AC by default, but you could write rules to do whatever you want.","title":"Be Aware"},{"location":"devices/meross-MSS425/#be-aware","text":"There are different versions of this power strip. An MSS425EEU-R purchased in August 2019 was based on the Mediatek Wi-Fi chip and not on an ESP82xx! Tasmota is only suitable for ESP82xx based devices.","title":"Be Aware"},{"location":"devices/meross-MSS425/#meross-power-strip","text":"This power strip was selling on Amazon for about $17 when I bought it. The ESP module is mounted on the side vertically on board. It's another Tuya TYWE3S, 1MB. For more information on the Tuya TYWE3S, see this page . I soldered pins on and bent them down to get everything back in the case. To open, 4 screws are under the soft foot pads. They take a size 2.0 triangle bit; make sure you have a large collection of small screwdriver bits around. The programming header is directly on the Tuya module and is silkscreened with the labels for the pins. Solder onto those and program just like any other Tuya. There's unfortunately no button to get into firmware mode that I could find, so you have to ground the pin yourself. If you're using an external power source for the board and another power source for your TXD/RXD, make sure to tie the grounds together or else it won't talk. I burned on the generic tasmota release and set it up like so: Relays 1-3 are the AC plugs Relays 4,5 are the USBs The button only turns off the first AC by default, but you could write rules to do whatever you want.","title":"meross Power Strip"},{"location":"devices/minitiger-Touch-Light-Switch/","text":"minitiger Touch Light Switch ~ This is a cheap Sonoff T1 clone. Available with 1/2/3 channels. The board has the ID 2PH89174A Device ~ ESP8285 micro Blue status LED (micro controlled) Separate touch IC controlled switch status indicators (blue and red) Aliexpress link: Click Aliexpress link for no neutral version (single live wire) version: Click Images ~ Front and soldering: Fullsize Front and identification number: Fullsize Back and GND: Fullsize Soldering layout: Fullsize Flashing ~ This board can be flashed with vanilla sonoff-tasmota. I used esptool on linux to upload the firmware. Programming mode: ~ Short GPIO0 to GND, as with all boards. If you have successfully put the micro into programming mode the LED does not light up! Config: ~ Single Channel: ~ Works out of the box, configured as Sonoff Basic. The LED does not light up when the switch is turned off. Configure as Sonoff T1 to enable the LED. Dual Channel: ~ {\"NAME\":\"Wall Switch 2C\",\"GPIO\":[17,255,255,255,0,22,18,0,21,56,0,0,0],\"FLAG\":0,\"BASE\":28} Dual Channel - No Neutral (Single Live Wire): ~ {\"NAME\":\"Wall Switch 2C\",\"GPIO\":[53,52,255,17,18,0,0,0,0,21,22,0,0],\"FLAG\":0,\"BASE\":28} Triple Channel: ~ Since I don't own such a board, you are on your own... Button 3 should be GPIO10 and Relay 3 should be GPIO4. Use at your own risk!","title":"minitiger Touch Light Switch"},{"location":"devices/minitiger-Touch-Light-Switch/#minitiger-touch-light-switch","text":"This is a cheap Sonoff T1 clone. Available with 1/2/3 channels. The board has the ID 2PH89174A","title":"minitiger Touch Light Switch"},{"location":"devices/minitiger-Touch-Light-Switch/#device","text":"ESP8285 micro Blue status LED (micro controlled) Separate touch IC controlled switch status indicators (blue and red) Aliexpress link: Click Aliexpress link for no neutral version (single live wire) version: Click","title":"Device"},{"location":"devices/minitiger-Touch-Light-Switch/#images","text":"Front and soldering: Fullsize Front and identification number: Fullsize Back and GND: Fullsize Soldering layout: Fullsize","title":"Images"},{"location":"devices/minitiger-Touch-Light-Switch/#flashing","text":"This board can be flashed with vanilla sonoff-tasmota. I used esptool on linux to upload the firmware.","title":"Flashing"},{"location":"devices/minitiger-Touch-Light-Switch/#programming-mode","text":"Short GPIO0 to GND, as with all boards. If you have successfully put the micro into programming mode the LED does not light up!","title":"Programming mode:"},{"location":"devices/minitiger-Touch-Light-Switch/#config","text":"","title":"Config:"},{"location":"devices/minitiger-Touch-Light-Switch/#single-channel","text":"Works out of the box, configured as Sonoff Basic. The LED does not light up when the switch is turned off. Configure as Sonoff T1 to enable the LED.","title":"Single Channel:"},{"location":"devices/minitiger-Touch-Light-Switch/#dual-channel","text":"{\"NAME\":\"Wall Switch 2C\",\"GPIO\":[17,255,255,255,0,22,18,0,21,56,0,0,0],\"FLAG\":0,\"BASE\":28}","title":"Dual Channel:"},{"location":"devices/minitiger-Touch-Light-Switch/#dual-channel-no-neutral-single-live-wire","text":"{\"NAME\":\"Wall Switch 2C\",\"GPIO\":[53,52,255,17,18,0,0,0,0,21,22,0,0],\"FLAG\":0,\"BASE\":28}","title":"Dual Channel - No Neutral (Single Live Wire):"},{"location":"devices/minitiger-Touch-Light-Switch/#triple-channel","text":"Since I don't own such a board, you are on your own... Button 3 should be GPIO10 and Relay 3 should be GPIO4. Use at your own risk!","title":"Triple Channel:"},{"location":"devices/wk30/","text":"Connection ~ Vcc - 3.3V TX - RX RX - TX GND - GND GPIO0 - GND Additional Information ~ This device is available on Amazon as \"Smart WiFi Plug Outlet Mini with Energy Monitoring.\" The product number, WK30 appears nowhere on the page on Amazon, so here's its ASIN: B07C326VKR It remains to be seen if this device actually features energy monitoring as in the title on Amazon. Nicely labeled holes for a header exist. The pictures below are with a header soldered on. All that was needed was to jumper GPIO0 to ground in addition to the usual connections. Once tasmota is up, configure the device as generic. Device Images ~ GPIO Config ~ This has the LEDs, GPIO4 and GPIO5 separated out as different relays so they can be controlled independently of the switch.","title":"Wk30"},{"location":"devices/wk30/#connection","text":"Vcc - 3.3V TX - RX RX - TX GND - GND GPIO0 - GND","title":"Connection"},{"location":"devices/wk30/#additional-information","text":"This device is available on Amazon as \"Smart WiFi Plug Outlet Mini with Energy Monitoring.\" The product number, WK30 appears nowhere on the page on Amazon, so here's its ASIN: B07C326VKR It remains to be seen if this device actually features energy monitoring as in the title on Amazon. Nicely labeled holes for a header exist. The pictures below are with a header soldered on. All that was needed was to jumper GPIO0 to ground in addition to the usual connections. Once tasmota is up, configure the device as generic.","title":"Additional Information"},{"location":"devices/wk30/#device-images","text":"","title":"Device Images"},{"location":"devices/wk30/#gpio-config","text":"This has the LEDs, GPIO4 and GPIO5 separated out as different relays so they can be controlled independently of the switch.","title":"GPIO Config"},{"location":"installation/","text":"","title":"Index"},{"location":"installation/Flashing/","text":"","title":"Flashing"},{"location":"installation/Hardware-Preparation/","text":"","title":"Hardware Preparation"},{"location":"installation/Initial-Configuration/","text":"","title":"Initial Configuration"},{"location":"installation/Prerequisites/","text":"","title":"Prerequisites"}]}